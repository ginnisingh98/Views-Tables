--------------------------------------------------------
--  DDL for Package Body HXC_TRANS_DISPLAY_KEY_UTILS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."HXC_TRANS_DISPLAY_KEY_UTILS" AS
/* $Header: hxctdkut.pkb 120.3 2008/04/15 13:32:51 bbayragi noship $ */
--
-- Private Functions and Procedures
--
-- ----------------------------------------------------------------------------
-- |-------------------<     replace_row_index_in_key    >--------------------|
-- ----------------------------------------------------------------------------
-- {Start Of Comments}
--
-- Description:
--   This function replaces the row index in a translation display key
--   with the new value specified.  The translation display key should
--   have the usual form: layout_component_id|row_index|column_index -
--   in this case, this function will replace the row_index part, and
--   return the modified translation display key.
--
-- Prerequisites:
--   The function must be passed a valid translation key.
--
-- In Parameters:
--   Name                           Reqd Type     Description
--   p_key                             Y varchar2 String representation of
--                                                display key.
--   p_row                             Y number   New row index
--
-- Post Success:
--   The row index portion of the display key is replaced.
--
-- Post Failure:
--   The function will return an undefined display key is sent an
--   invalid translation display key format.
--
-- Access Status:
--   Private.
--
-- {End Of Comments}
--
   function replace_row_index_in_key
      (p_key in varchar2,
       p_row in number)
      return varchar2 is
      l_new_key hxc_time_building_blocks.translation_display_key%type;
   begin
      l_new_key := substrb(p_key,1,instr(p_key,'|'));
      l_new_key := l_new_key||p_row;
      l_new_key := l_new_key||substrb(p_key,instr(p_key,'|',-1));
      return l_new_key;
   end replace_row_index_in_key;
--
-- ----------------------------------------------------------------------------
-- |----------------------<     row_index_from_key    >-----------------------|
-- ----------------------------------------------------------------------------
-- {Start Of Comments}
--
-- Description:
--   This function returns the row index from a translation key.  The
--   translation key must have the form:
--   layout_component_id|row_index|column_index, i.e. as generated by the
--   blockHashMapKey middle tier method in the data translator.
--
-- Prerequisites:
--   The function must be passed a valid translation key.
--
-- In Parameters:
--   Name                           Reqd Type     Description
--   p_key                          Y   varchar2  String representation of
--                                                display key.
--
-- Post Success:
--   The row index portion of the translation display key is returned
--   as a number.
--
-- Post Failure:
--   The function will return -1 if it is unable to determine the row
--   index based on the key.
--
-- Access Status:
--   Private.
--
-- {End Of Comments}
--
   function row_index_from_key
      (p_key in varchar2)
      return number is
   begin
      return to_number(substrb
                        (substrb(p_key,instr(p_key,'|')+1),
                         1,
                         instr(substrb(p_key,instr(p_key,'|')+1),'|')-1
                         )
                       );
   exception
      when others then
         return -1;

   end row_index_from_key;
--
-- Public Functions and Procedures --- see package header for documentation.
--
-- +--------------------------------------------------------------------------+
-- |------------------------<     missing_rows     >--------------------------|
-- +--------------------------------------------------------------------------+
--
   FUNCTION missing_rows
      (p_row_data in translation_row_used)
      return boolean is
      l_index pls_integer;
      l_sum pls_integer;
   Begin
      if(p_row_data.count = 0) then
         return false;
      end if;

      l_sum := 0;
      l_index := 1;
      Loop
         Exit when not p_row_data.exists(l_index);
         l_sum := l_sum +1;
         l_index := l_index + 1;
      End Loop;

      if(l_sum <> p_row_data.count) then
         return true;
      else
         return false;
      end if;

   End missing_rows;
--
-- +--------------------------------------------------------------------------+
-- |-----------------------<     new_display_key     >------------------------|
-- +--------------------------------------------------------------------------+
--
   FUNCTION new_display_key
             (p_existing_display_key in varchar2,
              p_existing_row_count in number)
    return varchar2 is
      l_key            hxc_time_building_blocks.translation_display_key%type;
      l_layout_comp_id hxc_time_building_blocks.translation_display_key%type;
      l_row_index      hxc_time_building_blocks.translation_display_key%type;

   Begin
      l_layout_comp_id := substrb(p_existing_display_key,1,instr(p_existing_display_key,'|'));
      l_key := substrb(p_existing_display_key,(instr(p_existing_display_key,'|')+1));
      l_row_index := substrb(l_key,1,instr(l_key,'|')-1);
      l_key := substrb(l_key,instr(l_key,'|',-1));
      l_key := l_layout_comp_id||(to_number(l_row_index)+p_existing_row_count)||l_key;
      return l_key;
   End new_display_key;
--
-- +--------------------------------------------------------------------------+
-- |----------------------<     remove_empty_rows     >-----------------------|
-- +--------------------------------------------------------------------------+
--
   PROCEDURE remove_empty_rows
      (p_row_data in            translation_row_used,
       p_blocks   in out NOCOPY hxc_block_table_type) is
      l_idx             pls_integer;
      l_row_number      pls_integer;
      l_row_idx         number;
      l_new_row_indices translation_row_used;
   Begin
      --
      -- First step is to find out what the row index should be
      -- and keep that for later use.
      --
      l_row_number := 0;
      l_idx :=  p_row_data.first;
      Loop
         Exit when NOT p_row_data.exists(l_idx);
         l_row_number := l_row_number + 1;
         if(l_row_number <> l_idx) then
            l_new_row_indices(l_idx) := l_row_number;
         end if;
         l_idx := p_row_data.next(l_idx);
      End Loop;
      --
      -- Now loop over the block structure, and reset the translation
      -- keys where appropriate.
      --
      l_idx := p_blocks.first;
      Loop
         Exit when NOT p_blocks.exists(l_idx);
         if (hxc_timecard_block_utils.is_detail_block(p_blocks(l_idx))) then
            l_row_idx := row_index_from_key(p_blocks(l_idx).translation_display_key);
            if (l_new_row_indices.exists(l_row_idx)) then
               -- Must replace the row index in the display key
               p_blocks(l_idx).translation_display_key :=
                  replace_row_index_in_key
                    (p_blocks(l_idx).translation_display_key,
                     l_new_row_indices(l_row_idx)
                     );
            end if;
         end if;
         l_idx := p_blocks.next(l_idx);
      End Loop;

   End remove_empty_rows;
--
-- +--------------------------------------------------------------------------+
-- |-------------------<     reset_column_index_to_zero     >-----------------|
-- +--------------------------------------------------------------------------+
--
   FUNCTION reset_column_index_to_zero
      (p_key in varchar2) return varchar2 is
   Begin
      return substrb(p_key,1,instr(p_key,c_key_separator,-1))||'0';
   End reset_column_index_to_zero;
--
-- +--------------------------------------------------------------------------+
-- |------------------------<     set_row_data     >--------------------------|
-- +--------------------------------------------------------------------------+
--
   PROCEDURE set_row_data
      (p_key      in     varchar2,
       p_row_data in out NOCOPY translation_row_used) is

      l_row_index number;

   Begin
      if((p_key is null) OR (p_key = '')) then
         null;
      else
         l_row_index := row_index_from_key(p_key);
         if(NOT p_row_data.exists(l_row_index)) then
            p_row_data(l_row_index) := 1;
         end if;
      end if;
   End set_row_data;
--
-- +--------------------------------------------------------------------------+
-- |---------------------<     timecard_row_count     >-----------------------|
-- +--------------------------------------------------------------------------+
--
   FUNCTION timecard_row_count
      (p_blocks in hxc_block_table_type)
      return number is
      l_index pls_integer;
      l_row_index number;
      l_row_count number;
   Begin
      l_row_count := 0;
      l_index := p_blocks.first;
      Loop
         Exit when not p_blocks.exists(l_index);
         if((p_blocks(l_index).scope = hxc_timecard.c_detail_scope)
           AND
            (hxc_timecard_block_utils.is_active_block(p_blocks(l_index))))
           then
            l_row_index := row_index_from_key(p_blocks(l_index).translation_display_key);
            if(l_row_index > l_row_count) then
               l_row_count := l_row_index;
            end if;
         end if;
         l_index := p_blocks.next(l_index);
      End Loop;
      return l_row_count;
   End timecard_row_count;

-- Added for DA Enhancement
-- +--------------------------------------------------------------------------+
-- |---------------------<     alter_translation_key     >-----------------------|
-- +--------------------------------------------------------------------------+
--

  PROCEDURE alter_translation_key
      	    (p_g_deposit_blocks in out nocopy hxc_block_table_type,
      	     p_actual_blocks in hxc_block_table_type
   	    ) is

  l_actual_blocks hxc_block_table_type;
  l_idx		NUMBER;
  l_index	NUMBER;
  l_deposit_translation_key	VARCHAR2(100);
  l_actual_translation_key	VARCHAR2(100);
  BEGIN

    l_actual_blocks := p_actual_blocks;

    l_idx := p_g_deposit_blocks.first;
      LOOP
      EXIT WHEN NOT p_g_deposit_blocks.exists(l_idx);
        IF   p_g_deposit_blocks(l_idx).scope = hxc_timecard.c_detail_scope
        AND  p_g_deposit_blocks(l_idx).APPROVAL_STATUS = 'SUBMITTED'
        THEN
/* 	  IF p_g_deposit_blocks(l_idx).MEASURE IS NOT NULL
	  OR (p_g_deposit_blocks(l_idx).START_TIME IS NOT NULL
	      AND p_g_deposit_blocks(l_idx).STOP_TIME IS NOT NULL)
	  THEN
*/	    l_index := l_actual_blocks.first;
	      LOOP
              EXIT WHEN NOT l_actual_blocks.exists(l_index);
                IF   l_actual_blocks(l_index).scope = hxc_timecard.c_detail_scope
		AND  l_actual_blocks(l_index).APPROVAL_STATUS = 'SUBMITTED'
        	THEN
        	  IF l_actual_blocks(l_index).TIME_BUILDING_BLOCK_ID = p_g_deposit_blocks(l_idx).TIME_BUILDING_BLOCK_ID THEN
        	    l_deposit_translation_key := p_g_deposit_blocks(l_idx).TRANSLATION_DISPLAY_KEY;
        	    l_actual_translation_key  := l_actual_blocks(l_index).TRANSLATION_DISPLAY_KEY;
        	    l_deposit_translation_key := SUBSTR(l_deposit_translation_key,1,INSTR(l_deposit_translation_key,'|')-1)||
        	    				 SUBSTR(l_actual_translation_key,INSTR(l_actual_translation_key,'|'));
        	    p_g_deposit_blocks(l_idx).TRANSLATION_DISPLAY_KEY := l_deposit_translation_key;
        	    p_g_deposit_blocks(l_idx).DATE_TO := l_actual_blocks(l_index).DATE_TO;
        	  END IF;
        	END IF;

              l_index := l_actual_blocks.next(l_index);
      	      END LOOP;--EXIT WHEN NOT l_actual_blocks.exists(l_index);
--	  END IF;--IF p_g_deposit_blocks(l_idx).MEASURE IS NOT NULL
        END IF;
      l_idx := p_g_deposit_blocks.next(l_idx);
      END LOOP;--EXIT WHEN NOT p_g_deposit_blocks.exists(l_idx1);



  END alter_translation_key;


END hxc_trans_display_key_utils;

/
