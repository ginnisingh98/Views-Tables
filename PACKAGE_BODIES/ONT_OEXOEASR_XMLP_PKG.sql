--------------------------------------------------------
--  DDL for Package Body ONT_OEXOEASR_XMLP_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."ONT_OEXOEASR_XMLP_PKG" AS
/* $Header: OEXOEASRB.pls 120.1 2007/12/25 07:13:10 npannamp noship $ */
  FUNCTION BEFOREREPORT RETURN BOOLEAN IS
  BEGIN
    BEGIN
      BEGIN
        P_CONC_REQUEST_ID := FND_GLOBAL.CONC_REQUEST_ID;
        /*SRW.USER_EXIT('FND SRWINIT')*/NULL;
      EXCEPTION
        WHEN /*SRW.USER_EXIT_FAILURE*/OTHERS THEN
          /*SRW.MESSAGE(1000
                     ,'Failed in BEFORE REPORT trigger')*/NULL;
          RETURN (FALSE);
      END;
      DECLARE
        L_COMPANY_NAME VARCHAR2(30);
        L_FUNCTIONAL_CURRENCY VARCHAR2(15);
        L_SOB_ID VARCHAR2(30);
      BEGIN
        /*SRW.REFERENCE(P_SOB_ID)*/NULL;
        IF P_SOB_ID IS NULL THEN
          L_SOB_ID := OE_SYS_PARAMETERS.VALUE('SET_OF_BOOKS_ID'
                                             ,MO_GLOBAL.GET_CURRENT_ORG_ID);
        ELSE
          L_SOB_ID := P_SOB_ID;
        END IF;
        SELECT
          SOB.NAME,
          SOB.CURRENCY_CODE
        INTO L_COMPANY_NAME,L_FUNCTIONAL_CURRENCY
        FROM
          GL_SETS_OF_BOOKS SOB,
          FND_CURRENCIES CUR
        WHERE SOB.SET_OF_BOOKS_ID = L_SOB_ID
          AND SOB.CURRENCY_CODE = CUR.CURRENCY_CODE;
        RP_COMPANY_NAME := L_COMPANY_NAME;
        RP_FUNCTIONAL_CURRENCY := L_FUNCTIONAL_CURRENCY;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          NULL;
      END;
      DECLARE
        L_REPORT_NAME VARCHAR2(240);
      BEGIN
        SELECT
          CP.USER_CONCURRENT_PROGRAM_NAME
        INTO L_REPORT_NAME
        FROM
          FND_CONCURRENT_PROGRAMS_VL CP,
          FND_CONCURRENT_REQUESTS CR
        WHERE CR.REQUEST_ID = P_CONC_REQUEST_ID
          AND CP.APPLICATION_ID = CR.PROGRAM_APPLICATION_ID
          AND CP.CONCURRENT_PROGRAM_ID = CR.CONCURRENT_PROGRAM_ID;
	   L_REPORT_NAME := substr(L_REPORT_NAME,1,instr(L_REPORT_NAME,' (XML)'));
        RP_REPORT_NAME := L_REPORT_NAME;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RP_REPORT_NAME := 'Agreement Activity Report' || P_ORDER_NUMBER_LOW;
      END;
      DECLARE
        L_CUSTOMER_NAME_LOW VARCHAR2(50);
        L_CUSTOMER_NAME_HIGH VARCHAR2(50);
        L_AGREEMENT_NAME_LOW VARCHAR2(50);
        L_AGREEMENT_NAME_HIGH VARCHAR2(50);
      BEGIN
        /*SRW.REFERENCE(P_AGREEMENT_LOW)*/NULL;
        /*SRW.REFERENCE(P_AGREEMENT_HIGH)*/NULL;
        IF (P_CUSTOMER_NAME_LOW IS NULL) AND (P_CUSTOMER_NAME_HIGH IS NULL) THEN
          NULL;
        ELSE
          IF P_CUSTOMER_NAME_LOW IS NULL THEN
            L_CUSTOMER_NAME_LOW := '   ';
          ELSE
            L_CUSTOMER_NAME_LOW := SUBSTR(P_CUSTOMER_NAME_LOW
                                         ,1
                                         ,18);
          END IF;
          IF P_CUSTOMER_NAME_HIGH IS NULL THEN
            L_CUSTOMER_NAME_HIGH := '   ';
          ELSE
            L_CUSTOMER_NAME_HIGH := SUBSTR(P_CUSTOMER_NAME_HIGH
                                          ,1
                                          ,18);
          END IF;
          RP_CUSTOMER_NAME_RANGE := 'From ' || L_CUSTOMER_NAME_LOW || ' To ' || L_CUSTOMER_NAME_HIGH;
        END IF;
        IF (P_AGREEMENT_LOW IS NULL) AND (P_AGREEMENT_HIGH IS NULL) THEN
          NULL;
        ELSE
          RP_AGREEMENT_RANGE := 'From ' || P_AGREEMENT_LOW || ' To ' || P_AGREEMENT_HIGH;
          RP_AGREEMENT_NAME_LOW := P_AGREEMENT_LOW;
          RP_AGREEMENT_NAME_HIGH := P_AGREEMENT_HIGH;
        END IF;
      END;
    END;
    RETURN (TRUE);
  END BEFOREREPORT;
  FUNCTION AFTERREPORT RETURN BOOLEAN IS
  BEGIN
    BEGIN
      /*SRW.USER_EXIT('FND SRWEXIT')*/NULL;
    EXCEPTION
      WHEN /*SRW.USER_EXIT_FAILURE*/OTHERS THEN
        /*SRW.MESSAGE(1
                   ,'Failed in AFTER REPORT TRIGGER')*/NULL;
        RETURN (FALSE);
    END;
    RETURN (TRUE);
  END AFTERREPORT;
  FUNCTION P_SOB_IDVALIDTRIGGER RETURN BOOLEAN IS
  BEGIN
    RETURN (TRUE);
  END P_SOB_IDVALIDTRIGGER;
  FUNCTION P_USE_FUNCTIONAL_CURRENCYVALID RETURN BOOLEAN IS
  BEGIN
    RETURN (TRUE);
  END P_USE_FUNCTIONAL_CURRENCYVALID;
  FUNCTION P_INTERFACE_LINE_CONTEXTVALIDT RETURN BOOLEAN IS
  BEGIN
    RETURN (TRUE);
  END P_INTERFACE_LINE_CONTEXTVALIDT;
  FUNCTION C_USE_CURRENCYFORMULA(CURRENCY2 IN VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    /*SRW.REFERENCE(RP_FUNCTIONAL_CURRENCY)*/NULL;
    /*SRW.REFERENCE(CURRENCY2)*/NULL;
    IF P_USE_FUNCTIONAL_CURRENCY = 'Y' THEN
      RETURN (RP_FUNCTIONAL_CURRENCY);
    ELSE
      RETURN (CURRENCY2);
    END IF;
    RETURN NULL;
  END C_USE_CURRENCYFORMULA;
  FUNCTION C_DATA_NOT_FOUNDFORMULA(CURRENCY2 IN VARCHAR2) RETURN NUMBER IS
  BEGIN
    RP_DATA_FOUND := CURRENCY2;
    RETURN (0);
  END C_DATA_NOT_FOUNDFORMULA;
  FUNCTION AFTERPFORM RETURN BOOLEAN IS
  BEGIN
    DECLARE
      L_AGREEMENT_TYPE VARCHAR2(100);
      L_DEBUG VARCHAR2(100);
    BEGIN
      /*SRW.REFERENCE(P_CUSTOMER_NAME_LOW)*/NULL;
      /*SRW.REFERENCE(P_CUSTOMER_NAME_HIGH)*/NULL;
      /*SRW.REFERENCE(P_AGREEMENT_LOW)*/NULL;
      /*SRW.REFERENCE(P_AGREEMENT_HIGH)*/NULL;
      /*SRW.REFERENCE(P_AGREEMENT_TYPE)*/NULL;
      /*SRW.REFERENCE(P_PURCHASE_NUM)*/NULL;
      /*SRW.REFERENCE(P_SALESPERSON)*/NULL;
      /*SRW.REFERENCE(P_ORDER_NUMBER_HIGH)*/NULL;
      /*SRW.REFERENCE(P_ORDER_NUMBER_LOW)*/NULL;
      IF (P_CUSTOMER_NAME_LOW IS NOT NULL) AND (P_CUSTOMER_NAME_HIGH IS NOT NULL) THEN
        LP_CUSTOMER_RANGE := 'and c.party_name between :p_customer_name_low  and  :p_customer_name_high';
      ELSIF (P_CUSTOMER_NAME_LOW IS NOT NULL) THEN
        LP_CUSTOMER_RANGE := 'and c.party_name >= :p_customer_name_low ';
      ELSIF (P_CUSTOMER_NAME_HIGH IS NOT NULL) THEN
        LP_CUSTOMER_RANGE := 'and c.party_name <= :p_customer_name_high ';
      END IF;
      IF (P_AGREEMENT_LOW IS NOT NULL) AND (P_AGREEMENT_HIGH IS NOT NULL) THEN
        LP_AGREEMENT_RANGE := 'and a.name between  :p_agreement_low  and :p_agreement_high ';
      ELSIF (P_AGREEMENT_LOW IS NOT NULL) THEN
        LP_AGREEMENT_RANGE := 'and a.name >= :p_agreement_low ';
      ELSIF (P_AGREEMENT_HIGH IS NOT NULL) THEN
        LP_AGREEMENT_RANGE := 'and a.name <= :p_agreement_high ';
      END IF;
      IF (P_ORDER_NUMBER_LOW IS NOT NULL) AND (P_ORDER_NUMBER_HIGH IS NOT NULL) THEN
        L_DEBUG := 'stmt#1';
        L_DEBUG := P_ORDER_NUMBER_LOW || ':' || P_ORDER_NUMBER_HIGH;
        LP_ORDER_NUMBER_RANGE := 'and h.order_number between  :p_order_number_low  and :p_order_number_high ';
      ELSIF (P_ORDER_NUMBER_LOW IS NOT NULL) THEN
        LP_ORDER_NUMBER_RANGE := 'and h.order_number >= :p_order_number_low';
      ELSIF (P_ORDER_NUMBER_HIGH IS NOT NULL) THEN
        LP_ORDER_NUMBER_RANGE := 'and h.order_number <= :p_order_number_high ';
      END IF;
      IF P_PURCHASE_NUM IS NOT NULL THEN
        LP_PURCHASE_NUM := 'and a.purchase_order_num =  :p_purchase_num';
      END IF;
      IF P_SALESPERSON IS NOT NULL THEN
        LP_SALESPERSON := 'and sr.name = :p_salesperson';
      END IF;
      L_DEBUG := 'Before agreement lookup';
      IF P_AGREEMENT_TYPE IS NOT NULL THEN
        LP_AGREEMENT_TYPE := 'and lu.lookup_code =  :p_agreement_type  and lu.lookup_type = ''QP_AGREEMENT_TYPE''';
        SELECT
          LU.MEANING
        INTO L_AGREEMENT_TYPE
        FROM
          QP_LOOKUPS LU
        WHERE LU.LOOKUP_TYPE = 'QP_AGREEMENT_TYPE'
          AND LU.LOOKUP_CODE = P_AGREEMENT_TYPE;
        LP_AGREEMENT_TYPE_DSP := L_AGREEMENT_TYPE;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        NULL;
      WHEN OTHERS THEN
        /*SRW.MESSAGE(1000
                   ,'Error in AFTER FORM Trigger:' || L_DEBUG || ':' || SQLERRM)*/NULL;
    END;
    RETURN (TRUE);
  END AFTERPFORM;
  FUNCTION RP_USE_FUNCTIONAL_CURRENCYFORM RETURN VARCHAR2 IS
  BEGIN
    DECLARE
      L_CURRENCY VARCHAR2(80);
    BEGIN
      SELECT
        MEANING
      INTO L_CURRENCY
      FROM
        FND_LOOKUPS
      WHERE LOOKUP_CODE = P_USE_FUNCTIONAL_CURRENCY
        AND LOOKUP_TYPE = 'YES_NO';
      RETURN (L_CURRENCY);
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RETURN (L_CURRENCY);
    END;
    RETURN NULL;
  END RP_USE_FUNCTIONAL_CURRENCYFORM;
  FUNCTION BEFOREPFORM RETURN BOOLEAN IS
  BEGIN
    RETURN (TRUE);
  END BEFOREPFORM;
  FUNCTION C_QTY_ORDERED_P RETURN NUMBER IS
  BEGIN
    RETURN C_QTY_ORDERED;
  END C_QTY_ORDERED_P;
  FUNCTION C_QTY_SHIPPED_P RETURN NUMBER IS
  BEGIN
    RETURN C_QTY_SHIPPED;
  END C_QTY_SHIPPED_P;
  FUNCTION C_QTY_SHIPPED_DSP_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_QTY_SHIPPED_DSP;
  END C_QTY_SHIPPED_DSP_P;
  FUNCTION C_QTY_ORDERED_DSP_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_QTY_ORDERED_DSP;
  END C_QTY_ORDERED_DSP_P;
  FUNCTION C_QTY_INVOICED_DSP_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_QTY_INVOICED_DSP;
  END C_QTY_INVOICED_DSP_P;
  FUNCTION C_QTY_INVOICED_P RETURN NUMBER IS
  BEGIN
    RETURN C_QTY_INVOICED;
  END C_QTY_INVOICED_P;
  FUNCTION RP_REPORT_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_REPORT_NAME;
  END RP_REPORT_NAME_P;
  FUNCTION RP_SUB_TITLE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_SUB_TITLE;
  END RP_SUB_TITLE_P;
  FUNCTION RP_COMPANY_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_COMPANY_NAME;
  END RP_COMPANY_NAME_P;
  FUNCTION RP_FUNCTIONAL_CURRENCY_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_FUNCTIONAL_CURRENCY;
  END RP_FUNCTIONAL_CURRENCY_P;
  FUNCTION RP_DATA_FOUND_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_DATA_FOUND;
  END RP_DATA_FOUND_P;
  FUNCTION RP_CUSTOMER_NAME_RANGE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_CUSTOMER_NAME_RANGE;
  END RP_CUSTOMER_NAME_RANGE_P;
  FUNCTION RP_AGREEMENT_RANGE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_AGREEMENT_RANGE;
  END RP_AGREEMENT_RANGE_P;
  FUNCTION RP_AGREEMENT_NAME_LOW_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_AGREEMENT_NAME_LOW;
  END RP_AGREEMENT_NAME_LOW_P;
  FUNCTION RP_AGREEMENT_NAME_HIGH_P RETURN VARCHAR2 IS
  BEGIN
    RETURN RP_AGREEMENT_NAME_HIGH;
  END RP_AGREEMENT_NAME_HIGH_P;
  FUNCTION IS_FIXED_RATE(X_FROM_CURRENCY IN VARCHAR2
                        ,X_TO_CURRENCY IN VARCHAR2
                        ,X_EFFECTIVE_DATE IN DATE) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
   /* STPROC.INIT('begin :X0 := GL_CURRENCY_API.IS_FIXED_RATE(:X_FROM_CURRENCY, :X_TO_CURRENCY, :X_EFFECTIVE_DATE); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(X_FROM_CURRENCY);
    STPROC.BIND_I(X_TO_CURRENCY);
    STPROC.BIND_I(X_EFFECTIVE_DATE);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
		   X0 := GL_CURRENCY_API.IS_FIXED_RATE(X_FROM_CURRENCY,X_TO_CURRENCY,X_EFFECTIVE_DATE);
    RETURN X0;
  END IS_FIXED_RATE;
/*PROCEDURE GET_RELATION(X_FROM_CURRENCY IN VARCHAR2
                        ,X_TO_CURRENCY IN VARCHAR2
                        ,X_EFFECTIVE_DATE IN DATE
                        ,X_FIXED_RATE IN OUT NOCOPY BOOLEAN
                        ,X_RELATIONSHIP IN OUT NOCOPY VARCHAR2) IS
BEGIN
		X_FIXED_RATE := sys.diutil.int_to_bool(X_FIXED_RATE);
	  GL_CURRENCY_API.GET_RELATION(X_FROM_CURRENCY, X_TO_CURRENCY, X_EFFECTIVE_DATE, X_FIXED_RATE, X_RELATIONSHIP);
		  X_FIXED_RATE := sys.diutil.bool_to_int(X_FIXED_RATE);
  END GET_RELATION;*/
  FUNCTION GET_EURO_CODE RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
   /* STPROC.INIT('begin :X0 := GL_CURRENCY_API.GET_EURO_CODE; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
		   X0 := GL_CURRENCY_API.GET_EURO_CODE;
    RETURN X0;
  END GET_EURO_CODE;
  FUNCTION GET_RATE(X_FROM_CURRENCY IN VARCHAR2
                   ,X_TO_CURRENCY IN VARCHAR2
                   ,X_CONVERSION_DATE IN DATE
                   ,X_CONVERSION_TYPE IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
   /* STPROC.INIT('begin :X0 := GL_CURRENCY_API.GET_RATE(:X_FROM_CURRENCY, :X_TO_CURRENCY, :X_CONVERSION_DATE, :X_CONVERSION_TYPE); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(X_FROM_CURRENCY);
    STPROC.BIND_I(X_TO_CURRENCY);
    STPROC.BIND_I(X_CONVERSION_DATE);
    STPROC.BIND_I(X_CONVERSION_TYPE);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
		   X0 := GL_CURRENCY_API.GET_RATE(X_FROM_CURRENCY, X_TO_CURRENCY, X_CONVERSION_DATE, X_CONVERSION_TYPE);
    RETURN X0;
  END GET_RATE;
  FUNCTION GET_RATE(X_SET_OF_BOOKS_ID IN NUMBER
                   ,X_FROM_CURRENCY IN VARCHAR2
                   ,X_CONVERSION_DATE IN DATE
                   ,X_CONVERSION_TYPE IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
 /*   STPROC.INIT('begin :X0 := GL_CURRENCY_API.GET_RATE(:X_SET_OF_BOOKS_ID, :X_FROM_CURRENCY, :X_CONVERSION_DATE, :X_CONVERSION_TYPE); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(X_SET_OF_BOOKS_ID);
    STPROC.BIND_I(X_FROM_CURRENCY);
    STPROC.BIND_I(X_CONVERSION_DATE);
    STPROC.BIND_I(X_CONVERSION_TYPE);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
		   X0 := GL_CURRENCY_API.GET_RATE(X_SET_OF_BOOKS_ID, X_FROM_CURRENCY, X_CONVERSION_DATE, X_CONVERSION_TYPE);
    RETURN X0;
  END GET_RATE;
  FUNCTION CONVERT_AMOUNT(X_FROM_CURRENCY IN VARCHAR2
                         ,X_TO_CURRENCY IN VARCHAR2
                         ,X_CONVERSION_DATE IN DATE
                         ,X_CONVERSION_TYPE IN VARCHAR2
                         ,X_AMOUNT IN NUMBER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
/*    STPROC.INIT('begin :X0 := GL_CURRENCY_API.CONVERT_AMOUNT(:X_FROM_CURRENCY, :X_TO_CURRENCY, :X_CONVERSION_DATE, :X_CONVERSION_TYPE, :X_AMOUNT); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(X_FROM_CURRENCY);
    STPROC.BIND_I(X_TO_CURRENCY);
    STPROC.BIND_I(X_CONVERSION_DATE);
    STPROC.BIND_I(X_CONVERSION_TYPE);
    STPROC.BIND_I(X_AMOUNT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
		   X0 := GL_CURRENCY_API.CONVERT_AMOUNT(X_FROM_CURRENCY, X_TO_CURRENCY, X_CONVERSION_DATE, X_CONVERSION_TYPE, X_AMOUNT);
    RETURN X0;
  END CONVERT_AMOUNT;
  FUNCTION CONVERT_AMOUNT(X_SET_OF_BOOKS_ID IN NUMBER
                         ,X_FROM_CURRENCY IN VARCHAR2
                         ,X_CONVERSION_DATE IN DATE
                         ,X_CONVERSION_TYPE IN VARCHAR2
                         ,X_AMOUNT IN NUMBER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
 /*   STPROC.INIT('begin :X0 := GL_CURRENCY_API.CONVERT_AMOUNT(:X_SET_OF_BOOKS_ID, :X_FROM_CURRENCY, :X_CONVERSION_DATE, :X_CONVERSION_TYPE, :X_AMOUNT); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(X_SET_OF_BOOKS_ID);
    STPROC.BIND_I(X_FROM_CURRENCY);
    STPROC.BIND_I(X_CONVERSION_DATE);
    STPROC.BIND_I(X_CONVERSION_TYPE);
    STPROC.BIND_I(X_AMOUNT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
		   X0 := GL_CURRENCY_API.CONVERT_AMOUNT(X_SET_OF_BOOKS_ID, X_FROM_CURRENCY, X_CONVERSION_DATE, X_CONVERSION_TYPE, X_AMOUNT);
    RETURN X0;
  END CONVERT_AMOUNT;
  FUNCTION GET_DERIVE_TYPE(SOB_ID IN NUMBER
                          ,PERIOD IN VARCHAR2
                          ,CURR_CODE IN VARCHAR2) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
  /*  STPROC.INIT('begin :X0 := GL_CURRENCY_API.GET_DERIVE_TYPE(:SOB_ID, :PERIOD, :CURR_CODE); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(SOB_ID);
    STPROC.BIND_I(PERIOD);
    STPROC.BIND_I(CURR_CODE);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;*/
    X0 := GL_CURRENCY_API.GET_DERIVE_TYPE(SOB_ID, PERIOD, CURR_CODE);
  END GET_DERIVE_TYPE;
  --added
  function C_CONVERT_AMOUNTFormula(p_use_functional_currency in varchar2,qty_ordered in number ,qty_invoiced in number ,qty_shipped in number ,
  currency2 IN VARCHAR2,rp_functional_currency  IN VARCHAR2,conversion_rate in number,p_sob_id  in number
  ,order_date in date,conversion_type_code in varchar2) return Number is
begin
Declare
     l_conversion_rate number (15,3);
 BEGIN
   l_conversion_rate := 0 ;
 if p_use_functional_currency = 'N' then
  c_qty_ordered  := nvl (qty_ordered,0);
  c_qty_invoiced  := nvl (qty_invoiced,0);
   c_qty_shipped  := nvl (qty_shipped,0);
 end if ;
 IF p_use_functional_currency = 'Y' THEN
	 IF currency2 = rp_functional_currency then
	   l_conversion_rate := 1 ;
	 else
	   IF conversion_rate is null then
	      l_conversion_rate := gl_currency_api.get_rate (
					p_sob_id,
					currency2,
					order_date,
					conversion_type_code );
	   ELSE
	     l_conversion_rate := conversion_rate ;
	   END IF;
	 END IF;
  c_qty_ordered := nvl (l_conversion_rate,0) * nvl ( qty_ordered,0);
  c_qty_shipped := nvl (l_conversion_rate,0) * nvl ( qty_shipped,0);
 c_qty_invoiced := nvl (l_conversion_rate,0) * nvl (qty_invoiced,0);
 END IF ;
 return (0);
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
   c_qty_ordered  := 0 ;
  c_qty_shipped  := 0 ;
  c_qty_invoiced := 0 ;
 c_qty_ordered_dsp  :=  'NO RATE' ;
 c_qty_shipped_dsp  :=  'NO RATE' ;
   c_qty_invoiced_dsp :=  'NO RATE' ;
   return (0);
 end;
RETURN NULL; end;
END ONT_OEXOEASR_XMLP_PKG;


/
