--------------------------------------------------------
--  DDL for Package Body BIS_GNRL_SEARCH_ENGINE_PVT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."BIS_GNRL_SEARCH_ENGINE_PVT" AS
/* $Header: BISVGSEB.pls 115.3 99/08/05 10:43:15 porting ship  $ */
-- **********************************************************
--   Procedure to build the InterMedia query
-- *********************************************************
Procedure build_query (
 p_api_version      in   pls_integer
,p_eul              in   varchar2
,p_keywords_tbl     in   BIS_GNRL_SEARCH_ENGINE_PVT.keywords_tbl_typ
,x_results_tbl      out  BIS_GNRL_SEARCH_ENGINE_PVT.results_tbl_typ
,x_return_status    out  varchar2
,x_error_tbl        out  BIS_UTILITIES_PUB.Error_Tbl_Type
)
IS
v_eul                varchar2(256);
l_sql                varchar2(32000);
l_wordlist           varchar2(32000);
l_dummy              pls_integer;
l_count              pls_integer;
l_cursor             pls_integer;
l_score1             pls_integer;
l_score2             pls_integer;
l_score3             pls_integer;
l_folder_id          pls_integer;
l_folder_name        varchar2(400);
l_folder_description varchar2(32000);
l_results_tbl        BIS_GNRL_SEARCH_ENGINE_PVT.results_tbl_typ;

BEGIN
  x_return_status := FND_API.G_RET_STS_SUCCESS;

 -- To make sure the Intermedia query does not break becuase of lack of schema name
 IF (p_eul IS NOT NULL) THEN
    v_eul := p_eul ||'.';
 ELSE
    v_eul := p_eul;
 END IF;

 -- Construct the search words list from the plsql
 -- table containing the words and add the appropriate InterMedia OPERATORS
 FOR i in 1 .. p_keywords_tbl.COUNT LOOP
   IF i = p_keywords_tbl.COUNT THEN
    l_wordlist := l_wordlist || c_stem_optr ||'{'|| p_keywords_tbl(i) ||'}';
    EXIT;
   END IF;
   l_wordlist := l_wordlist || c_stem_optr ||'{'||p_keywords_tbl(i)||'}'|| c_accum_optr;
 END LOOP;

 -- Add the appropriate number of ' to the ends of the word list to be embedded in the
 -- Intermedia query
 l_wordlist := concat_string(l_wordlist);

 -- ******************************************************************************
 --              CONSTRUCT THE INTERMEDIA SQL QUERY
 -- The '$' STEM operator creates a linguistic root of the word supplied
 -- and returns all row hits that contain words which could be probably
 -- generated by this root word.
 -- The ',' ACCUM operator accumulates the list of words supplied and returns
 -- the highest score for hits containing all of the words and then corresponding
 -- lower scores for subsequent row hits containing one or more words.
 -- The '{ }' ESCAPE SEQUENCE operators escape a group of reserved characters if exists.
 -- Example 1 : For word1 and word2 supplied, the query 'Contains(colname, 'word1,word2',2)
 -- will give the highest score for row hits containing both the words, and then
 -- a lower score for row hits for occurences of word1 OR word2.
 -- Example 2 : If the word contains 'function-layout', it will be read as {function-layout}
 --   as one word inclusive of the '-', where the '-' is escaped.
 -- QUERY FORMULA
 --   The following query will return rows that got the best hits according to
 --   the following priority order...
 --     1) All of the search words exist in eul_objs.obj_name column (Folder name)
 --     2) One or more search words exist in eul_objs.obj_name column (Folder name)
 --     3) All of the search words exist in eul_objs.obj_description col (Fldr desc.)
 --     4) One or more search words exist in eul_objs.obj_description col (Fldr desc)
 --     5) Now the detail table (eul_expressions.exp_name) is searched. This contains
 --        the cols that make up the above Folder/business view. These cols are searched
 --        for every folder_id (eul_objs.obj_id) as one singe 'document set', so that
 --        only one row is returned for hits on any of the folder columns. This part
 --        is taken care by the appropriate index 'BIS_BV_ITEM_NAMES_||'LANG''
 -- ****************************************************************************

 l_sql := ' select score(10), score(20), score(30), ' ||
          ' obj_id, obj_name, obj_description ' ||
          ' from  ' || v_eul || 'eul_objs ' ||
          ' where contains (obj_name, ' || l_wordlist || ', 10) > 0 ' ||
          '    or contains (obj_description, ' || l_wordlist || ', 20) > 0 ' ||
          '    or contains (obj_type, ' || l_wordlist || ', 30) > 0 ' ||
          ' order by score(10) DESC ,score(20) DESC ,score(30) DESC';

 -- *************************************************
 -- *************   For DEBUGGING    ****************
    -- dbms_output.put_line('l_wordlist '||l_wordlist);
    -- dbms_output.put_line('l_sql '||l_sql);
    -- dbms_output.put_line('l_sqlcount '||l_sqlcount);
   /*************************************************
    htp.p('ENTERED BUILD_QUERY ');
    htp.p('l_wordlist '||l_wordlist||'<BR>');
    htp.p('l_sql '||l_sql||'<BR>');
   *************************************************/

  -- Now prepare and run the sql query
  l_cursor  := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(l_cursor, l_sql, DBMS_SQL.NATIVE);
  DBMS_SQL.DEFINE_COLUMN(l_cursor,1, l_score1);
  DBMS_SQL.DEFINE_COLUMN(l_cursor,2, l_score2);
  DBMS_SQL.DEFINE_COLUMN(l_cursor,3, l_score3);
  DBMS_SQL.DEFINE_COLUMN(l_cursor,4, l_folder_id);
  DBMS_SQL.DEFINE_COLUMN(l_cursor,5, l_folder_name,400);
  DBMS_SQL.DEFINE_COLUMN(l_cursor,6, l_folder_description,32000);
  l_dummy := DBMS_SQL.EXECUTE(l_cursor);

  -- Collect the results - folder_id, folder_name and folder_description into
  -- the plsql table to send it back to BIS_BUSINESS_VIEWS_CATALOG packkage
  l_count := 1;
  LOOP
   l_dummy := DBMS_SQL.FETCH_ROWS(l_cursor);
     IF (l_dummy = 0)          THEN EXIT; END IF;
     IF (l_count > C_MAX_HITS) THEN EXIT; END IF;

   DBMS_SQL.COLUMN_VALUE(l_cursor, 1, l_score1);
   DBMS_SQL.COLUMN_VALUE(l_cursor, 2, l_score2);
   DBMS_SQL.COLUMN_VALUE(l_cursor, 3, l_score3);
   DBMS_SQL.COLUMN_VALUE(l_cursor, 4, l_folder_id);
   DBMS_SQL.COLUMN_VALUE(l_cursor, 5, l_folder_name);
   DBMS_SQL.COLUMN_VALUE(l_cursor, 6, l_folder_description);

   -- Transfer the fetched values from the buffer into the plsql table
   l_results_tbl(l_count).folder_id          := l_folder_id;
   l_results_tbl(l_count).folder_name        := l_folder_name;
   l_results_tbl(l_count).folder_description := l_folder_description;
   l_count := l_count + 1;
  END LOOP;

  -- Close the cursor
  DBMS_SQL.CLOSE_CURSOR(l_cursor);
  COMMIT;

 -- Send this table of results back
 x_results_tbl  := l_results_tbl;


EXCEPTION
  WHEN NO_DATA_FOUND THEN
    x_return_status := FND_API.G_RET_STS_ERROR;
  WHEN OTHERS THEN
    x_return_status := FND_API.G_RET_STS_UNEXP_ERROR;
  BIS_UTILITIES_PVT.Add_Error_Message
                      ( p_error_table       => x_error_Tbl
                      , p_error_msg_id      => SQLCODE
                      , p_error_description => SQLERRM
                      , x_error_table       => x_error_Tbl
                      );
  --htp.p('Error in BIS_GNRL_SEARCH_ENGINE_PVT.build_query'||SQLERRM);
  RAISE;

END build_query;

-- *************************************************************
--  Get the intermedia domain index owner
-- *************************************************************
Function get_a_index_owner( p_index    in varchar2 )
return varchar2
IS
CURSOR cur_idx_owner IS
  SELECT owner
  FROM ALL_INDEXES
  WHERE index_name like p_index;

l_owner    varchar2(200);
BEGIN

  OPEN  cur_idx_owner;
   BEGIN
     FETCH cur_idx_owner INTO l_owner;
   EXCEPTION
     WHEN OTHERS THEN CLOSE cur_idx_owner;
       RAISE;
   END;
  CLOSE cur_idx_owner;
  return l_owner;

EXCEPTION
  WHEN OTHERS THEN
  --htp.p('Error in BIS_GNRL_SEARCH_ENGINE_PVT.get_a_index_owner');
  RAISE;
END get_a_index_owner;

-- ****************************************************
--     Function to return a string with attachments on
--               both sides
-- ****************************************************
function concat_string (p_str   in varchar2)
return
   varchar2 is
v_local_str   varchar2(3200);

begin
   v_local_str := ''''||p_str||'''';

   return v_local_str;
end concat_string;

-- *****************************************************

-- ***************************************************************
-- ***************************************************************
END BIS_GNRL_SEARCH_ENGINE_PVT;

/
