--------------------------------------------------------
--  DDL for Package Body FA_CMP_STRING_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."FA_CMP_STRING_PKG" AS
/* $Header: facpstrb.pls 120.0.12010000.2 2009/07/19 08:37:36 glchen ship $   */
/*===========================================================================+
|             Copyright (c) 2001-2002 Oracle Corporation                     |
|                       Redwood Shores, CA, USA                              |
|                         All rights reserved.                               |
+============================================================================+
| PACKAGE NAME                                                               |
|     fa_cmp_string_pkg                                                      |
|                                                                            |
| DESCRIPTION                                                                |
|     This is a FA private package, which contains all the logic required    |
|     to handle the text generated by the compiler                           |
|                                                                            |
| HISTORY                                                                    |
|     25-FEB-2006 BRIDGWAY    Created                                        |
+===========================================================================*/

--+==========================================================================+
--|                                                                          |
--| OVERVIEW of private procedures and functions                             |
--|                                                                          |
--+==========================================================================+

g_Max_line            CONSTANT NUMBER        := 255;
g_chr_quote           CONSTANT VARCHAR2(9)   := '''';
g_chr_space           CONSTANT VARCHAR2(9)   := ' ';
G_MAX_PACKAGE_LINE_LENGTH CONSTANT INTEGER := 255;

--=============================================================================
--               *********** Local Trace Routine **********
--=============================================================================

G_CURRENT_RUNTIME_LEVEL        NUMBER := FND_LOG.G_CURRENT_RUNTIME_LEVEL;

G_LEVEL_STATEMENT     CONSTANT NUMBER := FND_LOG.LEVEL_STATEMENT;
G_LEVEL_PROCEDURE     CONSTANT NUMBER := FND_LOG.LEVEL_PROCEDURE;
G_LEVEL_EVENT         CONSTANT NUMBER := FND_LOG.LEVEL_EVENT;
G_LEVEL_EXCEPTION     CONSTANT NUMBER := FND_LOG.LEVEL_EXCEPTION;
G_LEVEL_ERROR         CONSTANT NUMBER := FND_LOG.LEVEL_ERROR;
G_LEVEL_UNEXPECTED    CONSTANT NUMBER := FND_LOG.LEVEL_UNEXPECTED;

G_MODULE_NAME         CONSTANT VARCHAR2(50):= 'fa.plsql.fa_cmp_string_pkg';

--+==========================================================================+
--|                                                                          |
--| PUBLIC Function                                                          |
--|                                                                          |
--+==========================================================================+

FUNCTION  ConcatTwoStrings (
                   p_array_string_1           IN DBMS_SQL.VARCHAR2S
                  ,p_array_string_2           IN DBMS_SQL.VARCHAR2S
) RETURN DBMS_SQL.VARCHAR2S IS

   l_array_string       DBMS_SQL.VARCHAR2S;
   l_Index              BINARY_INTEGER;
   l_procedure_name  varchar2(80) := 'ConcatTwoStrings';

BEGIN

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.begin',
                     'Beginning of procedure');
   END IF;


   IF (G_LEVEL_STATEMENT >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_STATEMENT,
                     G_MODULE_NAME||l_procedure_name,
                     'LENGTH string 1 = '||p_array_string_1.COUNT);
      fnd_log.string(G_LEVEL_STATEMENT,
                     G_MODULE_NAME||l_procedure_name,
                     'LENGTH string 2 = '||p_array_string_2.COUNT);
   END IF;

   l_array_string := p_array_string_1;

   IF p_array_string_2.COUNT > 0 THEN

      l_Index        := NVL(l_array_string.LAST,0);

      FOR Idx IN p_array_string_2.FIRST .. p_array_string_2.LAST LOOP

        IF p_array_string_2.EXISTS(Idx) THEN

           l_Index                 := l_Index + 1;
           l_array_string(l_Index) := p_array_string_2(Idx);

        END IF;

      END LOOP;

   END IF;

   IF (G_LEVEL_STATEMENT >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_STATEMENT,
                     G_MODULE_NAME||l_procedure_name,
                     'LENGTH result = '||l_array_string.COUNT);
   END IF;

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.end',
                     'End of procedure');
   END IF;

   RETURN l_array_string;

EXCEPTION
   WHEN OTHERS    THEN
        IF (G_LEVEL_UNEXPECTED >= G_CURRENT_RUNTIME_LEVEL ) THEN
           fnd_message.set_name('OFA','FA_SHARED_ORACLE_ERR');
           fnd_message.set_token('ORACLE_ERR',SQLERRM);
           FND_LOG.MESSAGE (G_LEVEL_UNEXPECTED,G_MODULE_NAME||l_procedure_name,TRUE);
        END IF;
        raise;

END ConcatTwoStrings;


--+==========================================================================+
--| PRIVATE procedures and functions                                         |
--|    CreateString                                                          |
--|    transforms CLOB lines (length > 255) into a list of lines not         |
--|    exceeding 255 characters                                              |
--|                                                                          |
--|    Modified this procedure to improve performance bug 3918467            |
--+==========================================================================+

PROCEDURE CreateString
        (p_package_text  IN  CLOB
        ,p_array_string  OUT NOCOPY DBMS_SQL.VARCHAR2S) IS

   l_Text                VARCHAR2(32000);
   l_SubText             VARCHAR2(256);

   l_MaxLine             NUMBER   := 255;

   l_NewLine             BOOLEAN;
   l_Literal             BOOLEAN;
   l_Space               BOOLEAN;

   l_pos                 NUMBER         ;

   l_Idx                 BINARY_INTEGER;
   l_array_string        DBMS_SQL.VARCHAR2S;
   l_procedure_name      varchar2(80) := 'CreateString';

   l_clob_string         CLOB;
   l_maxLength           NUMBER := 8000;

   l_length              number;
   l_iteration           number;

BEGIN

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.begin',
                     'Beginning of procedure');
   END IF;

   l_clob_string := p_package_text;

   l_pos       := 0;
   l_NewLine   := FALSE;
   l_Literal   := FALSE;
   l_Space     := FALSE;
   l_Idx       := 0;

   IF (G_LEVEL_STATEMENT >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_STATEMENT,
                     G_MODULE_NAME||l_procedure_name,
                     'Begin looping....');
   END IF;

   WHILE length(l_clob_string) > 0 LOOP

      l_text := substr(l_clob_string,1,l_maxLength);

      WHILE ( LENGTH(l_Text) >= l_MaxLine ) LOOP
         BEGIN

            l_SubText   := SUBSTR(l_Text,1,l_MaxLine);
            l_pos       := INSTR(l_SubText,g_chr_newline,1,1);

            IF l_pos = 0 THEN
               l_NewLine := FALSE;
               l_pos := INSTR(l_SubText,g_chr_quote,1,1);
               IF l_pos = 0 THEN
                  l_Literal := FALSE;
                  l_pos     := INSTR(l_SubText,g_chr_space,1,1);
                  l_Space   := (l_pos = 0);
               ELSE
                  l_Literal := TRUE;
               END IF;
            ELSE
               l_NewLine := TRUE;
            END IF;

            IF l_newline THEN
               l_Idx                  := l_Idx + 1;
               l_array_string(l_Idx)  := SUBSTR(l_SubText,1,l_pos);
               l_Text                 := SUBSTR(l_Text,l_pos + 1);
            ELSIF l_Literal THEN
               l_Idx                  := l_Idx + 1;
               l_array_string(l_Idx)  := SUBSTR(l_SubText,1,l_pos-1) || g_chr_newline;
               l_Text                 := SUBSTR(l_Text,l_pos);
            ELSIF l_Space   THEN
               l_Idx                  := l_Idx + 1;
               l_array_string(l_Idx)  := SUBSTR(l_SubText,1,l_pos-1) || g_chr_newline;
               l_Text                 := SUBSTR(l_Text,l_pos + 1);
            ELSE
               l_Idx                  := l_Idx + 1;
               l_array_string(l_Idx)  := l_SubText;
               l_Text                 := SUBSTR(l_Text,l_MaxLine + 1);
            END IF;
         END;
      END LOOP;

      IF (length(l_clob_string)-l_maxLength) >= 0 THEN
         l_clob_string := substr(l_clob_string,(l_maxLength - length(l_Text) + 1));
      ELSE
         l_clob_string := NULL;
         l_Idx                 := l_Idx + 1;
         l_array_string(l_Idx) := l_Text;
      END IF;

   END LOOP;

   p_array_string := l_array_string;

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.end',
                     'End of procedure');
   END IF;

END CreateString;

--+==========================================================================+
--| PRIVATE procedures and functions                                         |
--|    AddNewLine                                                            |
--|    transforms CLOB lines (length > 255) into a list of lines not         |
--|    exceeding 255 characters                                              |
--|                                                                          |
--|                                                                          |
--+==========================================================================+

PROCEDURE AddNewLine(p_array_string  IN  OUT NOCOPY DBMS_SQL.VARCHAR2S) IS

   l_Idx                 BINARY_INTEGER;
   l_array_string        DBMS_SQL.VARCHAR2S;
   l_procedure_name      varchar2(80) := 'AddNewLine';

BEGIN

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.begin',
                     'Beginning of procedure');
   END IF;

   l_array_string := p_array_string;

   IF l_array_string.COUNT > 0 THEN

      FOR Idx IN l_array_string.FIRST .. l_array_string.LAST LOOP

         IF l_array_string.EXISTS(Idx) THEN

            IF SUBSTR(l_array_string(Idx),LENGTH(l_array_string(Idx))) <> g_chr_newline THEN

               l_array_string(Idx) := l_array_string(Idx) || g_chr_newline;

            END IF;

         END IF;

      END LOOP;

   END IF;

   p_array_string := l_array_string;

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.end',
                     'End of procedure');
   END IF;

EXCEPTION

   WHEN OTHERS    THEN
        IF (G_LEVEL_UNEXPECTED >= G_CURRENT_RUNTIME_LEVEL ) THEN
           fnd_message.set_name('OFA','FA_SHARED_ORACLE_ERR');
           fnd_message.set_token('ORACLE_ERR',SQLERRM);
           FND_LOG.MESSAGE (G_LEVEL_UNEXPECTED,G_MODULE_NAME||l_procedure_name,TRUE);
        END IF;
        raise;

END AddNewLine;


--+==========================================================================+
--| PRIVATE procedures and functions                                         |
--|    truncate_lines                                                        |
--|    transforms CLOB lines (length > 255) into a list of lines not         |
--|    exceeding 255 characters, this constraint was inposed by MRC product  |
--|                                                                          |
--|                                                                          |
--+==========================================================================+

PROCEDURE truncate_lines(p_package_text IN OUT NOCOPY CLOB) IS


   l_Text                CLOB;
   l_SubText             VARCHAR2(256);

   l_MaxLine             NUMBER   := g_Max_line;

   l_NewLine             BOOLEAN;
   l_Literal             BOOLEAN;
   l_Space               BOOLEAN;

   l_pos                 NUMBER         ;

   l_Output              CLOB;
   l_procedure_name     varchar2(80) := 'truncate_lines';


BEGIN

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.begin',
                     'Beginning of procedure');
   END IF;


   l_Text      := p_package_text;
   l_pos       := 0;
   l_NewLine   := FALSE;
   l_Literal   := FALSE;
   l_Space     := FALSE;
   l_Output    := NULL;

   WHILE ( LENGTH(l_Text) >= l_MaxLine ) LOOP

      BEGIN

         l_SubText   := SUBSTR(l_Text,1,l_MaxLine);
         l_pos       := INSTR(l_SubText,g_chr_newline,1,1);

         IF l_pos = 0 THEN

            l_NewLine := FALSE;
            l_pos := INSTR(l_SubText,g_chr_quote,1,1);

            IF l_pos = 0 THEN

               l_Literal := FALSE;
               l_pos     := INSTR(l_SubText,g_chr_space,1,1);
               l_Space   := (l_pos = 0);

            ELSE

               l_Literal := TRUE;

            END IF;

         ELSE

            l_NewLine := TRUE;

         END IF;


         IF l_newline THEN

            l_Output               := l_Output || SUBSTR(l_SubText,1,l_pos);
            l_Text                 := SUBSTR(l_Text,l_pos + 1);

         ELSIF l_Literal THEN

            l_Output               := l_Output || SUBSTR(l_SubText,1,l_pos-1) || g_chr_newline;
            l_Text                 := SUBSTR(l_Text,l_pos);

         ELSIF l_Space   THEN

            l_Output               := l_Output || SUBSTR(l_SubText,1,l_pos-1) || g_chr_newline;
            l_Text                 := SUBSTR(l_Text,l_pos + 1);

         ELSE

            l_Output               := l_Output || l_SubText;
            l_Text                 := SUBSTR(l_Text,l_MaxLine + 1);

         END IF;

      END;

   END LOOP;


   IF LENGTH(l_Text) > 0 THEN

      l_Output              := l_Output|| l_Text;

   END IF;

   p_package_text := l_Output;

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.end',
                     'End of procedure');
   END IF;

EXCEPTION
   WHEN OTHERS    THEN
        IF (G_LEVEL_UNEXPECTED >= G_CURRENT_RUNTIME_LEVEL ) THEN
           fnd_message.set_name('OFA','FA_SHARED_ORACLE_ERR');
           fnd_message.set_token('ORACLE_ERR',SQLERRM);
           FND_LOG.MESSAGE (G_LEVEL_UNEXPECTED,G_MODULE_NAME||l_procedure_name,TRUE);
        END IF;
        raise;

END truncate_lines;

--+==========================================================================+
--|                                                                          |
--| PUBLIC Procedure                                                         |
--|                                                                          |
--+==========================================================================+

PROCEDURE DumpLines (p_array_output_string      IN DBMS_SQL.VARCHAR2S) IS

   l_array_string    DBMS_SQL.VARCHAR2S;
   l_procedure_name  varchar2(80) := 'DumpLines';

BEGIN

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.begin',
                     'Beginning of procedure');
   END IF;

   IF p_array_output_string.COUNT > 0 THEN

      FOR Idx IN p_array_output_string.FIRST .. p_array_output_string.LAST LOOP

         IF p_array_output_string.EXISTS(Idx) THEN

            IF (G_LEVEL_STATEMENT >= G_CURRENT_RUNTIME_LEVEL ) THEN
               fnd_log.string(G_LEVEL_STATEMENT,
                              G_MODULE_NAME||l_procedure_name,
                               RPAD(Idx,10,' ')||' '||p_array_output_string(Idx));
            END IF;

         END IF;

      END LOOP;

   END IF;

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.end',
                     'End of procedure');
   END IF;

EXCEPTION
   WHEN OTHERS    THEN
        IF (G_LEVEL_UNEXPECTED >= G_CURRENT_RUNTIME_LEVEL ) THEN
           fnd_message.set_name('OFA','FA_SHARED_ORACLE_ERR');
           fnd_message.set_token('ORACLE_ERR',SQLERRM);
           FND_LOG.MESSAGE (G_LEVEL_UNEXPECTED,G_MODULE_NAME||l_procedure_name,TRUE);
        END IF;
        raise;


END DumpLines;

--+==========================================================================+
--|                                                                          |
--| PUBLIC Procedure                                                         |
--|                                                                          |
--+==========================================================================+

FUNCTION replace_token
       (p_original_text             IN  CLOB
       ,p_token                     IN  VARCHAR2
       ,p_replacement_text          IN  CLOB) RETURN CLOB IS

   l_found_position        INTEGER;
   l_return_value          CLOB;
   l_procedure_name        varchar2(80) := 'replace_token';

BEGIN

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.begin',
                     'Beginning of procedure');
   END IF;


   -- Copy the original clob into a local variable
   l_return_value   := p_original_text;


   -- Find the first occurrence of the token
   l_found_position := INSTR(l_return_value, p_token);


   -- If not found exit
   IF l_found_position = 0 OR l_found_position IS NULL THEN
      NULL;
   ELSE
      -- Extract the portions around the token and embed the replacement
      -- Bug 4444678. Used the iterative call to replace_token

      l_return_value := SUBSTR(l_return_value ,1 ,l_found_position - 1) ||
                        p_replacement_text  ||
                        replace_token
                           (SUBSTR(l_return_value,l_found_position + LENGTH(p_token))
                           ,p_token
                           ,p_replacement_text);
   END IF;

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.end',
                     'End of procedure');
   END IF;

   RETURN l_return_value;

EXCEPTION
   WHEN OTHERS    THEN
        IF (G_LEVEL_UNEXPECTED >= G_CURRENT_RUNTIME_LEVEL ) THEN
           fnd_message.set_name('OFA','FA_SHARED_ORACLE_ERR');
           fnd_message.set_token('ORACLE_ERR',SQLERRM);
           FND_LOG.MESSAGE (G_LEVEL_UNEXPECTED,G_MODULE_NAME||l_procedure_name,TRUE);
        END IF;
        raise;

END replace_token;


PROCEDURE clob_to_varchar2s
                    (
                      p_clob          IN  CLOB
                     ,p_varchar2s     OUT NOCOPY DBMS_SQL.VARCHAR2S
                    )
IS
   l_current_table_index PLS_INTEGER;
   l_current_pos_in_clob PLS_INTEGER;
   l_next_newline_pos    PLS_INTEGER;
   l_clob_length         PLS_INTEGER;
   l_subarray            DBMS_SQL.VARCHAR2S;
   l_procedure_name        varchar2(80) := 'replace_token';

BEGIN

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.begin',
                     'Beginning of procedure');
   END IF;

   l_clob_length         := LENGTH(p_clob);
   l_current_table_index := -1;
   l_current_pos_in_clob := 1;

   WHILE l_current_pos_in_clob < l_clob_length LOOP
      l_current_table_index := l_current_table_index + 1;
      l_next_newline_pos    := INSTR
        ( p_clob                --clob to search
         ,g_chr_newline         --character to look for
         ,l_current_pos_in_clob --starting position
         ,1                     --occurrence
        );

      IF l_next_newline_pos = 0 THEN
         --no new line found, take all the string to the end
         --if the length of the substring exceeds the maximum
         --break it into substrings
         IF (l_clob_length - l_current_pos_in_clob + 1 )
             <= G_MAX_PACKAGE_LINE_LENGTH THEN
            --the chunk length is within the maximum
            p_varchar2s(l_current_table_index) := SUBSTR
                                                  ( p_clob
                                                   ,l_current_pos_in_clob
                                                  );
         ELSE
            CreateString
                   (
                     p_package_text => SUBSTR
                                          ( p_clob
                                           ,l_current_pos_in_clob
                                          )
                    ,p_array_string => l_subarray
                   );
            FOR i IN l_subarray.FIRST..l_subarray.LAST LOOP
               IF i > l_subarray.FIRST THEN
                  l_current_table_index := l_current_table_index + 1;
               END IF;
               p_varchar2s(l_current_table_index) := l_subarray(i);
            END LOOP;
         END IF;

         l_current_pos_in_clob              := l_clob_length;

      ELSIF l_next_newline_pos IS NULL THEN
         --probably offset > LOBMAXSIZE
         NULL;
         --raise exception
      ELSE
         IF (l_next_newline_pos - l_current_pos_in_clob + 1 )
            <= G_MAX_PACKAGE_LINE_LENGTH
         THEN
            --take the portion
            p_varchar2s(l_current_table_index) := SUBSTR
                                                  ( p_clob
                                                   ,l_current_pos_in_clob
                                                   ,l_next_newline_pos
                                                    - l_current_pos_in_clob
                                                    + 1
                                                  );
         ELSE
            CreateString
                   (
                     p_package_text => SUBSTR
                                                  ( p_clob
                                                   ,l_current_pos_in_clob
                                                   ,l_next_newline_pos
                                                    - l_current_pos_in_clob
                                                    + 1
                                                  )
                    ,p_array_string => l_subarray
                   );
            FOR i IN l_subarray.FIRST..l_subarray.LAST
            LOOP
               IF i > l_subarray.FIRST
               THEN
                  l_current_table_index := l_current_table_index + 1;
               END IF;
               p_varchar2s(l_current_table_index) := l_subarray(i);
            END LOOP;
         END IF;

         l_current_pos_in_clob              := l_next_newline_pos + 1;

      END IF;
   END LOOP;

   IF (G_LEVEL_PROCEDURE >= G_CURRENT_RUNTIME_LEVEL ) THEN
      fnd_log.string(G_LEVEL_PROCEDURE,
                     G_MODULE_NAME||l_procedure_name||'.end',
                     'End of procedure');
   END IF;

EXCEPTION
   WHEN OTHERS    THEN
        IF (G_LEVEL_UNEXPECTED >= G_CURRENT_RUNTIME_LEVEL ) THEN
           fnd_message.set_name('OFA','FA_SHARED_ORACLE_ERR');
           fnd_message.set_token('ORACLE_ERR',SQLERRM);
           FND_LOG.MESSAGE (G_LEVEL_UNEXPECTED,G_MODULE_NAME||l_procedure_name,TRUE);
        END IF;
        raise;

END clob_to_varchar2s;

--=============================================================================

END fa_cmp_string_pkg;

/
