--------------------------------------------------------
--  DDL for Package Body JL_JLMXFIMP_XMLP_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."JL_JLMXFIMP_XMLP_PKG" AS
/* $Header: JLMXFIMPB.pls 120.1 2007/12/25 16:53:01 dwkrishn noship $ */
  PROCEDURE GET_BASE_CURR_DATA IS
    BASE_CURR FND_CURRENCIES_VL.CURRENCY_CODE%TYPE;
    PREC FND_CURRENCIES_VL.PRECISION%TYPE;
    MIN_AU FND_CURRENCIES_VL.MINIMUM_ACCOUNTABLE_UNIT%TYPE;
    DESCR FND_CURRENCIES_VL.DESCRIPTION%TYPE;
    ERRNO NUMBER;
    ERRMSG VARCHAR2(1000);
  BEGIN
    BASE_CURR := '';
    PREC := 0;
    MIN_AU := 0;
    DESCR := '';
    BEGIN
      SELECT
        COMPANY_NAME,
        CATEGORY_FLEX_STRUCTURE
      INTO C_ORGANIZATION_NAME,CAT_FLEX_STRUCT
      FROM
        FA_SYSTEM_CONTROLS;
    EXCEPTION
      WHEN OTHERS THEN
        NULL;
    END;
    IF UPPER(P_MRCSOBTYPE) = 'R' THEN
      BEGIN
        SELECT
          FCURR.CURRENCY_CODE,
          FCURR.PRECISION,
          FCURR.MINIMUM_ACCOUNTABLE_UNIT,
          FCURR.DESCRIPTION
        INTO BASE_CURR,PREC,MIN_AU,DESCR
        FROM
          FA_BOOK_CONTROLS_MRC_V BKCTRL,
          FND_CURRENCIES_VL FCURR,
          GL_SETS_OF_BOOKS GSBKS
        WHERE BKCTRL.BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
          AND BKCTRL.SET_OF_BOOKS_ID = GSBKS.SET_OF_BOOKS_ID
          AND GSBKS.CURRENCY_CODE = FCURR.CURRENCY_CODE;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_ERR('JL_AR_FA_CURR_DET_NOT_DEFINED'
                   ,'N');
        WHEN OTHERS THEN
          RAISE_ORA_ERR;
      END;
    ELSE
      BEGIN
        SELECT
          FCURR.CURRENCY_CODE,
          FCURR.PRECISION,
          FCURR.MINIMUM_ACCOUNTABLE_UNIT,
          FCURR.DESCRIPTION
        INTO BASE_CURR,PREC,MIN_AU,DESCR
        FROM
          FA_BOOK_CONTROLS BKCTRL,
          FND_CURRENCIES_VL FCURR,
          GL_SETS_OF_BOOKS GSBKS
        WHERE BKCTRL.BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
          AND BKCTRL.SET_OF_BOOKS_ID = GSBKS.SET_OF_BOOKS_ID
          AND GSBKS.CURRENCY_CODE = FCURR.CURRENCY_CODE;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_ERR('JL_AR_FA_CURR_DET_NOT_DEFINED'
                   ,'N');
        WHEN OTHERS THEN
          RAISE_ORA_ERR;
      END;
    END IF;
    C_BASE_CURRENCY_CODE := BASE_CURR;
    C_BASE_PRECISION := PREC;
    C_BASE_MIN_ACCT_UNIT := MIN_AU;
    C_BASE_DESCRIPTION := DESCR;
  END GET_BASE_CURR_DATA;

  FUNCTION AFTERREPORT RETURN BOOLEAN IS
  BEGIN
    BEGIN
      /*SRW.USER_EXIT('FND SRWEXIT')*/NULL;
    EXCEPTION
      WHEN OTHERS THEN
        /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
    END;
    RETURN (TRUE);
  END AFTERREPORT;

  FUNCTION C_PRICE_INDEXFORMULA(ASSET_CATEGORY IN NUMBER
                               ,ACQDATE IN DATE) RETURN NUMBER IS
    X NUMBER(15);
    CATEGORY_DESC VARCHAR2(40);
    ERRMSG VARCHAR2(1000);
  BEGIN
    SELECT
      FPI.PRICE_INDEX_ID
    INTO X
    FROM
      FA_PRICE_INDEXES FPI,
      FA_CATEGORY_BOOK_DEFAULTS FCBD
    WHERE FCBD.BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
      AND FCBD.CATEGORY_ID = ASSET_CATEGORY
      AND ACQDATE >= FCBD.START_DPIS
      AND ACQDATE <= NVL(FCBD.END_DPIS
       ,ACQDATE)
      AND FCBD.PRICE_INDEX_NAME = FPI.PRICE_INDEX_NAME;
    IF X IS NULL THEN
      RAISE NO_DATA_FOUND;
    END IF;
    RETURN (X);
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      SELECT
        DESCRIPTION
      INTO CATEGORY_DESC
      FROM
        FA_CATEGORIES
      WHERE CATEGORY_ID = ASSET_CATEGORY;
      SET_NAME('JL'
              ,'JL_ZZ_FA_INDX_NOT_DEF_FOR_CATG');
      SET_TOKEN('ASSET_CATEGORY'
               ,CATEGORY_DESC
               ,FALSE);
      ERRMSG := GET;
      /*SRW.MESSAGE(JL_ZZ_FA_UTILITIES_PKG.GET_APP_ERRNUM('JL'
                                                       ,'JL_ZZ_FA_INDX_NOT_DEF_FOR_CATG')
                 ,ERRMSG)*/NULL;
      /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
      RETURN NULL;
    WHEN OTHERS THEN
      RAISE_ORA_ERR;
      RETURN NULL;
  END C_PRICE_INDEXFORMULA;

  FUNCTION C_INDEX_VALUE_JUNEFORMULA(C_PRICE_INDEX IN NUMBER) RETURN NUMBER IS
    X NUMBER;
    JUNE_PERIOD_DATE DATE;
    ERRMSG VARCHAR2(1000);
    INDEX_NAME VARCHAR2(40);
  BEGIN
    JUNE_PERIOD_DATE := TO_DATE('30-06-' || TO_CHAR(P_CURR_FY)
                               ,'DD-MM-YYYY');
    SELECT
      PRICE_INDEX_VALUE
    INTO X
    FROM
      FA_PRICE_INDEX_VALUES
    WHERE PRICE_INDEX_ID = C_PRICE_INDEX
      AND JUNE_PERIOD_DATE BETWEEN FROM_DATE
      AND TO_DATE;
    RETURN (NVL(X
              ,0));
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      SELECT
        PRICE_INDEX_NAME
      INTO INDEX_NAME
      FROM
        FA_PRICE_INDEXES
      WHERE PRICE_INDEX_ID = C_PRICE_INDEX;
      SET_NAME('JL'
              ,'JL_ZZ_FA_INDX_VAL_NOT_FOUND');
      SET_TOKEN('PRICE_INDEX'
               ,INDEX_NAME
               ,FALSE);
      SET_TOKEN('MISSING_DATE'
               ,TO_CHAR(JUNE_PERIOD_DATE)
               ,FALSE);
      ERRMSG := GET;
      /*SRW.MESSAGE(JL_ZZ_FA_UTILITIES_PKG.GET_APP_ERRNUM('JL'
                                                       ,'JL_ZZ_FA_INDX_VAL_NOT_FOUND')
                 ,ERRMSG)*/NULL;
      /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
      RETURN NULL;
    WHEN OTHERS THEN
      RAISE_ORA_ERR;
      RETURN NULL;
  END C_INDEX_VALUE_JUNEFORMULA;

  FUNCTION C_CORR_FACTORFORMULA(ACQDATE IN DATE
                               ,C_INDEX_VALUE_JUNE IN NUMBER
                               ,INPC IN NUMBER) RETURN NUMBER IS
    V_FACTOR NUMBER;
  BEGIN
    IF TRUNC(ACQDATE) > NVL(TRUNC(C_END_MID_YR)
       ,TRUNC(ACQDATE) - 1) THEN
      V_FACTOR := 1;
    ELSE
      V_FACTOR := TRUNC(C_INDEX_VALUE_JUNE / nvl(INPC,1)
                       ,C_RATIO_PRECISION);
    END IF;
    RETURN (V_FACTOR);
  END C_CORR_FACTORFORMULA;

  FUNCTION C_ADJ_NBV_LESS_50PERFORMULA(C_ADJ_NBV_END_PREV_FY IN NUMBER
                                      ,C_50PER_ADJ_DEPRN_CURR_FY IN NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN (C_ADJ_NBV_END_PREV_FY - C_50PER_ADJ_DEPRN_CURR_FY);
  END C_ADJ_NBV_LESS_50PERFORMULA;

  FUNCTION C_ADJ_NBV_END_PREV_FYFORMULA(C_NBV_END_PREV_FY IN NUMBER
                                       ,C_CORR_FACTOR IN NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN (C_NBV_END_PREV_FY * C_CORR_FACTOR);
  END C_ADJ_NBV_END_PREV_FYFORMULA;

  FUNCTION C_50PER_ADJ_DEPRN_CURR_FYFORMU(ADJUSTED_DEPRN_CURRENT_FY IN NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN (ADJUSTED_DEPRN_CURRENT_FY * 0.5);
  END C_50PER_ADJ_DEPRN_CURR_FYFORMU;

  FUNCTION C_IMPAC_BASE_VALUEFORMULA(ACQDATE IN DATE
                                    ,RETIREMENT_ID_1 IN NUMBER
                                    ,CF_RETIREMENT_DATE IN DATE
                                    ,PERIOD_COUNTER_FULLY_RESERVED IN NUMBER
                                    ,C_ADJ_NBV_LESS_50PER IN NUMBER) RETURN NUMBER IS
    L_PERIODS_OF_USE NUMBER;
    L_ADDITION_MONTH NUMBER;
    L_RETIREMENT_MONTH NUMBER;
    L_INCLUDE_RET VARCHAR2(1);
  BEGIN
    L_INCLUDE_RET := P_INCLUDE_RET;
    IF ACQDATE BETWEEN C_FISCAL_START_DATE AND C_FISCAL_END_DATE THEN
      L_ADDITION_MONTH := TO_NUMBER(TO_CHAR(ACQDATE
                                           ,'MM'));
    ELSE
      L_ADDITION_MONTH := 0;
    END IF;
    IF RETIREMENT_ID_1 IS NOT NULL THEN
      L_RETIREMENT_MONTH := TO_NUMBER(TO_CHAR(CF_RETIREMENT_DATE
                                             ,'MM'));
    ELSE
      IF PERIOD_COUNTER_FULLY_RESERVED IS NOT NULL AND (PERIOD_COUNTER_FULLY_RESERVED BETWEEN MIN_PERIOD_COUNTER AND MAX_PERIOD_COUNTER) THEN
        IF P_FULLY_DEPRN_ASSETS = 'IN USE' THEN
          L_RETIREMENT_MONTH := 13;
        END IF;
        IF P_FULLY_DEPRN_ASSETS = 'RETIRED' THEN
          IF UPPER(P_MRCSOBTYPE) = 'R' THEN
            BEGIN
              SELECT
                PERIOD_NUM
              INTO L_RETIREMENT_MONTH
              FROM
                FA_DEPRN_PERIODS_MRC_V
              WHERE BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
                AND PERIOD_COUNTER = PERIOD_COUNTER_FULLY_RESERVED;
            END;
          ELSE
            BEGIN
              SELECT
                PERIOD_NUM
              INTO L_RETIREMENT_MONTH
              FROM
                FA_DEPRN_PERIODS
              WHERE BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
                AND PERIOD_COUNTER = PERIOD_COUNTER_FULLY_RESERVED;
            END;
          END IF;
          L_INCLUDE_RET := 'Y';
        END IF;
      ELSE
        L_RETIREMENT_MONTH := 13;
      END IF;
    END IF;
    L_PERIODS_OF_USE := JL_ZZ_FA_FUNCTIONS_PKG.PERIODS_OF_USE(L_ADDITION_MONTH
                                                             ,L_RETIREMENT_MONTH
                                                             ,P_INCLUDE_DPIS
                                                             ,L_INCLUDE_RET);
    RETURN ((C_ADJ_NBV_LESS_50PER / PERIODS_PER_FY) * L_PERIODS_OF_USE);
  END C_IMPAC_BASE_VALUEFORMULA;

  FUNCTION C_NBV_END_PREV_FYFORMULA(ORIGINAL_COST IN NUMBER
                                   ,ACCUM_DEPRN_PREVIOUS_FY IN NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN (ORIGINAL_COST - ACCUM_DEPRN_PREVIOUS_FY);
  END C_NBV_END_PREV_FYFORMULA;

  PROCEDURE CUSTOM_INIT IS
    FIS_YR NUMBER(4);
    V_RATIO_PRECISION VARCHAR2(10);
    L_STAGE_REQUEST_ID NUMBER(15);
    L_SET_REQUEST_ID NUMBER(15);
    V_PERIODS_PER_FY NUMBER;
    V_CALENDAR_TYPE VARCHAR2(15);
    V_MIN_PERIOD_COUNTER NUMBER;
    V_MAX_PERIOD_COUNTER NUMBER;
    V_MIDDLE_YEAR NUMBER;
    V_START_DATE DATE;
    V_END_DATE DATE;
    V_START_DATE_FISCAL_YEAR DATE;
    V_END_DATE_FISCAL_YEAR DATE;
  BEGIN
    /*SRW.USER_EXIT('FND GETPROFILE NAME="CONC_REQUEST_ID", FIELD=":P_CONC_REQUEST_ID"')*/NULL;
    FND_PROFILE.GET('JLZZ_INF_RATIO_PRECISION'
                   ,V_RATIO_PRECISION);
    IF V_RATIO_PRECISION IS NULL THEN
      C_RATIO_PRECISION := 38;
    ELSE
      C_RATIO_PRECISION := TO_NUMBER(V_RATIO_PRECISION);
    END IF;
    IF UPPER(P_MRCSOBTYPE) = 'R' THEN
      BEGIN
        SELECT
          MIN(PERIOD_COUNTER),
          MAX(PERIOD_COUNTER)
        INTO V_MIN_PERIOD_COUNTER,V_MAX_PERIOD_COUNTER
        FROM
          FA_DEPRN_PERIODS_MRC_V
        WHERE BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
          AND FISCAL_YEAR = P_CURR_FY;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_ERR('JL_AR_FA_CUR_FY_DEP_PER_NOTDEF'
                   ,'N');
        WHEN OTHERS THEN
          RAISE_ORA_ERR;
      END;
      BEGIN
        SELECT
          CT.CALENDAR_TYPE,
          CT.NUMBER_PER_FISCAL_YEAR,
          CEIL(CT.NUMBER_PER_FISCAL_YEAR / 2)
        INTO V_CALENDAR_TYPE,V_PERIODS_PER_FY,V_MIDDLE_YEAR
        FROM
          FA_BOOK_CONTROLS_MRC_V BK,
          FA_CALENDAR_TYPES CT
        WHERE BK.BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
          AND CT.CALENDAR_TYPE = BK.DEPRN_CALENDAR;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_ERR('JL_AR_FA_CUR_FY_DEP_PER_NOTDEF'
                   ,'N');
        WHEN OTHERS THEN
          RAISE_ORA_ERR;
      END;
    ELSE
      BEGIN
        SELECT
          MIN(PERIOD_COUNTER),
          MAX(PERIOD_COUNTER)
        INTO V_MIN_PERIOD_COUNTER,V_MAX_PERIOD_COUNTER
        FROM
          FA_DEPRN_PERIODS
        WHERE BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
          AND FISCAL_YEAR = P_CURR_FY;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_ERR('JL_AR_FA_CUR_FY_DEP_PER_NOTDEF'
                   ,'N');
        WHEN OTHERS THEN
          RAISE_ORA_ERR;
      END;
      BEGIN
        SELECT
          CT.CALENDAR_TYPE,
          CT.NUMBER_PER_FISCAL_YEAR,
          CEIL(CT.NUMBER_PER_FISCAL_YEAR / 2)
        INTO V_CALENDAR_TYPE,V_PERIODS_PER_FY,V_MIDDLE_YEAR
        FROM
          FA_BOOK_CONTROLS BK,
          FA_CALENDAR_TYPES CT
        WHERE BK.BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
          AND CT.CALENDAR_TYPE = BK.DEPRN_CALENDAR;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_ERR('JL_AR_FA_CUR_FY_DEP_PER_NOTDEF'
                   ,'N');
        WHEN OTHERS THEN
          RAISE_ORA_ERR;
      END;
    END IF;
    IF UPPER(P_MRCSOBTYPE) = 'R' THEN
      BEGIN
        SELECT
          FY.START_DATE,
          FY.END_DATE,
          CP.START_DATE,
          CP.END_DATE
        INTO V_START_DATE_FISCAL_YEAR,V_END_DATE_FISCAL_YEAR,V_START_DATE,V_END_DATE
        FROM
          FA_BOOK_CONTROLS_MRC_V BC,
          FA_FISCAL_YEAR FY,
          FA_CALENDAR_PERIODS CP
        WHERE FY.FISCAL_YEAR = P_CURR_FY
          AND BC.BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
          AND BC.FISCAL_YEAR_NAME = FY.FISCAL_YEAR_NAME
          AND CP.CALENDAR_TYPE = V_CALENDAR_TYPE
          AND CP.START_DATE >= FY.START_DATE
          AND CP.END_DATE <= FY.END_DATE
          AND CP.PERIOD_NUM = V_MIDDLE_YEAR;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_ERR('JL_AR_FA_FY_DETAIL_NOT_DEFINED'
                   ,'Y');
        WHEN OTHERS THEN
          RAISE_ORA_ERR;
      END;
    ELSE
      BEGIN
        SELECT
          FY.START_DATE,
          FY.END_DATE,
          CP.START_DATE,
          CP.END_DATE
        INTO V_START_DATE_FISCAL_YEAR,V_END_DATE_FISCAL_YEAR,V_START_DATE,V_END_DATE
        FROM
          FA_BOOK_CONTROLS BC,
          FA_FISCAL_YEAR FY,
          FA_CALENDAR_PERIODS CP
        WHERE FY.FISCAL_YEAR = P_CURR_FY
          AND BC.BOOK_TYPE_CODE = P_BOOK_TYPE_CODE
          AND BC.FISCAL_YEAR_NAME = FY.FISCAL_YEAR_NAME
          AND CP.CALENDAR_TYPE = V_CALENDAR_TYPE
          AND CP.START_DATE >= FY.START_DATE
          AND CP.END_DATE <= FY.END_DATE
          AND CP.PERIOD_NUM = V_MIDDLE_YEAR;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_ERR('JL_AR_FA_FY_DETAIL_NOT_DEFINED'
                   ,'Y');
        WHEN OTHERS THEN
          RAISE_ORA_ERR;
      END;
    END IF;
    BEGIN
      SELECT
        A.REQUEST_ID
      INTO L_SET_REQUEST_ID
      FROM
        FND_CONCURRENT_REQUESTS A
      WHERE A.PARENT_REQUEST_ID = (
        SELECT
          B.REQUEST_ID
        FROM
          FND_CONCURRENT_REQUESTS B
        WHERE B.PARENT_REQUEST_ID = (
          SELECT
            C.PARENT_REQUEST_ID
          FROM
            FND_CONCURRENT_REQUESTS C
          WHERE C.ROWID <> B.ROWID
            AND C.REQUEST_ID = (
            SELECT
              D.PARENT_REQUEST_ID
            FROM
              FND_CONCURRENT_REQUESTS D
            WHERE D.REQUEST_ID = FND_GLOBAL.CONC_REQUEST_ID ) ) );
    EXCEPTION
      WHEN OTHERS THEN
        RAISE_ORA_ERR;
    END;
    P_PROCESS_ID := L_SET_REQUEST_ID;
    PERIODS_PER_FY := V_PERIODS_PER_FY;
    MIN_PERIOD_COUNTER := V_MIN_PERIOD_COUNTER;
    MAX_PERIOD_COUNTER := V_MAX_PERIOD_COUNTER;
    C_INI_MID_YR := V_START_DATE;
    C_END_MID_YR := V_END_DATE;
    C_FISCAL_START_DATE := V_START_DATE_FISCAL_YEAR;
    C_FISCAL_END_DATE := V_END_DATE_FISCAL_YEAR;
  END CUSTOM_INIT;

  PROCEDURE RAISE_ORA_ERR IS
    ERRMSG VARCHAR2(1000);
    ERRNUM NUMBER;
  BEGIN
    ERRNUM := SQLCODE;
    /*SRW.MESSAGE(ERRNUM
               ,ERRMSG)*/NULL;
    /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
  END RAISE_ORA_ERR;

  PROCEDURE RAISE_ERR(MSGNAME IN VARCHAR2
                     ,ABORT_FLAG IN VARCHAR2) IS
    ERRMSG VARCHAR2(1000);
  BEGIN
    SET_NAME('JL'
            ,MSGNAME);
    ERRMSG := GET;
    /*SRW.MESSAGE(JL_ZZ_FA_UTILITIES_PKG.GET_APP_ERRNUM('JL'
                                                     ,MSGNAME)
               ,ERRMSG)*/NULL;
    IF ABORT_FLAG = 'Y' THEN
      /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
    END IF;
  END RAISE_ERR;

  FUNCTION C_INDEX_VALUE_ACQFORMULA(C_PRICE_INDEX IN NUMBER
                                   ,ACQDATE IN DATE) RETURN NUMBER IS
    X NUMBER;
    ERRMSG VARCHAR2(1000);
    INDEX_NAME VARCHAR2(40);
  BEGIN
    SELECT
      PRICE_INDEX_VALUE
    INTO X
    FROM
      FA_PRICE_INDEX_VALUES
    WHERE PRICE_INDEX_ID = C_PRICE_INDEX
      AND ACQDATE BETWEEN FROM_DATE
      AND TO_DATE;
    RETURN (NVL(X
              ,0));
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      SELECT
        PRICE_INDEX_NAME
      INTO INDEX_NAME
      FROM
        FA_PRICE_INDEXES
      WHERE PRICE_INDEX_ID = C_PRICE_INDEX;
      SET_NAME('JL'
              ,'JL_ZZ_FA_INDX_VAL_NOT_FOUND');
      SET_TOKEN('PRICE_INDEX'
               ,INDEX_NAME
               ,FALSE);
      SET_TOKEN('MISSING_DATE'
               ,TO_CHAR(ACQDATE)
               ,FALSE);
      ERRMSG := GET;
      /*SRW.MESSAGE(JL_ZZ_FA_UTILITIES_PKG.GET_APP_ERRNUM('JL'
                                                       ,'JL_ZZ_FA_INDX_VAL_NOT_FOUND')
                 ,ERRMSG)*/NULL;
      /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
      RETURN NULL;
    WHEN OTHERS THEN
      RAISE_ORA_ERR;
      RETURN NULL;
  END C_INDEX_VALUE_ACQFORMULA;

  FUNCTION CF_RETIREMENT_DATE(RETIREMENT_ID_1 IN NUMBER) RETURN DATE IS
    L_FA_RETIREMENT DATE;
  BEGIN
    IF RETIREMENT_ID_1 IS NOT NULL THEN
      IF UPPER(P_MRCSOBTYPE) = 'R' THEN
        SELECT
          DATE_RETIRED
        INTO L_FA_RETIREMENT
        FROM
          FA_RETIREMENTS_MRC_V
        WHERE RETIREMENT_ID = RETIREMENT_ID_1;
      ELSE
        SELECT
          DATE_RETIRED
        INTO L_FA_RETIREMENT
        FROM
          FA_RETIREMENTS
        WHERE RETIREMENT_ID = RETIREMENT_ID_1;
      END IF;
    ELSE
      L_FA_RETIREMENT := NULL;
    END IF;
    RETURN (L_FA_RETIREMENT);
  END CF_RETIREMENT_DATE;

  FUNCTION CF_INCLUDE_DPISFORMULA RETURN CHAR IS
    T_MEANING VARCHAR2(30);
  BEGIN
    SELECT
      MEANING
    INTO T_MEANING
    FROM
      FND_LOOKUPS
    WHERE LOOKUP_TYPE = 'YES_NO'
      AND LOOKUP_CODE = P_INCLUDE_DPIS;
    RETURN (T_MEANING);
  EXCEPTION
    WHEN OTHERS THEN
      RETURN (P_INCLUDE_DPIS);
  END CF_INCLUDE_DPISFORMULA;

  FUNCTION CF_INCLUDE_RETFORMULA RETURN CHAR IS
    T_MEANING VARCHAR2(30);
  BEGIN
    SELECT
      MEANING
    INTO T_MEANING
    FROM
      FND_LOOKUPS
    WHERE LOOKUP_TYPE = 'YES_NO'
      AND LOOKUP_CODE = P_INCLUDE_RET;
    RETURN (T_MEANING);
  EXCEPTION
    WHEN OTHERS THEN
      RETURN (P_INCLUDE_RET);
  END CF_INCLUDE_RETFORMULA;

  FUNCTION CF_FULLY_DEPRN_ASSETFORMULA RETURN CHAR IS
    T_MEANING VARCHAR2(2000);
  BEGIN
    SELECT
      MEANING
    INTO T_MEANING
    FROM
      FND_LOOKUPS
    WHERE LOOKUP_TYPE = 'JLMX_FA_FULLY_DEPRN_ASSET_OPT'
      AND LOOKUP_CODE = P_FULLY_DEPRN_ASSETS
      AND sysdate between NVL(START_DATE_ACTIVE
       ,SYSDATE - 1)
      AND NVL(END_DATE_ACTIVE
       ,SYSDATE + 1)
      AND ENABLED_FLAG = 'Y';
    RETURN (T_MEANING);
  EXCEPTION
    WHEN OTHERS THEN
      RETURN (P_FULLY_DEPRN_ASSETS);
  END CF_FULLY_DEPRN_ASSETFORMULA;

  FUNCTION CF_INCLUDE_ZERO_NBV_ASSETSFORM RETURN CHAR IS
    T_MEANING VARCHAR2(30);
  BEGIN
    SELECT
      MEANING
    INTO T_MEANING
    FROM
      FND_LOOKUPS
    WHERE LOOKUP_TYPE = 'YES_NO'
      AND LOOKUP_CODE = P_INCLUDE_ZERO_NBV_ASSETS;
    RETURN (T_MEANING);
  EXCEPTION
    WHEN OTHERS THEN
      RETURN (P_INCLUDE_ZERO_NBV_ASSETS);
  END CF_INCLUDE_ZERO_NBV_ASSETSFORM;

  FUNCTION AFTERPFORM RETURN BOOLEAN IS
  BEGIN
  P_CONC_REQUEST_ID := FND_GLOBAL.CONC_REQUEST_ID;
    IF P_CA_SET_OF_BOOKS_ID <> -1999 THEN
      BEGIN
        SELECT
          MRC_SOB_TYPE_CODE,
          CURRENCY_CODE
        INTO P_MRCSOBTYPE,LP_CURRENCY_CODE
        FROM
          GL_SETS_OF_BOOKS
        WHERE SET_OF_BOOKS_ID = P_CA_SET_OF_BOOKS_ID;
      EXCEPTION
        WHEN OTHERS THEN
          P_MRCSOBTYPE := 'P';
      END;
    ELSE
      P_MRCSOBTYPE := 'P';
    END IF;
    /*SRW.MESSAGE(1
               ,'New:lp_currency_code' || LP_CURRENCY_CODE)*/NULL;
    IF UPPER(P_MRCSOBTYPE) = 'R' THEN
      LP_FA_BOOK_CONTROLS := 'FA_BOOK_CONTROLS_MRC_V';
      LP_FA_BOOKS := 'FA_BOOKS_MRC_V';
      LP_FA_ADJUSTMENTS := 'FA_ADJUSTMENTS_MRC_V';
      LP_FA_DEPRN_PERIODS := 'FA_DEPRN_PERIODS_MRC_V';
      LP_FA_DEPRN_DETAIL := 'FA_DEPRN_DETAIL_MRC_V';
      LP_FA_DEPRN_SUMMARY := 'FA_DEPRN_SUMMARY_MRC_V';
    ELSE
      LP_FA_BOOK_CONTROLS := 'FA_BOOK_CONTROLS';
      LP_FA_BOOKS := 'FA_BOOKS';
      LP_FA_ADJUSTMENTS := 'FA_ADJUSTMENTS';
      LP_FA_DEPRN_PERIODS := 'FA_DEPRN_PERIODS';
      LP_FA_DEPRN_DETAIL := 'FA_DEPRN_DETAL';
      LP_FA_DEPRN_SUMMARY := 'FA_DEPRN_SUMMARY';
    END IF;
    RETURN (TRUE);
  END AFTERPFORM;

  FUNCTION C_BASE_CURRENCY_CODE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_BASE_CURRENCY_CODE;
  END C_BASE_CURRENCY_CODE_P;

  FUNCTION C_BASE_PRECISION_P RETURN NUMBER IS
  BEGIN
    RETURN C_BASE_PRECISION;
  END C_BASE_PRECISION_P;

  FUNCTION C_BASE_MIN_ACCT_UNIT_P RETURN NUMBER IS
  BEGIN
    RETURN C_BASE_MIN_ACCT_UNIT;
  END C_BASE_MIN_ACCT_UNIT_P;

  FUNCTION C_BASE_DESCRIPTION_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_BASE_DESCRIPTION;
  END C_BASE_DESCRIPTION_P;

  FUNCTION C_ORGANIZATION_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_ORGANIZATION_NAME;
  END C_ORGANIZATION_NAME_P;

  FUNCTION C_CURR_FISCAL_YRX_P RETURN NUMBER IS
  BEGIN
    RETURN C_CURR_FISCAL_YRX;
  END C_CURR_FISCAL_YRX_P;

  FUNCTION CAT_FLEX_STRUCT_P RETURN NUMBER IS
  BEGIN
    RETURN CAT_FLEX_STRUCT;
  END CAT_FLEX_STRUCT_P;

  FUNCTION C_RATIO_PRECISION_P RETURN NUMBER IS
  BEGIN
    RETURN C_RATIO_PRECISION;
  END C_RATIO_PRECISION_P;

  FUNCTION C_ALL_SEGS_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_ALL_SEGS;
  END C_ALL_SEGS_P;

  FUNCTION PERIODS_PER_FY_P RETURN NUMBER IS
  BEGIN
    RETURN PERIODS_PER_FY;
  END PERIODS_PER_FY_P;

  FUNCTION MIN_PERIOD_COUNTER_P RETURN NUMBER IS
  BEGIN
    RETURN MIN_PERIOD_COUNTER;
  END MIN_PERIOD_COUNTER_P;

  FUNCTION MAX_PERIOD_COUNTER_P RETURN NUMBER IS
  BEGIN
    RETURN MAX_PERIOD_COUNTER;
  END MAX_PERIOD_COUNTER_P;

  FUNCTION C_INI_MID_YR_P RETURN DATE IS
  BEGIN
    RETURN C_INI_MID_YR;
  END C_INI_MID_YR_P;

  FUNCTION C_END_MID_YR_P RETURN DATE IS
  BEGIN
    RETURN C_END_MID_YR;
  END C_END_MID_YR_P;

  FUNCTION C_FISCAL_START_DATE_P RETURN DATE IS
  BEGIN
    RETURN C_FISCAL_START_DATE;
  END C_FISCAL_START_DATE_P;

  FUNCTION C_FISCAL_END_DATE_P RETURN DATE IS
  BEGIN
    RETURN C_FISCAL_END_DATE;
  END C_FISCAL_END_DATE_P;

  PROCEDURE SET_NAME(APPLICATION IN VARCHAR2
                    ,NAME IN VARCHAR2) IS
  BEGIN
   /* STPROC.INIT('begin FND_MESSAGE.SET_NAME(:APPLICATION, :NAME); end;');
    STPROC.BIND_I(APPLICATION);
    STPROC.BIND_I(NAME);
    STPROC.EXECUTE;*/

    FND_MESSAGE.SET_NAME(APPLICATION,NAME);
  END SET_NAME;

  PROCEDURE SET_TOKEN(TOKEN IN VARCHAR2
                     ,VALUE IN VARCHAR2
                     ,TRANSLATE IN BOOLEAN) IS
TRANSLATE1 BOOLEAN;
  BEGIN
 /*   STPROC.INIT('declare TRANSLATE BOOLEAN; begin TRANSLATE := sys.diutil.int_to_bool(:TRANSLATE); FND_MESSAGE.SET_TOKEN(:TOKEN, :VALUE, TRANSLATE); end;');
    STPROC.BIND_I(TRANSLATE);
    STPROC.BIND_I(TOKEN);
    STPROC.BIND_I(VALUE);
    STPROC.EXECUTE;*/

  --  TRANSLATE1 := sys.diutil.int_to_bool(TRANSLATE);
    FND_MESSAGE.SET_TOKEN(TOKEN,VALUE, TRANSLATE1);
  END SET_TOKEN;

  PROCEDURE RETRIEVE(MSGOUT OUT NOCOPY VARCHAR2) IS
  BEGIN
   /* STPROC.INIT('begin FND_MESSAGE.RETRIEVE(:MSGOUT); end;');
    STPROC.BIND_O(MSGOUT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,MSGOUT);*/null;
  END RETRIEVE;

  PROCEDURE CLEAR IS
  BEGIN
  /*  STPROC.INIT('begin FND_MESSAGE.CLEAR; end;');
    STPROC.EXECUTE;*/null;
  END CLEAR;

  FUNCTION GET_STRING(APPIN IN VARCHAR2
                     ,NAMEIN IN VARCHAR2) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
 /*   STPROC.INIT('begin :X0 := FND_MESSAGE.GET_STRING(:APPIN, :NAMEIN); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPIN);
    STPROC.BIND_I(NAMEIN);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_STRING;

  FUNCTION GET_NUMBER(APPIN IN VARCHAR2
                     ,NAMEIN IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
 /*   STPROC.INIT('begin :X0 := FND_MESSAGE.GET_NUMBER(:APPIN, :NAMEIN); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPIN);
    STPROC.BIND_I(NAMEIN);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_NUMBER;

  FUNCTION GET RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
  /*  STPROC.INIT('begin :X0 := FND_MESSAGE.GET; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
		   X0 := FND_MESSAGE.GET;
    RETURN X0;
  END GET;

  FUNCTION GET_ENCODED RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
   /* STPROC.INIT('begin :X0 := FND_MESSAGE.GET_ENCODED; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_ENCODED;

  PROCEDURE PARSE_ENCODED(ENCODED_MESSAGE IN VARCHAR2
                         ,APP_SHORT_NAME OUT NOCOPY VARCHAR2
                         ,MESSAGE_NAME OUT NOCOPY VARCHAR2) IS
  BEGIN
    /*STPROC.INIT('begin FND_MESSAGE.PARSE_ENCODED(:ENCODED_MESSAGE, :APP_SHORT_NAME, :MESSAGE_NAME); end;');
    STPROC.BIND_I(ENCODED_MESSAGE);
    STPROC.BIND_O(APP_SHORT_NAME);
    STPROC.BIND_O(MESSAGE_NAME);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,APP_SHORT_NAME);
    STPROC.RETRIEVE(3
                   ,MESSAGE_NAME);*/null;
  END PARSE_ENCODED;

  PROCEDURE SET_ENCODED(ENCODED_MESSAGE IN VARCHAR2) IS
  BEGIN
   /* STPROC.INIT('begin FND_MESSAGE.SET_ENCODED(:ENCODED_MESSAGE); end;');
    STPROC.BIND_I(ENCODED_MESSAGE);
    STPROC.EXECUTE;*/null;
  END SET_ENCODED;

  PROCEDURE RAISE_ERROR IS
  BEGIN
   /* STPROC.INIT('begin FND_MESSAGE.RAISE_ERROR; end;');
    STPROC.EXECUTE;*/null;
  END RAISE_ERROR;
  function BeforeReport return boolean is
begin


--SRW.USER_EXIT('FND SRWINIT');

IF upper(p_mrcsobtype) = 'R'
THEN
  fnd_client_info.set_currency_context(p_ca_set_of_books_id);
END IF;
-- Call report level PL/SQL function

get_base_curr_data;

-- Call report level PL/SQL

custom_init;

--SRW.REFERENCE(:cat_flex_struct);
/*SRW.USER_EXIT('FND FLEXSQL CODE="CAT#"
    NUM=":cat_flex_struct"
    APPL_SHORT_NAME="OFA"
    TABLEALIAS="ct"
    OUTPUT=":c_all_segs"
    MODE="SELECT"
    DISPLAY="ALL"');*/

  return (TRUE);
end;

END JL_JLMXFIMP_XMLP_PKG;



/
