--------------------------------------------------------
--  DDL for Package Body CE_CEXCLEAR_XMLP_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."CE_CEXCLEAR_XMLP_PKG" AS
/* $Header: CEXCLEARB.pls 120.0 2007/12/28 07:53:54 abraghun noship $ */
  FUNCTION BEFOREREPORT RETURN BOOLEAN IS
  BEGIN
    DECLARE
      L_MESSAGE FND_NEW_MESSAGES.MESSAGE_TEXT%TYPE;
    BEGIN
      P_CONC_REQUEST_ID := FND_GLOBAL.CONC_REQUEST_ID;
      INIT_SECURITY;
      BEGIN
        IF (P_BANK_BRANCH IS NOT NULL) THEN
          BEGIN
            SELECT
              ABB.BANK_NAME,
              ABB.BANK_BRANCH_NAME,
              L.MEANING,
              L2.MEANING
            INTO
              C_BANK_NAME
              ,C_BANK_BRANCH_NAME
              ,C_TRANSACTION_TYPE
              ,C_RECEIPT_TRANSLATION
            FROM
              CE_BANK_BRANCHES_V ABB,
              CE_LOOKUPS L,
              CE_LOOKUPS L2
            WHERE ABB.BRANCH_PARTY_ID = P_BANK_BRANCH
              AND L.LOOKUP_TYPE = 'TRAN_ORG_TYPE'
              AND L.LOOKUP_CODE = P_TYPE
              AND L2.LOOKUP_TYPE = 'TRX_TYPE'
              AND L2.LOOKUP_CODE = 'CASH';
          EXCEPTION
            WHEN OTHERS THEN
              SET_NAME('CE'
                      ,'CE_INVALID_BANK_BRANCH');
              L_MESSAGE := GET;
              RAISE_APPLICATION_ERROR(-20101
                                     ,NULL);
          END;
          IF (P_BANK_ACCOUNT IS NOT NULL) THEN
            BEGIN
              SELECT
                ABA.BANK_ACCOUNT_NUM,
                ABA.BANK_ACCOUNT_NAME,
                ABA.CURRENCY_CODE
              INTO
                C_BANK_ACCOUNT_NUM
                ,C_BANK_ACCOUNT_NAME
                ,C_BANK_CURRENCY_CODE
              FROM
                CE_BANK_ACCTS_GT_V ABA
              WHERE ABA.BANK_ACCOUNT_ID = P_BANK_ACCOUNT;
            EXCEPTION
              WHEN OTHERS THEN
                SET_NAME('CE'
                        ,'CE_INVALID_BANK_ACC');
                L_MESSAGE := GET;
                RAISE_APPLICATION_ERROR(-20101
                                       ,NULL);
            END;
          END IF;
        END IF;
      END;
      IF (P_BATCH_OR_TRX = 'T') THEN
        C_AMOUNT_WIDTH := 28;
      ELSE
        C_AMOUNT_WIDTH := 28;
      END IF;
      IF (P_DEBUG_MODE = 'Y') THEN
        NULL;
      END IF;
    END;
    RETURN (TRUE);
  END BEFOREREPORT;

  FUNCTION AFTERREPORT RETURN BOOLEAN IS
  BEGIN
    BEGIN
      NULL;
    END;
    RETURN (TRUE);
  END AFTERREPORT;

  FUNCTION G_TRANSACTION_TYPEGROUPFILTER(BANK_ACCOUNT_NUM IN VARCHAR2) RETURN BOOLEAN IS
  BEGIN
    IF BANK_ACCOUNT_NUM = '' THEN
      C_THE_END := 'N';
    ELSE
      C_THE_END := 'Y';
    END IF;
    RETURN (TRUE);
    RETURN (TRUE);
  END G_TRANSACTION_TYPEGROUPFILTER;

  FUNCTION C_AMOUNTFORMULA(AMOUNT IN NUMBER
                          ,TYPE IN VARCHAR2
                          ,BATCH_NUMBER IN VARCHAR2
                          ,BATCH_ID_1 IN NUMBER) RETURN NUMBER IS
  BEGIN
    IF (P_BATCH_OR_TRX = 'T') THEN
      RETURN (AMOUNT);
    ELSE
      IF (TYPE = 'PAYMENT') THEN
        BEGIN
          SELECT
            SUM(NVL(C.AMOUNT
                   ,0)),
            SUM(NVL(C.BASE_AMOUNT
                   ,C.AMOUNT))
          INTO
            C_BATCH_AMOUNT
            ,C_BATCH_BANK_ACCOUNT_AMOUNT
          FROM
            AP_CHECKS C
          WHERE C.CHECKRUN_NAME = BATCH_NUMBER;
          SELECT
            SUM(NVL(C.CLEARED_AMOUNT
                   ,0))
          INTO
            C_BATCH_CLEARED_AMOUNT
          FROM
            AP_CHECKS C
          WHERE C.CHECKRUN_NAME = BATCH_NUMBER
            AND C.CLEARED_DATE is not NULL;
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            NULL;
        END;
      ELSE
        BEGIN
          SELECT
            SUM(NVL(ARH.AMOUNT
                   ,0)),
            SUM(NVL(ARH.AMOUNT
                   ,0)),
            SUM(NVL(ARH.ACCTD_AMOUNT
                   ,0))
          INTO
            C_BATCH_AMOUNT
            ,C_BATCH_CLEARED_AMOUNT
            ,C_BATCH_BANK_ACCOUNT_AMOUNT
          FROM
            AR_CASH_RECEIPT_HISTORY ARH
          WHERE ARH.BATCH_ID = BATCH_ID_1
            AND ARH.STATUS = 'CLEARED'
            AND ARH.CURRENT_RECORD_FLAG = 'Y';
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            NULL;
        END;
      END IF;
    END IF;
    RETURN NULL;
  END C_AMOUNTFORMULA;

  FUNCTION C_BANK_ACCOUNT_AMOUNTFORMULA(ACCOUNT_AMOUNT IN NUMBER) RETURN NUMBER IS
  BEGIN
    IF (P_BATCH_OR_TRX = 'T') THEN
      RETURN (ACCOUNT_AMOUNT);
    ELSE
      NULL;
    END IF;
    RETURN NULL;
  END C_BANK_ACCOUNT_AMOUNTFORMULA;

  FUNCTION C_GRAND_CLEARED_AMOUNTFORMULA(TYPE IN VARCHAR2
                                        ,C_SUM_AMOUNT IN NUMBER
                                        ,C_SUM_BATCH_AMOUNT IN NUMBER) RETURN NUMBER IS
  BEGIN
    IF (P_BATCH_OR_TRX = 'T') THEN
      IF (TYPE = 'PAYMENT') THEN
        RETURN (-1 * (C_SUM_AMOUNT));
      ELSE
        RETURN (C_SUM_AMOUNT);
      END IF;
    ELSE
      IF (TYPE = 'PAYMENT') THEN
        RETURN (-1 * (C_SUM_BATCH_AMOUNT));
      ELSE
        RETURN (C_SUM_BATCH_AMOUNT);
      END IF;
    END IF;
    RETURN NULL;
  END C_GRAND_CLEARED_AMOUNTFORMULA;

  FUNCTION C_DATEFORMATFORMULA(C_DATEFORMAT IN VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    RETURN ('DD-MON-YY');
  END C_DATEFORMATFORMULA;

  FUNCTION C_ORDER_BYFORMULA RETURN VARCHAR2 IS
  BEGIN
    IF P_ORDER_BY = 'AMOUNT' THEN
      IF P_BATCH_OR_TRX = 'T' THEN
        RETURN ('ORDER BY 11,15');
      ELSE
        RETURN (NULL);
      END IF;
    ELSE
      RETURN ('ORDER BY 9');
    END IF;
    RETURN NULL;
  END C_ORDER_BYFORMULA;

  FUNCTION P_ORDER_BYVALIDTRIGGER RETURN BOOLEAN IS
  BEGIN
    RETURN (TRUE);
  END P_ORDER_BYVALIDTRIGGER;

  FUNCTION C_BATCH_AMOUNT_P RETURN NUMBER IS
  BEGIN
    RETURN C_BATCH_AMOUNT;
  END C_BATCH_AMOUNT_P;

  FUNCTION C_BATCH_BANK_ACCOUNT_AMOUNT_P RETURN NUMBER IS
  BEGIN
    RETURN C_BATCH_BANK_ACCOUNT_AMOUNT;
  END C_BATCH_BANK_ACCOUNT_AMOUNT_P;

  FUNCTION C_BATCH_CLEARED_AMOUNT_P RETURN NUMBER IS
  BEGIN
    RETURN C_BATCH_CLEARED_AMOUNT;
  END C_BATCH_CLEARED_AMOUNT_P;

  FUNCTION C_THE_END_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_THE_END;
  END C_THE_END_P;

  FUNCTION C_BANK_ACCOUNT_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_BANK_ACCOUNT_NAME;
  END C_BANK_ACCOUNT_NAME_P;

  FUNCTION C_BANK_ACCOUNT_NUM_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_BANK_ACCOUNT_NUM;
  END C_BANK_ACCOUNT_NUM_P;

  FUNCTION C_BANK_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_BANK_NAME;
  END C_BANK_NAME_P;

  FUNCTION C_BANK_BRANCH_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_BANK_BRANCH_NAME;
  END C_BANK_BRANCH_NAME_P;

  FUNCTION C_BANK_CURRENCY_CODE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_BANK_CURRENCY_CODE;
  END C_BANK_CURRENCY_CODE_P;

  FUNCTION C_TRANSACTION_TYPE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_TRANSACTION_TYPE;
  END C_TRANSACTION_TYPE_P;

  FUNCTION C_RECEIPT_TRANSLATION_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_RECEIPT_TRANSLATION;
  END C_RECEIPT_TRANSLATION_P;

  FUNCTION C_AMOUNT_WIDTH_P RETURN NUMBER IS
  BEGIN
    RETURN C_AMOUNT_WIDTH;
  END C_AMOUNT_WIDTH_P;

  FUNCTION C_COMPANY_NAME_HEADER_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_COMPANY_NAME_HEADER;
  END C_COMPANY_NAME_HEADER_P;

  PROCEDURE SET_NAME(APPLICATION IN VARCHAR2
                    ,NAME IN VARCHAR2) IS
  BEGIN
   /* STPROC.INIT('begin FND_MESSAGE.SET_NAME(:APPLICATION, :NAME); end;');
    STPROC.BIND_I(APPLICATION);
    STPROC.BIND_I(NAME);
    STPROC.EXECUTE;*/
    FND_MESSAGE.SET_NAME(APPLICATION, NAME);
  END SET_NAME;

 /* PROCEDURE SET_TOKEN(TOKEN IN VARCHAR2
                     ,VALUE IN VARCHAR2
                     ,TRANSLATE IN BOOLEAN) IS
  BEGIN
    STPROC.INIT('declare TRANSLATE BOOLEAN; begin TRANSLATE := sys.diutil.int_to_bool(:TRANSLATE); FND_MESSAGE.SET_TOKEN(:TOKEN, :VALUE, TRANSLATE); end;');
    STPROC.BIND_I(TRANSLATE);
    STPROC.BIND_I(TOKEN);
    STPROC.BIND_I(VALUE);
    STPROC.EXECUTE;
  END SET_TOKEN;*/

 /* PROCEDURE RETRIEVE(MSGOUT OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.RETRIEVE(:MSGOUT); end;');
    STPROC.BIND_O(MSGOUT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,MSGOUT);
  END RETRIEVE;*/

 /* PROCEDURE CLEAR IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.CLEAR; end;');
    STPROC.EXECUTE;
  END CLEAR;
*/
 /* FUNCTION GET_STRING(APPIN IN VARCHAR2
                     ,NAMEIN IN VARCHAR2) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := FND_MESSAGE.GET_STRING(:APPIN, :NAMEIN); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPIN);
    STPROC.BIND_I(NAMEIN);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_STRING;*/

  FUNCTION GET RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
   /* STPROC.INIT('begin :X0 := FND_MESSAGE.GET; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
		   X0 := FND_MESSAGE.GET;
    RETURN X0;
  END GET;

/*  FUNCTION GET_ENCODED RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := FND_MESSAGE.GET_ENCODED; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_ENCODED;*/

 /* PROCEDURE PARSE_ENCODED(ENCODED_MESSAGE IN VARCHAR2
                         ,APP_SHORT_NAME OUT NOCOPY VARCHAR2
                         ,MESSAGE_NAME OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.PARSE_ENCODED(:ENCODED_MESSAGE, :APP_SHORT_NAME, :MESSAGE_NAME); end;');
    STPROC.BIND_I(ENCODED_MESSAGE);
    STPROC.BIND_O(APP_SHORT_NAME);
    STPROC.BIND_O(MESSAGE_NAME);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,APP_SHORT_NAME);
    STPROC.RETRIEVE(3
                   ,MESSAGE_NAME);
  END PARSE_ENCODED;*/

/*  PROCEDURE SET_ENCODED(ENCODED_MESSAGE IN VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.SET_ENCODED(:ENCODED_MESSAGE); end;');
    STPROC.BIND_I(ENCODED_MESSAGE);
    STPROC.EXECUTE;
  END SET_ENCODED;*/

/*  PROCEDURE RAISE_ERROR IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.RAISE_ERROR; end;');
    STPROC.EXECUTE;
  END RAISE_ERROR;
*/
 /* PROCEDURE SET_101 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.SET_101; end;');
    STPROC.EXECUTE;
  END SET_101;*/

/*  PROCEDURE SET_801 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.SET_801; end;');
    STPROC.EXECUTE;
  END SET_801;*/

  /*PROCEDURE SET_200 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.SET_200; end;');
    STPROC.EXECUTE;
  END SET_200;*/

  /*PROCEDURE SET_222 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.SET_222; end;');
    STPROC.EXECUTE;
  END SET_222;*/

  /*PROCEDURE SET_260 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.SET_260; end;');
    STPROC.EXECUTE;
  END SET_260;*/

 /* PROCEDURE SET_999 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.SET_999; end;');
    STPROC.EXECUTE;
  END SET_999;*/

 /* PROCEDURE SET_ALL IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.SET_ALL; end;');
    STPROC.EXECUTE;
  END SET_ALL;*/

 /* PROCEDURE UNSET_101 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.UNSET_101; end;');
    STPROC.EXECUTE;
  END UNSET_101;*/

  /*PROCEDURE UNSET_200 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.UNSET_200; end;');
    STPROC.EXECUTE;
  END UNSET_200;*/

 /* PROCEDURE UNSET_222 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.UNSET_222; end;');
    STPROC.EXECUTE;
  END UNSET_222;*/

 /* PROCEDURE UNSET_260 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.UNSET_260; end;');
    STPROC.EXECUTE;
  END UNSET_260;*/

 /* PROCEDURE UNSET_999 IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.UNSET_999; end;');
    STPROC.EXECUTE;
  END UNSET_999;*/

/*  PROCEDURE UNSET_ALL IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.UNSET_ALL; end;');
    STPROC.EXECUTE;
  END UNSET_ALL;*/

/*  FUNCTION GET_101 RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := CE_AUTO_BANK_MATCH.GET_101; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_101;*/

 /* FUNCTION GET_200 RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := CE_AUTO_BANK_MATCH.GET_200; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_200;*/

 /* FUNCTION GET_222 RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := CE_AUTO_BANK_MATCH.GET_222; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_222;*/

 /* FUNCTION GET_260 RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := CE_AUTO_BANK_MATCH.GET_260; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_260;*/

 /* FUNCTION GET_999 RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := CE_AUTO_BANK_MATCH.GET_999; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_999;*/

/*  PROCEDURE SET_INVERSE_RATE(INVERSE_RATE IN VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.SET_INVERSE_RATE(:INVERSE_RATE); end;');
    STPROC.BIND_I(INVERSE_RATE);
    STPROC.EXECUTE;
  END SET_INVERSE_RATE;*/

 /* FUNCTION GET_INVERSE_RATE RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := CE_AUTO_BANK_MATCH.GET_INVERSE_RATE; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_INVERSE_RATE;*/

 /* FUNCTION GET_VAT_TAX_ID RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := CE_AUTO_BANK_MATCH.GET_VAT_TAX_ID; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_VAT_TAX_ID;*/

 /* FUNCTION CONVERT_AMOUNT_TOLERANCE(AMOUNT_TO_CONVERT IN NUMBER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := CE_AUTO_BANK_MATCH.CONVERT_AMOUNT_TOLERANCE(:AMOUNT_TO_CONVERT); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(AMOUNT_TO_CONVERT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END CONVERT_AMOUNT_TOLERANCE;*/

 /* FUNCTION VALIDATE_PAYMENT_METHOD RETURN BOOLEAN IS
    X0 BOOLEAN;
  BEGIN
    STPROC.INIT('declare X0rv BOOLEAN; begin X0rv := CE_AUTO_BANK_MATCH.VALIDATE_PAYMENT_METHOD; :X0 := sys.diutil.bool_to_int(X0rv); end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END VALIDATE_PAYMENT_METHOD;*/

 /* FUNCTION TRX_VALIDATION(NO_OF_CURRENCIES IN NUMBER) RETURN BOOLEAN IS
    X0 BOOLEAN;
  BEGIN
    STPROC.INIT('declare X0rv BOOLEAN; begin X0rv := CE_AUTO_BANK_MATCH.TRX_VALIDATION(:NO_OF_CURRENCIES); :X0 := sys.diutil.bool_to_int(X0rv); end;');
    STPROC.BIND_I(NO_OF_CURRENCIES);
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,X0);
    RETURN X0;
  END TRX_VALIDATION;*/

  /*PROCEDURE CALC_ACTUAL_TOLERANCE IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.CALC_ACTUAL_TOLERANCE; end;');
    STPROC.EXECUTE;
  END CALC_ACTUAL_TOLERANCE;*/

 /* PROCEDURE MATCH_PROCESS IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.MATCH_PROCESS; end;');
    STPROC.EXECUTE;
  END MATCH_PROCESS;*/

  /*PROCEDURE LOCK_TRANSACTION(X_RECONCILE_FLAG IN VARCHAR2
                            ,X_CALL_MODE IN VARCHAR2
                            ,X_TRX_TYPE IN VARCHAR2
                            ,X_CLEARING_TRX_TYPE IN VARCHAR2
                            ,X_TRX_ROWID IN VARCHAR2
                            ,X_BATCH_BA_AMOUNT IN NUMBER) IS
  BEGIN
    STPROC.INIT('begin CE_AUTO_BANK_MATCH.LOCK_TRANSACTION(:X_RECONCILE_FLAG, :X_CALL_MODE, :X_TRX_TYPE, :X_CLEARING_TRX_TYPE, :X_TRX_ROWID, :X_BATCH_BA_AMOUNT); end;');
    STPROC.BIND_I(X_RECONCILE_FLAG);
    STPROC.BIND_I(X_CALL_MODE);
    STPROC.BIND_I(X_TRX_TYPE);
    STPROC.BIND_I(X_CLEARING_TRX_TYPE);
    STPROC.BIND_I(X_TRX_ROWID);
    STPROC.BIND_I(X_BATCH_BA_AMOUNT);
    STPROC.EXECUTE;
  END LOCK_TRANSACTION;*/

 /* PROCEDURE DEBUG(LINE IN VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin CEP_STANDARD.DEBUG(:LINE); end;');
    STPROC.BIND_I(LINE);
    STPROC.EXECUTE;
  END DEBUG;*/

 /* PROCEDURE ENABLE_DEBUG IS
  BEGIN
    STPROC.INIT('begin CEP_STANDARD.ENABLE_DEBUG; end;');
    STPROC.EXECUTE;
  END ENABLE_DEBUG;*/

 /* PROCEDURE DISABLE_DEBUG IS
  BEGIN
    STPROC.INIT('begin CEP_STANDARD.DISABLE_DEBUG; end;');
    STPROC.EXECUTE;
  END DISABLE_DEBUG;*/

 /* FUNCTION GET_WINDOW_SESSION_TITLE RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := CEP_STANDARD.GET_WINDOW_SESSION_TITLE; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_WINDOW_SESSION_TITLE;*/

  /*FUNCTION GET_EFFECTIVE_DATE(P_BANK_ACCOUNT_ID IN NUMBER
                             ,P_TRX_CODE IN VARCHAR2
                             ,P_RECEIPT_DATE IN DATE) RETURN DATE IS
    X0 DATE;
  BEGIN
    STPROC.INIT('begin :X0 := CEP_STANDARD.GET_EFFECTIVE_DATE(:P_BANK_ACCOUNT_ID, :P_TRX_CODE, :P_RECEIPT_DATE); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(P_BANK_ACCOUNT_ID);
    STPROC.BIND_I(P_TRX_CODE);
    STPROC.BIND_I(P_RECEIPT_DATE);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_EFFECTIVE_DATE;*/

  PROCEDURE INIT_SECURITY IS
  BEGIN
   /* STPROC.INIT(' begin CEP_STANDARD.init_security; end;');
    STPROC.EXECUTE;*/
    CEP_STANDARD.init_security;
  END INIT_SECURITY;

END CE_CEXCLEAR_XMLP_PKG;


/
