--------------------------------------------------------
--  DDL for Package Body GL_GLWACCTR_XMLP_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."GL_GLWACCTR_XMLP_PKG" AS
/* $Header: GLWACCTRB.pls 120.2 2008/01/09 07:28:17 vijranga noship $ */

UNKNOWN_USER_EXIT EXCEPTION;

USER_EXIT_FAILURE EXCEPTION;

FUNCTION BEFOREREPORT RETURN BOOLEAN IS

  T_ERRORBUFFER            VARCHAR2(132);
  AMOUNT_WHERE             VARCHAR2(500);
  AMOUNT_WHERE2            VARCHAR2(500);
  JOURNAL_FROM		   VARCHAR2(500);
  JOURNAL_WHERE            VARCHAR2(1000);
  AFF_WHERE                VARCHAR2(500);
  AFF_WHERE2   		   VARCHAR2(4000);
  L_LEDGER_TYPE            VARCHAR2(100);
  L_LEDGER_CURR            VARCHAR2(100);
  L_LEDGER_FROM            VARCHAR2(1000);
  L_LEDGER_WHERE           VARCHAR2(2000);
  L_DAS_WHERE              VARCHAR2(2000);
  ERR_IN_REP EXCEPTION;

BEGIN

---------------------------------------------------------
-- INITIALIZE SRW.USER_EXIT
---------------------------------------------------------

BEGIN
--  SRW.USER_EXIT('FND SRWINIT');

  /*EXCEPTION
  WHEN SRW.UNKNOWN_USER_EXIT THEN
    SRW.MESSAGE(01,'FND SRWINIT USER EXIT IS UNKNOWN.');
    RAISE;
  WHEN SRW.USER_EXIT_FAILURE THEN
    SRW.MESSAGE(02,'FND SRWINIT USER EXIT IS FAILED.');
    RAISE;*/NULL;
END;

SELECT
	 FND_DATE.CANONICAL_TO_DATE(P_START_DATE),
  	 FND_DATE.CANONICAL_TO_DATE(P_END_DATE),
	 FND_NUMBER.CANONICAL_TO_NUMBER(P_LEDGER_ID),
	 FND_DATE.CANONICAL_TO_DATE(P_START_UPDATE_DATE),
  	 FND_DATE.CANONICAL_TO_DATE(P_END_UPDATE_DATE)
--         FND_NUMBER.CANONICAL_TO_NUMBER(:P_DOC_ID),
--        FND_NUMBER.CANONICAL_TO_NUMBER(:P_DOC_VALUE),
--        FND_NUMBER.CANONICAL_TO_NUMBER(:P_AMOUNT_FROM),
--        FND_NUMBER.CANONICAL_TO_NUMBER(:P_AMOUNT_TO),
--        FND_NUMBER.CANONICAL_TO_NUMBER(:P_SUB_DOC_ID),
--        FND_NUMBER.CANONICAL_TO_NUMBER(:P_SUB_DOC_VALUE)
INTO
     	H_START_DATE,
      	H_END_DATE,
	H_SET_OF_BOOKS_ID,
        H_START_UPDATE_DATE,
      	H_END_UPDATE_DATE
--	:H_DOC_ID,
--	:H_DOC_VALUE,
--	:H_AMOUNT_FROM,
--	:H_AMOUNT_TO,
--	:H_SUB_DOC_ID,
--	:H_SUB_DOC_VALUE
FROM DUAL;

 /* GET ACCESS SET INFO */
  BEGIN
    SELECT NAME , CHART_OF_ACCOUNTS_ID
    INTO   ACCESS_SET_NAME, CHART_OF_ACCOUNTS_ID
    FROM   GL_ACCESS_SETS
    WHERE  ACCESS_SET_ID = P_ACCESS_SET_ID;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      T_ERRORBUFFER := GL_MESSAGE.GET_MESSAGE('GL_PLL_INVALID_DATA_ACCESS_SET', 'Y',
                                              'DASID', TO_CHAR(P_ACCESS_SET_ID));
  --    SRW.MESSAGE('00', T_ERRORBUFFER);
    --  RAISE SRW.PROGRAM_ABORT;

    WHEN OTHERS THEN
      T_ERRORBUFFER := SQLERRM;
--      SRW.MESSAGE('00', T_ERRORBUFFER);
  --    RAISE SRW.PROGRAM_ABORT;
  END;

 -- BUILD DATA ACCESS SECURITY WHERE CLAUSE
  P_DAS_WHERE := GL_ACCESS_SET_SECURITY_PKG.GET_SECURITY_CLAUSE(
                  P_ACCESS_SET_ID,
                  'R',               -- FOR READ ACCESS
                  'LEDGER_COLUMN',
                  'LEDGER_ID',
                  'GLH',     -- TABLE ALIAS FOR GL_JE_HEADERS
                  'SEG_COLUMN',
                  NULL,
                  'CC',   -- TABLE ALIAS FOR GL_CODE_COMBINATIONS.
                  NULL);

  L_DAS_WHERE := GL_ACCESS_SET_SECURITY_PKG.GET_SECURITY_CLAUSE(
                  P_ACCESS_SET_ID,
                  'R',               -- FOR READ ACCESS
                  'LEDGER_COLUMN',
                  'LEDGER_ID',
                  'GLH2',     -- TABLE ALIAS FOR GL_JE_HEADERS
                  'SEG_COLUMN',
                  NULL,
                  'GCC2',   -- TABLE ALIAS FOR GL_CODE_COMBINATIONS.
                  NULL);

  IF (P_DAS_WHERE IS NOT NULL) THEN
    P_DAS_WHERE := ' AND ' || P_DAS_WHERE;
    L_DAS_WHERE := ' AND ' || L_DAS_WHERE;
  END IF;

--##############

  P_LEDGER_FROM := ' ';
  P_LEDGER_WHERE := ' ';
  L_LEDGER_FROM := ' ';
  L_LEDGER_WHERE := ' ';
  P_JOURNAL_WHERE_CLAUSE := ' ';
  /* GET THE LEDGER INFO WHEN A LEDGER/LEDGER SET IS SELECTED BY THE USER*/

  IF P_LEDGER_ID IS NOT NULL THEN


    /* GET INFORMATION OF LEDGER PARAMETER. */

    BEGIN
      SELECT CURRENCY_CODE, OBJECT_TYPE_CODE
      INTO   L_LEDGER_CURR,
             L_LEDGER_TYPE
      FROM   GL_LEDGERS
      WHERE  LEDGER_ID = P_LEDGER_ID;
    EXCEPTION
      WHEN OTHERS THEN
        T_ERRORBUFFER := SQLERRM;
    --    SRW.MESSAGE('00', T_ERRORBUFFER);
    --    RAISE SRW.PROGRAM_ABORT;
    END;

    IF (L_LEDGER_TYPE = 'S') THEN  -- IT IS A LEDGER SET
       L_LEDGER_FROM  := ', GL_LEDGER_SET_ASSIGNMENTS LS1';
      P_LEDGER_FROM := ', GL_LEDGER_SET_ASSIGNMENTS LS';
       L_LEDGER_WHERE := ' AND LS1.LEDGER_SET_ID = ' || TO_CHAR(P_LEDGER_ID) || ' AND ' ||
                       'LGR1.LEDGER_ID = LS1.LEDGER_ID';
      P_LEDGER_WHERE := ' AND LS.LEDGER_SET_ID = ' || TO_CHAR(P_LEDGER_ID) || ' AND ' ||
                       'LGR.LEDGER_ID = LS.LEDGER_ID';
    ELSE
      P_LEDGER_FROM := ' ';
      P_LEDGER_WHERE := ' AND LGR.LEDGER_ID = ' || TO_CHAR(P_LEDGER_ID);

      L_LEDGER_FROM := '';
      L_LEDGER_WHERE := ' AND  LGR1.LEDGER_ID = ' || TO_CHAR(P_LEDGER_ID);
    END IF;

  END IF; --IF :P_LEDGER_ID IS NOT NULL

--###############


  IF P_STATUS IS NOT NULL THEN

  IF (P_STATUS = 'E') THEN
     P_POSTING_STATUS := ' AND '|| ' GLB.STATUS IN ' ||
          '(SELECT LOOKUP_CODE FROM GL_LOOKUPS ' ||
          'WHERE LOOKUP_TYPE = ''MJE_BATCH_STATUS'' '||
          'AND LOOKUP_CODE NOT IN (''S'', ''I'', ''U'', ''P'')) ';
     P_HEADER_POSTING_STATUS :=
         ' AND GLH.JE_HEADER_ID = GLL.JE_HEADER_ID(+)
          AND GLL.CODE_COMBINATION_ID = CC.CODE_COMBINATION_ID(+) ';

  ELSE
   P_POSTING_STATUS := 'AND GLB.STATUS =  '''||P_STATUS||'''';
   P_HEADER_POSTING_STATUS :=
          'AND GLH.JE_HEADER_ID = GLL.JE_HEADER_ID
           AND GLL.LEDGER_ID = LGR.LEDGER_ID
           AND GLL.CODE_COMBINATION_ID = CC.CODE_COMBINATION_ID';

 END IF;

ELSE
   P_HEADER_POSTING_STATUS :=
          'AND GLH.JE_HEADER_ID = GLL.JE_HEADER_ID
           AND GLL.LEDGER_ID = LGR.LEDGER_ID
           AND GLL.CODE_COMBINATION_ID = CC.CODE_COMBINATION_ID';
   P_POSTING_STATUS := ' ';
END IF;

 IF (P_ACTUAL_FLAG IS NOT NULL) THEN

   P_ACTUAL_TYPE_WHERE := ' AND GLH.ACTUAL_FLAG = '''||P_ACTUAL_FLAG||'''';
 ELSE
   P_ACTUAL_TYPE_WHERE := ' ';

 END IF;


-----------------------------------------------------------
-- FLEXFIELDS
-- FILL OUT ACCT_SEGMENT_NAME, BAL_SEGMENT_NAME, SECONDARY_SEG
-----------------------------------------------------------

BEGIN

    -- SRW.REFERENCE(:CHART_OF_ACCOUNTS_ID);

     /*SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
               NUM=":CHART_OF_ACCOUNTS_ID"
               APPL_SHORT_NAME="SQLGL"
               OUTPUT=":SELECT_ACCOUNT"
               MODE="SELECT"
               DISPLAY="ALL"
               TABLEALIAS="CC"');

     SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
               NUM=":CHART_OF_ACCOUNTS_ID"
               APPL_SHORT_NAME="SQLGL"
               OUTPUT=":SELECT_ACCT_SEGMENT"
               MODE="SELECT"
               DISPLAY="GL_ACCOUNT"
	       IDISPLAY="GL_ACCOUNT"
               TABLEALIAS="CC"');

     SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
               NUM=":CHART_OF_ACCOUNTS_ID"
               APPL_SHORT_NAME="SQLGL"
               OUTPUT=":SELECT_BAL_SEGMENT"
               MODE="SELECT"
               DISPLAY="GL_BALANCING"
               TABLEALIAS="CC"');

     SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
               NUM=":CHART_OF_ACCOUNTS_ID"
               APPL_SHORT_NAME="SQLGL"
               OUTPUT=":SELECT_COST_CTR_SEGMENT"
               MODE="SELECT"
               DISPLAY="FA_COST_CTR"
	       IDISPLAY="FA_COST_CTR"
               TABLEALIAS="CC"');*/


 IF (P_SEC_SEG_NUM IS NOT NULL) THEN


    /* SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
                 NUM=":CHART_OF_ACCOUNTS_ID"
                 APPL_SHORT_NAME="SQLGL"
                 OUTPUT=":SELECT_SECONDARY_SEGMENT"
                 MODE="SELECT"
                 DISPLAY="GL_SECONDARY_TRACKING"
                 TABLEALIAS="CC"'); */

        SELECT 'CC.'||APPLICATION_COLUMN_NAME , FORM_LEFT_PROMPT
        INTO   SELECT_SECONDARY_SEGMENT, PARAM_SEC_SEG_NAME
        FROM   FND_ID_FLEX_SEGMENTS_VL S
        WHERE  S.ID_FLEX_CODE = 'GL#'
        AND    S.ID_FLEX_NUM = CHART_OF_ACCOUNTS_ID
        AND    S.ENABLED_FLAG = 'Y'
        AND    S.SEGMENT_NUM = P_SEC_SEG_NUM;



END IF;



IF (P_BAL_SEG_VAL IS NOT NULL) THEN
  /*SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
                 NUM=":CHART_OF_ACCOUNTS_ID"
                 APPL_SHORT_NAME="SQLGL"
                 OUTPUT=":P_BAL_WHERE"
                 MODE="WHERE"
                 DISPLAY="GL_BALANCING"
                 OPERATOR = "="
                 OPERAND1=":P_BAL_SEG_VAL"
                TABLEALIAS="CC"');*/

     P_BAL_WHERE := ' AND '||P_BAL_WHERE;


 -- ' AND '||:P_BAL_WHERE|| ' = '''||:P_BAL_SEG_VAL||'''';
END IF;


--      IF :P_SEC_SEG_NUM IS NULL THEN
--          :P_SEC_SEGMENT_WHERE:= 'A';
--      END IF;


 /* THE FOLLOWING IS NOT USED ANY WHERE IN THE UNIT TESTING
   SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
                 NUM=":CHART_OF_ACCOUNTS_ID"
                 APPL_SHORT_NAME="SQLGL"
                 OUTPUT=":P_ACC_SEGMENT_SELECT"
                 MODE="SELECT"
                 DISPLAY="ALL"
                 TABLEALIAS="GCC"');
*/

    IF P_CURRENCY IS NOT NULL THEN
        IF P_CURRENCY = 'STAT' THEN
          P_CURRENCY_WHERE := 'AND GLH.CURRENCY_CODE = ''STAT'' ';
       ELSE
          P_CURRENCY_WHERE := 'AND GLH.CURRENCY_CODE <> ''STAT'' ';
       END IF;

   END IF;

   -- SOURCE PARAMETER
   IF P_SOURCE IS NOT NULL THEN
          P_SOURCE_WHERE :=  'AND GLH.JE_SOURCE = '''||P_SOURCE||'''';
    ELSE
        P_SOURCE_WHERE := ' ';
   END IF;

   -- CATEGORY PARAMATER
   IF P_CATEGORY IS NOT NULL THEN
        P_CATEGORY_WHERE := 'AND GLH.JE_CATEGORY = '''||P_CATEGORY||'''';
    ELSE
      P_CATEGORY_WHERE := ' ';
  END IF;

   --  BATCH NAME PARAMETER
   IF P_BATCH_NAME IS NOT NULL THEN
        P_BATCH_WHERE := 'AND GLB.NAME = '''||P_BATCH_NAME||'''';
   ELSE
       P_BATCH_WHERE := ' ';
   END IF;

   IF P_DOC_ID IS NOT NULL THEN
      P_DOC_ID_WHERE := 'AND GLH.DOC_SEQUENCE_ID = '''||P_DOC_ID||'''';
   ELSE
     P_DOC_ID_WHERE := ' ';
   END IF;

   P_DOC_VAL_WHERE :=  ' ';
   IF ((P_DOC_VALUE IS NOT NULL)
        OR (P_START_DOC_VALUE IS NOT NULL)
           OR (P_END_DOC_VALUE IS NOT NULL)) THEN


    IF P_DOC_VALUE IS NOT NULL THEN
       P_DOC_VAL_WHERE := ' AND GLH.DOC_SEQUENCE_VALUE = '||P_DOC_VALUE;
    ELSE
       P_DOC_VAL_WHERE := ' ';
    END IF;

   IF   (P_START_DOC_VALUE IS NULL)
          AND  (P_END_DOC_VALUE IS NOT NULL) THEN
      P_DOC_VAL_WHERE :=  P_DOC_VAL_WHERE || ' AND GLH.DOC_SEQUENCE_VALUE <= '''||P_END_DOC_VALUE ||'''';

   ELSIF  (P_START_DOC_VALUE IS NOT NULL)
            AND (P_END_DOC_VALUE IS NULL) THEN
      P_DOC_VAL_WHERE :=  P_DOC_VAL_WHERE || ' AND GLH.DOC_SEQUENCE_VALUE >= '''||P_START_DOC_VALUE||'''';

   ELSIF  (P_START_DOC_VALUE IS NOT NULL)
            AND (P_END_DOC_VALUE IS NOT NULL) THEN
         P_DOC_VAL_WHERE :=  P_DOC_VAL_WHERE ||' AND GLH.DOC_SEQUENCE_VALUE BETWEEN '''
                              ||P_START_DOC_VALUE||''' AND '''||P_END_DOC_VALUE||'''';
   END IF;

  END IF;




   -- SUBLEDGER DOC SEQ ID AND VALUES.

   IF P_SUB_DOC_ID IS NOT NULL THEN
      P_SUB_DOC_ID_WHERE := ' AND GLL.SUBLEDGER_DOC_SEQUENCE_ID = '||P_SUB_DOC_ID;
   ELSE
      P_SUB_DOC_ID_WHERE := ' ';
   END IF;

   IF P_SUB_DOC_VALUE IS NOT NULL THEN
      P_SUB_DOC_VAL_WHERE := ' AND GLL.SUBLEDGER_DOC_SEQUENCE_VALUE = '''||P_SUB_DOC_VALUE||'''';
    ELSE
      P_SUB_DOC_VAL_WHERE := ' ';
   END IF;


   -- DO NOT SELECT ZERO JOURANL AMOUNTS LINE AMOUNTS.

   IF NVL(P_STATUS, 'P') <> 'E' THEN
      P_NOT_ZERO_LINE_WHERE:= ' AND ((NVL(GLL.ACCOUNTED_DR, 0) <> 0) OR (NVL(GLL.ACCOUNTED_CR, 0) <> 0)) ';
   ELSE
      P_NOT_ZERO_LINE_WHERE := ' ';
   END IF;

   -- CONTRA ACCOUNT

    P_CONTRA_ACCOUNT_WHERE := ' ';
    IF P_CONTRA_ACCT IS NOT NULL THEN
      --SRW.REFERENCE(:CHART_OF_ACCOUNTS_ID);
      /*SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
               NUM=":CHART_OF_ACCOUNTS_ID"
               APPL_SHORT_NAME="SQLGL"
               OUTPUT=":P_ACC_SEGMENT_WHERE"
               MODE="WHERE"
               DISPLAY="ALL"
	       OPERATOR="BETWEEN"
	       OPERAND1=:P_AFF_FROM
	       OPERAND2=:P_AFF_TO
               TABLEALIAS="CC"'); */

     IF (P_ACC_SEGMENT_WHERE IS NOT NULL) THEN
        P_ACC_SEGMENT_WHERE := ' AND ' ||P_ACC_SEGMENT_WHERE;
     END IF;

    --WHEN THE USER DEFINED THE CONTRA_ACCOUNT IN THE PARAMETER, THE REPORT SELECTS THE
    -- JOURNALS WHICH HAVE THE SAME SUBLEDGER_DOC_SEQUENCE_ID AND INCLUDE AT LEAST ONE
    -- MATCHED LINE.

--      SRW.REFERENCE(:CHART_OF_ACCOUNTS_ID);
  /*    SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
                    NUM=":CHART_OF_ACCOUNTS_ID"
                    APPL_SHORT_NAME="SQLGL"
                    OUTPUT=":P_CONTRA_ACCOUNT"
                    MODE="WHERE"
                    DISPLAY="GL_ACCOUNT"
	            OPERATOR = "="
                    OPERAND1 = ":P_CONTRA_ACCT"
                    TABLEALIAS="GCC2"');*/



       P_CONTRA_ACCOUNT_WHERE := ' AND EXISTS (SELECT GJL2.JE_LINE_NUM
                                     FROM GL_JE_LINES GJL2, GL_CODE_COMBINATIONS GCC2
       WHERE
       GJL2.JE_HEADER_ID = GLH.JE_HEADER_ID AND
       GJL2.CODE_COMBINATION_ID = GCC2.CODE_COMBINATION_ID AND
       ((GJL2.SUBLEDGER_DOC_SEQUENCE_ID = GLL.SUBLEDGER_DOC_SEQUENCE_ID AND
         GJL2.SUBLEDGER_DOC_SEQUENCE_VALUE = GLL.SUBLEDGER_DOC_SEQUENCE_VALUE) OR
        (GLL.SUBLEDGER_DOC_SEQUENCE_ID IS NULL AND GJL2.SUBLEDGER_DOC_SEQUENCE_ID IS NULL AND
         GJL2.SUBLEDGER_DOC_SEQUENCE_VALUE IS NULL)) AND
       ((GLL.ACCOUNTED_DR IS NOT NULL AND GLL.ACCOUNTED_DR<> 0 AND GJL2.ACCOUNTED_CR IS NOT NULL
         AND GJL2.ACCOUNTED_CR <> 0) OR
        (GLL.ACCOUNTED_CR IS NOT NULL AND GLL.ACCOUNTED_CR<> 0 AND GJL2.ACCOUNTED_DR IS NOT NULL
         AND GJL2.ACCOUNTED_DR <> 0)) AND '||P_CONTRA_ACCOUNT|| ' )';
    END IF;




   IF (P_START_UPDATE_DATE IS NOT NULL OR P_END_UPDATE_DATE IS NOT NULL)  THEN
      IF P_START_UPDATE_DATE IS NULL THEN
         P_JOURNAL_UPD_DATE_WHERE :=
  ' AND TRUNC(GLH.LAST_UPDATE_DATE) <= '''|| H_END_UPDATE_DATE ||'''';
      ELSIF P_END_UPDATE_DATE IS NULL THEN
   P_JOURNAL_UPD_DATE_WHERE :=  ' AND TRUNC(GLH.LAST_UPDATE_DATE) >= '''|| H_START_UPDATE_DATE ||'''';
       ELSIF  ((P_START_UPDATE_DATE IS NOT NULL) AND (P_END_UPDATE_DATE IS NOT NULL)) THEN
         P_JOURNAL_UPD_DATE_WHERE := ' AND TRUNC(GLH.LAST_UPDATE_DATE)  BETWEEN ''' || H_START_UPDATE_DATE || ''' AND ''' || H_END_UPDATE_DATE || '''';
      END IF;
   ELSE
     P_JOURNAL_UPD_DATE_WHERE := ' ';
  END IF;


  IF(P_LAST_UPDATED_BY IS NOT NULL) THEN

    P_JOURNAL_LAST_UPD_WHERE := ' AND GLH.LAST_UPDATED_BY =  '||P_LAST_UPDATED_BY;
  ELSE
    P_JOURNAL_LAST_UPD_WHERE := ' ';

  END IF;
---*****************************************--------


IF NVL(P_JOURNALS_LINE_FLAG,'L') = 'J' THEN

    IF NVL(P_STATUS,'U')<> 'P' THEN
         P_USE_DATE_COL := 'GLH2.DEFAULT_EFFECTIVE_DATE';
   ELSIF P_STATUS = 'P' THEN
         P_USE_DATE_COL := 'GLB2.POSTED_DATE';
   END IF;


   IF P_USE_DATE_COL = 'GLH2.DEFAULT_EFFECTIVE_DATE' AND
      (P_START_DATE IS NOT NULL OR P_END_DATE IS NOT NULL) THEN
      -- SUB QUERY START
      P_JOURNAL_DATE_WHERE_2 := ' AND GLH2.PERIOD_NAME IN (SELECT PERIOD_NAME FROM GL_PERIOD_STATUSES PS
           WHERE PS.APPLICATION_ID = 101 AND PS.LEDGER_ID =  LGR1.LEDGER_ID ';
      /* BUGFIX - 3804059 AND 4043565 CHANGED VARIABLES TO BIND */
      IF P_START_DATE IS NULL THEN
         P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND ( PS.START_DATE <= ''' || H_END_DATE || '''  )';
      ELSIF P_END_DATE IS NULL THEN
         P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND (PS.END_DATE >= ''' || H_START_DATE || '''  )';
      ELSE
         P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND (PS.END_DATE >= ''' || H_START_DATE ||''' AND PS.START_DATE <= ''' || H_END_DATE || ''')';
      END IF;
      P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||')';
      -- SUB QUERY END

   ELSIF P_USE_DATE_COL = 'GLL2.EFFECTIVE_DATE' AND --:P_JOURNAL_DATE_WHERE_2 IS NOT NULL THEN
         (P_START_DATE IS NOT NULL OR P_END_DATE IS NOT NULL) THEN

      -- SUB QUERY START
      P_JOURNAL_DATE_WHERE_2 := ' AND GLL2.PERIOD_NAME IN (SELECT PERIOD_NAME FROM GL_PERIOD_STATUSES PS
            WHERE PS.APPLICATION_ID = 101 AND PS.SET_OF_BOOKS_ID = ' || P_LEDGER_ID || ' ';
   -- BUGFIX - 3804059 AND 4043565 CHANGED VARIABLES TO BIND
      IF P_START_DATE IS NULL THEN
         P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND ( PS.START_DATE <= ''' || H_END_DATE || ''' )';
      ELSIF P_END_DATE IS NULL THEN
         P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND (PS.END_DATE >= ''' || H_START_DATE || '''  )';
      ELSE
         P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND (PS.END_DATE >= ''' || H_START_DATE || ''' AND PS.START_DATE <= ''' || H_END_DATE ||''')';
      END IF;
      P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||')';
      -- SUB QUERY END

 -- BUGFIX - 3804059 AND 4043565 CHANGED VARIABLES TO BIND
 /*  ELSIF (:P_START_DATE IS NULL AND :P_END_DATE IS NULL) THEN
      :P_JOURNAL_DATE_WHERE_2 := ' AND ( ' ||:P_START_DATE || ' IS NULL AND ' || :H_END_DATE || ' IS NULL) ';

   ELSIF ((:P_START_DATE IS  NOT NULL) AND (:P_END_DATE IS NOT NULL))THEN
      :P_JOURNAL_DATE_WHERE_2 := ' AND (( ' || :H_START_DATE || ' IS NOT NULL OR ' || :H_END_DATE || ' IS NOT NULL)) ';
*/
   END IF;

 -- BUGFIX - 3804059 AND 4043565 CHANGE VARIABLES TO BIND
   IF ((P_START_DATE IS  NOT NULL) OR (P_END_DATE IS NOT NULL))THEN
    IF P_START_DATE IS NULL THEN
      P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND TRUNC('|| P_USE_DATE_COL ||') <= ''' || H_END_DATE||'''' ;
    ELSIF P_END_DATE IS NULL THEN
      P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND TRUNC('|| P_USE_DATE_COL ||') >= ''' || H_START_DATE||'''';
    ELSIF ((P_START_DATE IS  NOT NULL) AND (P_END_DATE IS NOT NULL)) THEN
      P_JOURNAL_DATE_WHERE_2 := P_JOURNAL_DATE_WHERE_2 ||' AND TRUNC('|| P_USE_DATE_COL ||') BETWEEN '''|| H_START_DATE || ''' AND '''|| H_END_DATE || '''';
    END IF;
   END IF;


ELSE -- LINE LEVEL REQUEST


   IF P_PERIOD_NAME IS NOT NULL THEN

     --   BUGFIX - 3804059 AND 4043565 CHANGE TO BIND VARIABLE

      P_PERIOD_WHERE := 'AND GLB.DEFAULT_PERIOD_NAME = '''||P_PERIOD_NAME||'''' ;


   ELSE
     -- BUGFIX - 3804059 AND 4043565 CHANGE TO BIND VARIABLE
      P_PERIOD_WHERE := ' ';
     IF P_REPORT_NAME = 'CONTRA' OR  P_REPORT_NAME = 'VOUCHER' OR
         (P_JOURNALS_LINE_FLAG IS NOT NULL AND NVL(P_STATUS,'U') <> 'P') THEN

         -- USE GLL.EFFECTIVE_DATE FOR "ACCOUNT ANALYSIS - CONTRA ACCOUNT" AND "JOURNALS VOUCHER"

         P_USE_DATE_COL := 'GLL.EFFECTIVE_DATE';

     ELSIF P_STATUS = 'P' THEN

        P_USE_DATE_COL := 'GLB.POSTED_DATE';

     ELSE

        P_USE_DATE_COL := 'GLH.DEFAULT_EFFECTIVE_DATE';

     END IF;

     --
      -- PERFORMANCE ENHANCEMENT BOOST
      --
     IF (P_USE_DATE_COL = 'GLH.DEFAULT_EFFECTIVE_DATE' OR
          P_USE_DATE_COL = 'NVL(GLL.EFFECTIVE_DATE, GLH.DEFAULT_EFFECTIVE_DATE)') AND
           (P_START_DATE IS NOT NULL OR P_END_DATE IS NOT NULL) THEN

      /*   -- SUB QUERY START
         :P_JOURNAL_DATE_WHERE := ' AND GLH.PERIOD_NAME IN (SELECT + CARDINALITY(PS,2 )  PERIOD_NAME
               FROM GL_PERIOD_STATUSES PS
              WHERE PS.APPLICATION_ID = 101 AND PS.LEDGER_ID = LGR.LEDGER_ID  ';
      */
       -- BUGFIX - 3804059 AND 4043565 CHANGES VARIABLES TO BIND
         IF P_START_DATE IS NULL THEN
            P_JOURNAL_DATE_WHERE_3 := ' AND ( PS.START_DATE <= ''' || H_END_DATE ||''' )';
         ELSIF P_END_DATE IS NULL THEN
            P_JOURNAL_DATE_WHERE_3 := ' AND (PS.END_DATE >= ''' || H_START_DATE || '''  )';
         ELSE
            P_JOURNAL_DATE_WHERE_3 := ' AND (PS.END_DATE >= ''' || H_START_DATE || ''' AND PS.START_DATE <= ''' || H_END_DATE || ''' )';
         END IF;
        -- :P_JOURNAL_DATE_WHERE := P_JOURNAL_DATE_WHERE ||')';
        -- SUB QUERY END

      ELSIF NVL(P_USE_DATE_COL,'NULL') = 'GLL.EFFECTIVE_DATE' AND
           (P_START_DATE IS NOT NULL OR P_END_DATE IS NOT NULL) THEN

         -- SUB QUERY START
         P_JOURNAL_DATE_WHERE := ' AND GLL.PERIOD_NAME IN (SELECT /*+ CARDINAILTY(PS,2 ) */ PERIOD_NAME
               FROM GL_PERIOD_STATUSES PS
                WHERE PS.APPLICATION_ID = 101 AND PS.LEDGER_ID = LGR.LEDGER_ID  ';

       -- BUGFIX - 3804059 AND 4043565 CHANGES VARIABLES TO BIND
         IF P_START_DATE IS NULL THEN
            P_JOURNAL_DATE_WHERE := P_JOURNAL_DATE_WHERE ||' AND ( PS.START_DATE <= ''' || H_END_DATE || ''' )';
         ELSIF P_END_DATE IS NULL THEN
            P_JOURNAL_DATE_WHERE := P_JOURNAL_DATE_WHERE ||' AND (PS.END_DATE >= ''' || H_START_DATE || ''' )';

         ELSE
            P_JOURNAL_DATE_WHERE := P_JOURNAL_DATE_WHERE ||' AND (PS.END_DATE >= ''' || H_START_DATE ||
                                                                ''' AND PS.START_DATE <= ''' || H_END_DATE || ''' )';

         END IF;
         P_JOURNAL_DATE_WHERE := P_JOURNAL_DATE_WHERE ||')';
          -- SUB QUERY END

     /* ELSIF ((P_START_DATE IS NOT NULL) AND (P_END_DATE IS NOT NULL)) THEN
         P_JOURNAL_DATE_WHERE := ' ( AND (''' || P_START_DATE || ''' IS NOT NULL OR '''|| P_END_DATE || ''' IS NOT NULL)) '; */

      END IF;

     /* BUGFIX - 3804059 AND 4043565 CHANGES VARIABLES TO BIND */
   IF (P_START_DATE IS NOT NULL OR P_END_DATE IS NOT NULL)  THEN
      IF P_START_DATE IS NULL THEN
         P_JOURNAL_DATE_WHERE := P_JOURNAL_DATE_WHERE ||' AND TRUNC('|| P_USE_DATE_COL ||') <= ''' || H_END_DATE || '''';
      ELSIF P_END_DATE IS NULL THEN
         P_JOURNAL_DATE_WHERE := P_JOURNAL_DATE_WHERE ||' AND TRUNC('|| P_USE_DATE_COL ||') >= ''' || H_START_DATE || '''';
      ELSIF  ((P_START_DATE IS NOT NULL) AND (P_END_DATE IS NOT NULL)) THEN
         P_JOURNAL_DATE_WHERE := P_JOURNAL_DATE_WHERE ||' AND TRUNC('|| P_USE_DATE_COL ||') BETWEEN ''' || H_START_DATE || ''' AND ''' || H_END_DATE || '''';
      END IF;
   ELSE
     P_JOURNAL_DATE_WHERE := ' ';
  END IF;


   END IF;


END IF;

---*******************************************---------


IF NVL(P_JOURNALS_LINE_FLAG,'L') = 'J' THEN   -- SELECTION BY JOURNAL BASE
   AMOUNT_WHERE:= NULL;
   AFF_WHERE:= NULL;


   IF P_USE_DATE_COL = 'GLB2.POSTED_DATE' OR P_USE_DATE_COL = 'GLH2.DEFAULT_EFFECTIVE_DATE' THEN
      JOURNAL_FROM:=' GL_JE_BATCHES GLB2,  ';

      JOURNAL_WHERE:= ' AND GLB2.JE_BATCH_ID = GLH2.JE_BATCH_ID  ';
   ELSE
      JOURNAL_FROM:= NULL;
      JOURNAL_WHERE:= NULL;
   END IF;

   IF P_AMOUNT_FROM IS NOT NULL OR P_AMOUNT_TO IS NOT NULL THEN

      IF P_AMT_FLAG = 'DR' THEN
         AMOUNT_WHERE2:= ' AND GLL2.ACCOUNTED_DR <> 0 AND GLL2.ACCOUNTED_DR ';
      ELSIF P_AMT_FLAG = 'CR' THEN
         AMOUNT_WHERE2:= ' AND GLL2.ACCOUNTED_CR <> 0 AND GLL2.ACCOUNTED_CR ';
      ELSE
         AMOUNT_WHERE2:= ' AND ((GLL2.ACCOUNTED_DR <> 0 AND GLL2.ACCOUNTED_DR ';
      END IF;

    -- BUGFIX - 3804059 AND 4043565
      IF P_AMOUNT_FROM IS NOT NULL AND P_AMOUNT_TO IS NULL THEN
         AMOUNT_WHERE2:= AMOUNT_WHERE2 || ' >= '|| P_AMOUNT_FROM ||' ';
      ELSIF P_AMOUNT_FROM IS NULL AND P_AMOUNT_TO IS NOT NULL THEN
         AMOUNT_WHERE2:=  AMOUNT_WHERE2 || ' <= '|| P_AMOUNT_TO||'  ';
      ELSIF (P_AMOUNT_FROM IS NOT NULL) AND (P_AMOUNT_TO IS NOT NULL) THEN
         AMOUNT_WHERE2:= AMOUNT_WHERE2 || ' BETWEEN '||P_AMOUNT_FROM ||' AND '|| P_AMOUNT_TO||' ';
      END IF;

    -- BUGFIX - 3804059 AND 4043565 CHANGES VARIABLES TO BIND
      IF P_AMT_FLAG IS NULL THEN
         IF P_AMOUNT_FROM IS NOT NULL AND P_AMOUNT_TO IS NULL THEN
            AMOUNT_WHERE2:= AMOUNT_WHERE2 || ') OR (GLL2.ACCOUNTED_CR <> 0 AND GLL2.ACCOUNTED_CR ';
            AMOUNT_WHERE2:= AMOUNT_WHERE2 || ' >= '||P_AMOUNT_FROM || '))';
         ELSIF P_AMOUNT_FROM IS NULL AND P_AMOUNT_TO IS NOT NULL THEN
            AMOUNT_WHERE2:= AMOUNT_WHERE2 || ') OR (GLL2.ACCOUNTED_CR <> 0 AND GLL2.ACCOUNTED_CR ';
            AMOUNT_WHERE2:= AMOUNT_WHERE2 || ' <= '||P_AMOUNT_TO|| ' ))';
         ELSIF ((P_AMOUNT_FROM IS  NOT NULL) AND (P_AMOUNT_TO IS NOT NULL)) THEN
            AMOUNT_WHERE2:= AMOUNT_WHERE2 || ') OR (GLL2.ACCOUNTED_CR <> 0 AND GLL2.ACCOUNTED_CR ';
            AMOUNT_WHERE2:= AMOUNT_WHERE2 || ' BETWEEN '|| P_AMOUNT_FROM ||' AND '|| P_AMOUNT_TO ||' ))';
         END IF;
     /*  ELSIF (:P_AMOUNT_FROM IS NOT NULL AND
            AMOUNT_WHERE2:= AMOUNT_WHERE2 || ' AND ('||:P_AMOUNT_FROM ||' IS NOT NULL OR '||:P_AMOUNT_TO ||' IS NOT NULL) ';*/
      END IF;

   END IF;

 -- BUGFIX - 3804059 AND 4043565 CHANGES VARIABLES TO BIND
   IF P_AFF_FROM IS NOT NULL AND P_AFF_TO IS NOT NULL THEN


    /*  SRW.REFERENCE(:CHART_OF_ACCOUNTS_ID);
      SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
               NUM=":CHART_OF_ACCOUNTS_ID"
               APPL_SHORT_NAME="SQLGL"
               OUTPUT=":P_AFF_WHERE_JRL"
               MODE="WHERE"
               DISPLAY="ALL"
	       OPERATOR="BETWEEN"
	       OPERAND1=:P_AFF_FROM
	       OPERAND2=:P_AFF_TO
               TABLEALIAS="GCC3"'); */


	IF (P_AFF_WHERE_JRL IS NOT NULL) THEN
	 P_AFF_WHERE_JRL := ' AND '||P_AFF_WHERE_JRL;
	END IF;



        END IF;

   P_JOURNAL_FROM_CLAUSE:= ', (SELECT DISTINCT GLL2.JE_HEADER_ID JE_HEADER_ID,
        GLL2.SUBLEDGER_DOC_SEQUENCE_ID SUB_DOC_SEQ_ID,
        GLL2.SUBLEDGER_DOC_SEQUENCE_VALUE SUB_DOC_SEQ_VALUE
   FROM ' || JOURNAL_FROM ||
'         GL_LEDGERS   LGR1,
	  GL_JE_LINES GLL2,
          GL_JE_HEADERS GLH2,
          GL_CODE_COMBINATIONS GCC3 '||L_LEDGER_FROM||'
  WHERE   LGR1.LEDGER_ID = GLH2.LEDGER_ID
        '|| JOURNAL_WHERE ||'
        '||L_LEDGER_WHERE||'
        '|| P_JOURNAL_DATE_WHERE_2 || '
        '|| AMOUNT_WHERE2 || '
        '|| P_AFF_WHERE_JRL ||'
        '|| L_DAS_WHERE||
'   AND GLL2.JE_HEADER_ID = GLH2.JE_HEADER_ID
    AND GLH2.LEDGER_ID = GLL2.LEDGER_ID
    AND GLL2.CODE_COMBINATION_ID = GCC3.CODE_COMBINATION_ID
    AND (NVL(GLL2.ACCOUNTED_DR, 0) <> 0 OR NVL(GLL2.ACCOUNTED_CR, 0) <> 0 ))  SUB_TABLE
';

   P_JOURNAL_WHERE_CLAUSE:=' AND SUB_TABLE.JE_HEADER_ID = GLL.JE_HEADER_ID
      AND (SUB_TABLE.SUB_DOC_SEQ_ID IS NULL OR
           SUB_TABLE.SUB_DOC_SEQ_ID = GLL.SUBLEDGER_DOC_SEQUENCE_ID)
      AND (SUB_TABLE.SUB_DOC_SEQ_VALUE IS NULL OR
           SUB_TABLE.SUB_DOC_SEQ_VALUE = GLL.SUBLEDGER_DOC_SEQUENCE_VALUE)';



ELSE   -- SELECTION BY LINE BASE

   P_JOURNAL_FROM_CLAUSE:= ' ';

  --  BUGFIX - 3804059 AND 4043565 CHANGES VARIABLE TO BIND

   IF P_AFF_FROM IS NOT NULL AND P_AFF_TO IS NOT NULL THEN

    /*   SRW.REFERENCE(:CHART_OF_ACCOUNTS_ID);
       SRW.USER_EXIT('FND FLEXSQL CODE="GL#"
                 NUM=":CHART_OF_ACCOUNTS_ID"
                 APPL_SHORT_NAME="SQLGL"
                 OUTPUT=":P_AFF_WHERE"
                 MODE="WHERE"
                 DISPLAY="ALL"
	         OPERATOR="BETWEEN"
	         OPERAND1=:P_AFF_FROM
	         OPERAND2=:P_AFF_TO
                 TABLEALIAS="CC"');*/

  IF (P_AFF_WHERE IS NOT NULL) THEN
         P_AFF_WHERE := ' AND '||P_AFF_WHERE;
   END IF;

   END IF;


   IF (P_AMOUNT_FROM IS NOT NULL OR P_AMOUNT_TO IS NOT NULL) THEN

      IF P_AMT_FLAG = 'DR' THEN
         AMOUNT_WHERE:= ' AND GLL.ACCOUNTED_DR <> 0 AND GLL.ACCOUNTED_DR ';
      ELSIF P_AMT_FLAG = 'CR' THEN
         AMOUNT_WHERE:= ' AND GLL.ACCOUNTED_CR <> 0 AND GLL.ACCOUNTED_CR ';
      ELSE
         AMOUNT_WHERE:= ' AND ((GLL.ACCOUNTED_DR <> 0 AND GLL.ACCOUNTED_DR ';
      END IF;

      IF P_AMOUNT_FROM IS NOT NULL AND P_AMOUNT_TO IS NULL THEN
         AMOUNT_WHERE:= AMOUNT_WHERE || ' >= '|| P_AMOUNT_FROM;
      ELSIF P_AMOUNT_FROM IS NULL AND P_AMOUNT_TO IS NOT NULL THEN
         AMOUNT_WHERE:= AMOUNT_WHERE || ' <= '||P_AMOUNT_TO;
      ELSE
         AMOUNT_WHERE:= AMOUNT_WHERE || ' BETWEEN ' || P_AMOUNT_FROM ||' AND '|| P_AMOUNT_TO ||' ';
      END IF;

    -- BUGFIX - 3804059 AND 4043565 CHANGES VARIABLES TO BIND
      IF P_AMT_FLAG IS NULL THEN
         IF P_AMOUNT_FROM IS NOT NULL AND P_AMOUNT_TO IS NULL THEN
            AMOUNT_WHERE:= AMOUNT_WHERE || ') OR (GLL.ACCOUNTED_CR <> 0 AND GLL.ACCOUNTED_CR ';
            AMOUNT_WHERE:= AMOUNT_WHERE || ' >= '||P_AMOUNT_FROM||' ))';
         ELSIF P_AMOUNT_FROM IS NULL AND P_AMOUNT_TO IS NOT NULL THEN
            AMOUNT_WHERE:= AMOUNT_WHERE || ') OR (GLL.ACCOUNTED_CR <> 0 AND GLL.ACCOUNTED_CR ';
            AMOUNT_WHERE:= AMOUNT_WHERE || ' <= '||P_AMOUNT_TO||' ))';
         ELSE
            AMOUNT_WHERE:= AMOUNT_WHERE || ') OR (GLL.ACCOUNTED_CR <> 0 AND GLL.ACCOUNTED_CR ';
            AMOUNT_WHERE:= AMOUNT_WHERE || ' BETWEEN '||P_AMOUNT_FROM ||' AND  '|| P_AMOUNT_TO || ' ))';
         END IF;
    /*  -- BUGFIX - 3804059 AND 4043565 CHANGES VARIABLES TO BIND
      ELSE
         AMOUNT_WHERE := AMOUNT_WHERE || ' AND (P_AMOUNT_FROM IS NOT NULL OR P_AMOUNT_TO IS NOT NULL) '; */

      END IF;

    P_AMOUNT_WHERE := AMOUNT_WHERE;
   ELSE
      P_AMOUNT_WHERE := ' ';
   END IF;



END IF;

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%---
/* EXCEPTION
  WHEN SRW.UNKNOWN_USER_EXIT THEN
   -- SRW.MESSAGE(07,'FND FLEXSQL USER EXIT IS UNKNOWN.');
    RAISE;
  WHEN SRW.USER_EXIT_FAILURE THEN
  --  SRW.MESSAGE(08,'FND FLEXSQL USER EXIT FAILED.');
    RAISE;*/

END;



/***** COPY/RESOLVE PARAMETERS *****/

IF P_LEDGER_ID IS NOT NULL THEN
  SELECT NAME
  INTO   PARAM_LEDGER_NAME
  FROM   GL_LEDGERS
  WHERE  LEDGER_ID = P_LEDGER_ID;
END IF;

IF P_STATUS IS NOT NULL THEN
  GL_INFO.GL_GET_LOOKUP_VALUE('M', P_STATUS, 'JOURNAL_REPORT_TYPE',
                              PARAM_POSTING_STATUS, T_ERRORBUFFER);
/*  IF (T_ERRORBUFFER IS NOT NULL) THEN
     SRW.MESSAGE('00', T_ERRORBUFFER);
  END IF;*/
END IF;

PARAM_CURRENCY_CODE := P_CURRENCY;


 IF (P_REPORT_NAME = 'CHECK') THEN
   PARAM_START_DATE := H_START_UPDATE_DATE;
   PARAM_END_DATE := H_END_UPDATE_DATE;
 ELSE
   PARAM_START_DATE := H_START_DATE;
  PARAM_END_DATE := H_END_DATE;
 END IF;
 C_DATE_FORMAT := 'DD-MON-YY';
  C_PARAM_START_DATE :=  to_char(PARAM_START_DATE,C_DATE_FORMAT);
  C_PARAM_END_DATE := to_char(PARAM_END_DATE,C_DATE_FORMAT);
IF P_SOURCE IS NOT NULL THEN
  SELECT USER_JE_SOURCE_NAME
  INTO   PARAM_SOURCE
  FROM   GL_JE_SOURCES
  WHERE  JE_SOURCE_NAME = P_SOURCE;
END IF;

IF P_CATEGORY IS NOT NULL THEN
  SELECT USER_JE_CATEGORY_NAME
  INTO   PARAM_CATEGORY
  FROM   GL_JE_CATEGORIES
  WHERE  JE_CATEGORY_NAME = P_CATEGORY;
END IF;

PARAM_BATCH_NAME := P_BATCH_NAME;

IF P_LAST_UPDATED_BY IS NOT NULL THEN
  SELECT USER_NAME
  INTO   PARAM_LAST_UPDATED_BY
  FROM   FND_USER
  WHERE  USER_ID = P_LAST_UPDATED_BY;
END IF;

PARAM_BALANCING_SEGMENT := P_BAL_SEG_VAL;
PARAM_PERIOD_NAME := P_PERIOD_NAME;

IF P_JOURNALS_LINE_FLAG IS NOT NULL THEN
  GL_INFO.GL_GET_LOOKUP_VALUE('M', P_JOURNALS_LINE_FLAG, 'SELECTION_BASE',
                              PARAM_BASIS, T_ERRORBUFFER);
 /* IF (T_ERRORBUFFER IS NOT NULL) THEN
    SRW.MESSAGE('00', T_ERRORBUFFER);
  END IF;*/
END IF;

IF P_DOC_ID IS NOT NULL THEN
  SELECT NAME
  INTO   PARAM_DOC_SEQ_NAME
  FROM   FND_DOCUMENT_SEQUENCES
  WHERE  DOC_SEQUENCE_ID = P_DOC_ID;
END IF;
PARAM_DOC_SEQ_VALUE := P_DOC_VALUE;
PARAM_START_DOC_SEQ_VALUE := P_START_DOC_VALUE;
PARAM_END_DOC_SEQ_VALUE := P_END_DOC_VALUE;

IF P_SUB_DOC_ID IS NOT NULL THEN
  SELECT NAME
  INTO   PARAM_SUB_DOC_SEQ_NAME
  FROM   FND_DOCUMENT_SEQUENCES
  WHERE  DOC_SEQUENCE_ID = P_SUB_DOC_ID;
END IF;
PARAM_SUB_DOC_SEQ_VALUE := P_SUB_DOC_VALUE;

PARAM_ACCT_FROM := P_AFF_FROM;
PARAM_ACCT_TO := P_AFF_TO;

IF P_AMT_FLAG IS NOT NULL THEN
  GL_INFO.GL_GET_LOOKUP_VALUE('M', P_AMT_FLAG, 'GL_DR_CR',
                              PARAM_AMT_FLAG, T_ERRORBUFFER);
 /* IF (T_ERRORBUFFER IS NOT NULL) THEN
     SRW.MESSAGE('00', T_ERRORBUFFER);
  END IF;*/
END IF;

PARAM_AMOUNT_LOW := P_AMOUNT_FROM;
PARAM_AMOUNT_HIGH := P_AMOUNT_TO;
PARAM_CONTRA_ACCT := P_CONTRA_ACCT;

/* THE SEGMENT PROMPTS*/
--SRW.REFERENCE(:CHART_OF_ACCOUNTS_ID);

/*SRW.USER_EXIT('FND FLEXIDVAL CODE="GL#"
              APPL_SHORT_NAME="SQLGL"
              NUM=":CHART_OF_ACCOUNTS_ID"
              DATA=":P_AFF_FROM"
              LPROMPT=":BAL_SEG_NAME_DSP"
              DISPLAY="GL_BALANCING"
              IDISPLAY="GL_BALANCING"');*/

/*SRW.USER_EXIT('FND FLEXIDVAL CODE="GL#"
              APPL_SHORT_NAME="SQLGL"
              NUM=":CHART_OF_ACCOUNTS_ID"
              DATA=":P_AFF_FROM"
              LPROMPT=":ACCT_SEG_NAME_DSP"
              DISPLAY="GL_ACCOUNT"
              IDISPLAY="GL_ACCOUNT"');*/
/*IF ( P_SEC_SEG_NUM IS NOT NULL AND PARAM_SEC_SEG_NAME IS NULL) THEN

  SRW.REFERENCE(:P_SEC_SEG_NUM);
  SRW.USER_EXIT('FND FLEXIDVAL CODE="GL#"
              APPL_SHORT_NAME="SQLGL"
              NUM=":CHART_OF_ACCOUNTS_ID"
              DATA=":P_AFF_FROM"
              LPROMPT=":PARAM_SEC_SEG_NAME"
              DISPLAY=":P_SEC_SEG_NUM"
              IDISPLAY=":P_SEC_SEG_NUM"');
END IF*/

/***** END PARAMETER COPYING *****/


/******* START PERFORMANCE  HINTS *******/

IF P_REPORT_NAME = 'CHECK' THEN

  P_HINT_CLAUSE := '/*+ ORDERED */';

  IF ((P_STATUS = 'E') OR (P_STATUS = 'U') OR (P_BATCH_NAME IS NOT NULL)) THEN

   P_PERF_FROM :=
    ' GL_JE_BATCHES GLB,  GL_JE_HEADERS GLH '||P_LEDGER_FROM||
    ' , GL_JE_LINES GLL, GL_CODE_COMBINATIONS CC, GL_LEDGERS LGR, GL_JE_SOURCES GJS, GL_JE_CATEGORIES GJC, '||
    ' GL_DAILY_CONVERSION_TYPES DCT, FND_DOCUMENT_SEQUENCES DOCSEQ, '||
    ' FND_DOCUMENT_SEQUENCES SUBDOCSEQ, FND_USER FU ' ;

   -- SINCE THE FOLLOWING VARIABLE IS IN THE MAIN QUERY TO HANDLE THE REGULAR CASE
    -- AND IN THIS CASE IT IS INCLUDED INTO THE P_PERF_FROM

   P_LEDGER_FROM :=' ';


     ELSIF  ((P_STATUS <> 'E')  OR (P_STATUS <> 'U')) THEN


     IF P_LEDGER_FROM IS NOT NULL THEN

     P_HINT_CLAUSE := '/*+ ORDERED USE_NL(LS) INDEX(LS GL_LEDGER_SET_ASSIGNMENTS_N1)
 			    USE_NL(GLL) INDEX (GLL GL_JE_LINES_U1)
                            USE_NL(GLL)INDEX(CC GL_CODE_COMBINATIONS_U1)
                            USE_NL(GLB) INDEX(GLB GL_JE_BATCHES_U1)
                            USE_NL(GJC) INDEX (GJC GL_JE_CATEGORIES_TL_U1)
                            USE_NL(GJS) INDEX (GJS GL_JE_SOURCES_TL_U1)
                            USE_NL(DCT) INDEX (DCT GL_DAILY_CONVERSION_TYPES_U1)
                            USE_NL(DOCSEQ) INDEX(DOCSEQ FND_DOCUMENT_SEQUENCES_U1)
                            USE_NL(SUBDOCSEQ) INDEX(SUBDOCSEQ FND_DOCUMENT_SEQUENCES_U1)
                            USE_NL(FU) INDEX(FU FND_USER_U1)  */';
    ELSE
        P_HINT_CLAUSE := '/*+ ORDERED
  			    USE_NL(GLL) INDEX (GLL GL_JE_LINES_U1)
                            USE_NL(GLL)INDEX(CC GL_CODE_COMBINATIONS_U1)
                            USE_NL(GLB) INDEX(GLB GL_JE_BATCHES_U1)
                            USE_NL(GJC) INDEX (GJC GL_JE_CATEGORIES_TL_U1)
                            USE_NL(GJS) INDEX (GJS GL_JE_SOURCES_TL_U1)
                            USE_NL(DCT) INDEX (DCT GL_DAILY_CONVERSION_TYPES_U1)
                            USE_NL(DOCSEQ) INDEX(DOCSEQ FND_DOCUMENT_SEQUENCES_U1)
                            USE_NL(SUBDOCSEQ) INDEX(SUBDOCSEQ FND_DOCUMENT_SEQUENCES_U1)
                            USE_NL(FU) INDEX(FU FND_USER_U1)  */';
   END IF;

   P_PERF_FROM :=
    ' GL_JE_HEADERS GLH '||P_LEDGER_FROM||
    ' , GL_JE_BATCHES GLB, GL_JE_LINES GLL, GL_CODE_COMBINATIONS CC, GL_JE_SOURCES GJS,  GL_LEDGERS LGR,'||
    ' GL_JE_CATEGORIES GJC,  GL_DAILY_CONVERSION_TYPES DCT, FND_DOCUMENT_SEQUENCES DOCSEQ, '||
    ' FND_DOCUMENT_SEQUENCES SUBDOCSEQ, FND_USER FU ';

    -- SINCE THE FOLLOWING VARIABLE IS IN THE MAIN QUERY TO HANDLE THE REGULAR CASE
    -- AND IN THIS CASE IT IS INCLUDED INTO THE P_PERF_FROM

    P_LEDGER_FROM :=' ';

  END IF;

  IF P_PERF_FROM IS NULL THEN
      P_HINT_CLAUSE :=' ';
  END IF;

ELSE

  P_HINT_CLAUSE := ' ';
 /*  :P_PERF_FROM :=
    ' GL_JE_HEADERS GLH, GL_LEDGERS LGR,'||P_LEDGER_FROM||
    ' GL_JE_LINES GLL, GL_CODE_COMBINATIONS CC,  GL_JE_BATCHES GLB, GL_JE_SOURCES GJS, '||
    ' GL_JE_CATEGORIES GJC,  GL_DAILY_CONVERSION_TYPES DCT, FND_DOCUMENT_SEQUNCES DOCSEQ, '||
    ' FND_DOCUMENT_SEQUNCES SUBDOCSEQ, FND_USER FU'; */
END IF;


/******** END PERFORMANCE HINTS ********/



  RETURN (TRUE);
END BEFOREREPORT;

function AfterReport return boolean is
begin

/*srw.user_exit('FND SRWEXIT');*/null;
  return (TRUE);
end;

PROCEDURE SET_DATE_FORMAT IS
BEGIN

/*SRW.ATTR.MASK       := SRW.FORMATMASK_ATTR;*/null;

/*SRW.ATTR.FORMATMASK := H_DATEFORMAT;*/null;

/*SRW.SET_ATTR(0,SRW.ATTR);*/null;



END;

function CF_1Formula return Char is
  MULTIPLE_NAME varchar2(20);
begin


 multiple_name := 'MULTIPLE';

  RETURN(multiple_name);
end;

function H_START_PERIOD_DATEFormula return DATE is

  START_PERIOD_DATE date := SYSDATE;

begin



  RETURN(START_PERIOD_DATE);



EXCEPTION
  WHEN NO_DATA_FOUND THEN
    SELECT MIN(start_date)
      INTO start_period_date
      FROM gl_period_statuses
     WHERE application_id = 101
       AND set_of_books_id = H_SET_OF_BOOKS_ID
       AND adjustment_period_flag <> 'Y';

    RETURN(START_PERIOD_DATE);

  WHEN OTHERS THEN
    RETURN NULL;
end;

function H_START_PERIOD_NAMEFormula return Char is


  START_PERIOD_NAME varchar2(30) := SYSDATE;

begin



  RETURN(START_PERIOD_NAME);


EXCEPTION
  WHEN NO_DATA_FOUND THEN
    SELECT p1.period_name
      INTO start_period_name
      FROM gl_period_statuses p1
     WHERE p1.application_id = 101
       AND p1.set_of_books_id = H_SET_OF_BOOKS_ID
       AND p1.adjustment_period_flag <> 'Y'
       AND p1.start_date =
       (SELECT MIN(p2.start_date)
          FROM gl_period_statuses p2
         WHERE p2.application_id = p1.application_id
           AND p2.set_of_books_id = p1.set_of_books_id
           AND p2.adjustment_period_flag <> 'Y');

    RETURN(START_PERIOD_NAME);

  WHEN OTHERS THEN
    RETURN NULL;
end;

function NO_CONTRA_ACCOUNTFormula return Char is

    NO_CONTRA_NAME varchar2(20);
begin


 NO_CONTRA_NAME := 'NO CONTRA ACCOUNT';

  RETURN(NO_CONTRA_NAME);
end;

function tax_typeformula(TAX_TYPE_CODE in varchar2) return char is
  l_tax_type  VARCHAR2(80);
  errorbuffer VARCHAR2(132);
begin
  /*srw.reference(TAX_TYPE_CODE);*/null;

  if (TAX_TYPE_CODE is not null) then
    gl_info.gl_get_lookup_value('M', TAX_TYPE_CODE, 'TAX_TYPE',
                                l_tax_type, errorbuffer);
  end if;
  return (l_tax_type);
end;

function approval_statusformula(APPROVAL_STATUS_CODE in varchar2) return char is
  l_appr_status VARCHAR2(80);
  errorbuffer VARCHAR2(132);
begin
  /*srw.reference(APPROVAL_STATUS_CODE);*/null;

  gl_info.gl_get_lookup_value('M', APPROVAL_STATUS_CODE, 'JE_BATCH_APPROVAL_STATUS',
                              l_appr_status, errorbuffer);
  return (l_appr_status);
end;

function batch_statusformula(BATCH_STATUS_CODE in varchar2) return char is
  l_batch_status VARCHAR2(80);
  errorbuffer VARCHAR2(132);
begin
  /*srw.reference(BATCH_STATUS_CODE);*/null;

  gl_info.gl_get_lookup_value('M', BATCH_STATUS_CODE, 'MJE_BATCH_STATUS',
                              l_batch_status, errorbuffer);
  return (l_batch_status);
end;

function batch_typeformula(ACTUAL_FLAG in varchar2) return char is
  l_batch_type VARCHAR2(80);
  errorbuffer VARCHAR2(132);
begin
  /*srw.reference(ACTUAL_FLAG);*/null;

  gl_info.gl_get_lookup_value('D', ACTUAL_FLAG, 'BATCH_TYPE',
                              l_batch_type, errorbuffer);
  return (l_batch_type);
end;

function budget_ctrl_statusformula(BUD_CONTROL_STATUS in varchar2) return char is
  l_bc_status VARCHAR2(80);
  errorbuffer VARCHAR2(132);
begin
  /*srw.reference(BUD_CONTROL_STATUS);*/null;

  gl_info.gl_get_lookup_value('M', BUD_CONTROL_STATUS, 'JE_BATCH_BC_STATUS',
                              l_bc_status, errorbuffer);
  return (l_bc_status);
end;

function jrnl_typeformula(AVERAGE_JOURNAL_FLAG in varchar2) return char is
  l_journal_type VARCHAR2(80);
  errorbuffer VARCHAR2(132);
begin
  /*srw.reference(AVERAGE_JOURNAL_FLAG);*/null;

  gl_info.gl_get_lookup_value('M', AVERAGE_JOURNAL_FLAG, 'AB_JOURNAL_TYPE',
                              l_journal_type, errorbuffer);
  return (l_journal_type);
end;

function tax_statusformula(TAX_STATUS_CODE in varchar2) return char is
  l_tax_status VARCHAR2(80);
  errorbuffer VARCHAR2(132);
begin
  /*srw.reference(TAX_STATUS_CODE);*/null;

  gl_info.gl_get_lookup_value('M', TAX_STATUS_CODE, 'TAX_STATUS',
                              l_tax_status, errorbuffer);
  return (l_tax_status);
end;

function budget_nameformula(BUDGET_VERSION_ID in number) return char is
  l_budget_name VARCHAR2(15);
begin
  /*srw.reference(BUDGET_VERSION_ID);*/null;

  IF (BUDGET_VERSION_ID IS NOT NULL) THEN
    SELECT budget_name
    INTO   l_budget_name
    FROM   GL_BUDGET_VERSIONS
    WHERE  budget_version_id = BUDGET_VERSION_ID;
  END IF;
  return l_budget_name;
exception
  WHEN NO_DATA_FOUND THEN
    return null;
end;

function encumbrance_typeformula(ENCUMBRANCE_TYPE_ID in number) return char is
  l_enc_type VARCHAR2(30);
begin
  /*srw.reference(ENCUMBRANCE_TYPE_ID);*/null;

  IF (ENCUMBRANCE_TYPE_ID IS NOT NULL) THEN
    SELECT encumbrance_type
    INTO   l_enc_type
    FROM   GL_ENCUMBRANCE_TYPES
    WHERE  encumbrance_type_id = ENCUMBRANCE_TYPE_ID;
  END IF;
  return l_enc_type;
exception
  WHEN NO_DATA_FOUND THEN
    return null;
end;

function tax_codeformula(TAX_CODE_ID in number, TAX_TYPE_CODE in varchar2) return char is
  l_tax_code VARCHAR2(50);
begin
  /*srw.reference(TAX_CODE_ID);*/null;

  /*srw.reference(TAX_TYPE_CODE);*/null;

  IF (TAX_CODE_ID IS NOT NULL) THEN
    SELECT GLT.TAX_CODE
    INTO l_tax_code
    FROM GL_TAX_CODES_V GLT
    WHERE to_char(GLT.TAX_CODE_ID) = TAX_CODE_ID
    AND GLT.TAX_TYPE_CODE = TAX_TYPE_CODE;
  END IF;

  return (l_tax_code);
exception
  WHEN NO_DATA_FOUND THEN
    return null;
end;

function contra_acct_valueformula(HDR_ID in number, SUB_DOC_SEQ_ID in number, SUB_DOC_SEQ_VAL in number, ACCOUNTED_DR in number, ACCOUNTED_CR in number) return char is

    CONTRA_ACCT_SEGMENT       VARCHAR2(2000);
    l_CONTRA_ACCOUNT_NAME        VARCHAR2(2000);
    v_sql_stmt                 VARCHAr2(2000);



BEGIN

If (P_REPORT_NAME = 'CONTRA' ) THEN


 l_CONTRA_ACCOUNT_NAME := GL_XML_JOURNAL_RPT_PKG.Get_Contra_Account(SELECT_ACCT_SEGMENT,
     					  HDR_ID,
                                          SUB_DOC_SEQ_ID,
					  SUB_DOC_SEQ_VAL,
                           		  ACCOUNTED_DR,
                                          ACCOUNTED_CR);
RETURN (l_contra_account_name);

ELSE

 RETURN NULL;

END IF;



END;

FUNCTION CF_LINE_BALANCEFORMULA(BAL_SEG_VAL IN VARCHAR2, ACCT_SEG_VAL IN VARCHAR2, ADDITIONAL_SEGMENT_VALUE IN VARCHAR2, LEDGER_ID IN NUMBER, BATCH_STATUS_CODE IN VARCHAR2) RETURN NUMBER IS
 L_LINE_BALANCE NUMBER;

BEGIN

 IF (P_REPORT_NAME = 'CONTRA' ) THEN



   IF ( (BAL_SEG_VAL <> PREV_BAL_SEG_VAL)   OR
         ( ACCT_SEG_VAL <> PREV_ACCT_SEG_VAL) OR
          (NVL(ADDITIONAL_SEGMENT_VALUE, 'NULL') <>  PREV_SEC_SEG_VAL) OR
           (LEDGER_ID <> PREV_LED_ID) )         THEN


    L_LINE_BALANCE :=
     GL_XML_JOURNAL_RPT_PKG.NET_LINE_BALANCE
        (P_ACCT_SEG_WHERE => NVL(P_AFF_WHERE, P_ACC_SEGMENT_WHERE),
         P_STATUS         => BATCH_STATUS_CODE,
         P_START_DATE     => H_START_DATE,
         P_CURRENCY       => PARAM_CURRENCY_CODE,
         P_LED_ID         => LEDGER_ID,
         P_BAL_SEG_NAME   => SELECT_BAL_SEGMENT,
         P_BAL_SEG_VAL    => BAL_SEG_VAL,
         P_ACCT_SEG_NAME  => SELECT_ACCT_SEGMENT,
         P_ACCT_SEG_VAL   => ACCT_SEG_VAL,
         P_SEC_SEG_NAME   => SELECT_SECONDARY_SEGMENT,
         P_SEC_SEG_VAL    => ADDITIONAL_SEGMENT_VALUE);

       PREV_BAL_SEG_VAL   := BAL_SEG_VAL;
       PREV_ACCT_SEG_VAL  := ACCT_SEG_VAL;
       PREV_SEC_SEG_VAL   := NVL(ADDITIONAL_SEGMENT_VALUE,'NULL1');
       PREV_LED_ID        := LEDGER_ID;
       PREV_LINE_BAL      :=  L_LINE_BALANCE;


     RETURN L_LINE_BALANCE;

    ELSE

     RETURN PREV_LINE_BAL;

    END IF;

  ELSE

   RETURN  0;

  END IF;

 END CF_LINE_BALANCEFORMULA;

function cf_gl_balanceformula(BAL_SEG_VAL in varchar2, ACCT_SEG_VAL in varchar2, ADDITIONAL_SEGMENT_VALUE in varchar2, LEDGER_ID in number, BATCH_STATUS_CODE in varchar2) return number is
 l_beg_balance   NUMBER;

BEGIN

 If (P_REPORT_NAME = 'CONTRA' ) THEN


  IF ( (BAL_SEG_VAL <> NVL(PREV_BAL_SEG_VAL,NULL))  OR
         ( ACCT_SEG_VAL <> NVL(PREV_ACCT_SEG_VAL,'NULL')) OR
          (NVL(ADDITIONAL_SEGMENT_VALUE,'NULL') <>  NVL(PREV_SEC_SEG_VAL,'NULL1')) OR
           (LEDGER_ID <> NVL(PREV_LED_ID,0)) )         THEN

    l_beg_Balance :=
     GL_XML_JOURNAL_RPT_PKG.Net_Begin_Balance
        (P_ACCT_SEG_WHERE => NVL(P_AFF_WHERE, P_ACC_SEGMENT_WHERE),
         P_STATUS         => BATCH_STATUS_CODE,
         P_START_DATE     => H_START_DATE,
         P_CURRENCY       => PARAM_CURRENCY_CODE,
         P_LED_ID         => LEDGER_ID,
         P_BAL_SEG_NAME   => SELECT_BAL_SEGMENT,
         P_BAL_SEG_VAL    => BAL_SEG_VAL,
         P_ACCT_SEG_NAME  => SELECT_ACCT_SEGMENT,
         P_ACCT_SEG_VAL   => ACCT_SEG_VAL,
         P_SEC_SEG_NAME   => SELECT_SECONDARY_SEGMENT,
         P_SEC_SEG_VAL    => ADDITIONAL_SEGMENT_VALUE);

       PREV_BAL_SEG_VAL   := BAL_SEG_VAL;
       PREV_ACCT_SEG_VAL  := ACCT_SEG_VAL;
       PREV_SEC_SEG_VAL   := NVL(ADDITIONAL_SEGMENT_VALUE,'NULL1');
       PREV_LED_ID        := LEDGER_ID;
       PREV_GL_BAL      :=  l_Beg_balance;

     RETURN l_Beg_Balance;

    ELSE

     RETURN PREV_GL_BAL;

    END IF;

  ELSE
     RETURN 0;
  END IF;

END;

function begin_balanceformula(CF_LINE_BALANCE in number, CF_GL_BALANCE in number) return number is
begin
    If (P_REPORT_NAME = 'CONTRA' ) THEN

      IF ((CF_LINE_BALANCE IS NOT NULL)
              OR (CF_GL_BALANCE IS NOT NULL)) THEN
          Return (NVL(CF_LINE_BALANCE,0)) + (NVL(CF_GL_BALANCE,0));
       ELSE
          Return (CF_LINE_BALANCE) + (CF_GL_BALANCE);
      END IF;
    ELSE
       Return 0;
    End If;
end;

--Functions to refer Oracle report placeholders--

 Function ACCESS_SET_NAME_p return varchar2 is
	Begin
	 return ACCESS_SET_NAME;
	 END;
 Function PARAM_CURRENCY_CODE_p return varchar2 is
	Begin
	 return PARAM_CURRENCY_CODE;
	 END;
 Function CHART_OF_ACCOUNTS_ID_p return number is
	Begin
	 return CHART_OF_ACCOUNTS_ID;
	 END;
 Function PARAM_START_DATE_p return date is
	Begin
	 return PARAM_START_DATE;
	 END;
 Function PARAM_END_DATE_p return date is
	Begin
	 return PARAM_END_DATE;
	 END;
 Function PARAM_DOC_SEQ_VALUE_p return number is
	Begin
	 return PARAM_DOC_SEQ_VALUE;
	 END;
 Function PARAM_AMOUNT_LOW_p return number is
	Begin
	 return PARAM_AMOUNT_LOW;
	 END;
 Function PARAM_AMOUNT_HIGH_p return number is
	Begin
	 return PARAM_AMOUNT_HIGH;
	 END;
 Function PARAM_SUB_DOC_SEQ_VALUE_p return number is
	Begin
	 return PARAM_SUB_DOC_SEQ_VALUE;
	 END;
 Function SELECT_ACCT_SEGMENT_p return varchar2 is
	Begin
	 return SELECT_ACCT_SEGMENT;
	 END;
 Function SELECT_BAL_SEGMENT_p return varchar2 is
	Begin
	 return SELECT_BAL_SEGMENT;
	 END;
 Function PARAM_SEC_SEG_NAME_p return varchar2 is
	Begin
	 return PARAM_SEC_SEG_NAME;
	 END;
 Function PARAM_POSTING_STATUS_p return varchar2 is
	Begin
	 return PARAM_POSTING_STATUS;
	 END;
 Function NO_CONTRA_ACCOUNT_p return varchar2 is
	Begin
	 return NO_CONTRA_ACCOUNT;
	 END;
 Function P_ACC_SEGMENT_WHERE_p return varchar2 is
	Begin
	 return P_ACC_SEGMENT_WHERE;
	 END;
 Function P_CURRENCY_WHERE_p return varchar2 is
	Begin
	 return P_CURRENCY_WHERE;
	 END;
 Function P_SEC_SEGMENT_WHERE_p return varchar2 is
	Begin
	 return P_SEC_SEGMENT_WHERE;
	 END;
 Function P_DAS_WHERE_p return varchar2 is
	Begin
	 return P_DAS_WHERE;
	 END;
 Function SELECT_ACCOUNT_p return varchar2 is
	Begin
	 return SELECT_ACCOUNT;
	 END;
 Function SELECT_SECONDARY_SEGMENT_p return varchar2 is
	Begin
	 return SELECT_SECONDARY_SEGMENT;
	 END;
 Function P_POSTING_STATUS_p return varchar2 is
	Begin
	 return P_POSTING_STATUS;
	 END;
 Function P_HEADER_POSTING_STATUS_p return varchar2 is
	Begin
	 return P_HEADER_POSTING_STATUS;
	 END;
 Function P_SOURCE_WHERE_p return varchar2 is
	Begin
	 return P_SOURCE_WHERE;
	 END;
 Function P_BATCH_WHERE_p return varchar2 is
	Begin
	 return P_BATCH_WHERE;
	 END;
 Function P_CATEGORY_WHERE_p return varchar2 is
	Begin
	 return P_CATEGORY_WHERE;
	 END;
 Function P_BAL_WHERE_p return varchar2 is
	Begin
	 return P_BAL_WHERE;
	 END;
 Function P_DOC_ID_WHERE_p return varchar2 is
	Begin
	 return P_DOC_ID_WHERE;
	 END;
 Function P_DOC_VAL_WHERE_p return varchar2 is
	Begin
	 return P_DOC_VAL_WHERE;
	 END;
 Function P_SUB_DOC_ID_WHERE_p return varchar2 is
	Begin
	 return P_SUB_DOC_ID_WHERE;
	 END;
 Function P_SUB_DOC_VAL_WHERE_p return varchar2 is
	Begin
	 return P_SUB_DOC_VAL_WHERE;
	 END;
 Function P_NOT_ZERO_LINE_WHERE_p return varchar2 is
	Begin
	 return P_NOT_ZERO_LINE_WHERE;
	 END;
 Function P_CONTRA_ACCOUNT_WHERE_p return varchar2 is
	Begin
	 return P_CONTRA_ACCOUNT_WHERE;
	 END;
 Function P_CONTRA_ACCOUNT_p return varchar2 is
	Begin
	 return P_CONTRA_ACCOUNT;
	 END;
 Function P_PERIOD_WHERE_p return varchar2 is
	Begin
	 return P_PERIOD_WHERE;
	 END;
 Function P_JOURNAL_DATE_WHERE_p return varchar2 is
	Begin
	 return P_JOURNAL_DATE_WHERE;
	 END;
 Function P_JOURNAL_DATE_WHERE_2_p return varchar2 is
	Begin
	 return P_JOURNAL_DATE_WHERE_2;
	 END;
 Function P_USE_DATE_COL_p return varchar2 is
	Begin
	 return P_USE_DATE_COL;
	 END;
 Function P_JOURNAL_FROM_CLAUSE_p return varchar2 is
	Begin
	 return P_JOURNAL_FROM_CLAUSE;
	 END;
 Function P_JOURNAL_WHERE_CLAUSE_p return varchar2 is
	Begin
	 return P_JOURNAL_WHERE_CLAUSE;
	 END;
 Function PARAM_SOURCE_p return varchar2 is
	Begin
	 return PARAM_SOURCE;
	 END;
 Function PARAM_CATEGORY_p return varchar2 is
	Begin
	 return PARAM_CATEGORY;
	 END;
 Function PARAM_BATCH_NAME_p return varchar2 is
	Begin
	 return PARAM_BATCH_NAME;
	 END;
 Function PARAM_LAST_UPDATED_BY_p return varchar2 is
	Begin
	 return PARAM_LAST_UPDATED_BY;
	 END;
 Function PARAM_BALANCING_SEGMENT_p return varchar2 is
	Begin
	 return PARAM_BALANCING_SEGMENT;
	 END;
 Function PARAM_PERIOD_NAME_p return varchar2 is
	Begin
	 return PARAM_PERIOD_NAME;
	 END;
 Function PARAM_BASIS_p return varchar2 is
	Begin
	 return PARAM_BASIS;
	 END;
 Function PARAM_DOC_SEQ_NAME_p return varchar2 is
	Begin
	 return PARAM_DOC_SEQ_NAME;
	 END;
 Function PARAM_ACCT_FROM_p return varchar2 is
	Begin
	 return PARAM_ACCT_FROM;
	 END;
 Function PARAM_ACCT_TO_p return varchar2 is
	Begin
	 return PARAM_ACCT_TO;
	 END;
 Function PARAM_AMT_FLAG_p return varchar2 is
	Begin
	 return PARAM_AMT_FLAG;
	 END;
 Function PARAM_SUB_DOC_SEQ_NAME_p return varchar2 is
	Begin
	 return PARAM_SUB_DOC_SEQ_NAME;
	 END;
 Function PARAM_CONTRA_ACCT_p return varchar2 is
	Begin
	 return PARAM_CONTRA_ACCT;
	 END;
 Function PARAM_LEDGER_NAME_p return varchar2 is
	Begin
	 return PARAM_LEDGER_NAME;
	 END;
 Function PARAM_START_DOC_SEQ_VALUE_p return number is
	Begin
	 return PARAM_START_DOC_SEQ_VALUE;
	 END;
 Function PARAM_END_DOC_SEQ_VALUE_p return number is
	Begin
	 return PARAM_END_DOC_SEQ_VALUE;
	 END;
 Function H_SET_OF_BOOKS_ID_p return number is
	Begin
	 return H_SET_OF_BOOKS_ID;
	 END;
 Function BAL_SEG_NAME_DSP_p return varchar2 is
	Begin
	 return BAL_SEG_NAME_DSP;
	 END;
 Function ACCT_SEG_NAME_DSP_p return varchar2 is
	Begin
	 return ACCT_SEG_NAME_DSP;
	 END;
 Function SELECT_COST_CTR_SEGMENT_p return varchar2 is
	Begin
	 return SELECT_COST_CTR_SEGMENT;
	 END;
 Function H_START_DATE_p return date is
	Begin
	 return H_START_DATE;
	 END;
 Function H_END_DATE_p return date is
	Begin
	 return H_END_DATE;
	 END;
 Function PREV_BAL_SEG_VAL_p return varchar2 is
	Begin
	 return PREV_BAL_SEG_VAL;
	 END;
 Function P_LEDGER_WHERE_p return varchar2 is
	Begin
	 return P_LEDGER_WHERE;
	 END;
 Function P_LEDGER_FROM_p return varchar2 is
	Begin
	 return P_LEDGER_FROM;
	 END;
 Function PREV_ACCT_SEG_VAL_p return varchar2 is
	Begin
	 return PREV_ACCT_SEG_VAL;
	 END;
 Function PREV_SEC_SEG_VAL_p return varchar2 is
	Begin
	 return PREV_SEC_SEG_VAL;
	 END;
 Function PREV_LED_ID_p return number is
	Begin
	 return PREV_LED_ID;
	 END;
 Function PREV_LINE_BAL_p return number is
	Begin
	 return PREV_LINE_BAL;
	 END;
 Function PREV_GL_BAL_p return number is
	Begin
	 return PREV_GL_BAL;
	 END;
 Function P_AFF_WHERE_p return varchar2 is
	Begin
	 return P_AFF_WHERE;
	 END;
 Function P_AMOUNT_WHERE_p return varchar2 is
	Begin
	 return P_AMOUNT_WHERE;
	 END;
 Function P_AFF_WHERE_JRL_p return varchar2 is
	Begin
	 return P_AFF_WHERE_JRL;
	 END;
 Function P_ACC_SEGMENT_SELECT_p return varchar2 is
	Begin
	 return P_ACC_SEGMENT_SELECT;
	 END;
 Function P_JOURNAL_UPD_DATE_WHERE_p return varchar2 is
	Begin
	 return P_JOURNAL_UPD_DATE_WHERE;
	 END;
 Function H_START_UPDATE_DATE_p return date is
	Begin
	 return H_START_UPDATE_DATE;
	 END;
 Function H_END_UPDATE_DATE_p return date is
	Begin
	 return H_END_UPDATE_DATE;
	 END;
 Function P_JOURNAL_LAST_UPD_WHERE_p return varchar2 is
	Begin
	 return P_JOURNAL_LAST_UPD_WHERE;
	 END;
 Function P_JOURNAL_DATE_WHERE_3_p return varchar2 is
	Begin
	 return P_JOURNAL_DATE_WHERE_3;
	 END;
 Function P_HINT_CLAUSE_p return varchar2 is
	Begin
	 return P_HINT_CLAUSE;
	 END;
 Function P_PERF_FROM_p return varchar2 is
	Begin
	 return P_PERF_FROM;
	 END;
 Function P_ACTUAL_TYPE_WHERE_p return varchar2 is
	Begin
	 return P_ACTUAL_TYPE_WHERE;
	 END;
END GL_GLWACCTR_XMLP_PKG ;


/
