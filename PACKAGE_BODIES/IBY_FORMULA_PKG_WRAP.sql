--------------------------------------------------------
--  DDL for Package Body IBY_FORMULA_PKG_WRAP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."IBY_FORMULA_PKG_WRAP" AS
/*$Header: ibywforb.pls 115.10 2002/11/19 00:25:52 jleybovi ship $*/

/*
** Wrapper Package generated by rosette for iby_formula_pkg.
*/

  /*
  ** Name getPayeeFormulas
  ** Purpose: Calls the actual getPayeeFormulas method in iby_formula_pkg.
  **          This procedure is a wrapper generated by Rosette
  **          to the actual procedure in iby_formula_pkg for Java
  **          programs to be able to call it.
  */
  procedure getpayeeformulas(i_payeeid  varchar2,
    o_riskformula_id out nocopy JTF_NUMBER_TABLE,
    o_riskformula_name out nocopy JTF_VARCHAR2_TABLE_100,
    o_riskformula_description out nocopy JTF_VARCHAR2_TABLE_300,
    o_riskformula_flag out nocopy JTF_NUMBER_TABLE)

  is
    ddo_riskformula iby_formula_pkg.formula_table;
    ddindx binary_integer; indx binary_integer;
  begin

    -- copy data to the local IN or IN-OUT args, if any


    -- here's the delegated call to the old PL/SQL routine
    iby_formula_pkg.getpayeeformulas(i_payeeid,
      ddo_riskformula);

    -- copy data back from the local OUT or IN-OUT args, if any

    if ddo_riskformula is null or ddo_riskformula.count = 0 then
      o_riskformula_id := JTF_NUMBER_TABLE();
      o_riskformula_name := JTF_VARCHAR2_TABLE_100();
      o_riskformula_description := JTF_VARCHAR2_TABLE_300();
      o_riskformula_flag := JTF_NUMBER_TABLE();
    else
        o_riskformula_id := JTF_NUMBER_TABLE();
        o_riskformula_name := JTF_VARCHAR2_TABLE_100();
        o_riskformula_description := JTF_VARCHAR2_TABLE_300();
        o_riskformula_flag := JTF_NUMBER_TABLE();
    -- if ddo_riskformula is not null or ddo_riskformula.count > 0 then
       if ddo_riskformula.count > 0 then
          o_riskformula_id.extend(ddo_riskformula.count);
          o_riskformula_name.extend(ddo_riskformula.count);
          o_riskformula_description.extend(ddo_riskformula.count);
          o_riskformula_flag.extend(ddo_riskformula.count);
          ddindx := ddo_riskformula.first;
          indx := 1;
          while true loop
            o_riskformula_id(indx) := ddo_riskformula(ddindx).id;
            o_riskformula_name(indx) := ddo_riskformula(ddindx).name;
            o_riskformula_description(indx) := ddo_riskformula(ddindx).description;
            o_riskformula_flag(indx) := ddo_riskformula(ddindx).flag;
            indx := indx+1;
            if ddo_riskformula.last =ddindx
              then exit;
            end if;
            ddindx := ddo_riskformula.next(ddindx);
          end loop;
        end if;
     end if;
  end getpayeeformulas;

  /*
  ** Name createFormula
  ** Purpose: Calls the actual createFormula method in iby_formula_pkg.
  **          This procedure is a wrapper generated by Rosette
  **          to the actual procedure in iby_formula_pkg for Java
  **          programs to be able to call it.
  */
  procedure createformula(i_payeeid varchar2, i_name  varchar2,
    i_description  varchar2,
    i_flag integer,
    i_count integer,
    i_factors_name JTF_VARCHAR2_TABLE_100,
    i_factors_weight JTF_NUMBER_TABLE,
    o_id out nocopy number)

  is
    ddi_factors iby_formula_pkg.factor_table;
    ddindx binary_integer; indx binary_integer;
  begin

    -- copy data to the local IN or IN-OUT args, if any


    if i_factors_name is not null and i_factors_name.count > 0 then
        if i_factors_name.count > 0 then
          indx := i_factors_name.first;
          ddindx := 1;
          while true loop
            ddi_factors(ddindx).name := i_factors_name(indx);
            ddi_factors(ddindx).weight := i_factors_weight(indx);
            ddindx := ddindx+1;
            if i_factors_name.last =indx
              then exit;
            end if;
            indx := i_factors_name.next(indx);
          end loop;
        end if;
     end if;


    -- here's the delegated call to the old PL/SQL routine
    iby_formula_pkg.createformula(i_payeeid, i_name,
      i_description,
      i_flag,
      i_count,
      ddi_factors,
      o_id);

    -- copy data back from the local OUT or IN-OUT args, if any

  end createformula;

  /*
  ** Name modifyFormula
  ** Purpose: Calls the actual modifyFormula method in iby_formula_pkg.
  **          This procedure is a wrapper generated by Rosette
  **          to the actual procedure in iby_formula_pkg for Java
  **          programs to be able to call it.
  */
  procedure modifyformula(i_id  number,
    i_name  varchar2,
    i_description  varchar2,
    i_flag integer,
    i_count integer,
    i_factors_name JTF_VARCHAR2_TABLE_100,
    i_factors_weight JTF_NUMBER_TABLE)

  is
    ddi_factors iby_formula_pkg.factor_table;
    ddindx binary_integer; indx binary_integer;
  begin

    -- copy data to the local IN or IN-OUT args, if any



    if i_factors_name is not null and i_factors_name.count > 0 then
        if i_factors_name.count > 0 then
          indx := i_factors_name.first;
          ddindx := 1;
          while true loop
            ddi_factors(ddindx).name := i_factors_name(indx);
            ddi_factors(ddindx).weight := i_factors_weight(indx);
            ddindx := ddindx+1;
            if i_factors_name.last =indx
              then exit;
            end if;
            indx := i_factors_name.next(indx);
          end loop;
        end if;
     end if;

    -- here's the delegated call to the old PL/SQL routine
    iby_formula_pkg.modifyformula(i_id,
      i_name,
      i_description,
      i_flag,
      i_count,
      ddi_factors);

    -- copy data back from the local OUT or IN-OUT args, if any

  end modifyformula;

  /*
  ** Name loadFormula
  ** Purpose: Calls the actual loadFormula method in iby_formula_pkg.
  **          This procedure is a wrapper generated by Rosette
  **          to the actual procedure in iby_formula_pkg for Java
  **          programs to be able to call it.
  */
  procedure loadformula(i_factorid  number,
    o_name out nocopy varchar2,
    o_description out nocopy varchar2,
    o_flag out nocopy integer,
    o_factors_name out nocopy JTF_VARCHAR2_TABLE_100,
    o_factors_weight out nocopy JTF_NUMBER_TABLE)

  is
    ddo_factors iby_formula_pkg.factor_table;
    ddindx binary_integer; indx binary_integer;
  begin

    -- copy data to the local IN or IN-OUT args, if any


    -- here's the delegated call to the old PL/SQL routine
    iby_formula_pkg.loadformula(i_factorid,
      o_name, o_description, o_flag, ddo_factors);

    -- copy data back from the local OUT or IN-OUT args, if any

    if ddo_factors is null or ddo_factors.count = 0 then
      o_factors_name := JTF_VARCHAR2_TABLE_100();
      o_factors_weight := JTF_NUMBER_TABLE();
    else
        o_factors_name := JTF_VARCHAR2_TABLE_100();
        o_factors_weight := JTF_NUMBER_TABLE();
    -- if ddo_factors is not null or ddo_factors.count > 0 then
        if ddo_factors.count > 0 then
          o_factors_name.extend(ddo_factors.count);
          o_factors_weight.extend(ddo_factors.count);
          ddindx := ddo_factors.first;
          indx := 1;
          while true loop
            o_factors_name(indx) := ddo_factors(ddindx).name;
            o_factors_weight(indx) := ddo_factors(ddindx).weight;
            indx := indx+1;
            if ddo_factors.last =ddindx
              then exit;
            end if;
            ddindx := ddo_factors.next(ddindx);
          end loop;
        end if;
     end if;
  end loadformula;

end iby_formula_pkg_wrap;


/
