--------------------------------------------------------
--  DDL for Package Body PER_BG_NUMBERING_METHOD_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."PER_BG_NUMBERING_METHOD_PKG" AS
/* $Header: pebgnuma.pkb 115.9 2004/03/01 09:18:43 irgonzal noship $ */
--
-- Package Variables
--
   g_X_EMPprofileset       boolean;
   g_X_APLprofileset       boolean;
   g_X_CWKprofileset       boolean;
--
   g_debug                 boolean      := hr_utility.debug_enabled;
   g_pkg_name              varchar2(30) := 'per_bg_numbering_method_pkg';
   g_max_person_number     number       := 999999999999999999999999999999;
   g_max_global_person_num number       := 999999999999999999999999999;
   --
   -- Enh 2931775
   g_emp_sequence_name   varchar2(30) := 'PER_GLOBAL_EMP_NUM_S';
   g_apl_sequence_name   varchar2(30) := 'PER_GLOBAL_APL_NUM_S';
   g_cwk_sequence_name   varchar2(30) := 'PER_GLOBAL_CWK_NUM_S';
   --
   g_xbg_EMPNum_profile  varchar2(30) := 'PER_GLOBAL_EMP_NUM';
   g_xbg_APLNum_profile  varchar2(30) := 'PER_GLOBAL_APL_NUM';
   g_xbg_CWKNum_profile  varchar2(30) := 'PER_GLOBAL_CWK_NUM';
   --
   g_bg_context_name     varchar2(30) := 'Business Group Information';
   g_automatic_method    varchar2(1)  := 'A';
--
   g_EMP_Num_FF_cached    boolean := FALSE;
   g_EMP_Num_FF_ID_cache  ff_formulas_f.formula_name%TYPE := null;
   --
   g_APL_Num_FF_cached    boolean := FALSE;
   g_APL_Num_FF_ID_cache  ff_formulas_f.formula_name%TYPE := null;
   --
   g_CWK_Num_FF_cached    boolean := FALSE;
   g_CWK_Num_FF_ID_cache  ff_formulas_f.formula_name%TYPE := null;

--
-- ---------------------------------------------------------------------------+
-- Local Procedures
-- ---------------------------------------------------------------------------+
-- Write_Log: writes messages to the LOG file generated by Concurrent Mg.
-- ---------------------------------------------------------------------------+
PROCEDURE Write_Log
         ( p_message varchar2 ) IS
--
   c_proc_name varchar2(100) := g_pkg_name||'.write_log';
BEGIN
   FND_FILE.PUT_LINE(FND_FILE.LOG,p_message);

EXCEPTION
      WHEN OTHERS THEN
         --
         -- Exception raised whilst writing the log file...
         --
         hr_utility.set_location(c_proc_name,1000);
         FND_FILE.PUT_LINE(FND_FILE.LOG,SQLERRM);
         RAISE;
END Write_Log;
-- ---------------------------------------------------------------------------+
-- ---------------------------------------------------------------------------+
-- Get_Max_applicant_number: - Applicants -
--  Returns the maximum numeric value being used in a business group.
-- ---------------------------------------------------------------------------+
FUNCTION get_max_applicant_number
             (p_business_group_id IN per_all_people.business_group_id%TYPE)
    RETURN NUMBER IS
  --
  TYPE l_applicant_number_type IS TABLE OF per_all_people_f.applicant_number%TYPE
       INDEX BY BINARY_INTEGER;
  --
  l_applicant_number_tab l_applicant_number_type;
  l_max_applicant_number NUMBER := 0;
  --
  cursor csr_applicants is
        select applicant_number
        from   per_all_people_f
        where  business_group_id = p_business_group_id
        and    applicant_number is not null;
  --
BEGIN
  OPEN csr_applicants;
  LOOP
    -- bulk collect 500 rows at a time
    FETCH csr_applicants BULK COLLECT INTO l_applicant_number_tab LIMIT 500;
    -- loop through each element
    FOR i IN l_applicant_number_tab.FIRST..l_applicant_number_tab.LAST LOOP
      BEGIN
        -- perform a number conversion and then max comparison
        -- if this fails because the applicant_number contains alpha chars
        -- then the VALUE_ERROR exception will be raised and handled
        IF TO_NUMBER(l_applicant_number_tab(i)) > l_max_applicant_number THEN
          -- conversion succeeded, store new max number
          l_max_applicant_number := TO_NUMBER(l_applicant_number_tab(i));
        END IF;
      EXCEPTION
        WHEN VALUE_ERROR THEN
          -- conversion error, applicant number must contain an alpha char so ignore
          NULL;
      END;
    END LOOP;
    EXIT WHEN csr_applicants%NOTFOUND;
  END LOOP;
  CLOSE csr_applicants;
  RETURN(l_max_applicant_number);
EXCEPTION
  WHEN OTHERS THEN
    -- this exception is most probably raised from a VALUE_ERROR when
    -- l_applicant_number_tab.FIRST fails due to a fetch returning no
    -- rows.
    -- close the cursor if its open
    IF csr_applicants%ISOPEN THEN
      CLOSE csr_applicants;
    END IF;
    RETURN(l_max_applicant_number);
END get_max_applicant_number;
-- ---------------------------------------------------------------------------+
-- ---------------------------------------------------------------------------+
-- Get_Max_employee_number: - Employees -
--  Returns the maximum numeric value being used in a business group.
-- ---------------------------------------------------------------------------+
--
FUNCTION get_max_employee_number
     (p_business_group_id IN per_all_people.business_group_id%TYPE)
    RETURN NUMBER IS
  --
  TYPE l_employee_number_type IS TABLE OF per_all_people_f.employee_number%TYPE
       INDEX BY BINARY_INTEGER;
  --
  l_employee_number_tab l_employee_number_type;
  l_max_employee_number NUMBER := 0;
  --
  cursor csr_employees is
        select employee_number
        from   per_all_people_f
        where  business_group_id = p_business_group_id
        and    employee_number is not null;
  --
BEGIN
  OPEN csr_employees;
  LOOP
    -- bulk collect 500 rows at a time
    FETCH csr_employees BULK COLLECT INTO l_employee_number_tab LIMIT 500;
    -- loop through each element
    FOR i IN l_employee_number_tab.FIRST..l_employee_number_tab.LAST LOOP
      BEGIN
        -- perform a number conversion and then max comparison
        -- if this fails because the employee_number contains alpha chars
        -- then the VALUE_ERROR exception will be raised and handled
        --
        IF TO_NUMBER(l_employee_number_tab(i)) > l_max_employee_number THEN
          -- conversion succeeded, store new max number
          l_max_employee_number := TO_NUMBER(l_employee_number_tab(i));
        END IF;
      EXCEPTION
        WHEN VALUE_ERROR THEN
          -- conversion error, employee number must contain an alpha char so ignore
          NULL;
      END;
    END LOOP;
    EXIT WHEN csr_employees%NOTFOUND;
  END LOOP;
  CLOSE csr_employees;
  RETURN(l_max_employee_number);
EXCEPTION
  WHEN OTHERS THEN
    -- this exception is most probably raised from a VALUE_ERROR when
    -- l_employee_number_tab.FIRST fails due to a fetch returning no
    -- rows.
    -- close the cursor if its open
    IF csr_employees%ISOPEN THEN
      CLOSE csr_employees;
    END IF;
    RETURN(l_max_employee_number);
END get_max_employee_number;
-- ---------------------------------------------------------------------------+
-- ---------------------------------------------------------------------------+
-- Get_Max_CWK_number: - Contingent Workers -
--  Returns the maximum numeric value being used in a business group.
-- ---------------------------------------------------------------------------+
--
FUNCTION get_max_cwk_number
     (p_business_group_id IN per_all_people.business_group_id%TYPE)
    RETURN NUMBER IS
  --
  TYPE l_cwk_number_type IS TABLE OF per_all_people_f.npw_number%TYPE
       INDEX BY BINARY_INTEGER;
  --
  l_cwk_number_tab l_cwk_number_type;
  l_max_cwk_number NUMBER := 0;
  --
  cursor csr_cwk is
        select npw_number
        from   per_all_people_f
        where  business_group_id = p_business_group_id
        and    npw_number is not null;
  --
BEGIN
  OPEN csr_cwk;
  LOOP
    -- bulk collect 500 rows at a time
    FETCH csr_cwk BULK COLLECT INTO l_cwk_number_tab LIMIT 500;
    -- loop through each element
    FOR i IN l_cwk_number_tab.FIRST..l_cwk_number_tab.LAST LOOP
      BEGIN
        -- perform a number conversion and then max comparison
        -- if this fails because the npw_number contains alpha chars
        -- then the VALUE_ERROR exception will be raised and handled
        --
        IF TO_NUMBER(l_cwk_number_tab(i)) > l_max_cwk_number THEN
          -- conversion succeeded, store new max number
          l_max_cwk_number := TO_NUMBER(l_cwk_number_tab(i));
        END IF;
      EXCEPTION
        WHEN VALUE_ERROR THEN
          -- conversion error, cwk number must contain an alpha char so ignore
          NULL;
      END;
    END LOOP;
    EXIT WHEN csr_cwk%NOTFOUND;
  END LOOP;
  CLOSE csr_cwk;
  RETURN(l_max_cwk_number);
EXCEPTION
  WHEN OTHERS THEN
    -- this exception is most probably raised from a VALUE_ERROR when
    -- l_employee_number_tab.FIRST fails due to a fetch returning no
    -- rows.
    -- close the cursor if its open
    IF csr_cwk%ISOPEN THEN
      CLOSE csr_cwk;
    END IF;
    RETURN(l_max_cwk_number);
END get_max_cwk_number;
-- ---------------------------------------------------------------------------+
-- ---------------------------------------------------------------------------+
PROCEDURE convert_to_auto_gen_method
    (errbuf              OUT nocopy varchar2
    ,retcode             OUT nocopy number
    ,p_business_group_id IN  number
    ,p_person_type       IN  varchar2
    ) IS
--
--  Local variables
--
   c_proc_name         varchar2(100) := g_pkg_name||'.convert_to_auto_gen_method';

   e_ResourceBusy      EXCEPTION;
      PRAGMA EXCEPTION_INIT(e_ResourceBusy, -54);

   TYPE t_bgRecord IS RECORD
    (
      org_id            HR_ORGANIZATION_INFORMATION.Organization_id%TYPE,
      emp_method        HR_ORGANIZATION_INFORMATION.Org_information2%TYPE,
      apl_method        HR_ORGANIZATION_INFORMATION.Org_information3%TYPE,
      cwk_method        HR_ORGANIZATION_INFORMATION.Org_information16%TYPE
    );

   l_max_num_found     number        := 0;
   l_message           varchar2(200) := null;
   l_rows_updated      number;
   l_continue_flag     boolean := FALSE;
   l_use_sequence      boolean := FALSE;


   l_organization_id   per_all_people_f.business_group_id%TYPE;
   l_rec_per_bg_groups t_bgRecord;
--
-- Returns the current method of number generation
--
   cursor csr_method(cp_bg_id per_all_people.business_group_id%TYPE) is
      SELECT organization_id, Org_information2, Org_information3, Org_information16
        from  hr_organization_information
       where organization_id = cp_bg_id
         and ORG_INFORMATION_CONTEXT  = g_bg_context_name
      FOR UPDATE of Org_information3          -- method_of_generation_apl_num
                  , Org_information2          -- method_of_generation_emp_num
                  , Org_information16 NOWAIT; -- method_of_generation_cwk_num
--
-- Returns next value stored per person type
--
   cursor csr_next_value(cp_bg_id per_all_people.business_group_id%TYPE
                 ,cp_person_type  per_person_types.system_person_type%TYPE) is
      SELECT business_group_id
        from per_number_generation_controls
       where business_group_id   = cp_bg_id
         and type = cp_person_type
      FOR UPDATE of next_value NOWAIT;
--
--
BEGIN
   --hr_utility.trace_on(null,'oracle');

   hr_utility.set_location('Entering: '||c_proc_name,1);
   hr_utility.trace('Parameters:');
   hr_utility.trace('  business_group_id = '||to_char(p_business_group_id));
   hr_utility.trace('  person type       = '||p_person_type);

   --
   BEGIN
       -- Lock per_all_people_f to ensure person records are not created/updated/deleted
       --
       hr_utility.set_location(c_proc_name,2);
       l_rows_updated    := 0;
       l_organization_id := p_business_group_id;
       l_use_sequence    := Global_person_numbering(p_person_type);

       LOCK TABLE per_all_people_f
        IN EXCLUSIVE MODE NOWAIT;
       --
       open csr_method(p_business_group_id);
       fetch csr_method into l_rec_per_bg_groups;

       if csr_method%FOUND then

          hr_utility.set_location(c_proc_name,5);
          if l_use_sequence then
             l_continue_flag := TRUE;
             hr_utility.set_location(c_proc_name,7);
          else
             open csr_next_value(p_business_group_id, p_person_type);
             fetch csr_next_value into l_organization_id;
             l_continue_flag := csr_next_value%FOUND;
          end if;

          if l_continue_flag then

             hr_utility.set_location(c_proc_name,10);
             -- -------------------------------------------------------------+
             --                     Processing Applicants                    +
             -- -------------------------------------------------------------+
             if p_person_type = 'APL' then

               hr_utility.set_location(c_proc_name,12);
               l_max_num_found := get_max_applicant_number(p_business_group_id);

               UPDATE HR_ORGANIZATION_INFORMATION
                  SET Org_information3 = g_automatic_method  -- method_of_generation_apl_num
                WHERE organization_id = l_organization_id
                  AND ORG_INFORMATION_CONTEXT  = g_bg_context_name;

               hr_utility.set_location(c_proc_name,14);
               l_rows_updated := SQL%ROWCOUNT;

             -- -------------------------------------------------------------+
             --                     Processing Employees                     +
             -- -------------------------------------------------------------+
             elsif p_person_type = 'EMP' then

               hr_utility.set_location(c_proc_name,16);
               -- needs to check whether CWK method = 'Based on Employee'
               -- if yes, then need to greatest(empno, cwkno)
               --
               if l_rec_per_bg_groups.cwk_method = 'E' then
                  hr_utility.set_location(c_proc_name,17);

                  l_max_num_found := greatest(get_max_employee_number(p_business_group_id)
                                             ,get_max_cwk_number(p_business_group_id));
               else
                  l_max_num_found := get_max_employee_number(p_business_group_id);
               end if;

               UPDATE HR_ORGANIZATION_INFORMATION
                  SET Org_information2 = g_automatic_method  -- method_of_generation_emp_num
                WHERE organization_id = l_organization_id
                  AND ORG_INFORMATION_CONTEXT  = g_bg_context_name;

               hr_utility.set_location(c_proc_name,18);
               l_rows_updated := SQL%ROWCOUNT;
             -- -------------------------------------------------------------+
             --           Processing Contingent Workers                      +
             -- -------------------------------------------------------------+
             elsif p_person_type = 'CWK' then

               hr_utility.set_location(c_proc_name,20);
               -- needs to check whether CWK method = 'Based on Employee'
               -- if yes, then need to greatest(empno, cwkno)
               --
               if l_rec_per_bg_groups.cwk_method = 'E' then
                  hr_utility.set_location(c_proc_name,21);

                  l_max_num_found := greatest(get_max_employee_number(p_business_group_id)
                                             ,get_max_cwk_number(p_business_group_id));
               else
                  l_max_num_found := get_max_cwk_number(p_business_group_id);
               end if;

               UPDATE HR_ORGANIZATION_INFORMATION
                  SET Org_information16 = g_automatic_method  -- method_of_generation_cwk_num
                WHERE organization_id = l_organization_id
                  AND ORG_INFORMATION_CONTEXT  = g_bg_context_name;

               hr_utility.set_location(c_proc_name,22);
               l_rows_updated := SQL%ROWCOUNT;
             end if;
             -- -------------------------------------------------------------+
             --                   Update NEXT VALUE                          +
             -- -------------------------------------------------------------+
             if (l_max_num_found + 1 > g_max_person_number)
                or (l_use_sequence and l_max_num_found > g_max_global_person_num)
             then

                hr_utility.set_message(800,'PER_289925_MAX_VALUE');
                hr_utility.raise_error;
             else
                if l_rows_updated > 0 and l_max_num_found is not null then
                    hr_utility.set_location(c_proc_name,24);

                    if l_use_sequence then
                       -- alter sequence
                       hr_utility.set_location(c_proc_name,25);
                       set_global_sequence(p_person_type,l_max_num_found);
                    else
                       hr_utility.set_location(c_proc_name,26);
                       UPDATE per_number_generation_controls
                          SET next_value = l_max_num_found + 1
                       WHERE business_group_id = l_organization_id
                         and type = p_person_type;
                       if csr_next_value%ISOPEN then
                          close csr_next_value;
                       end if;
                    end if;
                end if;
             end if;

             hr_utility.set_location(c_proc_name,27);

          end if; -- continue flag?

       end if; -- csr_method cursor
       --
       hr_utility.set_location(c_proc_name,28);
       hr_utility.trace(' MAX value found = '||to_char(l_max_num_found));
       --
       close csr_method;
   EXCEPTION
      when TIMEOUT_ON_RESOURCE OR e_ResourceBusy then
         hr_utility.set_location(c_proc_name,29);
         -- The required resources are used by some other process.

         hr_utility.set_message(800,'PER_289849_RESOURCE_BUSY');
         hr_utility.raise_error;

   END; -- Lock table
   hr_utility.set_location('Leaving: '||c_proc_name,35);
   --hr_utility.trace_off;

END convert_to_auto_gen_method;
-- -------------------------------------------------------------------------- +
-- -------------------------------------------------------------------------- +
-- SET_GLOBAL_SEQUENCE:                                                       |
-- Alters the global sequence for a specific person type based on last        |
-- number parameter.                                                          |
-- -------------------------------------------------------------------------- +
PROCEDURE SET_GLOBAL_SEQUENCE(p_person_type IN varchar2
                             ,p_last_number IN NUMBER)
   IS
   PRAGMA AUTONOMOUS_TRANSACTION;
   -- this is required since DDL commands execute implicit commits
   -- if for some reason, this procedure fails the calling procedure
   -- should be rolled back.
   --
   l_max_number      number;
   c_proc_name       varchar2(100) := g_pkg_name||'.set_global_sequence';
   l_seq_owner       varchar2(30);
   l_seq_name        varchar2(30);
   l_seq_increment   number;
   l_string          varchar2(1000);
   l_PrevSettings    varchar2(1000);
   l_mynextval       number;
   l_currval         number;
   l_seq_last        number;
   l_cache_size      number;
   l_min_value       number;
   l_max_value       number;
   l_cycleflag       varchar2(1);
   l_cache_arg       varchar2(100);
   l_alterflag       number := 0;
  -- 3385104 start
   l_status    varchar2(50);
   l_industry  varchar2(50);
   l_owner     varchar2(50);
   l_ret       boolean := FND_INSTALLATION.GET_APP_INFO ('PER', l_status,
                                                      l_industry, l_owner);
  --3385104 end
   --
   cursor csr_seq_details(cp_seq_name varchar2) IS
        SELECT sequence_owner, last_number, cache_size,
             min_value, max_value, cycle_flag
        FROM all_sequences
        WHERE sequence_name = cp_seq_name
          and sequence_owner = l_owner;
 -- added owner condition for fix of bug 3385104
--
BEGIN -- main set_global_sequence
   if g_debug then
      hr_utility.trace('Entering :'||c_proc_name);
   end if;
   -- -------------------------------------------+
   -- get the sequence name based on person type |
   -- -------------------------------------------+
   if p_person_type = 'EMP' then
      l_seq_name := g_emp_sequence_name;
   elsif p_person_type = 'APL' then
      l_seq_name := g_apl_sequence_name;
   elsif p_person_type = 'CWK' then
      l_seq_name := g_cwk_sequence_name;
   end if;
   -- ---------------------------------------+
   -- get current sequence details           |
   -- ---------------------------------------+
   open csr_seq_details(l_seq_name);
   fetch csr_seq_details into l_seq_owner, l_seq_last, l_cache_size
                            , l_min_value, l_max_value, l_cycleflag;
   close csr_seq_details;
   -- ----------------------------------------+
   -- set details regarding original settings |
   -- ----------------------------------------+
   IF (l_cache_size = 0) THEN
      l_cache_arg := ' ';
   ELSE
      l_cache_arg := ' CACHE ' || l_cache_size;
   END IF;
   --
   --
   l_PrevSettings := 'ALTER SEQUENCE ' || l_seq_owner || '.' || l_seq_name
                    || ' INCREMENT BY 1 ' ||
                    l_cache_arg || ' MAXVALUE ' || to_char(l_max_value)
                    || ' MINVALUE ' || to_char(l_min_value);
   -- -----------------------------------------------------------+
   -- get current value from sequence to calculate the increment |
   -- -----------------------------------------------------------+
   l_mynextval := 0;
   l_currval   := 0;
   l_string := 'SELECT ' || l_seq_owner || '.' || l_seq_name ||
              '.NEXTVAL FROM sys.dual';

   EXECUTE IMMEDIATE l_string INTO l_mynextval;

   l_mynextval := l_mynextval - 1;
   l_currval   := l_mynextval;     -- store this value in case of a rollback
   --
   if g_debug then
      hr_utility.trace('Current Value = '||to_char(l_mynextval));
   end if;
   -- ---------------------------------------+
   -- calculate the increment                |
   -- ---------------------------------------+
   if l_mynextval < p_last_number then
       l_alterflag := l_alterflag + 1;

       l_seq_increment := p_last_number - l_mynextval -1;
       --
       if g_debug then
          hr_utility.trace('Altering sequence increment to ' || l_seq_increment);
       end if;
       --
       l_string := 'ALTER SEQUENCE ' || l_seq_owner || '.' || l_seq_name
                   || ' INCREMENT BY ' ||
                   l_seq_increment ||
                   ' NOCACHE NOMAXVALUE';

       EXECUTE IMMEDIATE l_string;
       -- -----------------------------------------------------+
       -- force the update of the sequence into the new range  |
       -- -----------------------------------------------------+
       if g_debug then
          hr_utility.trace('Forcing sequence increment');
       end if;
       --
       l_string := 'SELECT ' || l_seq_owner || '.' || l_seq_name ||
                  '.nextval FROM sys.dual';

       EXECUTE IMMEDIATE l_string INTO l_mynextval;
       l_alterflag := l_alterflag + 1;
       -- ---------------------------------------+
       -- return sequence to previous settings   |
       -- ---------------------------------------+
       if g_debug then
          hr_utility.trace('Reseting sequence increment');
       end if;

       EXECUTE IMMEDIATE l_PrevSettings;
       l_alterflag := l_alterflag + 1;
       --
   end if; -- l_mynextval < p_last_number
   if g_debug then
      hr_utility.trace('Leaving : '||c_proc_name);
   end if;
EXCEPTION
   when others then
   --
   -- Rollback sequence changes
   --
   if l_alterflag > 1 and l_mynextval > 0 and l_currval > 0 then
       l_seq_increment := l_currval - l_mynextval;
       l_string := 'ALTER SEQUENCE ' || l_seq_owner || '.' || l_seq_name
                   || ' INCREMENT BY ' ||
                   l_seq_increment || ' NOCACHE ';

       EXECUTE IMMEDIATE l_string;
       --
       l_string := 'SELECT ' || l_seq_owner || '.' || l_seq_name ||
                  '.nextval FROM sys.dual';

       EXECUTE IMMEDIATE l_string INTO l_mynextval;
       -- return to previous settings
       EXECUTE IMMEDIATE l_PrevSettings;
       if g_debug then
          hr_utility.trace('Leaving: sequence rollback done =>'||c_proc_name);
       end if;
   end if;
   --
   --
   RAISE;
END SET_GLOBAL_SEQUENCE;
-- -------------------------------------------------------------------------- +
-- -------------------------------------------------------------------------- +
-- CONVERT_TO_GLOBAL_SEQUENCE: - this is run as a Conc. Request -             |
-- Enables the global sequence for a specific person type.                    |
-- This sequence will be use to generate person numbers and will be shared    |
-- among all business groups.                                                 |
-- -------------------------------------------------------------------------- +
PROCEDURE convert_to_global_sequence
    (errbuf              OUT nocopy varchar2
    ,retcode             OUT nocopy number
    ,p_person_type       IN  varchar2
    ) IS

   l_max_number      number;
   c_proc_name       varchar2(100) := g_pkg_name||'.convert_to_global_sequence';
   --
   l_message         varchar2(2000);
   l_success         boolean := FALSE;
   l_session_date    date;
   --
   e_ResourceBusy      EXCEPTION;
      PRAGMA EXCEPTION_INIT(e_ResourceBusy, -54);
   e_ProfileUpdFailed  EXCEPTION;
   e_SeqError          EXCEPTION;
   --
   cursor csr_max_emp_num(cp_person_type varchar2) is
       select max(next_value)
        from per_number_generation_controls png
            ,hr_organization_information    hoi
        where png.business_group_id = hoi.organization_id
          and hoi.ORG_INFORMATION_CONTEXT  = g_bg_context_name
          and hoi.Org_information2 = g_automatic_method
          and png.type = cp_person_type;

   cursor csr_max_apl_num(cp_person_type varchar2) is
       select max(next_value)
        from per_number_generation_controls png
            ,hr_organization_information    hoi
        where png.business_group_id = hoi.organization_id
          and hoi.ORG_INFORMATION_CONTEXT  = g_bg_context_name
          and hoi.Org_information3 = g_automatic_method
          and png.type = cp_person_type;

   cursor csr_max_cwk_num(cp_person_type varchar2) is
       select max(next_value)
        from per_number_generation_controls png
            ,hr_organization_information    hoi
        where png.business_group_id = hoi.organization_id
          and hoi.ORG_INFORMATION_CONTEXT  = g_bg_context_name
          and hoi.Org_information16 = g_automatic_method
          and png.type = cp_person_type;
   --
BEGIN
   l_session_date := HR_GENERAL.Effective_Date;

   if Global_person_numbering(p_person_type) then
      --
      --  profile option is already set
      --
      hr_utility.set_message(800,'PER_289182_GLOBALNUM_SET');
      l_message := fnd_message.get();

      Write_Log(l_message);
      retcode := 1;  -- raise warning
   else
       l_max_number := 1;
       if g_debug then
          hr_utility.set_location('Entering: '||c_proc_name,1);
       end if;
       -- Lock per_all_people_f to ensure person records are not created/updated/deleted
       --
       LOCK TABLE per_all_people_f
        IN EXCLUSIVE MODE NOWAIT;
       --
       -- altering profile option
       --
       if p_person_type = 'EMP' then
          if not fnd_profile.save(g_xbg_EMPNum_profile,'Y','SITE') then
             RAISE e_ProfileUpdFailed;
          end if;
          open csr_max_emp_num(p_person_type);
          fetch csr_max_emp_num into l_max_number;
          close csr_max_emp_num;

       elsif p_person_type = 'APL' then
          if not fnd_profile.save(g_xbg_APLNum_profile,'Y','SITE') then
             RAISE e_ProfileUpdFailed;
          end if;
          open csr_max_apl_num(p_person_type);
          fetch csr_max_apl_num into l_max_number;
          close csr_max_apl_num;

       elsif p_person_type = 'CWK' then
          if not fnd_profile.save(g_xbg_CWKNum_profile,'Y','SITE') then
             RAISE e_ProfileUpdFailed;
          end if;
          open csr_max_cwk_num(p_person_type);
          fetch csr_max_cwk_num into l_max_number;
          close csr_max_cwk_num;

       end if; -- person types
       --
       -- ------------------------------------------------------------------- +
       --                     Alter the sequence                              |
       -- ------------------------------------------------------------------- +
       -- Sequence is altered based on next_value.
       ---
       Set_Global_Sequence(p_person_type, l_max_number);
      --
      if Get_PersonNumber_Formula(p_person_type,l_session_date) is not null then
      --
      --  custom algorithm is enabled
      --
         hr_utility.set_message(800,'PER_449102_NUMGEN_FF_SET');
         l_message := fnd_message.get();

         Write_Log(l_message);
         retcode := 1;  -- raise warning
      end if;
   end if; -- profile option set?
   if g_debug then
      hr_utility.set_location('Leaving: '||c_proc_name,35);
   end if;
   --
EXCEPTION
  when TIMEOUT_ON_RESOURCE OR e_ResourceBusy then
     if g_debug then
        hr_utility.set_location(c_proc_name,29);
     end if;
     -- The required resources are used by some other process.

     hr_utility.set_message(800,'PER_289849_RESOURCE_BUSY');
     hr_utility.raise_error;

  when e_ProfileUpdFailed then

     hr_utility.set_message(800,'PER_289181_SEQUENCE_FAIL'); -- change message
     hr_utility.raise_error;

END convert_to_global_sequence;
-- ---------------------------------------------------------------------------+
--  Global_person_numbering:                                                  |
-- This function returns TRUE when "global person numbering" profile          |
-- option for a particular person type is set to "yes".                       |
-- If this profile option is set, then the global sequence is being used      |
-- to generate automatic person numbers.                                      |
-- ---------------------------------------------------------------------------+
FUNCTION Global_person_numbering(p_person_type IN varchar2)
  RETURN BOOLEAN IS

   l_value varchar2(100);
   l_defined boolean;
   l_result  boolean;
   --
   -- FND_PROFILE.get_specific is required to read from the database
   -- in case Conc. Program that changes profile value already ran.
   -- The value is cached once the profile value is set to 'Y';
   -- FND_PROFILE.value is not used because it reads from cache thus existing
   -- forms sessions will get old values.
   --
BEGIN
   l_result := FALSE;
   if p_person_type = 'EMP' then
     if g_X_EMPprofileset is null then
           --
           FND_PROFILE.get_specific(name_z    => g_xbg_EMPNum_profile
                                   ,val_z     => l_value
                                   ,defined_z => l_defined);
          if l_defined and nvl(l_value,'N')= 'Y' then
             g_X_EMPprofileset := TRUE;
             l_result := TRUE;
          end if;
     else
        return(g_X_EMPprofileset);
     end if;
   --
   -- Applicants
   --
   elsif p_person_type = 'APL' then
     if g_X_APLprofileset is null then
           --
           FND_PROFILE.get_specific(name_z    => g_xbg_APLNum_profile
                                   ,val_z     => l_value
                                   ,defined_z => l_defined);
          if l_defined and nvl(l_value,'N')= 'Y' then
             g_X_APLprofileset := TRUE;
             l_result := TRUE;
          end if;
     else
        return(g_X_APLprofileset);
     end if;
   --
   -- Contingent Workers
   --
   elsif p_person_type = 'CWK' then
     if g_X_CWKprofileset is null then
           --
           FND_PROFILE.get_specific(name_z    => g_xbg_CWKNum_profile
                                   ,val_z     => l_value
                                   ,defined_z => l_defined);
          if l_defined and nvl(l_value,'N')= 'Y' then
             g_X_CWKprofileset := TRUE;
             l_result := TRUE;
          end if;
     else
        return(g_X_CWKprofileset);
     end if;

   else
      l_result := FALSE;
   end if;
   return(l_result);

END Global_person_numbering;
--
-- ---------------------------------------------------------------------------+
-- ---------------------------------------------------------------------------+
FUNCTION GetGlobalPersonNum(p_person_type IN varchar2)
  RETURN number IS
  l_next_value number;
  c_proc_name  varchar2(100) := g_pkg_name||'.GetGlobalPersonNum';
BEGIN
   l_next_value := null;
   if p_person_type = 'EMP' then
      select PER_GLOBAL_EMP_NUM_S.NEXTVAL
        into l_next_value
        from dual;
   elsif p_person_type = 'APL' then
      select PER_GLOBAL_APL_NUM_S.NEXTVAL
        into l_next_value
        from dual;

   elsif p_person_type = 'CWK' then
      select PER_GLOBAL_CWK_NUM_S.NEXTVAL
        into l_next_value
        from dual;

   end if;
   if g_debug then
      hr_utility.set_location(c_proc_name,20);
   end if;
   return (l_next_value);
END GetGlobalPersonNum;
--
-- --------------------------------------------------------------------- +
-- Name:    Get_PersonNumber_Formula
-- Purpose: Retrieves the fast formula id defined for person number
--          generation.
-- Returns: formula id is successful, null otherwise.
-- --------------------------------------------------------------------- +
FUNCTION Get_PersonNumber_Formula(p_person_type    varchar2
                                 ,p_effective_date date)
  RETURN number IS
   --
   l_formula_id number;
   l_formula_name ff_formulas_f.formula_name%TYPE;
   e_NoFormula exception;
   --
BEGIN
    l_formula_id := null;
    begin
        if p_person_type = 'EMP' then
              l_formula_name := 'EMP_NUMBER_GENERATION';
        elsif p_person_type = 'APL' then
           l_formula_name := 'APL_NUMBER_GENERATION';
        elsif p_person_type = 'CWK' then
           l_formula_name := 'CWK_NUMBER_GENERATION';
        else
           raise e_NoFormula;
        end if;
        --
       select ff.formula_id
       into   l_formula_id
       from   ff_formulas_f ff
       where  ff.formula_name = l_formula_name
       and    ff.business_group_id = 0 -- global FF defined in Setup BG
                                       -- we ignore the Legislation Code
       and    p_effective_date between ff.effective_start_date and
                                       ff.effective_end_date;
    exception

    	    when no_data_found or e_NoFormula then

    	       l_formula_id := null;
    end;
    return (l_formula_id);
--
END Get_PersonNumber_Formula;
-- --------------------------------------------------------------------- +
-- Name:    Execute_Get_Person_Number_FF
-- Purpose: Execute fast formula in order to generate next person number.
-- Returns: Next person number
-- --------------------------------------------------------------------- +
FUNCTION EXECUTE_GET_PERSON_NUMBER_FF(
          p_formula_id        number
         ,p_effective_date    date
         ,p_business_group_id number
         ,p_person_type       varchar2
         ,p_legislation_code  varchar2
         ,p_person_id         number
         ,p_person_number     varchar2
         ,p_party_id          number
         ,p_date_of_birth     date
         ,p_start_date        date
         ,p_national_id       per_all_people_f.national_identifier%TYPE)
   RETURN VARCHAR2 IS

  l_proc varchar2(100) := g_pkg_name||'.execute_get_person_number_ff';
  l_inputs               ff_exec.inputs_t;
  l_outputs              ff_exec.outputs_t;
  l_user_message         varchar2(1) := 'N';
  l_invalid_message      fnd_new_messages.message_text%TYPE;
  l_person_number        varchar2(30);
  e_WrongParameters      exception;
BEGIN
    hr_utility.set_location('Entering: '||l_proc,1);
    --
    -- Initalize the formula.
    --
    ff_exec.init_formula
      (p_formula_id     => p_formula_id
      ,p_effective_date => p_effective_date
      ,p_inputs         => l_inputs
      ,p_outputs        => l_outputs);

    hr_utility.set_location(l_proc, 45);

    --
    -- Assign the inputs.
    --
    for i_input in l_inputs.first..l_inputs.last
    loop

      if l_inputs(i_input).name    = 'BUSINESS_GROUP_ID' then
         l_inputs(i_input).value  := p_business_group_id;
      elsif l_inputs(i_input).name = 'LEGISLATION_CODE' then
         l_inputs(i_input).value  := p_legislation_code;
      elsif l_inputs(i_input).name = 'PERSON_TYPE' then
         l_inputs(i_input).value  := p_person_type;
      elsif l_inputs(i_input).name = 'PERSON_ID' then
         l_inputs(i_input).value  := p_person_id;
      elsif l_inputs(i_input).name = 'PERSON_NUMBER' then
         l_inputs(i_input).value  := p_person_number;
      elsif l_inputs(i_input).name = 'PARTY_ID' then
         l_inputs(i_input).value  := p_party_id;
      elsif l_inputs(i_input).name = 'DATE_OF_BIRTH' then
         l_inputs(i_input).value  := fnd_date.date_to_canonical(p_date_of_birth);
      elsif l_inputs(i_input).name = 'START_DATE' then
         l_inputs(i_input).value  := fnd_date.date_to_canonical(p_start_date);
      elsif l_inputs(i_input).name = 'NATIONAL_ID' then
         l_inputs(i_input).value  := p_national_id;

      else
         hr_utility.trace('2020 name = '||l_inputs(i_input).name);
         raise e_WrongParameters;
      end if;
    end loop;
    hr_utility.set_location(l_proc,50);
    --
    -- Run the formula.
    --
    ff_exec.run_formula(l_inputs, l_outputs);
    --
    -- Assign the outputs.
    --
    for i_output in l_outputs.first..l_outputs.last
    loop
      if l_outputs(i_output).name = 'NEXT_NUMBER' then

        if l_outputs(i_output).value = 'FAILED' then
          l_user_message := 'Y';
        else
            l_person_number := l_outputs(i_output).value;
        end if;

      elsif l_outputs(i_output).name = 'INVALID_MSG' then
           --
           -- Here any customer-defined messages are set and
           -- raised after this loop.
           --
           l_invalid_message := l_outputs(i_output).value;
      else
        raise e_WrongParameters;
      end if;

    end loop;
    --
    -- If the Fast Formula raises a user-defined error message,
    -- raise the error back to the user. Here the message is
    -- truncated to 30 characters because that is the limit
    -- in the calling program.
    --
    if l_user_message = 'Y' then
      hr_utility.set_message(800, substr(l_invalid_message, 1, 30));
      hr_utility.raise_error;
    end if;

    hr_utility.set_location(l_proc,55);

    return l_person_number;

exception

  when e_WrongParameters then
    --
    -- The inputs / outputs of the Fast Formula are incorrect
    -- so raise an error.
    --
    hr_utility.set_message(800,'HR_449943_BAD_FF_DEFINITION');
    hr_utility.raise_error;

END EXECUTE_GET_PERSON_NUMBER_FF;
--
--
END PER_BG_NUMBERING_METHOD_PKG;

/
