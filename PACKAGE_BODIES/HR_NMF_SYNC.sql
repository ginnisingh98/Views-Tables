--------------------------------------------------------
--  DDL for Package Body HR_NMF_SYNC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."HR_NMF_SYNC" as
/* $Header: hrnmfsyn.pkb 120.7 2006/11/03 12:29:14 rvarshne noship $ */

--
  g_package    CONSTANT varchar2(30) := 'hr_nmf_sync.';
  g_FULL_NAME  CONSTANT hr_name_formats.format_name%TYPE := 'FULL_NAME';
  g_ORDER_NAME CONSTANT hr_name_formats.format_name%TYPE := 'ORDER_NAME';
  g_LIST_NAME  CONSTANT hr_name_formats.format_name%TYPE := 'LIST_NAME';
--
-- Write_Log: writes messages to the LOG file generated by Concurrent Mg.
-- ---------------------------------------------------------------------------+
PROCEDURE Write_Log
         ( p_message varchar2 ) IS
--
   c_proc_name CONSTANT varchar2(100) := g_package||'.write_log';
BEGIN
   FND_FILE.PUT_LINE(FND_FILE.LOG,p_message);

EXCEPTION
      WHEN OTHERS THEN
         --
         -- Exception raised whilst writing the log file...
         --
         FND_FILE.PUT_LINE(FND_FILE.LOG,SQLERRM);
         RAISE;
END Write_Log;
--
/* =====================================================================
   Name    : cache_mask_info
   =====================================================================
   Purpose : Populates the PL/SQL table with the given mask information.
             If the table is already cached, the mask is added.
   Returns : Nothing.
   ---------------------------------------------------------------------*/
PROCEDURE cache_mask_info(p_legislation_code  in varchar2
                         ,p_format_name       in varchar2
                         ,p_scope             in varchar2) IS
--
  cursor csr_get_masks(cp_legCode    varchar2
                      ,cp_formatName varchar2
                      ,cp_scope      varchar2) is
    select nmf.legislation_code
          ,nmf.format_name
          ,nmf.user_format_choice
          ,nmf.format_mask
     from HR_NAME_FORMATS nmf
   where ((cp_legCode is not null and nmf.legislation_code = cp_legCode)
           OR ( nmf.legislation_code is null))
     and ((cp_formatName is not null and nmf.format_name = cp_formatName)
           OR (cp_formatName is null))
     and ((cp_scope is not null and nmf.user_format_choice = cp_scope)
           OR (cp_scope is null));
  --
  cursor csr_get_all_leg(cp_formatName varchar2
                        ,cp_scope      varchar2) is
    select nmf.legislation_code
          ,nmf.format_name
          ,nmf.user_format_choice
          ,nmf.format_mask
     from HR_NAME_FORMATS nmf
   where nmf.legislation_code in
         (select distinct legislation_code from per_business_groups_perf)
     and ((cp_formatName is not null and nmf.format_name = cp_formatName)
           OR (cp_formatName is null))
     and ((cp_scope is not null and nmf.user_format_choice = cp_scope)
           OR (cp_scope is null));
  --
BEGIN
  --
  -- Cache the format masks based on parameters being passed
  --
  if g_masks_cached = FALSE then
    g_leg_masks_cache.sz := 0;
  end if;
--
  for masks_rec in csr_get_masks(p_legislation_code
                                ,p_format_name
                                ,p_scope) loop
--
    g_leg_masks_cache.sz := g_leg_masks_cache.sz + 1;
    g_leg_masks_cache.legislation_code(g_leg_masks_cache.sz) := masks_rec.legislation_code;
    g_leg_masks_cache.format_name(g_leg_masks_cache.sz) := masks_rec.format_name;
    g_leg_masks_cache.user_format_choice(g_leg_masks_cache.sz) := masks_rec.user_format_choice;
    g_leg_masks_cache.format_mask(g_leg_masks_cache.sz) := masks_rec.format_mask;
  --
  end loop;
  --
  if p_legislation_code is null then
    -- cache all legislations
    for masks_rec in csr_get_all_leg(p_format_name, p_scope) loop
    --
        g_leg_masks_cache.sz := g_leg_masks_cache.sz + 1;
        g_leg_masks_cache.legislation_code(g_leg_masks_cache.sz) := masks_rec.legislation_code;
        g_leg_masks_cache.format_name(g_leg_masks_cache.sz) := masks_rec.format_name;
        g_leg_masks_cache.user_format_choice(g_leg_masks_cache.sz) := masks_rec.user_format_choice;
        g_leg_masks_cache.format_mask(g_leg_masks_cache.sz) := masks_rec.format_mask;
      --
    end loop;
  end if;
--
   g_masks_cached := TRUE;
--
END cache_mask_info;
--
/* =====================================================================
   Name    : get_cache_mask
/* =====================================================================
   Purpose : Gets the cached mask from a cached pl/sql table to prevent
             same reads of tables for each person in the sync process.
   Returns : format_mask if found, otherwise NULL.
   ---------------------------------------------------------------------*/
function get_cache_mask (p_legislation_code  in varchar2
                        ,p_format_name      in varchar2
                        ,p_scope            in varchar2 )
  return varchar2 is

  l_mask_rec      number;
  l_format_mask   hr_name_formats.format_mask%TYPE;

begin
--
  l_format_mask := null;
  --
   for l_mask_rec in 1..g_leg_masks_cache.sz loop

     if   (nvl(g_leg_masks_cache.legislation_code(l_mask_rec),'NULL') = nvl(p_legislation_code,'NULL'))
      and (g_leg_masks_cache.format_name(l_mask_rec) = p_format_name)
      and (g_leg_masks_cache.user_format_choice(l_mask_rec) = p_scope)
     then
       l_format_mask := g_leg_masks_cache.format_mask(l_mask_rec);
       exit;
     end if;

   end loop;

   return l_format_mask;
   -- This will be null if the mask is not in the cached mask table
--
end get_cache_mask;
--
/* ========================================================================
   Name    : get_mask
   ========================================================================
   Purpose : Gets the mask information from a cached pl/sql table to prevent
             same table scans on name formats table for each person in the
             sync process.
   Returns : format mask if found, otherwise null.
   -----------------------------------------------------------------------*/
function get_mask(p_legislation_code  in varchar2
                 ,p_format_name      in varchar2
                 ,p_scope            in varchar2 )
   return varchar2 is
--
  l_format_mask hr_name_formats.format_mask%TYPE;
--
begin
--
  if NOT g_masks_cached then
   cache_mask_info(p_legislation_code  => p_legislation_code
                  ,p_format_name       => p_format_name
                  ,p_scope             => p_scope);
  end if;

  l_format_mask := get_cache_mask
          (p_legislation_code  => p_legislation_code
          ,p_format_name       => p_format_name
          ,p_scope             => p_scope);

  return l_format_mask;
  -- This will be null if mask does not exist
--
end get_mask;
--
/* =====================================================================
   Name    : cache_bg_info
   =====================================================================
   Purpose : Populates the PL/SQL table with the given business group
             information. If the table is already cached, the bg is added.
   Returns : Nothing.
   ---------------------------------------------------------------------*/
PROCEDURE cache_bg_info(p_legislation_code in varchar2) IS
--
  cursor  csr_get_bgs(cp_legCode varchar2) is
    select legislation_code, business_group_id, name
      from PER_BUSINESS_GROUPS_PERF bg
     where ((cp_legCode is not null and bg.legislation_code = cp_legCode)
        or (cp_legCode is null));
--
BEGIN
  --
  if g_bg_cached = FALSE then
    g_business_groups_cache.sz := 0;
  end if;
  --
  for bgs_rec in csr_get_bgs(p_legislation_code) loop
  --
    g_business_groups_cache.sz := g_business_groups_cache.sz + 1;
    g_business_groups_cache.legislation_code(g_business_groups_cache.sz) := bgs_rec.legislation_code;
    g_business_groups_cache.bg_name(g_business_groups_cache.sz) := bgs_rec.name;
    g_business_groups_cache.business_group_id(g_business_groups_cache.sz) := bgs_rec.business_group_id;
  --
  end loop;
  --
  g_bg_cached := TRUE;
--
END cache_bg_info;
--
--
/* =====================================================================
   Name    : get_cache_bg_leg_code
/* =====================================================================
   Purpose : retrieves the legislation code associated with business
             group parameter
   Returns : legislation code if found, otherwise null
   ---------------------------------------------------------------------*/
function get_cache_bg_leg_code(p_business_group_id number)
  return varchar2 is
--
  l_legislation_code varchar2(80);
begin
  l_legislation_code := null;
  for bg_rec in 1.. g_business_groups_cache.sz loop
    if g_business_groups_cache.business_group_id(bg_rec) = p_business_group_id then
      l_legislation_code := g_business_groups_cache.legislation_code(bg_rec);
      exit;
    end if;
  end loop;
  return l_legislation_code;
end get_cache_bg_leg_code;
--
--
/* =====================================================================
   Name    : cache_format_names
/* =====================================================================
   Purpose : Caches the format names into a pl/sql table for later
             processing.
   Returns : nothing
   ---------------------------------------------------------------------*/
procedure cache_format_names is
begin
  g_format_names_tbl(1) := g_FULL_NAME;
  g_format_names_tbl(2) := g_ORDER_NAME;
  g_format_names_tbl(3) := g_LIST_NAME;
end;
--
--
/* =====================================================================
   Name    : get_cache_seeded_mask
/* =====================================================================
   Purpose : Gets the cached seeded mask from a cached pl/sql table to
             preventsame reads of tables for each person in the sync
             process.
   Returns : format_mask if found, otherwise NULL.
   ---------------------------------------------------------------------*/
function get_cache_seeded_mask
    (p_format_name      in varchar2
    ,p_scope            in varchar2 ) return varchar2 is

  l_mask_rec      number;
  l_format_mask   hr_name_formats.format_mask%TYPE;

begin
--
  l_format_mask := null;
  --
   for l_mask_rec in 1..g_leg_masks_cache.sz loop

     if   (g_leg_masks_cache.legislation_code(l_mask_rec) is null)
      and (g_leg_masks_cache.format_name(l_mask_rec) = p_format_name)
      and (g_leg_masks_cache.user_format_choice(l_mask_rec) = p_scope)
     then
       l_format_mask := g_leg_masks_cache.format_mask(l_mask_rec);
       exit;
     end if;
   end loop;
   return l_format_mask;
   -- This will be null if the mask is not in the cached mask table
--
end get_cache_seeded_mask;
--
/* =====================================================================
   Name    : cache_seeded_pkg
   =====================================================================
   Purpose : Populates the PL/SQL table with the given seeded proc
             information.
   Returns : Nothing.
   ---------------------------------------------------------------------*/
PROCEDURE cache_seeded_pkg IS
--
  l_format_name hr_name_formats.format_name%TYPE;
  --
  cursor csr_get_legislations is
    select leg.territory_code legislation_code
     from fnd_territories_vl leg
    where leg.territory_code in
     (select distinct legislation_code from per_business_groups_perf);
  --
BEGIN
--
  if g_seeded_pkg_cached = FALSE then
    g_leg_seeded_pkg_cache.sz := 0;
  end if;
--
  for leg_rec in csr_get_legislations loop
    --
    l_format_name := g_FULL_NAME;
    g_leg_seeded_pkg_cache.sz := g_leg_seeded_pkg_cache.sz + 1;
    g_leg_seeded_pkg_cache.legislation_code(g_leg_seeded_pkg_cache.sz) := leg_rec.legislation_code;
    g_leg_seeded_pkg_cache.format_name(g_leg_seeded_pkg_cache.sz) := l_format_name;
    hr_person_name.get_seeded_procedure_name
         (p_format_name       => l_format_name
         ,p_legislation_code  => leg_rec.legislation_code
         ,p_package_name      =>
            g_leg_seeded_pkg_cache.seeded_package_name(g_leg_seeded_pkg_cache.sz)
         ,p_procedure_name   =>
            g_leg_seeded_pkg_cache.seeded_procedure_name(g_leg_seeded_pkg_cache.sz)
         );
    --
    l_format_name := g_ORDER_NAME;
    g_leg_seeded_pkg_cache.sz := g_leg_seeded_pkg_cache.sz + 1;
    g_leg_seeded_pkg_cache.legislation_code(g_leg_seeded_pkg_cache.sz) := leg_rec.legislation_code;
    g_leg_seeded_pkg_cache.format_name(g_leg_seeded_pkg_cache.sz) := l_format_name;
    hr_person_name.get_seeded_procedure_name
         (p_format_name       => l_format_name
         ,p_legislation_code  => leg_rec.legislation_code
         ,p_package_name      =>
            g_leg_seeded_pkg_cache.seeded_package_name(g_leg_seeded_pkg_cache.sz)
         ,p_procedure_name   =>
            g_leg_seeded_pkg_cache.seeded_procedure_name(g_leg_seeded_pkg_cache.sz)
         );
  --
  end loop;
--
   g_seeded_pkg_cached := TRUE;
--
END cache_seeded_pkg;
--
/* =====================================================================
   Name    : get_cache_seeded_pkg
/* =====================================================================
   Purpose : Gets the cached seeded package from a cached pl/sql table
             to prevent same reads of tables for each person in the
             sync process.
   Returns : seeded package name if found, otherwise NULL.
   ---------------------------------------------------------------------*/
procedure get_cache_seeded_pkg
    (p_format_name       in varchar2
    ,p_legislation_code  in varchar2
    ,p_pkg_name          out NOCOPY varchar2
    ,p_procedure_name    out NOCOPY varchar2 ) is
--
  l_pkg_rec      number;
  l_pkg_name     varchar2(80);
  l_proc_name    varchar2(80);
--
begin
--
  l_pkg_name := null;
  l_proc_name := null;
   for l_pkg_rec in 1..g_leg_seeded_pkg_cache.sz loop
     if   (g_leg_seeded_pkg_cache.legislation_code(l_pkg_rec) = p_legislation_code)
      and (g_leg_seeded_pkg_cache.format_name(l_pkg_rec) = p_format_name)
     then
       l_pkg_name  := g_leg_seeded_pkg_cache.seeded_package_name(l_pkg_rec);
       l_proc_name := g_leg_seeded_pkg_cache.seeded_procedure_name(l_pkg_rec);
       exit;
     end if;

   end loop;
   p_pkg_name := l_pkg_name;
   p_procedure_name := l_proc_name;
--
end get_cache_seeded_pkg;
--
/* ========================================================================
   Name    : get_seeded_pkg
   ========================================================================
   Purpose : Gets the seeded pkg information from a cached pl/sql table
             to prevent same table scans for each person in the
             sync process.
   Returns : pkg and procedure names if found, otherwise null.
   -----------------------------------------------------------------------*/
procedure get_seeded_pkg
    (p_format_name       in varchar2
    ,p_legislation_code  in varchar2
    ,p_pkg_name          out NOCOPY varchar2
    ,p_procedure_name    out NOCOPY varchar2 ) is
--
begin
--
  --  will assume value is always cached
  --
  get_cache_seeded_pkg
    (p_format_name       => p_format_name
    ,p_legislation_code  => p_legislation_code
    ,p_pkg_name          => p_pkg_name
    ,p_procedure_name    => p_procedure_name);
--
end get_seeded_pkg;
--
/* ========================================================================
   Name    : sync_person_names
   ========================================================================
   Purpose : rebuilds the person names in per_all_people_f depending on
             parameters being passed.
   Returns : nothing, it updates the table with newly constructed names.
   -----------------------------------------------------------------------*/
procedure sync_person_names
    (p_rowid              in rowid
    ,p_person_id          in number
    ,p_person_rec         in hr_person_name.t_nameColumns_Rec
    ,p_legislation_code   in varchar2
    ,p_format_name        in varchar2
    ,p_user_format_choice in varchar2
    ,p_num_rows_processed out nocopy number) IS
--
  l_format_mask         hr_name_formats.format_mask%TYPE;
  l_seeded_format_mask  hr_name_formats.format_mask%TYPE;
  l_pkg_name            varchar2(80);
  l_proc_name           varchar2(80);


  l_new_name            per_all_people_f.full_name%TYPE;
  l_full_name           per_all_people_f.full_name%TYPE;
  l_order_name          per_all_people_f.order_name%TYPE;
  l_local_name          per_all_people_f.local_name%TYPE;
  l_global_name         per_all_people_f.global_name%TYPE;
  l_name_changed        boolean;
--
--
begin
  --
  l_name_changed       := FALSE;
  l_full_name          :=  p_person_rec.full_name;
  l_order_name         :=  p_person_rec.order_name;
  l_local_name         :=  p_person_rec.local_name;
  l_global_name        :=  p_person_rec.global_name;
  l_pkg_name           :=  null;
  l_proc_name          :=  null;
  --
  if p_format_name is not null and p_format_name in (g_FULL_NAME,g_ORDER_NAME) then
    get_seeded_pkg
      (p_format_name       => p_format_name
      ,p_legislation_code  => p_legislation_code
      ,p_pkg_name          => l_pkg_name
      ,p_procedure_name    => l_proc_name);
  end if;
  --
  if p_format_name is not null then
    if p_user_format_choice is not null then
      --
      l_format_mask := get_mask(p_legislation_code => p_legislation_code
                               ,p_format_name      => p_format_name
                               ,p_scope            => p_user_format_choice);
      l_seeded_format_mask := get_mask(p_legislation_code  => NULL
                               ,p_format_name      => p_format_name
                               ,p_scope            => p_user_format_choice);
      l_new_name := hr_person_name.derive_formatted_name
                    (p_person_names_rec   => p_person_rec
                    ,p_format_name        => p_format_name
                    ,p_legislation_code   => p_legislation_code
                    ,p_format_mask        => l_format_mask
                    ,p_seeded_pkg         => l_pkg_name
                    ,p_seeded_procedure   => l_proc_name
                    ,p_seeded_format_mask => l_seeded_format_mask);
      if p_format_name = g_FULL_NAME then
        l_full_name := l_new_name;
      elsif p_format_name = g_ORDER_NAME then
        l_order_name := l_new_name;
      elsif p_format_name = g_LIST_NAME and p_user_format_choice = 'L' then
        l_local_name := l_new_name;
      elsif p_format_name = g_LIST_NAME and p_user_format_choice = 'G' then
        l_global_name := l_new_name;
      end if;
    else
      -- ------------------------------------------------------------------
      -- User format choice is null; therefore, generate for all types
      -- ------------------------------------------------------------------
      if p_format_name in (g_FULL_NAME,g_ORDER_NAME) then
        l_format_mask := get_mask(p_legislation_code => p_legislation_code
                                 ,p_format_name      => p_format_name
                                 ,p_scope            => 'L');
        l_seeded_format_mask := get_mask(p_legislation_code  => NULL
                                        ,p_format_name       => p_format_name
                                        ,p_scope             => 'L');
        l_new_name := hr_person_name.derive_formatted_name
        (p_person_names_rec   => p_person_rec
        ,p_format_name        => p_format_name
        ,p_legislation_code   => p_legislation_code
        ,p_format_mask        => l_format_mask
        ,p_seeded_pkg         => l_pkg_name
        ,p_seeded_procedure   => l_proc_name
        ,p_seeded_format_mask => l_seeded_format_mask);
        --
        if p_format_name = g_FULL_NAME then
          l_full_name := l_new_name;
        elsif p_format_name = g_ORDER_NAME then
          l_order_name := l_new_name;
        end if;
      --
      else
        l_format_mask := get_mask(p_legislation_code => p_legislation_code
                                 ,p_format_name      => p_format_name
                                 ,p_scope            => 'L');

        l_seeded_format_mask := get_mask(p_legislation_code  => NULL
                                        ,p_format_name       => p_format_name
                                        ,p_scope             => 'L');

        l_local_name := hr_person_name.derive_formatted_name
        (p_person_names_rec   => p_person_rec
        ,p_format_name        => p_format_name
        ,p_legislation_code   => p_legislation_code
        ,p_format_mask        => l_format_mask
        ,p_seeded_pkg         => NULL
        ,p_seeded_procedure   => NULL
        ,p_seeded_format_mask => l_seeded_format_mask);
      --
        l_format_mask := get_mask(p_legislation_code  => p_legislation_code
                                 ,p_format_name       => p_format_name
                                 ,p_scope             => 'G');

        l_seeded_format_mask := get_mask(p_legislation_code  => NULL
                                        ,p_format_name       => p_format_name
                                        ,p_scope             => 'G');

        l_global_name := hr_person_name.derive_formatted_name
        (p_person_names_rec   => p_person_rec
        ,p_format_name        => p_format_name
        ,p_legislation_code   => p_legislation_code
        ,p_format_mask        => l_format_mask
        ,p_seeded_pkg         => NULL
        ,p_seeded_procedure   => NULL
        ,p_seeded_format_mask => l_seeded_format_mask);
      --
      end if; -- format_name in Full_name / Order Name
    end if; -- user format choice is null
  else -- format name is null
    -- ------------------------------------------------------------------
    -- Sync all the stored names
    -- ------------------------------------------------------------------
    l_pkg_name           := null;
    l_proc_name          := null;
    l_format_mask        := null;
    l_seeded_format_mask := null;
    if p_user_format_choice is not null then
--
      for i in g_format_names_tbl.first .. g_format_names_tbl.last loop
        l_format_mask := get_mask(p_legislation_code => p_legislation_code
                                 ,p_format_name      => g_format_names_tbl(i)
                                 ,p_scope            => p_user_format_choice);
        l_seeded_format_mask := get_mask(p_legislation_code  => NULL
                                 ,p_format_name      => g_format_names_tbl(i)
                                 ,p_scope            => p_user_format_choice);
        if g_format_names_tbl(i) in (g_FULL_NAME,g_ORDER_NAME) then
          get_seeded_pkg
            (p_format_name       => g_format_names_tbl(i)
            ,p_legislation_code  => p_legislation_code
            ,p_pkg_name          => l_pkg_name
            ,p_procedure_name    => l_proc_name);
        else
          l_pkg_name := null;
          l_proc_name := null;
        end if;
        l_new_name := hr_person_name.derive_formatted_name
        (p_person_names_rec   => p_person_rec
        ,p_format_name        => g_format_names_tbl(i)
        ,p_legislation_code   => p_legislation_code
        ,p_format_mask        => l_format_mask
        ,p_seeded_pkg         => l_pkg_name
        ,p_seeded_procedure   => l_proc_name
        ,p_seeded_format_mask => l_seeded_format_mask);
        --
        if p_format_name = g_FULL_NAME then
          l_full_name := l_new_name;
        elsif p_format_name = g_ORDER_NAME then
          l_order_name := l_new_name;
        elsif p_format_name = g_LIST_NAME and p_user_format_choice = 'L' then
          l_local_name := l_new_name;
        elsif p_format_name = g_LIST_NAME and p_user_format_choice = 'G' then
          l_global_name := l_new_name;
        end if;
     end loop;
    else
      -- ------------------------------------------------------------------
      -- User format choice is null; therefore, generate for all stored
      -- names and all user format choices
      -- ------------------------------------------------------------------
      l_pkg_name := null;
      l_proc_name := null;
      l_format_mask := null;

      for i in g_format_names_tbl.first .. g_format_names_tbl.last loop
        if g_format_names_tbl(i) in (g_FULL_NAME,g_ORDER_NAME) then
          l_format_mask := get_mask(p_legislation_code  => p_legislation_code
                                   ,p_format_name      => g_format_names_tbl(i)
                                   ,p_scope            => 'L');
          l_seeded_format_mask := get_mask(p_legislation_code  => NULL
                                   ,p_format_name      => g_format_names_tbl(i)
                                   ,p_scope            => 'L');
          get_seeded_pkg
            (p_format_name       => g_format_names_tbl(i)
            ,p_legislation_code  => p_legislation_code
            ,p_pkg_name          => l_pkg_name
            ,p_procedure_name    => l_proc_name);
          l_new_name := hr_person_name.derive_formatted_name
                        (p_person_names_rec   => p_person_rec
                        ,p_format_name        => g_format_names_tbl(i)
                        ,p_legislation_code   => p_legislation_code
                        ,p_format_mask        => l_format_mask
                        ,p_seeded_pkg         => l_pkg_name
                        ,p_seeded_procedure   => l_proc_name
                        ,p_seeded_format_mask => l_seeded_format_mask);
           if g_format_names_tbl(i)  = g_FULL_NAME then
            l_full_name := l_new_name;
           else
            l_order_name := l_new_name;
           end if;
        else
          l_format_mask := get_mask(p_legislation_code  => p_legislation_code
                                   ,p_format_name      => g_format_names_tbl(i)
                                   ,p_scope            => 'L');
          l_seeded_format_mask := get_mask(p_legislation_code  => NULL
                                   ,p_format_name      => g_format_names_tbl(i)
                                   ,p_scope            => 'L');

          l_local_name := hr_person_name.derive_formatted_name
                          (p_person_names_rec   => p_person_rec
                          ,p_format_name        => g_format_names_tbl(i)
                          ,p_legislation_code   => p_legislation_code
                          ,p_format_mask        => l_format_mask
                          ,p_seeded_pkg         => NULL
                          ,p_seeded_procedure   => NULL
                          ,p_seeded_format_mask => l_seeded_format_mask);

          l_format_mask := get_mask(p_legislation_code  => p_legislation_code
                                   ,p_format_name      => g_format_names_tbl(i)
                                   ,p_scope            => 'G');
          l_seeded_format_mask := get_mask(p_legislation_code  => NULL
                                   ,p_format_name      => g_format_names_tbl(i)
                                   ,p_scope            => 'G');

          l_global_name := hr_person_name.derive_formatted_name
                          (p_person_names_rec   => p_person_rec
                          ,p_format_name        => g_format_names_tbl(i)
                          ,p_legislation_code   => p_legislation_code
                          ,p_format_mask        => l_format_mask
                          ,p_seeded_pkg         => NULL
                          ,p_seeded_procedure   => NULL
                          ,p_seeded_format_mask => l_seeded_format_mask);

        end if;
     end loop;
   end if;
  end if; -- all stored names, all user format choice options
  -- ---------------------------------------------------------------------
  -- Update per_all_people_f table with new names
  -- ---------------------------------------------------------------------
  if nvl(l_full_name,'NULL') <> nvl(p_person_rec.full_name,'NULL') then
    l_name_changed := TRUE;
  elsif nvl(l_order_name,'NULL') <> nvl(p_person_rec.order_name,'NULL') then
    l_name_changed := TRUE;
  elsif nvl(l_local_name,'NULL') <> nvl(p_person_rec.local_name,'NULL') then
    l_name_changed := TRUE;
  elsif nvl(l_global_name,'NULL') <> nvl(p_person_rec.global_name,'NULL') then
    l_name_changed := TRUE;
  end if;
  if l_name_changed then
    update per_all_people_f
       set full_name   = l_full_name
          ,order_name  = l_order_name
          ,local_name  = l_local_name
          ,global_name = l_global_name
     where rowid = p_rowid;
     p_num_rows_processed := SQL%ROWCOUNT;
  end if;
--
end sync_person_names;
--
--
PROCEDURE alter_who_trigger(p_action in varchar2
                           ,p_error  out nocopy varchar2) is
  --
  trigger_not_exists EXCEPTION;
  PRAGMA EXCEPTION_INIT(trigger_not_exists,-04080);
  --
  l_owner all_triggers.owner%TYPE;
  l_cmd   varchar2(1000);
  --
  cursor csr_get_trigger_owner is
   select table_owner from user_triggers
     where trigger_name = 'PER_ALL_PEOPLE_F_WHO';
BEGIN
  p_error := null;
  open csr_get_trigger_owner;
  fetch csr_get_trigger_owner into l_owner;
  close csr_get_trigger_owner;
  if l_owner is not null then
    l_cmd := 'ALTER TRIGGER PER_ALL_PEOPLE_F_WHO ';
    if p_action = 'DISABLE' then
      l_cmd := l_cmd || 'DISABLE';
      EXECUTE IMMEDIATE l_cmd;
    elsif p_action = 'ENABLE' then
      l_cmd := l_cmd || 'ENABLE';
      EXECUTE IMMEDIATE l_cmd;
    end if;
  end if;
EXCEPTION
  when trigger_not_exists then NULL;
  when others then p_error := substr(SQLERRM,1,512);
END alter_who_trigger;
--
-- ----------------------------------------------------------------------------
-- |--------------------------< range_cursor >--------------------------------|
-- ----------------------------------------------------------------------------
--
PROCEDURE range_cursor (pactid in 	  number,
			                  sqlstr out NOCOPY varchar2) is

  l_proc CONSTANT varchar2(100) := g_package||'range_curosr';
  l_leg_code  varchar2(30);
  l_bg_list   varchar2(4000);
  --
  cursor  csr_get_bgs(cp_legCode varchar2) is
    select business_group_id
      from PER_BUSINESS_GROUPS_PERF bg
     where bg.legislation_code = cp_legCode;
  --
BEGIN
  select pay_core_utils.get_parameter('LEGISLATION_CODE',
                                   ppa.legislative_parameters)
    into l_leg_code
   from pay_payroll_actions ppa
  where ppa.payroll_action_id = pactid;
  /*
  ** Define the SQL statement to get the people we want to process. Provide
  ** initial filtering based on business group if appropriate.
  */
  if l_leg_code is null then
    /*
    **scope is ALL_BUS_GRP
    */
    sqlstr := 'select distinct per.person_id
                from per_all_people_f per
    	            where :payroll_action_id > 0
              order by per.person_id';
  else
    sqlstr := 'select distinct per.person_id
                from per_all_people_f per
                    ,per_business_groups_perf bg
    	             where :payroll_action_id > 0
                     and bg.business_group_id = per.business_group_id
                     and bg.legislation_code = '||''''||l_leg_code||''''||
    				         ' order by per.person_id';
  end if;

END range_cursor;
--
-- ----------------------------------------------------------------------------
-- |--------------------------< action_creation >-----------------------------|
-- ----------------------------------------------------------------------------
--
-- Purpose : This routine creates assignment actions for a specific chunk.
--           Only one action is created for a single person ID.
--
-- Notes :
--
PROCEDURE action_creation (pactid    in number,
                           stperson  in number,
			                     endperson in number,
			                     chunk     in number) is
  --
  l_temp_person_id per_all_people_f.person_id%TYPE;
  l_lockingactid   pay_assignment_actions.assignment_action_id%TYPE;
  l_business_group_id number;
  l_legislation_code per_business_groups_perf.legislation_code%TYPE;
  --
  cursor csr_actions(cp_pactid    number
                    ,cp_stperson  number
                    ,cp_endperson number
                    ,cp_leg_code  varchar2) is   -- #4571033
        select distinct ppf.person_id
      from per_all_people_f         ppf
          ,per_business_groups_perf bg
          ,pay_payroll_actions      ppa
         where ppf.person_id between cp_stperson and cp_endperson
             and ppa.payroll_action_id = cp_pactid
             and ppf.business_group_id = bg.business_group_id
             and bg.legislation_code   = cp_leg_code;
  --
  cursor csr_actions_no_leg(cp_pactid    number
                    ,cp_stperson  number
                    ,cp_endperson number) is
        select distinct ppf.person_id
      from per_all_people_f         ppf
          ,pay_payroll_actions      ppa
         where ppf.person_id between cp_stperson and cp_endperson
             and ppa.payroll_action_id = cp_pactid;
  --
BEGIN
  select pay_core_utils.get_parameter('LEGISLATION_CODE',
                                   ppa.legislative_parameters)
   into l_legislation_code
   from pay_payroll_actions ppa
  where ppa.payroll_action_id = pactid;
  if l_legislation_code is null then
  --
    for people_rec in csr_actions_no_leg(pactid, stperson, endperson) loop
      select pay_assignment_actions_s.nextval into l_lockingactid
       from dual;
       -- Passed person_id/PER_ALL_PEOPLE_F as object_id/object_type, procedure
       -- archive_data needs it to process a person.
       hr_nonrun_asact.insact(lockingactid => l_lockingactid,
                          assignid     => -1,
                          pactid       => pactid,
                          chunk        => chunk,
                          greid        => null,
                          object_id    => people_rec.person_id,
                          object_type  => 'PER_ALL_PEOPLE_F');
    end loop;
  else
  -- only process those belonging to a specific legislation
  --
    for people_rec in csr_actions(pactid, stperson, endperson, l_legislation_code) loop
      select pay_assignment_actions_s.nextval into l_lockingactid
       from dual;
       -- Passed person_id/PER_ALL_PEOPLE_F as object_id/object_type, procedure
       -- archive_data needs it to process a person.
       hr_nonrun_asact.insact(lockingactid => l_lockingactid,
                          assignid     => -1,
                          pactid       => pactid,
                          chunk        => chunk,
                          greid        => null,
                          object_id    => people_rec.person_id,
                          object_type  => 'PER_ALL_PEOPLE_F');
    end loop;
  end if;
  --
END action_creation;
-- ----------------------------------------------------------------------------
-- |---------------------------< initialization >-----------------------------|
-- ----------------------------------------------------------------------------
--
-- Purpose : This process is called for each slave process to perform
--           standard initialization.
--
-- Notes :
--
PROCEDURE initialization(pactid in number) IS
--
  p_format_name_choice varchar2(80);
BEGIN
 --Added this for bug 5641860
 hr_general.g_data_migrator_mode := 'Y';
 --
  -- get parameters and initialize global variables
  --
  select pay_core_utils.get_parameter('LEGISLATION_CODE',
                                   ppa.legislative_parameters)
        ,pay_core_utils.get_parameter('FORMAT_NAME_CHOICE',
                                   ppa.legislative_parameters)
   into g_prm_legislation_code, p_format_name_choice
   from pay_payroll_actions ppa
  where ppa.payroll_action_id = pactid;

  if p_format_name_choice = 'A' then
    g_prm_format_name := null;
    g_prm_scope := null;
  elsif p_format_name_choice = 'O' then
    g_prm_format_name := g_ORDER_NAME;
    g_prm_scope := 'L';
  elsif p_format_name_choice = 'F' then
    g_prm_format_name := g_FULL_NAME;
    g_prm_scope := 'L';
  elsif p_format_name_choice = 'S' then
    g_prm_format_name := g_LIST_NAME;
    g_prm_scope := 'L';
  elsif p_format_name_choice = 'U' then
    g_prm_format_name := g_LIST_NAME;
    g_prm_scope := 'G';
  elsif p_format_name_choice = 'V' then
    g_prm_format_name := g_LIST_NAME;
    g_prm_scope := null;
  end if;

  write_log('Parameters: - Initialization Phase - ');
  write_log('p_format_name_choice= '||p_format_name_choice);
  write_log('p_legislation_code= '||g_prm_legislation_code);
  write_log('format_name= '||g_prm_format_name);
  write_log('user_format_choice= '||g_prm_scope);
  --
  cache_mask_info(p_legislation_code  => g_prm_legislation_code
                 ,p_format_name       => g_prm_format_name
                 ,p_scope             => g_prm_scope);
  --
  cache_bg_info(p_legislation_code  => g_prm_legislation_code);
  --
  if p_format_name_choice not in ('S','U') then
    cache_seeded_pkg;
  end if;
  --
  cache_format_names;
  --
END initialization;
--
-- ----------------------------------------------------------------------------
-- |----------------------------< archive_data >------------------------------|
-- ----------------------------------------------------------------------------
--
-- Purpose : This process is called for each assignment action and performs the
--           processing required for each individual person.
--
-- Notes :
--
PROCEDURE archive_data(p_assactid       in number,
                       p_effective_date in date) is
  --
  l_person_id          per_all_people_f.person_id%TYPE;
  l_legislation_code   varchar2(80);
  l_num_rows_processed number;
  --
  cursor csr_person is
  select  ass.object_id
   from  pay_assignment_actions ass
  where  ass.assignment_action_id = p_assactid;
  --
  cursor csr_get_person(cp_person_id number)  is
      select rowid row_id
            ,FIRST_NAME
            ,MIDDLE_NAMES
            ,LAST_NAME
            ,SUFFIX
            ,PRE_NAME_ADJUNCT
            ,TITLE
            ,KNOWN_AS
            ,EMAIL_ADDRESS
            ,EMPLOYEE_NUMBER
            ,APPLICANT_NUMBER
            ,NPW_NUMBER
            ,PREVIOUS_LAST_NAME
            ,PER_INFORMATION1
            ,PER_INFORMATION2
            ,PER_INFORMATION3
            ,PER_INFORMATION4
            ,PER_INFORMATION5
            ,PER_INFORMATION6
            ,PER_INFORMATION7
            ,PER_INFORMATION8
            ,PER_INFORMATION9
            ,PER_INFORMATION10
            ,PER_INFORMATION11
            ,PER_INFORMATION12
            ,PER_INFORMATION13
            ,PER_INFORMATION14
            ,PER_INFORMATION15
            ,PER_INFORMATION16
            ,PER_INFORMATION17
            ,PER_INFORMATION18
            ,PER_INFORMATION19
            ,PER_INFORMATION20
            ,PER_INFORMATION21
            ,PER_INFORMATION22
            ,PER_INFORMATION23
            ,PER_INFORMATION24
            ,PER_INFORMATION25
            ,PER_INFORMATION26
            ,PER_INFORMATION27
            ,PER_INFORMATION28
            ,PER_INFORMATION29
            ,PER_INFORMATION30
            ,ATTRIBUTE1
            ,ATTRIBUTE2
            ,ATTRIBUTE3
            ,ATTRIBUTE4
            ,ATTRIBUTE5
            ,ATTRIBUTE6
            ,ATTRIBUTE7
            ,ATTRIBUTE8
            ,ATTRIBUTE9
            ,ATTRIBUTE10
            ,ATTRIBUTE11
            ,ATTRIBUTE12
            ,ATTRIBUTE13
            ,ATTRIBUTE14
            ,ATTRIBUTE15
            ,ATTRIBUTE16
            ,ATTRIBUTE17
            ,ATTRIBUTE18
            ,ATTRIBUTE19
            ,ATTRIBUTE20
            ,ATTRIBUTE21
            ,ATTRIBUTE22
            ,ATTRIBUTE23
            ,ATTRIBUTE24
            ,ATTRIBUTE25
            ,ATTRIBUTE26
            ,ATTRIBUTE27
            ,ATTRIBUTE28
            ,ATTRIBUTE29
            ,ATTRIBUTE30
            ,FULL_NAME
            ,ORDER_NAME
            ,LOCAL_NAME
            ,GLOBAL_NAME
            ,BUSINESS_GROUP_ID
       from per_all_people_f
      where person_id = cp_person_id
        for update nowait;

BEGIN
  l_num_rows_processed := 0;
  l_legislation_code := g_prm_legislation_code;
  --
  open  csr_person;
  fetch csr_person into l_person_id;
  close csr_person;
  --
  for people_rec in csr_get_person(l_person_id) loop
    if l_legislation_code is null then
      l_legislation_code := get_cache_bg_leg_code(people_rec.business_group_id);
    end if;
    --
    sync_person_names
      (p_rowid              => people_rec.row_id
      ,p_person_id          => l_person_id
      ,p_person_rec         => people_rec
      ,p_legislation_code   => l_legislation_code
      ,p_format_name        => g_prm_format_name
      ,p_user_format_choice => g_prm_scope
      ,p_num_rows_processed => l_num_rows_processed);
  end loop;
  --
END archive_data;
--
--
-- ----------------------------------------------------------------------------+
-- |----------------------------< sync_list_name >-----------------------------|
-- ----------------------------------------------------------------------------+
--
-- Purpose : This process will update the global_name and local_name columns
--           for those records having null values in these columns.
--           This runs single-threaded and therefore, can be used for Shared
--           HR installations only.
--
-- Notes :
--
PROCEDURE sync_list_name(errbuf  out NOCOPY varchar2
                        ,retcode out NOCOPY number) is
  --
  l_person_id          per_all_people_f.person_id%TYPE;
  l_legislation_code   varchar2(80);
  l_limit              natural := 100; -- Limiting the bulk collect, if not limited then bulk collect
                                     -- returns entire rows for the condition, it may affect memory
  l_prev_collect     number  := 0;   -- Cumulative record count till previous fetch
  l_curr_collect     number  := 0;   -- Cumulative record count including the current fetch
  l_diff_collect     number  := 0;   -- To check that, whether the last fetch retrived any new
                                     -- records, if not then to exit from the loop
  Type t_rowids is table of ROWID
       index by binary_integer;

  Type t_leg_code is table of varchar2(80) index by binary_integer;
  --
  l_rowids_tab          t_rowids;
  l_leg_code_tab        t_leg_code;
  l_num_rows_processed  number;
  l_total_rows          number;
  l_commit              number;
  --
  cursor csr_get_person(cp_row_id rowid)  is
      select rowid row_id
            ,FIRST_NAME
            ,MIDDLE_NAMES
            ,LAST_NAME
            ,SUFFIX
            ,PRE_NAME_ADJUNCT
            ,TITLE
            ,KNOWN_AS
            ,EMAIL_ADDRESS
            ,EMPLOYEE_NUMBER
            ,APPLICANT_NUMBER
            ,NPW_NUMBER
            ,PREVIOUS_LAST_NAME
            ,PER_INFORMATION1
            ,PER_INFORMATION2
            ,PER_INFORMATION3
            ,PER_INFORMATION4
            ,PER_INFORMATION5
            ,PER_INFORMATION6
            ,PER_INFORMATION7
            ,PER_INFORMATION8
            ,PER_INFORMATION9
            ,PER_INFORMATION10
            ,PER_INFORMATION11
            ,PER_INFORMATION12
            ,PER_INFORMATION13
            ,PER_INFORMATION14
            ,PER_INFORMATION15
            ,PER_INFORMATION16
            ,PER_INFORMATION17
            ,PER_INFORMATION18
            ,PER_INFORMATION19
            ,PER_INFORMATION20
            ,PER_INFORMATION21
            ,PER_INFORMATION22
            ,PER_INFORMATION23
            ,PER_INFORMATION24
            ,PER_INFORMATION25
            ,PER_INFORMATION26
            ,PER_INFORMATION27
            ,PER_INFORMATION28
            ,PER_INFORMATION29
            ,PER_INFORMATION30
            ,ATTRIBUTE1
            ,ATTRIBUTE2
            ,ATTRIBUTE3
            ,ATTRIBUTE4
            ,ATTRIBUTE5
            ,ATTRIBUTE6
            ,ATTRIBUTE7
            ,ATTRIBUTE8
            ,ATTRIBUTE9
            ,ATTRIBUTE10
            ,ATTRIBUTE11
            ,ATTRIBUTE12
            ,ATTRIBUTE13
            ,ATTRIBUTE14
            ,ATTRIBUTE15
            ,ATTRIBUTE16
            ,ATTRIBUTE17
            ,ATTRIBUTE18
            ,ATTRIBUTE19
            ,ATTRIBUTE20
            ,ATTRIBUTE21
            ,ATTRIBUTE22
            ,ATTRIBUTE23
            ,ATTRIBUTE24
            ,ATTRIBUTE25
            ,ATTRIBUTE26
            ,ATTRIBUTE27
            ,ATTRIBUTE28
            ,ATTRIBUTE29
            ,ATTRIBUTE30
            ,FULL_NAME
            ,ORDER_NAME
            ,LOCAL_NAME
            ,GLOBAL_NAME
            ,BUSINESS_GROUP_ID
       from per_all_people_f
      where rowid = cp_row_id
        for update nowait;
  --
  cursor csr_get_rows_toUpd is
    select peo.rowid, bg.legislation_code
      from per_all_people_f         peo
          ,per_business_groups_perf bg
     where (peo.global_name is null or peo.local_name is null)
       and peo.business_group_id = bg.business_group_id;
  --
BEGIN
  l_num_rows_processed := 0;
  l_total_rows         := 0;
  l_commit             := 100;
  --
  -- initialize mask information
  --
  g_prm_legislation_code := NULL;
  g_prm_format_name := NULL;
  g_prm_scope := null;
  cache_mask_info(p_legislation_code  => g_prm_legislation_code
                 ,p_format_name       => g_prm_format_name
                 ,p_scope             => g_prm_scope);
  --
  open csr_get_rows_toUpd;
  --
  loop
  --
    fetch csr_get_rows_toUpd bulk collect into
         l_rowids_tab, l_leg_code_tab limit l_limit;
         l_prev_collect := l_curr_collect;
         l_curr_collect := csr_get_rows_toUpd%rowcount;
         l_diff_collect := l_curr_collect - l_prev_collect;
      --
      if l_diff_collect > 0 then
         --
         for i in l_rowids_tab.first..l_rowids_tab.last loop
          --
          -- synchronize names in table
          --
            for people_rec in csr_get_person(l_rowids_tab(i)) loop
              --
              sync_person_names
                (p_rowid              => people_rec.row_id
                ,p_person_id          => null
                ,p_person_rec         => people_rec
                ,p_legislation_code   => l_leg_code_tab(i)
                ,p_format_name        => g_LIST_NAME
                ,p_user_format_choice => NULL       -- this will update local and global
                ,p_num_rows_processed => l_num_rows_processed);
              l_total_rows := l_total_rows + l_num_rows_processed;
            end loop;
            if l_total_rows >= l_commit then
              l_total_rows := 0;
              commit;
            end if;
         end loop;
         --
      end if;
      --
    -- Exiting, if the present fetch is NOT returning any new rows
    exit when (l_diff_collect = 0);
    --
  --
  end loop;
  --
  close csr_get_rows_toUpd;
  --
  retcode := 0;
  errbuf := NULL;
EXCEPTION when others then
  retcode := 2;
  errbuf  := substr(SQLERRM,1,512);
  --
END sync_list_name;
--
-- ----------------------------------------------------------------------------
-- |-----------------------< submit_sync_names >------------------------------|
-- ----------------------------------------------------------------------------
--
procedure submit_sync_names
      (errbuf 		                 out NOCOPY varchar2
      ,retcode 		                 out NOCOPY number
      ,p_effective_date 	         varchar2
      ,p_action_parameter_group_id varchar2
      ,p_format_name_choice        varchar2
      ,p_legislation_code          varchar2
      ,p_format_name               varchar2
      ,p_user_format_choice        varchar2
      ,p_disable_who_triggers      varchar2
      ) is

  l_proc            CONSTANT  varchar2(100) := g_package||'submit_sync_names';
  l_business_group_id         number;
  l_action_parameter_group_id number;
  l_logging                   pay_action_parameters.parameter_value%TYPE;
  l_request_id                number;
  l_effective_date            varchar2(50);
  l_update_date               date;
  l_debug                     boolean;
  l_success                   boolean;
  l_status                    varchar2(100);
  l_phase                     varchar2(100);
  l_dev_status                varchar2(100);
  l_dev_phase                 varchar2(100);
  l_message                   varchar2(100);
  l_request_data              varchar2(100);
  l_format_name               hr_name_formats.format_name%TYPE;
  l_user_format_choice        hr_name_formats.user_format_choice%TYPE;
  l_call_status boolean;
  l_trigger_error             varchar2(512);
  l_data_migrator_mode 	      varchar2(30); -- For Bug 5581236
--
begin
  l_debug := FALSE;
  l_effective_date := p_effective_date; --fnd_date.date_to_canonical(p_effective_date);
  l_action_parameter_group_id := to_number(p_action_parameter_group_id);
  l_update_date    := trunc(sysdate);
  l_trigger_error  := null;
  -- For Bug 5581236
  l_data_migrator_mode := hr_general.g_data_migrator_mode;
  hr_general.g_data_migrator_mode := 'Y';
  --
  -- Perform restart checking....
  --
  l_request_data := fnd_conc_global.request_data;
  if l_request_data is not null then
   l_call_status :=  fnd_concurrent.get_request_status(
                                    request_id => l_request_data,
                                    phase      => l_phase,
                                    status     => l_status,
                                    dev_phase  => l_dev_phase,
                                    dev_status => l_dev_status,
                                    message    => l_message);


   if  l_dev_phase = 'COMPLETE' and l_dev_status = 'ERROR' then
      errbuf := l_message;
      retcode := 2;
   else
      l_trigger_error := null;
      if p_disable_who_triggers = 'Y' then
        alter_who_trigger('ENABLE', l_trigger_error);
      end if;
      if l_trigger_error is not null then
        errbuf := l_trigger_error;
        retcode := 2;
      else
        retcode := 0;
      end if;
   end if;
  return;
  end if;
  --
  -- verify "disable who trigger" parameter
  --
  if p_disable_who_triggers = 'Y' then
    alter_who_trigger('DISABLE', l_trigger_error);
  end if;
  if l_trigger_error is not null then
    errbuf := l_trigger_error;
    retcode := 2;
  else
  --
    if hr_general.chk_product_installed(800) = 'TRUE' then


        l_request_id := fnd_request.submit_request
             (application => 'PER',
              program     => 'PERNMFT_INT',
              sub_request => TRUE,
              argument1   => 'ARCHIVE',
              argument2   => 'PERNMFT',        -- report type
              argument3   => 'PERNMFT',        -- report qualifier
              argument4   => l_effective_date, -- start date
              argument5   => l_effective_date, -- effective date
              argument6   => 'PROCESS',        -- report category
              argument7   => fnd_profile.value('PER_BUSINESS_GROUP_ID'),
              argument8   => null,             -- magnetic filename
              argument9   => null,             -- report filename
              argument10  => l_action_parameter_group_id,
              argument11  => 'FORMAT_NAME_CHOICE='||p_format_name_choice,
              argument12  => 'LEGISLATION_CODE='||p_legislation_code,
              argument13  => 'FORMAT_NAME='||p_format_name,
              argument14  => 'USER_FORMAT_CHOICE='||p_user_format_choice);
        --
        -- Set the status of the process and then exit until the sub-requests
        -- have completed.
        --
        if l_request_id = 0 then
          if p_disable_who_triggers = 'Y' then
            alter_who_trigger('ENABLE', l_trigger_error);
          end if;
        	errbuf := fnd_message.get;
        	retcode := 2;
        else
          fnd_conc_global.set_req_globals(conc_status  => 'PAUSED',
                                          request_data => l_request_id );
      	retcode := 0;
        end if;
      else
        --
        -- this is a SHARED HR installation
        --
        if p_format_name = 'V' then -- LIST NAME format (local and global)
          sync_list_name(errbuf, retcode);
          if p_disable_who_triggers = 'Y' then
            alter_who_trigger('ENABLE', l_trigger_error);
          end if; -- prm setting
        end if; -- format = List Name?
      --
      end if; -- prod installed
  end if; -- trigger error
  -- For Bug 5581236
  hr_general.g_data_migrator_mode := l_data_migrator_mode;
end submit_sync_names;
--
-- --------------------------------------------------------------------------+
--                           ValidateRun
-- --------------------------------------------------------------------------+
--
PROCEDURE ValidateRun(p_result OUT nocopy varchar2) IS
  l_result varchar2(10);
BEGIN
   l_result := hr_update_utility.isUpdateComplete
      (p_app_shortname      => 'PER'
      ,p_function_name      => null
      ,p_business_group_id  => null
      ,p_update_name        => 'PERNMFT');
   --
   if l_result = 'FALSE' then
      p_result := 'TRUE';
   else
     p_result := 'FALSE';
   end if;
   --
END ValidateRun;
--
--
END HR_NMF_SYNC;

/
