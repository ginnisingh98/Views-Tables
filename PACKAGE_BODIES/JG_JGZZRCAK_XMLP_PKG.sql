--------------------------------------------------------
--  DDL for Package Body JG_JGZZRCAK_XMLP_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."JG_JGZZRCAK_XMLP_PKG" AS
/* $Header: JGZZRCAKB.pls 120.2 2007/12/25 16:05:50 npannamp noship $ */
  FUNCTION BEFOREREPORT RETURN BOOLEAN IS
  BEGIN
    P_CONC_REQUEST_ID := FND_GLOBAL.CONC_REQUEST_ID;
    /*SRW.USER_EXIT('FND SRWINIT')*/NULL;
    IF (P_DEBUG_SWITCH = 'Y') THEN
      /*SRW.MESSAGE(1
                 ,'After SRWINIT.')*/NULL;
    END IF;
    DECLARE
      COAID NUMBER;
      LEDNAME VARCHAR2(30);
      FUNCURR VARCHAR2(15);
      ERRBUF VARCHAR2(132);
      P_PRECISION NUMBER;
      P_EXT_PRECISION NUMBER;
      P_MIN_ACCT_UNIT NUMBER;
      ORG_ID NUMBER;
    BEGIN
      GL_INFO.GL_GET_LEDGER_INFO(P_SOB_ID
                                ,COAID
                                ,LEDNAME
                                ,FUNCURR
                                ,ERRBUF);
      IF (ERRBUF IS NOT NULL) THEN
        /*SRW.MESSAGE(4
                   ,ERRBUF)*/NULL;
        /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
      END IF;
      CP_FUNC_CURRENCY := FUNCURR;
      CP_STRUCT_NUM := COAID;
      CP_SOB_NAME := LEDNAME;
      GET_INFO(CP_FUNC_CURRENCY
              ,P_PRECISION
              ,P_EXT_PRECISION
              ,P_MIN_ACCT_UNIT);
      CP_PRECISION := P_PRECISION;
      SELECT
        TO_CHAR(SYSDATE
               ,'DD-MON-YYYY HH24:MI:SS')
      INTO CP_SYSDATE
      FROM
        DUAL;
      CP_LETTER_DATE := SUBSTR(CP_SYSDATE
                              ,1
                              ,11);
      ORG_ID := MO_GLOBAL.GET_CURRENT_ORG_ID;
      CP_COUNTRY_CODE := JG_ZZ_SHARED_PKG.GET_COUNTRY(ORG_ID);
      P_ORG_ID := ORG_ID;
      IF CP_COUNTRY_CODE = NULL THEN
        /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
      END IF;
      IF (P_DEBUG_SWITCH = 'Y') THEN
        /*SRW.BREAK*/NULL;
      END IF;
      DECLARE
        CURSOR GET_DOC_SEQUENCE_INFO IS
          SELECT
            DSC.NAME,
            DS.DOC_SEQUENCE_ID,
            DSU.NEXTVAL
          FROM
            FND_DOC_SEQUENCE_CATEGORIES DSC,
            FND_DOCUMENT_SEQUENCES DS,
            FND_DOC_SEQUENCE_ASSIGNMENTS DSA,
            FND_DOC_SEQUENCE_USERS DSU
          WHERE DSA.CATEGORY_CODE = DSC.CODE
            AND DSA.APPLICATION_ID = DSC.APPLICATION_ID
            AND DS.DOC_SEQUENCE_ID = DSA.DOC_SEQUENCE_ID
            AND DSU.DOC_SEQUENCE_ID = DSA.DOC_SEQUENCE_ID
            AND DSA.DOC_SEQUENCE_ASSIGNMENT_ID = P_DOC_SEQ_ASSIGN_ID
            AND DSA.SET_OF_BOOKS_ID = P_SOB_ID
            AND DSA.END_DATE is NULL;
        CURSOR GET_CUST_NAME IS
          SELECT
            DISTINCT
            MIN(HP.PARTY_NAME),
            MAX(HP.PARTY_NAME)
          FROM
            AR_CASH_RECEIPTS ACR,
            HZ_PARTIES HP,
            HZ_CUST_ACCOUNTS HCA
          WHERE ( ACR.GLOBAL_ATTRIBUTE1 is NULL
            AND ACR.GLOBAL_ATTRIBUTE2 is NULL )
            AND HP.PARTY_ID = HCA.PARTY_ID
            AND HCA.CUST_ACCOUNT_ID = ACR.PAY_FROM_CUSTOMER;
        CURSOR GET_RECEIPT_DATES IS
          SELECT
            DISTINCT
            MIN(RECEIPT_DATE),
            MAX(RECEIPT_DATE)
          FROM
            AR_CASH_RECEIPTS CR
          WHERE ( CR.GLOBAL_ATTRIBUTE1 is NULL
            AND CR.GLOBAL_ATTRIBUTE2 is NULL );
        CURSOR GET_LOCATION_INFO IS
          SELECT
            SUBSTR(HR.LOCATION_CODE
                  ,1
                  ,20),
            SUBSTR(HR.ADDRESS_LINE_1
                  ,1
                  ,60),
            SUBSTR(HR.ADDRESS_LINE_2
                  ,1
                  ,60),
            SUBSTR(HR.ADDRESS_LINE_3
                  ,1
                  ,60),
            HR.POSTAL_CODE || ' ' || HR.TOWN_OR_CITY,
            FT2.TERRITORY_SHORT_NAME,
            HR.TELEPHONE_NUMBER_1,
            HR.TELEPHONE_NUMBER_2,
            HR.TELEPHONE_NUMBER_3,
            XFI.REGISTRATION_NUMBER
          FROM
            HR_LOCATIONS HR,
            XLE_FIRSTPARTY_INFORMATION_V XFI,
            FND_TERRITORIES_VL FT2
          WHERE XFI.LEGAL_ENTITY_ID = P_ORG_ID
            AND XFI.LOCATION_ID = HR.LOCATION_ID
            AND FT2.TERRITORY_CODE = HR.COUNTRY
            AND HR.OFFICE_SITE_FLAG = 'Y';
      BEGIN
        OPEN GET_LOCATION_INFO;
        FETCH GET_LOCATION_INFO
         INTO CP_HR_LOCATION,CP_HR_ADDRESS1,CP_HR_ADDRESS2,CP_HR_ADDRESS3,CP_HR_CITY,CP_HR_TERRITORY,CP_HR_TELEPHONE,CP_HR_FAX,CP_HR_TELEPHONE3,CP_HR_TAX_ID;
        CLOSE GET_LOCATION_INFO;
        IF (P_REPRINT = 'N') THEN
          IF ((P_RA_FROM IS NOT NULL) OR (P_RA_TO IS NOT NULL)) THEN
            SET_NAME('JG'
                    ,'JG_ZZ_ACK_CREATE');
            /*SRW.MESSAGE(12
                       ,GET)*/NULL;
            /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
          END IF;
          OPEN GET_DOC_SEQUENCE_INFO;
          FETCH GET_DOC_SEQUENCE_INFO
           INTO CP_CATEGORY,CP_DOC_SEQ_ID,P_RA_FROM;
          CLOSE GET_DOC_SEQUENCE_INFO;
          IF ((P_CUSTOMER_FROM IS NULL) AND (P_CUSTOMER_TO IS NULL)) THEN
            OPEN GET_CUST_NAME;
            FETCH GET_CUST_NAME
             INTO P_CUSTOMER_FROM,P_CUSTOMER_TO;
            CLOSE GET_CUST_NAME;
          ELSIF (P_CUSTOMER_FROM IS NULL) THEN
            P_CUSTOMER_FROM := P_CUSTOMER_TO;
          ELSIF (P_CUSTOMER_TO IS NULL) THEN
            P_CUSTOMER_TO := P_CUSTOMER_FROM;
          ELSIF (P_CUSTOMER_FROM > P_CUSTOMER_TO) THEN
            /*SRW.MESSAGE(18
                       ,'P_CUSTOMER_FROM is larger than P_CUSTOMER_TO.')*/NULL;
            /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
          END IF;
          IF ((P_RECEIPT_FROM IS NULL) AND (P_RECEIPT_TO IS NULL)) THEN
            OPEN GET_RECEIPT_DATES;
            FETCH GET_RECEIPT_DATES
             INTO P_RECEIPT_FROM,P_RECEIPT_TO;
            CLOSE GET_RECEIPT_DATES;
          ELSIF (P_RECEIPT_FROM IS NULL) THEN
            P_RECEIPT_FROM := P_RECEIPT_TO;
          ELSIF (P_RECEIPT_TO IS NULL) THEN
            P_RECEIPT_TO := P_RECEIPT_FROM;
          ELSIF (P_RECEIPT_FROM > P_RECEIPT_TO) THEN
            /*SRW.MESSAGE(20
                       ,'P_RECEIPT_FROM is larger than P_RECEIPT_TO.')*/NULL;
            /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
          END IF;
          CP_WHERE_RECEIPT_DATES := 'cr.receipt_date between to_date(' || '''' || TO_CHAR(P_RECEIPT_FROM) || '''' || ',''DD-MON-RR'') AND
                                              to_date(' || '''' || TO_CHAR(P_RECEIPT_TO) || '''' || ',''DD-MON-RR'')';
          CUSTOMER_RECEIPTS(P_CUSTOMER_FROM
                           ,P_CUSTOMER_TO);
        ELSE
          IF ((P_RA_FROM IS NULL) AND (P_RA_TO IS NULL)) THEN
            SET_NAME('JG'
                    ,'JG_ZZ_ACK_REPRINT');
            /*SRW.MESSAGE(24
                       ,GET)*/NULL;
            /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
          ELSIF (P_RA_TO IS NULL) THEN
            P_RA_TO := P_RA_FROM;
          ELSIF (P_RA_FROM IS NULL) THEN
            P_RA_FROM := P_RA_TO;
          ELSIF (P_RA_FROM > P_RA_TO) THEN
            /*SRW.MESSAGE(28
                       ,'P_RA_FROM is larger than P_RA_TO.')*/NULL;
            /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
          END IF;
          SELECT
            DISTINCT
            MIN(RECEIPT_DATE),
            MAX(RECEIPT_DATE)
          INTO P_RECEIPT_FROM,P_RECEIPT_TO
          FROM
            AR_CASH_RECEIPTS CR
          WHERE TO_NUMBER(CR.GLOBAL_ATTRIBUTE1) >= P_RA_FROM
            AND TO_NUMBER(CR.GLOBAL_ATTRIBUTE1) <= P_RA_TO;
          IF (P_RECEIPT_FROM IS NULL) AND (P_RECEIPT_TO IS NULL) THEN
            /*SRW.MESSAGE(32
                       ,'The receipt sequence number has been modified manually!')*/NULL;
            /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
          END IF;
        END IF;
        CP_DATE_FROM := TO_CHAR(P_RECEIPT_FROM
                               ,'DD-MON-YYYY');
        CP_DATE_TO := TO_CHAR(P_RECEIPT_TO
                             ,'DD-MON-YYYY');
      END;
      IF (P_DEBUG_SWITCH = 'Y') THEN
        /*SRW.BREAK*/NULL;
      END IF;
    EXCEPTION
      WHEN OTHERS THEN
        /*SRW.MESSAGE(888
                   ,'Error in BeforeReport Trigger.')*/NULL;
        /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
    END;
    RETURN (TRUE);
  END BEFOREREPORT;

  FUNCTION AFTERREPORT RETURN BOOLEAN IS
  BEGIN
    /*SRW.USER_EXIT('FND SRWEXIT')*/NULL;
    RETURN (TRUE);
  END AFTERREPORT;

  FUNCTION CF_WORD_AMOUNTFORMULA(C_CURR_TOTAL_CURRENCY IN VARCHAR2
                                ,CS_CURR_TOTAL IN NUMBER) RETURN VARCHAR2 IS
  BEGIN
    DECLARE
      L_WORD_TEXT VARCHAR2(240);
      L_WIDTH NUMBER := 58;
      L_PRECISION NUMBER;
      L_CURRENCY_NAME VARCHAR2(80);
    BEGIN
      IF (C_CURR_TOTAL_CURRENCY <> 'PTE') THEN
        SELECT
          NAME,
          PRECISION
        INTO L_CURRENCY_NAME,L_PRECISION
        FROM
          FND_CURRENCIES_VL
        WHERE CURRENCY_CODE = C_CURR_TOTAL_CURRENCY;
        CP_UNIT_SINGULAR := L_CURRENCY_NAME;
        CP_UNIT_PLURAL := L_CURRENCY_NAME;
        CP_SUB_UNIT_SINGULAR := '';
        CP_SUB_UNIT_PLURAL := '';
        CP_UNIT_RATIO := POWER(10
                              ,L_PRECISION);
      ELSE
        CP_UNIT_SINGULAR := 'Escudo';
        CP_UNIT_PLURAL := 'Escudos';
        CP_SUB_UNIT_SINGULAR := 'Centavo';
        CP_SUB_UNIT_PLURAL := 'Centavos';
        CP_UNIT_RATIO := 100;
      END IF;
      L_WORD_TEXT := GET_WORD_VALUE(CS_CURR_TOTAL
                                   ,CP_UNIT_SINGULAR
                                   ,CP_UNIT_PLURAL
                                   ,CP_SUB_UNIT_SINGULAR
                                   ,CP_SUB_UNIT_PLURAL
                                   ,CP_UNIT_RATIO);
      L_WORD_TEXT := L_WORD_TEXT || ' ';
      IF NVL(LENGTH(L_WORD_TEXT)
         ,0) <= L_WIDTH THEN
        L_WORD_TEXT := RPAD(L_WORD_TEXT
                           ,L_WIDTH
                           ,'*');
      ELSIF NVL(LENGTH(L_WORD_TEXT)
         ,0) <= L_WIDTH * 2 THEN
        L_WORD_TEXT := RPAD(L_WORD_TEXT
                           ,L_WIDTH * 2 - (L_WIDTH - INSTR(SUBSTR(L_WORD_TEXT
                                       ,1
                                       ,L_WIDTH + 1)
                                ,' '
                                ,-1))
                           ,'*');
      ELSIF NVL(LENGTH(L_WORD_TEXT)
         ,0) <= L_WIDTH * 3 THEN
        L_WORD_TEXT := RPAD(L_WORD_TEXT
                           ,L_WIDTH * 3
                           ,'*');
      END IF;
      RETURN (L_WORD_TEXT);
    EXCEPTION
      WHEN OTHERS THEN
        NULL;
    END;
    RETURN NULL;
  END CF_WORD_AMOUNTFORMULA;

  PROCEDURE CUSTOMER_RECEIPTS(FROM_CUST IN VARCHAR2
                             ,TO_CUST IN VARCHAR2) IS
    CURSOR CUR_CUST(C_FROM IN VARCHAR2,C_TO IN VARCHAR2) IS
      SELECT
        DISTINCT
        HCA.CUST_ACCOUNT_ID,
        CR.CURRENCY_CODE,
        HCSU.SITE_USE_ID
      FROM
        HZ_PARTIES HP,
        HZ_CUST_ACCOUNTS HCA,
        HZ_CUST_SITE_USES HCSU,
        HZ_LOCATIONS HL,
        HZ_CUST_ACCT_SITES HCAS,
        AR_CASH_RECEIPTS CR,
        AR_CASH_RECEIPT_HISTORY CRH,
        HZ_PARTY_SITES HPS
      WHERE HP.PARTY_ID = HCA.PARTY_ID
        AND ( HP.PARTY_NAME >= C_FROM
        AND HP.PARTY_NAME <= C_TO )
        AND HCA.CUST_ACCOUNT_ID = HCAS.CUST_ACCOUNT_ID
        AND HCAS.CUST_ACCT_SITE_ID = HCSU.CUST_ACCT_SITE_ID
        AND HP.PARTY_ID = HPS.PARTY_ID
        AND HL.LOCATION_ID = HPS.LOCATION_ID
        AND UPPER(HCSU.SITE_USE_CODE) = 'BILL_TO'
        AND HCSU.GLOBAL_ATTRIBUTE1 = 'Y'
        AND ( CR.GLOBAL_ATTRIBUTE1 is NULL
        AND CR.GLOBAL_ATTRIBUTE2 is NULL )
        AND CR.RECEIPT_DATE >= P_RECEIPT_FROM
        AND CR.RECEIPT_DATE <= P_RECEIPT_TO
        AND CRH.STATUS = 'CLEARED'
        AND CRH.CASH_RECEIPT_ID = CR.CASH_RECEIPT_ID
        AND CR.PAY_FROM_CUSTOMER = HCA.CUST_ACCOUNT_ID;
    CURSOR UPDATE_AR_CASH_RECEIPTS(C_CUST IN NUMBER,C_CURRENCY IN VARCHAR2,C_SITE_USE_ID IN NUMBER) IS
      SELECT
        ROWID
      FROM
        AR_CASH_RECEIPTS CR
      WHERE CR.PAY_FROM_CUSTOMER = C_CUST
        AND CR.CURRENCY_CODE = C_CURRENCY
        AND CR.CUSTOMER_SITE_USE_ID = C_SITE_USE_ID
        AND CR.GLOBAL_ATTRIBUTE1 is NULL
        AND CR.GLOBAL_ATTRIBUTE2 is NULL
        AND CR.RECEIPT_DATE >= P_RECEIPT_FROM
        AND CR.RECEIPT_DATE <= P_RECEIPT_TO
        AND exists (
        SELECT
          CRH.CASH_RECEIPT_ID
        FROM
          AR_CASH_RECEIPT_HISTORY CRH
        WHERE CRH.STATUS = 'CLEARED'
          AND CRH.CASH_RECEIPT_ID = CR.CASH_RECEIPT_ID );
    C_CUST NUMBER;
    C_CURRENCY VARCHAR2(3);
    C_RECEIPT NUMBER;
    C_SITE_USE_ID NUMBER;
    L_BATCH NUMBER;
    L_COUNT NUMBER;
  BEGIN
    L_BATCH := 1000;
    L_COUNT := 0;
    FOR customer_row IN CUR_CUST(FROM_CUST, TO_CUST) LOOP
      C_CUST := CUSTOMER_ROW.CUST_ACCOUNT_ID;
      C_CURRENCY := CUSTOMER_ROW.CURRENCY_CODE;
      C_SITE_USE_ID := CUSTOMER_ROW.SITE_USE_ID;
      C_RECEIPT := GET_NEXT_USER_SEQUENCE('0'
                                         ,P_DOC_SEQ_ASSIGN_ID
                                         ,CP_DOC_SEQ_ID);
      CP_DOC_VALUE := C_RECEIPT;
      P_RA_TO := C_RECEIPT;
      AR_DOC_SEQUENCE_AUDIT_P;
      FOR receipt_row IN UPDATE_AR_CASH_RECEIPTS(C_CUST,C_CURRENCY,C_SITE_USE_ID) LOOP
        UPDATE
          AR_CASH_RECEIPTS cr
        SET
          CR.GLOBAL_ATTRIBUTE1 = C_RECEIPT
          ,CR.GLOBAL_ATTRIBUTE2 = TO_CHAR(SYSDATE
                 ,'YYYY/MM/DD HH24:MI:SS')
          ,CR.GLOBAL_ATTRIBUTE3 = CP_CATEGORY
        WHERE CR.ROWID = RECEIPT_ROW.ROWID;
        L_COUNT := L_COUNT + 1;
        IF (L_COUNT = L_BATCH) THEN
          COMMIT;
          L_COUNT := 0;
        END IF;
      END LOOP;
    END LOOP;
    IF (L_COUNT < L_BATCH) THEN
      COMMIT;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      /*SRW.MESSAGE(999
                 ,'Error in procedure - Customer_Receipts' || TO_CHAR(SQLCODE))*/NULL;
      /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
  END CUSTOMER_RECEIPTS;

  PROCEDURE AR_DOC_SEQUENCE_AUDIT_P IS
  BEGIN
    INSERT INTO AR_DOC_SEQUENCE_AUDIT
      (DOC_SEQUENCE_ID
      ,DOC_SEQUENCE_ASSIGNMENT_ID
      ,DOC_SEQUENCE_VALUE
      ,CREATION_DATE
      ,CREATED_BY)
    VALUES   (CP_DOC_SEQ_ID
      ,P_DOC_SEQ_ASSIGN_ID
      ,CP_DOC_VALUE
      ,SYSDATE
      ,0);
  END AR_DOC_SEQUENCE_AUDIT_P;

  FUNCTION CF_COUNTFORMULA(CS_INV_APPLIED_AMT IN NUMBER) RETURN NUMBER IS
  BEGIN
    IF (CS_INV_APPLIED_AMT = 0) THEN
      RETURN (0);
    ELSE
      RETURN (1);
    END IF;
  END CF_COUNTFORMULA;

  FUNCTION CONVERT_NUMBER2(SEGMENT IN NUMBER) RETURN VARCHAR2 IS
    VALUE_TEXT VARCHAR2(80) := '';
    V_CENTENAS VARCHAR2(12);
    CENTENAS NUMBER := POWER(10
         ,2);
    V_DEZENAS VARCHAR2(10);
    DEZENAS NUMBER := 10;
    V_UNIDADES VARCHAR2(10);
    CURRENT_SEG VARCHAR2(80);
    RESTO VARCHAR2(3);
    NUM INTEGER := SEGMENT;
  BEGIN
    CURRENT_SEG := TRUNC(NUM / CENTENAS);
    RESTO := MOD(NUM
                ,CENTENAS);
    NUM := NUM - (CURRENT_SEG * CENTENAS);
    IF CURRENT_SEG <> 0 THEN
      IF CURRENT_SEG = 1 THEN
        IF RESTO = 0 THEN
          VALUE_TEXT := VALUE_TEXT || 'cem ';
        ELSE
          VALUE_TEXT := VALUE_TEXT || 'cento ';
        END IF;
      ELSIF CURRENT_SEG = 2 THEN
        VALUE_TEXT := VALUE_TEXT || 'duzentos ';
      ELSIF CURRENT_SEG = 3 THEN
        VALUE_TEXT := VALUE_TEXT || 'trezentos ';
      ELSIF CURRENT_SEG = 4 THEN
        VALUE_TEXT := VALUE_TEXT || 'quatrocentos ';
      ELSIF CURRENT_SEG = 5 THEN
        VALUE_TEXT := VALUE_TEXT || 'quinhentos ';
      ELSIF CURRENT_SEG = 6 THEN
        VALUE_TEXT := VALUE_TEXT || 'seiscentos ';
      ELSIF CURRENT_SEG = 7 THEN
        VALUE_TEXT := VALUE_TEXT || 'setecentos ';
      ELSIF CURRENT_SEG = 8 THEN
        VALUE_TEXT := VALUE_TEXT || 'oitocentos ';
      ELSIF CURRENT_SEG = 9 THEN
        VALUE_TEXT := VALUE_TEXT || 'novecentos ';
      END IF;
    END IF;
    CURRENT_SEG := TRUNC(NUM / DEZENAS);
    RESTO := MOD(NUM
                ,DEZENAS);
    NUM := NUM - (CURRENT_SEG * DEZENAS);
    IF CURRENT_SEG <> 0 THEN
      IF CURRENT_SEG = 1 THEN
        IF RESTO = 0 THEN
          VALUE_TEXT := VALUE_TEXT || 'dez ';
        ELSIF RESTO = 1 THEN
          VALUE_TEXT := VALUE_TEXT || 'onze ';
        ELSIF RESTO = 2 THEN
          VALUE_TEXT := VALUE_TEXT || 'doze ';
        ELSIF RESTO = 3 THEN
          VALUE_TEXT := VALUE_TEXT || 'treze ';
        ELSIF RESTO = 4 THEN
          VALUE_TEXT := VALUE_TEXT || 'catorze ';
        ELSIF RESTO = 5 THEN
          VALUE_TEXT := VALUE_TEXT || 'quinze ';
        ELSIF RESTO = 6 THEN
          VALUE_TEXT := VALUE_TEXT || 'dezasseis ';
        ELSIF RESTO = 7 THEN
          VALUE_TEXT := VALUE_TEXT || 'dezassete ';
        ELSIF RESTO = 8 THEN
          VALUE_TEXT := VALUE_TEXT || 'dezoito ';
        ELSIF RESTO = 9 THEN
          VALUE_TEXT := VALUE_TEXT || 'dezanove ';
        END IF;
      ELSIF CURRENT_SEG = 2 THEN
        VALUE_TEXT := VALUE_TEXT || 'vinte ';
      ELSIF CURRENT_SEG = 3 THEN
        VALUE_TEXT := VALUE_TEXT || 'trinta ';
      ELSIF CURRENT_SEG = 4 THEN
        VALUE_TEXT := VALUE_TEXT || 'quarenta ';
      ELSIF CURRENT_SEG = 5 THEN
        VALUE_TEXT := VALUE_TEXT || 'cinquenta ';
      ELSIF CURRENT_SEG = 6 THEN
        VALUE_TEXT := VALUE_TEXT || 'sessenta ';
      ELSIF CURRENT_SEG = 7 THEN
        VALUE_TEXT := VALUE_TEXT || 'setenta ';
      ELSIF CURRENT_SEG = 8 THEN
        VALUE_TEXT := VALUE_TEXT || 'oitenta ';
      ELSIF CURRENT_SEG = 9 THEN
        VALUE_TEXT := VALUE_TEXT || 'noventa ';
      END IF;
    END IF;
    IF NUM <> 0 AND CURRENT_SEG <> 1 THEN
      IF NUM = 1 THEN
        VALUE_TEXT := VALUE_TEXT || 'um ';
      ELSIF NUM = 2 THEN
        VALUE_TEXT := VALUE_TEXT || 'dois ';
      ELSIF NUM = 3 THEN
        VALUE_TEXT := VALUE_TEXT || 'tres ';
      ELSIF NUM = 4 THEN
        VALUE_TEXT := VALUE_TEXT || 'quatro ';
      ELSIF NUM = 5 THEN
        VALUE_TEXT := VALUE_TEXT || 'cinco ';
      ELSIF NUM = 6 THEN
        VALUE_TEXT := VALUE_TEXT || 'seis ';
      ELSIF NUM = 7 THEN
        VALUE_TEXT := VALUE_TEXT || 'sete ';
      ELSIF NUM = 8 THEN
        VALUE_TEXT := VALUE_TEXT || 'oito ';
      ELSIF NUM = 9 THEN
        VALUE_TEXT := VALUE_TEXT || 'nove ';
      END IF;
    END IF;
    RETURN (VALUE_TEXT);
  END CONVERT_NUMBER2;

  FUNCTION CONVERT_NUMBER(IN_NUMERAL IN INTEGER := 0) RETURN VARCHAR2 IS
    NUMBER_TOO_LARGE EXCEPTION;
    NUMERAL INTEGER := ABS(IN_NUMERAL);
    MAX_DIGIT INTEGER := 12;
    NUMBER_TEXT VARCHAR2(240) := '';
    CURRENT_SEGMENT VARCHAR2(80);
    B_ZERO VARCHAR2(25) := 'Zero';
    B_THOUSAND VARCHAR2(25) := 'Mil ';
    THOUSAND NUMBER := POWER(10
         ,3);
    B_MILLION VARCHAR2(25) := 'Milh?o ';
    B_MILLIONS VARCHAR2(25) := 'Milh?es ';
    MILLION NUMBER := POWER(10
         ,6);
    B_BILLION VARCHAR2(25) := 'Bili?  ';
    B_BILLIONS VARCHAR2(25) := 'Bili?es ';
    BILLION NUMBER := POWER(10
         ,9);
  BEGIN
    IF NUMERAL >= POWER(10
         ,MAX_DIGIT) THEN
      RAISE NUMBER_TOO_LARGE;
    END IF;
    IF NUMERAL = 0 THEN
      RETURN (B_ZERO);
    END IF;
    CURRENT_SEGMENT := TRUNC(NUMERAL / BILLION);
    NUMERAL := NUMERAL - (CURRENT_SEGMENT * BILLION);
    IF CURRENT_SEGMENT <> 0 THEN
      IF CURRENT_SEGMENT = 1 THEN
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_BILLION;
      ELSE
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_BILLIONS;
      END IF;
    END IF;
    CURRENT_SEGMENT := TRUNC(NUMERAL / MILLION);
    NUMERAL := NUMERAL - (CURRENT_SEGMENT * MILLION);
    IF CURRENT_SEGMENT <> 0 THEN
      IF CURRENT_SEGMENT = 1 THEN
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_MILLION;
      ELSE
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_MILLIONS;
      END IF;
    END IF;
    CURRENT_SEGMENT := TRUNC(NUMERAL / THOUSAND);
    NUMERAL := NUMERAL - (CURRENT_SEGMENT * THOUSAND);
    IF CURRENT_SEGMENT <> 0 THEN
      IF CURRENT_SEGMENT = 1 THEN
        NUMBER_TEXT := NUMBER_TEXT || B_THOUSAND;
      ELSE
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_THOUSAND;
      END IF;
    END IF;
    IF NUMERAL <> 0 THEN
      NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(NUMERAL);
    END IF;
    NUMBER_TEXT := SUBSTR(NUMBER_TEXT
                         ,1
                         ,1) || RTRIM(LOWER(SUBSTR(NUMBER_TEXT
                                     ,2
                                     ,NVL(LENGTH(NUMBER_TEXT)
                                        ,0))));
    RETURN (NUMBER_TEXT);
    RETURN NULL;
  EXCEPTION
    WHEN NUMBER_TOO_LARGE THEN
      RETURN (NULL);
    WHEN OTHERS THEN
      RETURN (NULL);
  END CONVERT_NUMBER;

  FUNCTION GET_WORD_VALUE(P_AMOUNT IN NUMBER
                         ,P_UNIT_SINGULAR IN VARCHAR2
                         ,P_UNIT_PLURAL IN VARCHAR2
                         ,P_SUB_UNIT_SINGULAR IN VARCHAR2
                         ,P_SUB_UNIT_PLURAL IN VARCHAR2
                         ,P_UNIT_RATIO IN NUMBER) RETURN VARCHAR2 IS
    L_WORD_AMOUNT VARCHAR2(240) := CONVERT_NUMBER(TRUNC(P_AMOUNT));
    L_DECIMAL_PART NUMBER := TRUNC((P_AMOUNT - TRUNC(P_AMOUNT)) * P_UNIT_RATIO);
    L_WORD_AMOUNT2 VARCHAR2(240);
    L_CURRENCY_WORD VARCHAR2(240);
    L_LOG INTEGER;
    FUNCTION MY_LOG(A IN INTEGER
                   ,B IN INTEGER) RETURN NUMBER IS
    BEGIN
      IF A <> 10 THEN
        RETURN (NULL);
      ELSIF B > 0 AND B <= 10 THEN
        RETURN (1);
      ELSIF B > 10 AND B <= 100 THEN
        RETURN (2);
      ELSIF B > 100 AND B <= 1000 THEN
        RETURN (3);
      ELSE
        RETURN (NULL);
      END IF;
      RETURN NULL;
    END MY_LOG;
  BEGIN
    L_LOG := MY_LOG(10
                   ,P_UNIT_RATIO);
    IF (L_DECIMAL_PART > 0) THEN
      L_WORD_AMOUNT2 := CONVERT_NUMBER(L_DECIMAL_PART);
      SELECT
        INITCAP(LOWER('e' || ' ' || L_WORD_AMOUNT2 || ' ' || DECODE(L_DECIMAL_PART
                            ,1
                            ,P_SUB_UNIT_SINGULAR
                            ,P_SUB_UNIT_PLURAL)))
      INTO L_WORD_AMOUNT2
      FROM
        DUAL;
    END IF;
    IF P_UNIT_RATIO in (0,1) OR P_UNIT_RATIO IS NULL THEN
      SELECT
        INITCAP(LOWER(L_WORD_AMOUNT || ' ' || DECODE(TRUNC(P_AMOUNT)
                            ,1
                            ,P_UNIT_SINGULAR
                            ,P_UNIT_PLURAL)))
      INTO L_CURRENCY_WORD
      FROM
        DUAL;
    ELSE
      SELECT
        INITCAP(LOWER(L_WORD_AMOUNT || ' ' || DECODE(TRUNC(P_AMOUNT)
                            ,1
                            ,P_UNIT_SINGULAR
                            ,P_UNIT_PLURAL) || ' ' || L_WORD_AMOUNT2))
      INTO L_CURRENCY_WORD
      FROM
        DUAL;
    END IF;
    RETURN (L_CURRENCY_WORD);
  END GET_WORD_VALUE;

  FUNCTION PRECISION(CUR_CODE IN VARCHAR2) RETURN NUMBER IS
    L_PRECISION NUMBER;
  BEGIN
    SELECT
      PRECISION
    INTO L_PRECISION
    FROM
      FND_CURRENCIES_VL
    WHERE CURRENCY_CODE = CUR_CODE;
    RETURN (L_PRECISION);
  EXCEPTION
    WHEN OTHERS THEN
      /*SRW.MESSAGE(999
                 ,'Error in procedure - precision')*/NULL;
      /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
  END PRECISION;

  FUNCTION CP_FUNC_CURRENCY_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_FUNC_CURRENCY;
  END CP_FUNC_CURRENCY_P;

  FUNCTION CP_PRECISION_P RETURN NUMBER IS
  BEGIN
    RETURN CP_PRECISION;
  END CP_PRECISION_P;

  FUNCTION CP_STRUCT_NUM_P RETURN NUMBER IS
  BEGIN
    RETURN CP_STRUCT_NUM;
  END CP_STRUCT_NUM_P;

  FUNCTION CP_SOB_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_SOB_NAME;
  END CP_SOB_NAME_P;

  FUNCTION CP_WHERE_RECEIPT_DATES_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_WHERE_RECEIPT_DATES;
  END CP_WHERE_RECEIPT_DATES_P;

  FUNCTION CP_SUB_UNIT_PLURAL_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_SUB_UNIT_PLURAL;
  END CP_SUB_UNIT_PLURAL_P;

  FUNCTION CP_SUB_UNIT_SINGULAR_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_SUB_UNIT_SINGULAR;
  END CP_SUB_UNIT_SINGULAR_P;

  FUNCTION CP_UNIT_PLURAL_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_UNIT_PLURAL;
  END CP_UNIT_PLURAL_P;

  FUNCTION CP_UNIT_SINGULAR_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_UNIT_SINGULAR;
  END CP_UNIT_SINGULAR_P;

  FUNCTION CP_UNIT_RATIO_P RETURN NUMBER IS
  BEGIN
    RETURN CP_UNIT_RATIO;
  END CP_UNIT_RATIO_P;

  FUNCTION CP_SYSDATE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_SYSDATE;
  END CP_SYSDATE_P;

  FUNCTION CP_COUNTRY_CODE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_COUNTRY_CODE;
  END CP_COUNTRY_CODE_P;

  FUNCTION CP_DATE_FROM_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_DATE_FROM;
  END CP_DATE_FROM_P;

  FUNCTION CP_DATE_TO_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_DATE_TO;
  END CP_DATE_TO_P;

  FUNCTION CP_CATEGORY_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_CATEGORY;
  END CP_CATEGORY_P;

  FUNCTION CP_DOC_SEQ_ID_P RETURN NUMBER IS
  BEGIN
    RETURN CP_DOC_SEQ_ID;
  END CP_DOC_SEQ_ID_P;

  FUNCTION CP_DOC_VALUE_P RETURN NUMBER IS
  BEGIN
    RETURN CP_DOC_VALUE;
  END CP_DOC_VALUE_P;

  FUNCTION CP_LETTER_DATE_P RETURN DATE IS
  BEGIN
    RETURN CP_LETTER_DATE;
  END CP_LETTER_DATE_P;

  FUNCTION CP_HR_ADDRESS1_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_ADDRESS1;
  END CP_HR_ADDRESS1_P;

  FUNCTION CP_HR_ADDRESS2_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_ADDRESS2;
  END CP_HR_ADDRESS2_P;

  FUNCTION CP_HR_ADDRESS3_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_ADDRESS3;
  END CP_HR_ADDRESS3_P;

  FUNCTION CP_HR_CITY_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_CITY;
  END CP_HR_CITY_P;

  FUNCTION CP_HR_FAX_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_FAX;
  END CP_HR_FAX_P;

  FUNCTION CP_HR_LOCATION_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_LOCATION;
  END CP_HR_LOCATION_P;

  FUNCTION CP_HR_TAX_ID_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_TAX_ID;
  END CP_HR_TAX_ID_P;

  FUNCTION CP_HR_TELEPHONE_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_TELEPHONE;
  END CP_HR_TELEPHONE_P;

  FUNCTION CP_HR_TELEPHONE3_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_TELEPHONE3;
  END CP_HR_TELEPHONE3_P;

  FUNCTION CP_HR_TERRITORY_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_HR_TERRITORY;
  END CP_HR_TERRITORY_P;

  PROCEDURE JG_GET_SET_OF_BOOKS_INFO(SOBID IN NUMBER
                                    ,COAID OUT NOCOPY NUMBER
                                    ,SOBNAME OUT NOCOPY VARCHAR2
                                    ,FUNC_CURR OUT NOCOPY VARCHAR2
                                    ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
  JG_INFO.JG_GET_SET_OF_BOOKS_INFO(SOBID, COAID, SOBNAME, FUNC_CURR, ERRBUF);
    /*STPROC.INIT('begin JG_INFO.JG_GET_SET_OF_BOOKS_INFO(:SOBID, :COAID, :SOBNAME, :FUNC_CURR, :ERRBUF); end;');
    STPROC.BIND_I(SOBID);
    STPROC.BIND_O(COAID);
    STPROC.BIND_O(SOBNAME);
    STPROC.BIND_O(FUNC_CURR);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,COAID);
    STPROC.RETRIEVE(3
                   ,SOBNAME);
    STPROC.RETRIEVE(4
                   ,FUNC_CURR);
    STPROC.RETRIEVE(5
                   ,ERRBUF);*/
  END JG_GET_SET_OF_BOOKS_INFO;

  PROCEDURE JG_GET_BUD_OR_ENC_NAME(ACTUAL_TYPE IN VARCHAR2
                                  ,TYPE_ID IN NUMBER
                                  ,NAME OUT NOCOPY VARCHAR2
                                  ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
  JG_INFO.JG_GET_BUD_OR_ENC_NAME(ACTUAL_TYPE, TYPE_ID, NAME, ERRBUF);
    /*STPROC.INIT('begin JG_INFO.JG_GET_BUD_OR_ENC_NAME(:ACTUAL_TYPE, :TYPE_ID, :NAME, :ERRBUF); end;');
    STPROC.BIND_I(ACTUAL_TYPE);
    STPROC.BIND_I(TYPE_ID);
    STPROC.BIND_O(NAME);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(3
                   ,NAME);
    STPROC.RETRIEVE(4
                   ,ERRBUF);*/
  END JG_GET_BUD_OR_ENC_NAME;

  PROCEDURE JG_GET_LOOKUP_VALUE(LMODE IN VARCHAR2
                               ,CODE IN VARCHAR2
                               ,TYPE IN VARCHAR2
                               ,VALUE OUT NOCOPY VARCHAR2
                               ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
  JG_INFO.JG_GET_LOOKUP_VALUE(LMODE, CODE, TYPE, VALUE, ERRBUF);
   /* STPROC.INIT('begin JG_INFO.JG_GET_LOOKUP_VALUE(:LMODE, :CODE, :TYPE, :VALUE, :ERRBUF); end;');
    STPROC.BIND_I(LMODE);
    STPROC.BIND_I(CODE);
    STPROC.BIND_I(TYPE);
    STPROC.BIND_O(VALUE);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(4
                   ,VALUE);
    STPROC.RETRIEVE(5
                   ,ERRBUF);*/
  END JG_GET_LOOKUP_VALUE;

  PROCEDURE JG_GET_FIRST_PERIOD(APP_ID IN NUMBER
                               ,TSET_OF_BOOKS_ID IN NUMBER
                               ,TPERIOD_NAME IN VARCHAR2
                               ,TFIRST_PERIOD OUT NOCOPY VARCHAR2
                               ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
  JG_INFO.JG_GET_FIRST_PERIOD(APP_ID, TSET_OF_BOOKS_ID, TPERIOD_NAME, TFIRST_PERIOD, ERRBUF);
    /*STPROC.INIT('begin JG_INFO.JG_GET_FIRST_PERIOD(:APP_ID, :TSET_OF_BOOKS_ID, :TPERIOD_NAME, :TFIRST_PERIOD, :ERRBUF); end;');
    STPROC.BIND_I(APP_ID);
    STPROC.BIND_I(TSET_OF_BOOKS_ID);
    STPROC.BIND_I(TPERIOD_NAME);
    STPROC.BIND_O(TFIRST_PERIOD);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(4
                   ,TFIRST_PERIOD);
    STPROC.RETRIEVE(5
                   ,ERRBUF);*/
  END JG_GET_FIRST_PERIOD;

  PROCEDURE JG_GET_FIRST_PERIOD_OF_QUARTER(APP_ID IN NUMBER
                                          ,TSET_OF_BOOKS_ID IN NUMBER
                                          ,TPERIOD_NAME IN VARCHAR2
                                          ,TFIRST_PERIOD OUT NOCOPY VARCHAR2
                                          ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
  JG_INFO.JG_GET_FIRST_PERIOD_OF_QUARTER(APP_ID, TSET_OF_BOOKS_ID, TPERIOD_NAME, TFIRST_PERIOD, ERRBUF);
    /*STPROC.INIT('begin JG_INFO.JG_GET_FIRST_PERIOD_OF_QUARTER(:APP_ID, :TSET_OF_BOOKS_ID, :TPERIOD_NAME, :TFIRST_PERIOD, :ERRBUF); end;');
    STPROC.BIND_I(APP_ID);
    STPROC.BIND_I(TSET_OF_BOOKS_ID);
    STPROC.BIND_I(TPERIOD_NAME);
    STPROC.BIND_O(TFIRST_PERIOD);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(4
                   ,TFIRST_PERIOD);
    STPROC.RETRIEVE(5
                   ,ERRBUF);*/
  END JG_GET_FIRST_PERIOD_OF_QUARTER;

  FUNCTION JG_FORMAT_CURR_AMT(IN_PRECISION IN NUMBER
                             ,IN_AMOUNT_DISP IN VARCHAR2) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
  X0 := JG_INFO.JG_FORMAT_CURR_AMT(IN_PRECISION, IN_AMOUNT_DISP);
    /*STPROC.INIT('begin :X0 := JG_INFO.JG_FORMAT_CURR_AMT(:IN_PRECISION, :IN_AMOUNT_DISP); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(IN_PRECISION);
    STPROC.BIND_I(IN_AMOUNT_DISP);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END JG_FORMAT_CURR_AMT;

  FUNCTION GET_FORMAT_MASK(CURRENCY_CODE IN VARCHAR2
                          ,FIELD_LENGTH IN NUMBER) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
  X0 := FND_CURRENCY.GET_FORMAT_MASK(CURRENCY_CODE, FIELD_LENGTH);
    /*STPROC.INIT('begin :X0 := FND_CURRENCY.GET_FORMAT_MASK(:CURRENCY_CODE, :FIELD_LENGTH); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(CURRENCY_CODE);
    STPROC.BIND_I(FIELD_LENGTH);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_FORMAT_MASK;

  FUNCTION SAFE_GET_FORMAT_MASK(CURRENCY_CODE IN VARCHAR2
                               ,FIELD_LENGTH IN NUMBER) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
  X0 := FND_CURRENCY.SAFE_GET_FORMAT_MASK(CURRENCY_CODE, FIELD_LENGTH);
    /*STPROC.INIT('begin :X0 := FND_CURRENCY.SAFE_GET_FORMAT_MASK(:CURRENCY_CODE, :FIELD_LENGTH); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(CURRENCY_CODE);
    STPROC.BIND_I(FIELD_LENGTH);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END SAFE_GET_FORMAT_MASK;

  PROCEDURE GET_INFO(CURRENCY_CODE IN VARCHAR2
                    ,PRECISION OUT NOCOPY NUMBER
                    ,EXT_PRECISION OUT NOCOPY NUMBER
                    ,MIN_ACCT_UNIT OUT NOCOPY NUMBER) IS
  BEGIN
  FND_CURRENCY.GET_INFO(CURRENCY_CODE, PRECISION, EXT_PRECISION, MIN_ACCT_UNIT);
    /*STPROC.INIT('begin FND_CURRENCY.GET_INFO(:CURRENCY_CODE, :PRECISION, :EXT_PRECISION, :MIN_ACCT_UNIT); end;');
    STPROC.BIND_I(CURRENCY_CODE);
    STPROC.BIND_O(PRECISION);
    STPROC.BIND_O(EXT_PRECISION);
    STPROC.BIND_O(MIN_ACCT_UNIT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,PRECISION);
    STPROC.RETRIEVE(3
                   ,EXT_PRECISION);
    STPROC.RETRIEVE(4
                   ,MIN_ACCT_UNIT);*/
  END GET_INFO;

  PROCEDURE BUILD_FORMAT_MASK(FORMAT_MASK OUT NOCOPY VARCHAR2
                             ,FIELD_LENGTH IN NUMBER
                             ,PRECISION IN NUMBER
                             ,MIN_ACCT_UNIT IN NUMBER
                             ,DISP_GRP_SEP IN BOOLEAN
                             ,NEG_FORMAT IN VARCHAR2
                             ,POS_FORMAT IN VARCHAR2) IS
  --DISP_GRP_SEP BOOLEAN;
  begin
  --DISP_GRP_SEP := sys.diutil.int_to_bool(:DISP_GRP_SEP);
  FND_CURRENCY.BUILD_FORMAT_MASK(FORMAT_MASK, FIELD_LENGTH, PRECISION, MIN_ACCT_UNIT, DISP_GRP_SEP, NEG_FORMAT, POS_FORMAT);
    /*STPROC.INIT('declare DISP_GRP_SEP BOOLEAN; begin DISP_GRP_SEP := sys.diutil.int_to_bool(:DISP_GRP_SEP); FND_CURRENCY.BUILD_FORMAT_MASK(:FORMAT_MASK, :FIELD_LENGTH, :PRECISION, :MIN_ACCT_UNIT, DISP_GRP_SEP, :NEG_FORMAT, :POS_FORMAT); end;');
    STPROC.BIND_I(DISP_GRP_SEP);
    STPROC.BIND_O(FORMAT_MASK);
    STPROC.BIND_I(FIELD_LENGTH);
    STPROC.BIND_I(PRECISION);
    STPROC.BIND_I(MIN_ACCT_UNIT);
    STPROC.BIND_I(NEG_FORMAT);
    STPROC.BIND_I(POS_FORMAT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,FORMAT_MASK);*/
  END BUILD_FORMAT_MASK;

  PROCEDURE SAFE_BUILD_FORMAT_MASK(FORMAT_MASK OUT NOCOPY VARCHAR2
                                  ,FIELD_LENGTH IN NUMBER
                                  ,PRECISION IN NUMBER
                                  ,MIN_ACCT_UNIT IN NUMBER
                                  ,DISP_GRP_SEP IN BOOLEAN
                                  ,NEG_FORMAT IN VARCHAR2
                                  ,POS_FORMAT IN VARCHAR2) IS
    --DISP_GRP_SEP BOOLEAN;
    begin
    --DISP_GRP_SEP := sys.diutil.int_to_bool(:DISP_GRP_SEP);
    FND_CURRENCY.SAFE_BUILD_FORMAT_MASK(FORMAT_MASK, FIELD_LENGTH, PRECISION, MIN_ACCT_UNIT, DISP_GRP_SEP, NEG_FORMAT, POS_FORMAT);
    /*STPROC.INIT('declare DISP_GRP_SEP BOOLEAN; begin DISP_GRP_SEP := sys.diutil.int_to_bool(:DISP_GRP_SEP); FND_CURRENCY.SAFE_BUILD_FORMAT_MASK(:FORMAT_MASK, :FIELD_LENGTH, :PRECISION, :MIN_ACCT_UNIT, DISP_GRP_SEP, :NEG_FORMAT, :POS_FORMAT); end;');
    STPROC.BIND_I(DISP_GRP_SEP);
    STPROC.BIND_O(FORMAT_MASK);
    STPROC.BIND_I(FIELD_LENGTH);
    STPROC.BIND_I(PRECISION);
    STPROC.BIND_I(MIN_ACCT_UNIT);
    STPROC.BIND_I(NEG_FORMAT);
    STPROC.BIND_I(POS_FORMAT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,FORMAT_MASK);*/
  END SAFE_BUILD_FORMAT_MASK;

  PROCEDURE SET_NAME(APPLICATION IN VARCHAR2
                    ,NAME IN VARCHAR2) IS
  BEGIN
  FND_MESSAGE.SET_NAME(APPLICATION, NAME);
    /*STPROC.INIT('begin FND_MESSAGE.SET_NAME(:APPLICATION, :NAME); end;');
    STPROC.BIND_I(APPLICATION);
    STPROC.BIND_I(NAME);
    STPROC.EXECUTE;*/
  END SET_NAME;

  PROCEDURE SET_TOKEN(TOKEN IN VARCHAR2
                     ,VALUE IN VARCHAR2
                     ,TRANSLATE IN BOOLEAN) IS
  --TRANSLATE BOOLEAN;
  begin
  --TRANSLATE := sys.diutil.int_to_bool(:TRANSLATE);
  FND_MESSAGE.SET_TOKEN(TOKEN, VALUE, TRANSLATE);
   /* STPROC.INIT('declare TRANSLATE BOOLEAN; begin TRANSLATE := sys.diutil.int_to_bool(:TRANSLATE); FND_MESSAGE.SET_TOKEN(:TOKEN, :VALUE, TRANSLATE); end;');
    STPROC.BIND_I(TRANSLATE);
    STPROC.BIND_I(TOKEN);
    STPROC.BIND_I(VALUE);
    STPROC.EXECUTE;*/
  END SET_TOKEN;

  PROCEDURE RETRIEVE(MSGOUT OUT NOCOPY VARCHAR2) IS
  BEGIN
  FND_MESSAGE.RETRIEVE(MSGOUT);
    /*STPROC.INIT('begin FND_MESSAGE.RETRIEVE(:MSGOUT); end;');
    STPROC.BIND_O(MSGOUT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,MSGOUT);*/
  END RETRIEVE;

  PROCEDURE CLEAR IS
  BEGIN
  FND_MESSAGE.CLEAR;
    /*STPROC.INIT('begin FND_MESSAGE.CLEAR; end;');
    STPROC.EXECUTE;*/
  END CLEAR;

  FUNCTION GET_STRING(APPIN IN VARCHAR2
                     ,NAMEIN IN VARCHAR2) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
  X0 := FND_MESSAGE.GET_STRING(APPIN, NAMEIN);
    /*STPROC.INIT('begin :X0 := FND_MESSAGE.GET_STRING(:APPIN, :NAMEIN); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPIN);
    STPROC.BIND_I(NAMEIN);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_STRING;

  FUNCTION GET_NUMBER(APPIN IN VARCHAR2
                     ,NAMEIN IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
  X0 := FND_MESSAGE.GET_NUMBER(APPIN, NAMEIN);
    /*STPROC.INIT('begin :X0 := FND_MESSAGE.GET_NUMBER(:APPIN, :NAMEIN); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPIN);
    STPROC.BIND_I(NAMEIN);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_NUMBER;

  FUNCTION GET RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
  X0 := FND_MESSAGE.GET;
    /*STPROC.INIT('begin :X0 := FND_MESSAGE.GET; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET;

  FUNCTION GET_ENCODED RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
  X0 := FND_MESSAGE.GET_ENCODED;
    /*STPROC.INIT('begin :X0 := FND_MESSAGE.GET_ENCODED; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_ENCODED;

  PROCEDURE PARSE_ENCODED(ENCODED_MESSAGE IN VARCHAR2
                         ,APP_SHORT_NAME OUT NOCOPY VARCHAR2
                         ,MESSAGE_NAME OUT NOCOPY VARCHAR2) IS
  BEGIN
  FND_MESSAGE.PARSE_ENCODED(ENCODED_MESSAGE, APP_SHORT_NAME, MESSAGE_NAME);
    /*STPROC.INIT('begin FND_MESSAGE.PARSE_ENCODED(:ENCODED_MESSAGE, :APP_SHORT_NAME, :MESSAGE_NAME); end;');
    STPROC.BIND_I(ENCODED_MESSAGE);
    STPROC.BIND_O(APP_SHORT_NAME);
    STPROC.BIND_O(MESSAGE_NAME);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,APP_SHORT_NAME);
    STPROC.RETRIEVE(3
                   ,MESSAGE_NAME);*/
  END PARSE_ENCODED;

  PROCEDURE SET_ENCODED(ENCODED_MESSAGE IN VARCHAR2) IS
  BEGIN
  FND_MESSAGE.SET_ENCODED(ENCODED_MESSAGE);
    /*STPROC.INIT('begin FND_MESSAGE.SET_ENCODED(:ENCODED_MESSAGE); end;');
    STPROC.BIND_I(ENCODED_MESSAGE);
    STPROC.EXECUTE;*/
  END SET_ENCODED;

  PROCEDURE RAISE_ERROR IS
  BEGIN
  FND_MESSAGE.RAISE_ERROR;
  /*  STPROC.INIT('begin FND_MESSAGE.RAISE_ERROR; end;');
    STPROC.EXECUTE;*/
  END RAISE_ERROR;

  FUNCTION GET_NEXT_SEQUENCE(APPID IN NUMBER
                            ,CAT_CODE IN VARCHAR2
                            ,SOBID IN NUMBER
                            ,MET_CODE IN VARCHAR2
                            ,TRX_DATE IN DATE
                            ,DBSEQNM IN OUT NOCOPY VARCHAR2
                            ,DBSEQID IN OUT NOCOPY INTEGER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
  X0 := FND_SEQNUM.GET_NEXT_SEQUENCE(APPID, CAT_CODE, SOBID, MET_CODE, TRX_DATE, DBSEQNM, DBSEQID);
    /*STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_SEQUENCE(:APPID, :CAT_CODE, :SOBID, :MET_CODE, :TRX_DATE, :DBSEQNM, :DBSEQID); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPID);
    STPROC.BIND_I(CAT_CODE);
    STPROC.BIND_I(SOBID);
    STPROC.BIND_I(MET_CODE);
    STPROC.BIND_I(TRX_DATE);
    STPROC.BIND_IO(DBSEQNM);
    STPROC.BIND_IO(DBSEQID);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    STPROC.RETRIEVE(7
                   ,DBSEQNM);
    STPROC.RETRIEVE(8
                   ,DBSEQID);*/
    RETURN X0;
  END GET_NEXT_SEQUENCE;

  PROCEDURE GET_SEQ_NAME(APPID IN NUMBER
                        ,CAT_CODE IN VARCHAR2
                        ,SOBID IN NUMBER
                        ,MET_CODE IN VARCHAR2
                        ,TRX_DATE IN DATE
                        ,DBSEQNM OUT NOCOPY VARCHAR2
                        ,DBSEQID OUT NOCOPY INTEGER
                        ,SEQASSID OUT NOCOPY INTEGER) IS
  BEGIN
  FND_SEQNUM.GET_SEQ_NAME(APPID, CAT_CODE, SOBID, MET_CODE, TRX_DATE, DBSEQNM, DBSEQID, SEQASSID);
    /*STPROC.INIT('begin FND_SEQNUM.GET_SEQ_NAME(:APPID, :CAT_CODE, :SOBID, :MET_CODE, :TRX_DATE, :DBSEQNM, :DBSEQID, :SEQASSID); end;');
    STPROC.BIND_I(APPID);
    STPROC.BIND_I(CAT_CODE);
    STPROC.BIND_I(SOBID);
    STPROC.BIND_I(MET_CODE);
    STPROC.BIND_I(TRX_DATE);
    STPROC.BIND_O(DBSEQNM);
    STPROC.BIND_O(DBSEQID);
    STPROC.BIND_O(SEQASSID);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(6
                   ,DBSEQNM);
    STPROC.RETRIEVE(7
                   ,DBSEQID);
    STPROC.RETRIEVE(8
                   ,SEQASSID);*/
  END GET_SEQ_NAME;

  FUNCTION GET_NEXT_AUTO_SEQ(DBSEQNM IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
  X0 := FND_SEQNUM.GET_NEXT_AUTO_SEQ(DBSEQNM);
    /*STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_AUTO_SEQ(:DBSEQNM); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(DBSEQNM);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_NEXT_AUTO_SEQ;

  FUNCTION GET_NEXT_AUTO_SEQUENCE(APPID IN NUMBER
                                 ,CAT_CODE IN VARCHAR2
                                 ,SOBID IN NUMBER
                                 ,MET_CODE IN VARCHAR2
                                 ,TRX_DATE IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
  X0 := FND_SEQNUM.GET_NEXT_AUTO_SEQUENCE(APPID, CAT_CODE, SOBID, MET_CODE, TRX_DATE);
    /*STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_AUTO_SEQUENCE(:APPID, :CAT_CODE, :SOBID, :MET_CODE, :TRX_DATE); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPID);
    STPROC.BIND_I(CAT_CODE);
    STPROC.BIND_I(SOBID);
    STPROC.BIND_I(MET_CODE);
    STPROC.BIND_I(TRX_DATE);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_NEXT_AUTO_SEQUENCE;

  FUNCTION GET_NEXT_AUTO_SEQUENCE(APPID IN NUMBER
                                 ,CAT_CODE IN VARCHAR2
                                 ,SOBID IN NUMBER
                                 ,MET_CODE IN VARCHAR2
                                 ,TRX_DATE IN DATE) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
  X0 := FND_SEQNUM.GET_NEXT_AUTO_SEQUENCE(APPID, CAT_CODE, SOBID, MET_CODE, TRX_DATE);
   /* STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_AUTO_SEQUENCE(:APPID, :CAT_CODE, :SOBID, :MET_CODE, :TRX_DATE); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPID);
    STPROC.BIND_I(CAT_CODE);
    STPROC.BIND_I(SOBID);
    STPROC.BIND_I(MET_CODE);
    STPROC.BIND_I(TRX_DATE);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_NEXT_AUTO_SEQUENCE;

  PROCEDURE CREATE_GAPLESS_SEQUENCES IS
  BEGIN
  FND_SEQNUM.CREATE_GAPLESS_SEQUENCES;
    /*STPROC.INIT('begin FND_SEQNUM.CREATE_GAPLESS_SEQUENCES; end;');
    STPROC.EXECUTE;*/
  END CREATE_GAPLESS_SEQUENCES;

  /*FUNCTION CREATE_GAPLESS_SEQUENCE(SEQID IN NUMBER
                                  ,SEQASSID IN NUMBER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
  X0 := FND_SEQNUM.CREATE_GAPLESS_SEQUENCE(SEQID,SEQASSID);
    STPROC.INIT('begin :X0 := FND_SEQNUM.CREATE_GAPLESS_SEQUENCE(:SEQID, :SEQASSID); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(SEQID);
    STPROC.BIND_I(SEQASSID);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END CREATE_GAPLESS_SEQUENCE;*/

  FUNCTION GET_NEXT_USER_SEQUENCE(FDS_USER_ID IN NUMBER
                                 ,SEQASSID IN NUMBER
                                 ,SEQID IN NUMBER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
  X0 := FND_SEQNUM.GET_NEXT_USER_SEQUENCE(FDS_USER_ID, SEQASSID, SEQID);
    /*STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_USER_SEQUENCE(:FDS_USER_ID, :SEQASSID, :SEQID); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(FDS_USER_ID);
    STPROC.BIND_I(SEQASSID);
    STPROC.BIND_I(SEQID);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);*/
    RETURN X0;
  END GET_NEXT_USER_SEQUENCE;

END JG_JGZZRCAK_XMLP_PKG;



/
