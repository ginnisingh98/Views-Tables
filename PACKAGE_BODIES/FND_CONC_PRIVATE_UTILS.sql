--------------------------------------------------------
--  DDL for Package Body FND_CONC_PRIVATE_UTILS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."FND_CONC_PRIVATE_UTILS" as
/* $Header: AFCPSCRB.pls 120.6.12010000.8 2018/05/07 16:56:23 pferguso ship $ */


-- FUNCTION get_fs_svc_name:
-- Gets the service name based on given node and the value of FS_SVC_PREVIX
-- profile option.
--
-- node is the node on which FNDFS is running
--
FUNCTION get_fs_svc_name(node IN VARCHAR2) RETURN VARCHAR2
  IS
     svc     varchar2(254);

BEGIN
   if (fnd_profile.defined('FS_SVC_PREFIX')) then
     fnd_profile.get('FS_SVC_PREFIX', svc);
     if (svc is not null) then
       svc := substr(svc || node, 1, 254);
     else
       svc := 'FNDFS_' || node;
     end if;
   else
     svc := 'FNDFS_' || node;
   end if;

   RETURN svc;

END get_fs_svc_name;


-- FUNCTION generate_req_out_URL:
-- Creates a URL for a report file, given a request ID.
--
-- req_id is the request id
--    So we know what file we're securing
--
-- lifetime is the number of minutes for which the URL is valid
--    After this time, VERIFY_ID will no longer consider the token
--    generated by the call to CREATE_ID to be valid.
--    Here we default to 1440 minutes = one day, since we're using this
--    function to secure a file which multiple users may want to see.
--
FUNCTION generate_req_out_URL(req_id IN NUMBER,
			                  lifetime IN NUMBER DEFAULT 1440) RETURN VARCHAR2
  IS
     base	VARCHAR2(257);
     url	VARCHAR2(512);
     fname      VARCHAR2(255);
     node       VARCHAR2(50);
     id	        VARCHAR2(32);
     mtype  VARCHAR2(80);
     fs_enabled VARCHAR2(2);
     pos     number;
     svc     varchar2(254);
BEGIN

   fnd_profile.get('APPS_WEB_AGENT', base);

   IF(base IS NULL) THEN
      RETURN NULL;
   END IF;

   SELECT fcr.outfile_name, fcr.outfile_node_name, fmt.mime_type
     INTO fname, node, mtype
     FROM fnd_concurrent_requests fcr, fnd_mime_types_vl fmt
     WHERE fcr.request_id = req_id
     AND   fcr.output_file_type = fmt.file_format_code
     AND   rownum = 1;

   /* Bug 3322395: No longer limit FNDFS service prefix to 9
      characters. Logic to get the service name for FNDFS is now
      split into new function. Avoids duplication of code.  */

   svc := get_fs_svc_name(node);

   id := fnd_webfile.create_id(fname,
                               svc,
                               lifetime,
                               mtype,
                               req_id);

   base := Ltrim(Rtrim(base));

   -- Strip any file path from the base URL by truncating at the
   -- third '/'.
   -- This leaves us with something like 'http://ap363sun:8000'.

   pos := instr(base, '/', 1, 3);
   if (pos > 0) then
     base := substr(base, 1, pos - 1);
   end if;

   -- 2638328 - security violation - removing login information from URL
   url := base || '/OA_CGI/FNDWRR.exe?' || 'temp_id=' || id ;

   RETURN url;

END generate_req_out_URL;




/*returns either error or (possibly null) resubmission time */
function get_resub_time(req_id in number) Return varchar2 is

my_resub   varchar2(100);
dummy 	   number;
unit_code  varchar2(100);
type_code  varchar2(100);
resub_time varchar2(8);
resub_end  date;
req_sdate  date;
interval   number;
sysd	   date;
class_id   number;
class_app_id number;
class_type varchar2(1);
class_info varchar2(64);
found      number;
offset     number;
temp_date  date;
dow        number;
dom        number;
nextdom    number;
tz_adjusted     boolean;
requested_by    number;
client_timezone varchar2(50);
server_timezone varchar2(50);
request_endDate date;

begin

  /* are we wasting our time? */
  select count(*) into dummy
  from fnd_concurrent_requests
  where request_id = req_id;

  if dummy = 0 then
    return 'CONC-Request missing';
  end if;

  /* get info */
  select Resubmit_Time, Resubmit_Interval_Type_Code, Requested_Start_Date,
         Resubmit_Interval_Unit_Code, Resubmit_Interval, sysdate,
	 RELEASE_CLASS_ID, RELEASE_CLASS_APP_ID, Resubmit_End_Date, requested_by
  into resub_time, type_code, req_sdate,
	unit_code, interval, sysd,
	class_id, class_app_id,resub_end, requested_by
  from fnd_concurrent_requests
  where request_id = req_id;


  /* get class info */
  class_type := NULL;
  class_info := NULL;

  if class_id is not null then
    select C.class_type, C.class_info, C.date2
    into class_type, class_info, request_endDate
    from fnd_conc_release_classes C
    where RELEASE_CLASS_ID = class_id
    and APPLICATION_ID = class_app_id;
  end if;

  /* hack to take care of 'SMART' resubmission with complex schedules
     basiclly we return the earliest period start  (of the periods involved
     in the schedule) that is greater thensysdate.  If none then return sysdate
     +1 ... Some nice to have improvements would be to use the stop times
     for negated periods (instead of start times).  Also updating the start/stop
     times so that at least the stop time occurs in the future.
  */

  if (unit_code= 'SMART') then
    select to_char(nvl(min(p.PERIOD_START_TIME),sysdate+1),
	'DD-MON-YYYY HH24:MI:SS')
      into my_resub
      from fnd_conc_rel_conj_members cm,
      fnd_conc_rel_disj_members dm,
      fnd_conc_release_periods p
      where cm.DISJUNCTION_ID = dm.DISJUNCTION_ID
      and cm.DISJUNCTION_APPLICATION_ID = dm.DISJUNCTION_APPLICATION_ID
      and cm.release_class_id=class_id
      and cm.class_APPLICATION_ID=class_app_id
      and dm.PERIOD_OR_STATE_FLAG = 'P'
      and dm.PERIOD_APPLICATION_ID = p.APPLICATION_ID
      and dm.PERIOD_ID = p.concurrent_PERIOD_ID
      and  P.PERIOD_START_TIME>sysdate;

    return my_resub;
  end if;



  if class_type = 'S' then

    temp_date := req_sdate;
    tz_adjusted := false;

    if fnd_timezones.timezones_enabled() = 'Y' then
      client_timezone := fnd_profile.value_specific('CLIENT_TIMEZONE_ID',
requested_by, -1, -1, -1, -1);
      if client_timezone is not null then
        client_timezone := fnd_timezones.get_code(client_timezone);
        server_timezone := fnd_timezones.get_server_timezone_code();
        if server_timezone is not null and client_timezone <> server_timezone
then
          temp_date := fnd_timezone_pub.adjust_datetime(temp_date,
server_timezone, client_timezone);
          tz_adjusted := true;
        end if;
      end if;
    end if;

    temp_date := fnd_conc_release_class_utils.calc_specific_startdate(temp_date,
class_info);
    if temp_date is null then
       return null;
    end if;

    if tz_adjusted = true then
      temp_date := fnd_timezone_pub.adjust_datetime(temp_date, client_timezone,
server_timezone);
    end if;

    if ( (request_endDate is null) or (request_endDate >= temp_date) ) then
       my_resub := to_char(temp_date, 'DD-MON-YYYY HH24:MI:SS');
    else
       return null;
    end if;


  else

    /* this will be resub time for all but type 'S' class types */

    select TO_CHAR(DECODE(resub_time,
                   NULL, DECODE (type_code, 'START', req_sdate, sysd)
			  + DECODE(unit_code,
		/*		'MINUTES', GREATEST(interval, 1)/1440, */
				'MINUTES', interval/1440,
				'HOURS', interval/24,
                                'DAYS', interval,
 				'MONTHS', ADD_MONTHS(
				   DECODE(type_code, 'START', req_sdate, sysd),
					interval) -
			           DECODE(type_code, 'START', req_sdate, sysd)),
                  /*TIME*/ TO_DATE (TO_CHAR (sysd, 'DD-MON-YYYY')
                      || ' ' || resub_time, 'DD-MON-YYYY HH24:MI:SS')
                     + Decode(
                  Sign(To_Date(To_Char(sysd, 'HH24:MI:SS'), 'HH24:MI:SS')
                       - To_Date(resub_time, 'HH24:MI:SS')
                      ), 1, 1, 0)), 'DD-MON-YYYY HH24:MI:SS')
       into my_resub
       from dual;

  end if;

  /* some fairly obvious reasons to quit */
  if (interval is null  and resub_time is null and (class_type <> 'S')) or
     (NVL(resub_end,sysd) < sysd) or
     (NVL(resub_end,TO_DATE(my_resub,
                                   'DD-MON-YYYY HH24:MI:SS')) <
         TO_DATE(my_resub,
                        'DD-MON-YYYY HH24:MI:SS')) then
     return null;
  end if;

 /***------------------------------------------------------------------
 ** Make sure the requested_start_date for the next request is greater
 ** than sysdate (e.g. if the system went down for a week, then cycle
 ** through resub dates until we get one after sysdate.  */

 /* this will only be necessary for type_code = 'START' */

 while (sysd > to_date(my_resub,
                              'DD-MON-YYYY HH24:MI:SS')) loop

    select TO_CHAR(TO_DATE(my_resub,
                                  'DD-MON-YYYY HH24:MI:SS') +
   /*  		DECODE(unit_code, 'MINUTES', GREATEST(interval, 1)/1440, */
  		DECODE(unit_code, 'MINUTES', interval/1440,
                                  'HOURS', interval/24,
                                  'DAYS', interval,
                                  'MONTHS', ADD_MONTHS(
                                                To_Date(my_resub,
                                                               'DD-MON-YYYY HH24:MI:SS'),
                                                interval)
                                           -  To_Date(my_resub,
                                                             'DD-MON-YYYY HH24:MI:SS'))
		,'DD-MON-YYYY HH24:MI:SS')
      into my_resub
      from dual;
 end loop;

 if (NVL(resub_end,TO_DATE(my_resub,
                                  'DD-MON-YYYY HH24:MI:SS')) <
                   TO_DATE(my_resub,
                                  'DD-MON-YYYY HH24:MI:SS')) then
    return null;
 else return my_resub;
 end if;

end get_resub_time;

-- Procedure added as bug fix for bug#4172657
Procedure set_notification_attr (nid in number ,
				requrl in varchar2,
				req_id in number,
				stat in varchar2,
				completion in date) is

pname    varchar2(512);
user     varchar2(255);
pdesc    varchar2(240);
e_addr   varchar2(240);
wf_error exception;
begin
	   select u.user_name, r.description,
		   p.user_concurrent_program_name, u.email_address
	    into   user, pdesc, pname, e_addr
	    from   fnd_concurrent_requests r, fnd_concurrent_programs_vl p,
		   fnd_user u
	    where  r.program_application_id = p.application_id
	    and    r.concurrent_program_id = p.concurrent_program_id
	    and    r.request_id = req_id
	    and    u.user_id = r.requested_by;

	    if (pdesc is not null) then
		pname := pdesc || '(' || pname || ')';
	    end if;


	    begin

		if ( requrl is not NULL ) then
		    wf_notification.setattrtext(nid, 'REQ_URL', requrl);
		end if;

		wf_notification.setattrnumber(nid, 'REQID', req_id);
		wf_notification.setattrtext(nid, 'STAT', RTRIM(stat));
		wf_notification.setattrtext(nid, 'PROGNAME', pname);
		wf_notification.setattrdate(nid, 'TIME', completion);
		wf_notification.setattrdate(nid, 'DATE', completion);
		wf_notification.setattrtext(nid, 'SUBMITTER', user);
		wf_notification.setattrtext(nid, '#FROM_ROLE', user);
		wf_notification.setattrtext(nid, '#WFM_REPLYTO', e_addr);
		wf_notification.denormalize_notification(nid);
	    exception
		when others then
		    raise wf_error;
	    end;


end set_notification_attr;

function send_simple_done_msg(req_id     in number,
                              stat in    varchar2,
                              recip in   varchar2,
                              completion in date,
                              etext      out NOCOPY  varchar2,
                              estack     out NOCOPY  varchar2
                             ) return number is

nid      number;         /*notification id*/
pname    varchar2(512);  /*progname*/
user     varchar2(255);  /*submitter*/
pdesc    varchar2(240);  /* prog description */
profbuf  varchar2(255);  /* buffer for profile value */
requrl   varchar2(255) := NULL;  /* URL for output */
url_ttl  number;         /* Time to live for url - in minutes */
ename    varchar2(30);   /* Error name returned by wf_core.get_error */
e_addr   varchar2(240);  /* email address of user */
wf_error exception;
msgname  varchar2(255);
msgtype  varchar2(255) := 'FNDCMMSG';
send_url boolean;
-- for bug 4535714
ofilesize      number;
saveoutputflag varchar2(1);
-- for bug 4172657
notify_id number;

cursor nids_cursor is
	    select notification_id
	    from wf_notifications
	    where group_id = nid;
-- code for bug 4172657 ends

begin
    estack := '';
    etext := '';

-- bug4535714
-- get the output file size and save output flag here
-- output file may exist at this point but deleted later depending on flag
-- handling null as zero

    select decode(ofile_size,NULL,0,ofile_size), save_output_flag
      into ofilesize, saveoutputflag
    from fnd_concurrent_requests
    where request_id = req_id;

-- bug453714 ends

    fnd_profile.get ('CONC_ATTACH_URL', profbuf);

    if profbuf = 'Y' then

        fnd_profile.get ('CONC_URL_LIFETIME', profbuf);
        url_ttl := to_number(profbuf);

        /* Note, we must set a default value for url_ttl.        *
         * Stored procedure defaults only work for missing args, *
         * not for null args.                                    */
        if (url_ttl is null) then
            url_ttl := 1440;
        end if;

-- bug4535714
-- if the filesize is zero or saveoutputflag is not set, don't send URL
-- as it will point to a zero size file and error

        if ofilesize > 0 and saveoutputflag='Y' then
           msgname := 'REQ_COMPLETION_W_URL';
           send_url := true;
        else
           msgname := 'SIMPLE_REQ_COMPLETION';
           send_url := false;
        end if;
-- bug4535714 end

    else
        msgname := 'SIMPLE_REQ_COMPLETION';
        send_url := false;

    end if;

    -- If this profile option is set, use the Workflow 'sendgroup' API
    -- to send a notification to all members of the role.
    fnd_profile.get('CONC_NOTIFY_GROUP', profbuf);

    begin
        if profbuf = 'Y' then
	    nid := wf_notification.sendgroup(recip, msgtype, msgname);
	    open nids_cursor;
		LOOP
			fetch nids_cursor into notify_id;
                           -- Get a unique file name each time
                           if (send_url) then
                              requrl := fnd_webfile.get_url(
                                           fnd_webfile.request_out,
                                           req_id, null, null, url_ttl);
                           end if;
			   set_notification_attr (notify_id ,requrl,
                                           req_id,stat,completion);
			 exit when nids_cursor%NOTFOUND;
		end LOOP;

	    close nids_cursor;
	else
           nid := wf_notification.send(recip, msgtype, msgname);

           -- Get a unique file name each time
           if (send_url) then
              requrl := fnd_webfile.get_url( fnd_webfile.request_out,
                                           req_id, null, null, url_ttl);
           end if;
           set_notification_attr (nid ,requrl,req_id,stat,completion);

	end if;

    exception
        when others then
            raise wf_error;
    end;


    return(nid);


exception
    when wf_error then
        wf_core.get_error(ename, etext, estack);
        return(-1);
    when others then
        return(-2);

end send_simple_done_msg;

/* Gets the machine name in node format for current session instance */

function get_session_node return varchar is

  mynode varchar2(255) := null;

begin

  select LOGFILE_NODE_NAME
  into mynode
  from fnd_concurrent_requests
  where request_id = fnd_global.conc_request_id;

  return mynode;

exception
  when others then
     begin
         select upper(substr (machine, 1, instr(machine, '.')-1 ))
         into mynode
         from v$session
         where audsid=USERENV('SESSIONID');
     exception
         when others then null;
     end;

  return mynode;

end get_session_node;


procedure record_temp_file_use_pvt (filename in varchar2, type in varchar2,
	req_id in number, sess_id in number, node in varchar2) is
PRAGMA AUTONOMOUS_TRANSACTION;

begin

	update fnd_temp_files
	set REQUEST_ID = decode (req_id, 0, null, req_id),
	    SESSION_ID = sess_id
	where filename =  record_temp_file_use_pvt.filename
	and node = record_temp_file_use_pvt.node
	and type = record_temp_file_use_pvt.type;

	if not SQL%FOUND then
	  if (FND_LOG.LEVEL_STATEMENT >= FND_LOG.G_CURRENT_RUNTIME_LEVEL ) then
	    FND_LOG.STRING(FND_LOG.LEVEL_STATEMENT,'fnd.plsql.fnd_conc_private_utils.record_temp_file_use_pvt',
	  		   'insert into fnd_temp_files');
	  end if;
	  insert into fnd_temp_files
	     (FILENAME, TYPE, REQUEST_ID, SESSION_ID, NODE)
	  values (record_temp_file_use_pvt.filename, record_temp_file_use_pvt.type, req_id, sess_id, record_temp_file_use_pvt.node);
	else
	  if (FND_LOG.LEVEL_STATEMENT >= FND_LOG.G_CURRENT_RUNTIME_LEVEL ) then
	    FND_LOG.STRING(FND_LOG.LEVEL_STATEMENT,'fnd.plsql.fnd_conc_private_utils.record_temp_file_use_pvt',
	  		   'fnd_temp_files updated');
	  end if;
	end if;

        commit;

exception
  when others then
  	  if( FND_LOG.LEVEL_EXCEPTION >= FND_LOG.G_CURRENT_RUNTIME_LEVEL ) then
  	  	FND_MESSAGE.SET_NAME('FND', 'SQL-GENERIC ERROR');
  	  	FND_MESSAGE.SET_TOKEN('ERRNO', SQLCODE, FALSE);
  	  	FND_MESSAGE.SET_TOKEN('REASON', SQLERRM, FALSE);
  	  	FND_MESSAGE.SET_TOKEN('ROUTINE', 'RECORD_TEMP_FILE_USE_PVT');
  	  	FND_LOG.MESSAGE(FND_LOG.LEVEL_EXCEPTION, 'fnd.plsql.fnd_conc_private_utils.record_temp_file_use_pvt');
  	  end if;

end record_temp_file_use_pvt;

/* Overloaded: records use of a temp file in fnd_temp_files */

procedure record_temp_file_use(filename in varchar, node in varchar) is

req_id number := null;
type_code varchar2(1);
begin
    req_id := fnd_global.conc_request_id;
    if req_id > 0 then
      type_code := 'R';
    else
      type_code := 'O';
    end if;
    record_temp_file_use(filename, node, type_code, req_id);

end record_temp_file_use;

/* Overloaded: records use of a temp file in fnd_temp_files
 * type_codes: F=Fnd_file context; R=Request context; O=Other context
 */
procedure record_temp_file_use( filename in varchar, node in varchar,
				type_code in varchar, req_id in number) is

ses_id number := null;
mynode varchar2(255);

begin

    mynode := node;
    if (mynode is null) then
        mynode := get_session_node;
    end if;

    select userenv('SESSIONID') into ses_id from dual;

    record_temp_file_use_pvt (filename, type_code, req_id, ses_id, mynode);

exception
  	  when others then null;

end record_temp_file_use;

procedure erase_temp_file_use_pvt (filename in varchar2, node in varchar2, type in varchar) is
PRAGMA AUTONOMOUS_TRANSACTION;

begin

     	delete from fnd_temp_files
	where filename =  erase_temp_file_use_pvt.filename
	and upper(node) = upper(erase_temp_file_use_pvt.node)
	and upper(type) = upper(erase_temp_file_use_pvt.type);

	if not SQL%FOUND then
	  if (FND_LOG.LEVEL_STATEMENT >= FND_LOG.G_CURRENT_RUNTIME_LEVEL ) then
	    FND_LOG.STRING(FND_LOG.LEVEL_STATEMENT,'fnd.plsql.fnd_conc_private_utils.erase_temp_file_use_pvt',
	  		   'filename: '|| filename ||' on node: '|| node ||
	  		   ' with type: '||type||' not found');
	  end if;
	else
	  if (FND_LOG.LEVEL_STATEMENT >= FND_LOG.G_CURRENT_RUNTIME_LEVEL ) then
	    FND_LOG.STRING(FND_LOG.LEVEL_STATEMENT,'fnd.plsql.fnd_conc_private_utils.erase_temp_file_use_pvt',
	  		   'filename: '|| filename ||' on node: '|| node ||
	  		   ' with type: '||type||' erased');
	  end if;
	end if;

        commit;

exception
  when others then
  	  	  if( FND_LOG.LEVEL_EXCEPTION >= FND_LOG.G_CURRENT_RUNTIME_LEVEL ) then
  	  	      FND_MESSAGE.SET_NAME('FND', 'SQL-GENERIC ERROR');
  	  	      FND_MESSAGE.SET_TOKEN('ERRNO', SQLCODE, FALSE);
  	  	      FND_MESSAGE.SET_TOKEN('REASON', SQLERRM, FALSE);
  	  	      FND_MESSAGE.SET_TOKEN('ROUTINE', 'ERASE_TEMP_FILE_USAGE_PVT');
  	  	      FND_LOG.MESSAGE(FND_LOG.LEVEL_EXCEPTION, 'fnd.plsql.fnd_conc_private_utils.erase_temp_file_usage_pvt');
  	      	  end if;

end erase_temp_file_use_pvt;

/* deletes record of a temp file from fnd_temp_files */

procedure erase_temp_file_use(filename in varchar, node in varchar, type in varchar) is

  mynode varchar2(255);

begin

    mynode := node;

    if (mynode is null) then
       mynode := get_session_node;
    end if;

    erase_temp_file_use_pvt (filename, mynode, type);

exception
	when others then null;

end erase_temp_file_use;

/* returns 1 if temp file has been recorded, else returns 0 */

function check_temp_file_use (filename in varchar, node in varchar, type in varchar) return number is
  mynode varchar(255) := null;
  file_recorded number := 0;
begin
	mynode := node;
        if mynode is null then
        	mynode := get_session_node;
        end if;

        begin
	  select 1
	  into file_recorded
	  from fnd_temp_files
	  where filename = check_temp_file_use.filename
	  and (node is null or upper(node) = upper(mynode))
	  and upper(type) = upper(check_temp_file_use.type);
	exception
	  when no_data_found then
	  	  null;
	  when others then
  	  	  if( FND_LOG.LEVEL_EXCEPTION >= FND_LOG.G_CURRENT_RUNTIME_LEVEL ) then
  	  	      FND_MESSAGE.SET_NAME('FND', 'SQL-GENERIC ERROR');
  	  	      FND_MESSAGE.SET_TOKEN('ERRNO', SQLCODE, FALSE);
  	  	      FND_MESSAGE.SET_TOKEN('REASON', SQLERRM, FALSE);
  	  	      FND_MESSAGE.SET_TOKEN('ROUTINE', 'ERASE_TEMP_FILE_USAGE_PVT');
  	  	      FND_LOG.MESSAGE(FND_LOG.LEVEL_EXCEPTION, 'fnd.plsql.fnd_conc_private_utils.check_temp_file_use');
  	      	  end if;
	end;

	return file_recorded;

end check_temp_file_use;

Procedure call_pp_plsql(user_id in number,
                        resp_id in number,
                        resp_appl_id in number,
                        security_group_id in number,
                        site_id in number,
                        login_id in number,
                        conc_login_id in number,
                        prog_appl_id in number,
                        conc_program_id in number,
                        conc_request_id in number,
                        conc_priority_request in number,
                        program in varchar2,
                        step in number,
                        errbuf out NOCOPY varchar2,
                        retcode out NOCOPY number) is
  PRAGMA AUTONOMOUS_TRANSACTION;
  session_id number;
  sql_string varchar2(255);
  tmp_buff varchar2(2000);
begin
  fnd_global.bless_next_init('FND_PERMIT_0003');
  fnd_global.initialize (session_id, user_id, resp_id,
             resp_appl_id, security_group_id, site_id, login_id,
             conc_login_id, prog_appl_id, conc_program_id,
             conc_request_id, conc_priority_request);

  sql_string := 'BEGIN ' || program ||
                 '(:errbuf, :retcode, :step); END;';


  execute immediate sql_string using out errbuf,out retcode, in step;

  /* If retcode is not set, then we'll assume success, since
   * no exception was raised. */

  if retcode is null then
    retcode := 0;
  end if;

  return;

  /* The calling routing will handle exceptions. */
end call_pp_plsql;



/*
 * Switch a manager's resource consumer group to the group it is assigned to
 * in FND_CONCURRENT_QUEUES, or the default group if one is not assigned.
 */
procedure set_mgr_rcg(qaid in number, qid in number) is

que_rcg            varchar2(32);
old_rcg            varchar2(32);
resource_mgr_off   exception;

pragma exception_init(resource_mgr_off, -29373);
pragma autonomous_transaction;

begin

  begin
    select nvl(RESOURCE_CONSUMER_GROUP, 'DEFAULT_CONSUMER_GROUP')
    into que_rcg
    from fnd_concurrent_queues
    where CONCURRENT_QUEUE_ID = qid
    and   APPLICATION_ID = qaid;
  exception
    when others then
      que_rcg := 'DEFAULT_CONSUMER_GROUP';
  end;
  dbms_session.switch_current_consumer_group(que_rcg, old_rcg, FALSE);

  commit;

exception
  -- Ignore this error, this means the user has not chosen to use the resource manager
  when resource_mgr_off then
    commit;

  when others then
    if( FND_LOG.LEVEL_EXCEPTION >= FND_LOG.G_CURRENT_RUNTIME_LEVEL ) then
	  FND_MESSAGE.SET_NAME('FND', 'CONC-CANT SWITCH RCG');
	  FND_MESSAGE.SET_TOKEN('ROUTINE', 'SET_MGR_RCG');
	  FND_MESSAGE.SET_TOKEN('QID', qid);
	  FND_MESSAGE.SET_TOKEN('RCG', que_rcg);
	  FND_MESSAGE.SET_TOKEN('REASON', SQLERRM);
	  FND_LOG.MESSAGE(FND_LOG.LEVEL_EXCEPTION, 'fnd.plsql.FND_CONC_PRIVATE_UTILS.SET_MGR_RCG');
	end if;
	commit;

end set_mgr_rcg;


/*
 * Switch multiorg context
 * Not for use in 11i
 */
procedure set_multiorg_context(org_type in varchar2, org_id in number) is

begin

   execute immediate('begin mo_global.init(''M''); end;');
   if ( org_type = 'S' ) then
      mo_global.set_policy_context('S', org_id);
   elsif ( org_type = 'M' ) then
      mo_global.set_policy_context('M', null);
   end if;


end set_multiorg_context;



/*
 * When a request is taken off hold it is possible that its original start date
 * may have been missed. If it is scheduled to run on a specific day, it may not
 * currently be that day, and the request should not run immediately.
 * Call get_resub_time for specific-dats requests, and return a new start date if needed.
 * Return null if the start date does not need to be changed.
 *
*/
function adjust_start_date(req_id in number) return varchar2 is

class_id   number;
class_app_id number;
class_type varchar2(1) := NULL;

begin

 select  release_class_id, release_class_app_id
  into  class_id, class_app_id
  from fnd_concurrent_requests
      where request_id = req_id
      and requested_start_date < sysdate;


  if class_id is not null then
    select C.class_type
    into class_type
    from fnd_conc_release_classes C
    where release_class_id = class_id
    and application_id = class_app_id;
  end if;


  if class_type = 'S' then
     return get_resub_time(req_id);
  end if;

  return null;

exception
   when others then
      return null;

end adjust_start_date;

end FND_CONC_PRIVATE_UTILS;

/
