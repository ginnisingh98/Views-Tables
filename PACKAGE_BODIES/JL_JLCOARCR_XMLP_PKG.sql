--------------------------------------------------------
--  DDL for Package Body JL_JLCOARCR_XMLP_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."JL_JLCOARCR_XMLP_PKG" AS
/* $Header: JLCOARCRB.pls 120.1 2007/12/25 16:43:30 dwkrishn noship $ */
  FUNCTION BEFOREREPORT RETURN BOOLEAN IS
    VLOCATION_ID NUMBER;
  BEGIN
    P_CONC_REQUEST_ID := FND_GLOBAL.CONC_REQUEST_ID;
    /*SRW.USER_EXIT('FND SRWINIT')*/NULL;
    DECLARE
      COAID NUMBER;
      SOBNAME VARCHAR2(30);
      FUNCTCURR VARCHAR2(15);
      ERRBUF VARCHAR2(132);
      P_PRECISION NUMBER;
      P_EXT_PRECISION NUMBER;
      P_MIN_ACCT_UNIT NUMBER;
    BEGIN
      GL_GET_SET_OF_BOOKS_INFO(P_SET_OF_BOOKS_ID
                              ,COAID
                              ,SOBNAME
                              ,FUNCTCURR
                              ,ERRBUF);
      IF (ERRBUF IS NOT NULL) THEN
        /*SRW.MESSAGE('00'
                   ,ERRBUF)*/NULL;
        /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
      END IF;
      C_FUNC_CURRENCY := FUNCTCURR;
      C_STRUCT_NUM := COAID;
      C_SOB_NAME := SOBNAME;
      GET_INFO(C_FUNC_CURRENCY
              ,P_PRECISION
              ,P_EXT_PRECISION
              ,P_MIN_ACCT_UNIT);
      C_PRECISION := P_PRECISION;
    END;
    BEGIN
      SELECT
        LE.NAME,
        LE.REGISTRATION_NUMBER,
        LE.ADDRESS_LINE_1,
        LE.ADDRESS_LINE_2,
        LE.ADDRESS_LINE_3
      INTO COMPANY_NAME,NIT_NUMBER,VADDRESS1,VADDRESS2,VADDRESS3
      FROM
        HR_LOCATIONS HR,
        XLE_FIRSTPARTY_INFORMATION_V LE
      WHERE HR.LOCATION_ID = LE.LOCATION_ID
        AND LE.LEGAL_ENTITY_ID = P_LEGAL_ENTITY_ID;
    EXCEPTION
      WHEN OTHERS THEN
        COMPANY_NAME := 'Company Name...';
        NIT_NUMBER := 'Nit_Number';
        DIGIT_VERIF := 1;
        VADDRESS1 := 'address1...';
        VADDRESS2 := 'address2...';
    END;
    BEGIN
      SELECT
        GEO.GEOGRAPHY_NAME
      INTO VTOWN_CITY
      FROM
        HZ_GEOGRAPHIES GEO,
        HR_LOCATIONS HL,
        XLE_FIRSTPARTY_INFORMATION_V LE
      WHERE GEO.GEOGRAPHY_NAME = HL.TOWN_OR_CITY
        AND GEO.GEOGRAPHY_TYPE = 'CITY'
        AND GEO.COUNTRY_CODE = HL.COUNTRY
        AND GEO.GEOGRAPHY_ELEMENT2_CODE = HL.REGION_2
        AND LE.LEGAL_ENTITY_ID = P_LEGAL_ENTITY_ID
        AND HL.LOCATION_ID = LE.LOCATION_ID;
    EXCEPTION
      WHEN OTHERS THEN
        VTOWN_CITY := 'town_or_city';
    END;
    BEGIN
      SELECT
        GEO.GEOGRAPHY_NAME
      INTO VREGION
      FROM
        HZ_GEOGRAPHIES GEO,
        HR_LOCATIONS HRL,
        XLE_FIRSTPARTY_INFORMATION_V LE
      WHERE LE.LEGAL_ENTITY_ID = P_LEGAL_ENTITY_ID
        AND LE.LOCATION_ID = HRL.LOCATION_ID
        AND GEO.GEOGRAPHY_CODE = HRL.REGION_2
        AND GEO.GEOGRAPHY_TYPE = 'PROVINCE'
        AND GEO.COUNTRY_CODE = HRL.COUNTRY;
    EXCEPTION
      WHEN OTHERS THEN
        VREGION := 'region';
    END;
    BEGIN
      SELECT
        FT.TERRITORY_SHORT_NAME
      INTO VCOUNTRY
      FROM
        FND_TERRITORIES_VL FT,
        HR_LOCATIONS HL
      WHERE FT.TERRITORY_CODE = HL.COUNTRY
        AND HL.LOCATION_ID = VLOCATION_ID;
    EXCEPTION
      WHEN OTHERS THEN
        VCOUNTRY := NULL;
    END;
    RETURN (TRUE);
  END BEFOREREPORT;
  FUNCTION AFTERREPORT RETURN BOOLEAN IS
  BEGIN
    /*SRW.USER_EXIT('FND SRWEXIT')*/NULL;
    RETURN (TRUE);
  END AFTERREPORT;
  FUNCTION CONVERT_NUMBER2(SEGMENT IN NUMBER) RETURN VARCHAR2 IS
    VALUE_TEXT VARCHAR2(80) := '';
    V_CENTENAS VARCHAR2(12);
    CENTENAS NUMBER := POWER(10
         ,2);
    V_DEZENAS VARCHAR2(10);
    DEZENAS NUMBER := 10;
    V_UNIDADES VARCHAR2(10);
    CURRENT_SEG VARCHAR2(80);
    RESTO VARCHAR2(3);
    NUM INTEGER := SEGMENT;
  BEGIN
    CURRENT_SEG := TRUNC(NUM / CENTENAS);
    RESTO := MOD(NUM
                ,CENTENAS);
    NUM := NUM - (CURRENT_SEG * CENTENAS);
    IF CURRENT_SEG <> 0 THEN
      IF CURRENT_SEG = 1 THEN
        IF RESTO = 0 THEN
          VALUE_TEXT := VALUE_TEXT || 'cem ';
        ELSE
          VALUE_TEXT := VALUE_TEXT || 'cento ';
        END IF;
      ELSIF CURRENT_SEG = 2 THEN
        VALUE_TEXT := VALUE_TEXT || 'duzentos ';
      ELSIF CURRENT_SEG = 3 THEN
        VALUE_TEXT := VALUE_TEXT || 'trezentos ';
      ELSIF CURRENT_SEG = 4 THEN
        VALUE_TEXT := VALUE_TEXT || 'quatrocentos ';
      ELSIF CURRENT_SEG = 5 THEN
        VALUE_TEXT := VALUE_TEXT || 'quinhentos ';
      ELSIF CURRENT_SEG = 6 THEN
        VALUE_TEXT := VALUE_TEXT || 'seiscentos ';
      ELSIF CURRENT_SEG = 7 THEN
        VALUE_TEXT := VALUE_TEXT || 'setecentos ';
      ELSIF CURRENT_SEG = 8 THEN
        VALUE_TEXT := VALUE_TEXT || 'oitocentos ';
      ELSIF CURRENT_SEG = 9 THEN
        VALUE_TEXT := VALUE_TEXT || 'novecentos ';
      END IF;
    END IF;
    CURRENT_SEG := TRUNC(NUM / DEZENAS);
    RESTO := MOD(NUM
                ,DEZENAS);
    NUM := NUM - (CURRENT_SEG * DEZENAS);
    IF CURRENT_SEG <> 0 THEN
      IF CURRENT_SEG = 1 THEN
        IF RESTO = 0 THEN
          VALUE_TEXT := VALUE_TEXT || 'dez ';
        ELSIF RESTO = 1 THEN
          VALUE_TEXT := VALUE_TEXT || 'onze ';
        ELSIF RESTO = 2 THEN
          VALUE_TEXT := VALUE_TEXT || 'doze ';
        ELSIF RESTO = 3 THEN
          VALUE_TEXT := VALUE_TEXT || 'treze ';
        ELSIF RESTO = 4 THEN
          VALUE_TEXT := VALUE_TEXT || 'catorze ';
        ELSIF RESTO = 5 THEN
          VALUE_TEXT := VALUE_TEXT || 'quinze ';
        ELSIF RESTO = 6 THEN
          VALUE_TEXT := VALUE_TEXT || 'dezasseis ';
        ELSIF RESTO = 7 THEN
          VALUE_TEXT := VALUE_TEXT || 'dezassete ';
        ELSIF RESTO = 8 THEN
          VALUE_TEXT := VALUE_TEXT || 'dezoito ';
        ELSIF RESTO = 9 THEN
          VALUE_TEXT := VALUE_TEXT || 'dezanove ';
        END IF;
      ELSIF CURRENT_SEG = 2 THEN
        VALUE_TEXT := VALUE_TEXT || 'vinte ';
      ELSIF CURRENT_SEG = 3 THEN
        VALUE_TEXT := VALUE_TEXT || 'trinta ';
      ELSIF CURRENT_SEG = 4 THEN
        VALUE_TEXT := VALUE_TEXT || 'quarenta ';
      ELSIF CURRENT_SEG = 5 THEN
        VALUE_TEXT := VALUE_TEXT || 'cinquenta ';
      ELSIF CURRENT_SEG = 6 THEN
        VALUE_TEXT := VALUE_TEXT || 'sessenta ';
      ELSIF CURRENT_SEG = 7 THEN
        VALUE_TEXT := VALUE_TEXT || 'setenta ';
      ELSIF CURRENT_SEG = 8 THEN
        VALUE_TEXT := VALUE_TEXT || 'oitenta ';
      ELSIF CURRENT_SEG = 9 THEN
        VALUE_TEXT := VALUE_TEXT || 'noventa ';
      END IF;
    END IF;
    IF NUM <> 0 AND CURRENT_SEG <> 1 THEN
      IF NUM = 1 THEN
        VALUE_TEXT := VALUE_TEXT || 'um ';
      ELSIF NUM = 2 THEN
        VALUE_TEXT := VALUE_TEXT || 'dois ';
      ELSIF NUM = 3 THEN
        VALUE_TEXT := VALUE_TEXT || 'tres ';
      ELSIF NUM = 4 THEN
        VALUE_TEXT := VALUE_TEXT || 'quatro ';
      ELSIF NUM = 5 THEN
        VALUE_TEXT := VALUE_TEXT || 'cinco ';
      ELSIF NUM = 6 THEN
        VALUE_TEXT := VALUE_TEXT || 'seis ';
      ELSIF NUM = 7 THEN
        VALUE_TEXT := VALUE_TEXT || 'sete ';
      ELSIF NUM = 8 THEN
        VALUE_TEXT := VALUE_TEXT || 'oito ';
      ELSIF NUM = 9 THEN
        VALUE_TEXT := VALUE_TEXT || 'nove ';
      END IF;
    END IF;
    RETURN VALUE_TEXT;
  END CONVERT_NUMBER2;
  FUNCTION CONVERT_NUMBER(IN_NUMERAL IN INTEGER := 0) RETURN VARCHAR2 IS
    NUMBER_TOO_LARGE EXCEPTION;
    NUMERAL INTEGER := ABS(IN_NUMERAL);
    MAX_DIGIT INTEGER := 12;
    NUMBER_TEXT VARCHAR2(240) := '';
    CURRENT_SEGMENT VARCHAR2(80);
    B_ZERO VARCHAR2(25) := 'Zero';
    B_THOUSAND VARCHAR2(25) := 'Mil ';
    THOUSAND NUMBER := POWER(10
         ,3);
    B_MILLION VARCHAR2(25) := 'Milh?o ';
    B_MILLIONS VARCHAR2(25) := 'Milh?es ';
    MILLION NUMBER := POWER(10
         ,6);
    B_BILLION VARCHAR2(25) := 'Bili?  ';
    B_BILLIONS VARCHAR2(25) := 'Bili?es ';
    BILLION NUMBER := POWER(10
         ,9);
  BEGIN
    IF NUMERAL >= POWER(10
         ,MAX_DIGIT) THEN
      RAISE NUMBER_TOO_LARGE;
    END IF;
    IF NUMERAL = 0 THEN
      RETURN (B_ZERO);
    END IF;
    CURRENT_SEGMENT := TRUNC(NUMERAL / BILLION);
    NUMERAL := NUMERAL - (CURRENT_SEGMENT * BILLION);
    IF CURRENT_SEGMENT <> 0 THEN
      IF CURRENT_SEGMENT = 1 THEN
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_BILLION;
      ELSE
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_BILLIONS;
      END IF;
    END IF;
    CURRENT_SEGMENT := TRUNC(NUMERAL / MILLION);
    NUMERAL := NUMERAL - (CURRENT_SEGMENT * MILLION);
    IF CURRENT_SEGMENT <> 0 THEN
      IF CURRENT_SEGMENT = 1 THEN
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_MILLION;
      ELSE
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_MILLIONS;
      END IF;
    END IF;
    CURRENT_SEGMENT := TRUNC(NUMERAL / THOUSAND);
    NUMERAL := NUMERAL - (CURRENT_SEGMENT * THOUSAND);
    IF CURRENT_SEGMENT <> 0 THEN
      IF CURRENT_SEGMENT = 1 THEN
        NUMBER_TEXT := NUMBER_TEXT || B_THOUSAND;
      ELSE
        NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(CURRENT_SEGMENT) || B_THOUSAND;
      END IF;
    END IF;
    IF NUMERAL <> 0 THEN
      NUMBER_TEXT := NUMBER_TEXT || CONVERT_NUMBER2(NUMERAL);
    END IF;
    NUMBER_TEXT := SUBSTR(NUMBER_TEXT
                         ,1
                         ,1) || RTRIM(LOWER(SUBSTR(NUMBER_TEXT
                                     ,2
                                     ,NVL(LENGTH(NUMBER_TEXT)
                                        ,0))));
    RETURN (NUMBER_TEXT);
    RETURN NULL;
  EXCEPTION
    WHEN NUMBER_TOO_LARGE THEN
      RETURN (NULL);
    WHEN OTHERS THEN
      RETURN (NULL);
  END CONVERT_NUMBER;
  FUNCTION GET_WORD_VALUE(P_AMOUNT IN NUMBER
                         ,P_UNIT_SINGULAR IN VARCHAR2
                         ,P_UNIT_PLURAL IN VARCHAR2
                         ,P_SUB_UNIT_SINGULAR IN VARCHAR2
                         ,P_SUB_UNIT_PLURAL IN VARCHAR2
                         ,P_UNIT_RATIO IN NUMBER) RETURN VARCHAR2 IS
    L_WORD_AMOUNT VARCHAR2(240) := CONVERT_NUMBER(TRUNC(P_AMOUNT));
    L_DECIMAL_PART NUMBER := TRUNC((P_AMOUNT - TRUNC(P_AMOUNT)) * P_UNIT_RATIO);
    L_WORD_AMOUNT2 VARCHAR2(240);
    L_CURRENCY_WORD VARCHAR2(240);
    L_LOG INTEGER;
    FUNCTION MY_LOG(A IN INTEGER
                   ,B IN INTEGER) RETURN NUMBER IS
    BEGIN
      IF A <> 10 THEN
        RETURN (NULL);
      ELSIF B > 0 AND B <= 10 THEN
        RETURN (1);
      ELSIF B > 10 AND B <= 100 THEN
        RETURN (2);
      ELSIF B > 100 AND B <= 1000 THEN
        RETURN (3);
      ELSE
        RETURN (NULL);
      END IF;
      RETURN NULL;
    END MY_LOG;
  BEGIN
    L_LOG := MY_LOG(10
                   ,P_UNIT_RATIO);
    IF (L_DECIMAL_PART > 0) THEN
      L_WORD_AMOUNT2 := CONVERT_NUMBER(L_DECIMAL_PART);
      SELECT
        INITCAP(LOWER('e' || ' ' || L_WORD_AMOUNT2 || ' ' || DECODE(L_DECIMAL_PART
                            ,1
                            ,P_SUB_UNIT_SINGULAR
                            ,P_SUB_UNIT_PLURAL)))
      INTO L_WORD_AMOUNT2
      FROM
        DUAL;
    END IF;
    IF P_UNIT_RATIO in (0,1) OR P_UNIT_RATIO IS NULL THEN
      SELECT
        INITCAP(LOWER(L_WORD_AMOUNT || ' ' || DECODE(TRUNC(P_AMOUNT)
                            ,1
                            ,P_UNIT_SINGULAR
                            ,P_UNIT_PLURAL)))
      INTO L_CURRENCY_WORD
      FROM
        DUAL;
    ELSE
      SELECT
        INITCAP(LOWER(L_WORD_AMOUNT || ' ' || DECODE(TRUNC(P_AMOUNT)
                            ,1
                            ,P_UNIT_SINGULAR
                            ,P_UNIT_PLURAL) || ' ' || L_WORD_AMOUNT2))
      INTO L_CURRENCY_WORD
      FROM
        DUAL;
    END IF;
    RETURN (L_CURRENCY_WORD);
  END GET_WORD_VALUE;
  FUNCTION PRECISION(CUR_CODE IN VARCHAR2) RETURN NUMBER IS
    L_PRECISION NUMBER;
  BEGIN
    SELECT
      PRECISION
    INTO L_PRECISION
    FROM
      FND_CURRENCIES_VL
    WHERE CURRENCY_CODE = CUR_CODE;
    RETURN (L_PRECISION);
    RETURN NULL;
  EXCEPTION
    WHEN OTHERS THEN
      /*SRW.MESSAGE(999
                 ,'Error in procedure - precision')*/NULL;
      /*RAISE SRW.PROGRAM_ABORT*/RAISE_APPLICATION_ERROR(-20101,null);
  END PRECISION;
  FUNCTION CF_INVOICE_NUMFORMULA(INVOICE_NUMBER IN VARCHAR2) RETURN CHAR IS
  BEGIN
    DECLARE
      INV_NUM VARCHAR2(20);
    BEGIN
      IF INVOICE_NUMBER = 'ACC' THEN
        SELECT
          MEANING
        INTO INV_NUM
        FROM
          AR_LOOKUPS
        WHERE LOOKUP_TYPE = 'PAYMENT_TYPE'
          AND LOOKUP_CODE = 'ACC';
      ELSIF INVOICE_NUMBER = 'UNAPP' THEN
        SELECT
          MEANING
        INTO INV_NUM
        FROM
          AR_LOOKUPS
        WHERE LOOKUP_TYPE = 'PAYMENT_TYPE'
          AND LOOKUP_CODE = 'UNAPP';
      ELSE
        INV_NUM := INVOICE_NUMBER;
      END IF;
      RETURN (INV_NUM);
    END;
  END CF_INVOICE_NUMFORMULA;
  FUNCTION C_FUNC_CURRENCY_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_FUNC_CURRENCY;
  END C_FUNC_CURRENCY_P;
  FUNCTION C_PRECISION_P RETURN NUMBER IS
  BEGIN
    RETURN C_PRECISION;
  END C_PRECISION_P;
  FUNCTION C_STRUCT_NUM_P RETURN NUMBER IS
  BEGIN
    RETURN C_STRUCT_NUM;
  END C_STRUCT_NUM_P;
  FUNCTION C_SOB_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_SOB_NAME;
  END C_SOB_NAME_P;
  FUNCTION C_REPORT_START_DATE_P RETURN DATE IS
  BEGIN
    RETURN C_REPORT_START_DATE;
  END C_REPORT_START_DATE_P;
  FUNCTION C_REPORT_RUN_TIME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN C_REPORT_RUN_TIME;
  END C_REPORT_RUN_TIME_P;
  FUNCTION VLOCATION_ID_P RETURN NUMBER IS
  BEGIN
    RETURN VLOCATION_ID;
  END VLOCATION_ID_P;
  FUNCTION COMPANY_NAME_P RETURN VARCHAR2 IS
  BEGIN
    RETURN COMPANY_NAME;
  END COMPANY_NAME_P;
  FUNCTION NIT_NUMBER_P RETURN VARCHAR2 IS
  BEGIN
    RETURN NIT_NUMBER;
  END NIT_NUMBER_P;
  FUNCTION DIGIT_VERIF_P RETURN VARCHAR2 IS
  BEGIN
    RETURN DIGIT_VERIF;
  END DIGIT_VERIF_P;
  FUNCTION VADDRESS1_P RETURN VARCHAR2 IS
  BEGIN
    RETURN VADDRESS1;
  END VADDRESS1_P;
  FUNCTION VADDRESS2_P RETURN VARCHAR2 IS
  BEGIN
    RETURN VADDRESS2;
  END VADDRESS2_P;
  FUNCTION VREGION_P RETURN VARCHAR2 IS
  BEGIN
    RETURN VREGION;
  END VREGION_P;
  FUNCTION VTOWN_CITY_P RETURN VARCHAR2 IS
  BEGIN
    RETURN VTOWN_CITY;
  END VTOWN_CITY_P;
  FUNCTION VADDRESS3_P RETURN VARCHAR2 IS
  BEGIN
    RETURN VADDRESS3;
  END VADDRESS3_P;
  FUNCTION VCOUNTRY_P RETURN VARCHAR2 IS
  BEGIN
    RETURN VCOUNTRY;
  END VCOUNTRY_P;
/*   PROCEDURE JG_GET_SET_OF_BOOKS_INFO(SOBID IN NUMBER
                                    ,COAID OUT NOCOPY NUMBER
                                    ,SOBNAME OUT NOCOPY VARCHAR2
                                    ,FUNC_CURR OUT NOCOPY VARCHAR2
                                    ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin JG_INFO.JG_GET_SET_OF_BOOKS_INFO(:SOBID, :COAID, :SOBNAME, :FUNC_CURR, :ERRBUF); end;');
    STPROC.BIND_I(SOBID);
    STPROC.BIND_O(COAID);
    STPROC.BIND_O(SOBNAME);
    STPROC.BIND_O(FUNC_CURR);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,COAID);
    STPROC.RETRIEVE(3
                   ,SOBNAME);
    STPROC.RETRIEVE(4
                   ,FUNC_CURR);
    STPROC.RETRIEVE(5
                   ,ERRBUF);
  END JG_GET_SET_OF_BOOKS_INFO;
 PROCEDURE JG_GET_BUD_OR_ENC_NAME(ACTUAL_TYPE IN VARCHAR2
                                  ,TYPE_ID IN NUMBER
                                  ,NAME OUT NOCOPY VARCHAR2
                                  ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin JG_INFO.JG_GET_BUD_OR_ENC_NAME(:ACTUAL_TYPE, :TYPE_ID, :NAME, :ERRBUF); end;');
    STPROC.BIND_I(ACTUAL_TYPE);
    STPROC.BIND_I(TYPE_ID);
    STPROC.BIND_O(NAME);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(3
                   ,NAME);
    STPROC.RETRIEVE(4
                   ,ERRBUF);
  END JG_GET_BUD_OR_ENC_NAME;
  PROCEDURE JG_GET_LOOKUP_VALUE(LMODE IN VARCHAR2
                               ,CODE IN VARCHAR2
                               ,TYPE IN VARCHAR2
                               ,VALUE OUT NOCOPY VARCHAR2
                               ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin JG_INFO.JG_GET_LOOKUP_VALUE(:LMODE, :CODE, :TYPE, :VALUE, :ERRBUF); end;');
    STPROC.BIND_I(LMODE);
    STPROC.BIND_I(CODE);
    STPROC.BIND_I(TYPE);
    STPROC.BIND_O(VALUE);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(4
                   ,VALUE);
    STPROC.RETRIEVE(5
                   ,ERRBUF);
  END JG_GET_LOOKUP_VALUE;
  PROCEDURE JG_GET_FIRST_PERIOD(APP_ID IN NUMBER
                               ,TSET_OF_BOOKS_ID IN NUMBER
                               ,TPERIOD_NAME IN VARCHAR2
                               ,TFIRST_PERIOD OUT NOCOPY VARCHAR2
                               ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin JG_INFO.JG_GET_FIRST_PERIOD(:APP_ID, :TSET_OF_BOOKS_ID, :TPERIOD_NAME, :TFIRST_PERIOD, :ERRBUF); end;');
    STPROC.BIND_I(APP_ID);
    STPROC.BIND_I(TSET_OF_BOOKS_ID);
    STPROC.BIND_I(TPERIOD_NAME);
    STPROC.BIND_O(TFIRST_PERIOD);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(4
                   ,TFIRST_PERIOD);
    STPROC.RETRIEVE(5
                   ,ERRBUF);
  END JG_GET_FIRST_PERIOD;
   PROCEDURE JG_GET_FIRST_PERIOD_OF_QUARTER(APP_ID IN NUMBER
                                          ,TSET_OF_BOOKS_ID IN NUMBER
                                          ,TPERIOD_NAME IN VARCHAR2
                                          ,TFIRST_PERIOD OUT NOCOPY VARCHAR2
                                          ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin JG_INFO.JG_GET_FIRST_PERIOD_OF_QUARTER(:APP_ID, :TSET_OF_BOOKS_ID, :TPERIOD_NAME, :TFIRST_PERIOD, :ERRBUF); end;');
    STPROC.BIND_I(APP_ID);
    STPROC.BIND_I(TSET_OF_BOOKS_ID);
    STPROC.BIND_I(TPERIOD_NAME);
    STPROC.BIND_O(TFIRST_PERIOD);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(4
                   ,TFIRST_PERIOD);
    STPROC.RETRIEVE(5
                   ,ERRBUF);
  END JG_GET_FIRST_PERIOD_OF_QUARTER;
 FUNCTION JG_FORMAT_CURR_AMT(IN_PRECISION IN NUMBER
                             ,IN_AMOUNT_DISP IN VARCHAR2) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := JG_INFO.JG_FORMAT_CURR_AMT(:IN_PRECISION, :IN_AMOUNT_DISP); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(IN_PRECISION);
    STPROC.BIND_I(IN_AMOUNT_DISP);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END JG_FORMAT_CURR_AMT;*/
 /* PROCEDURE GL_GET_PERIOD_DATES(TSET_OF_BOOKS_ID IN NUMBER
                               ,TPERIOD_NAME IN VARCHAR2
                               ,TSTART_DATE OUT NOCOPY DATE
                               ,TEND_DATE OUT NOCOPY DATE
                               ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin GL_INFO.GL_GET_PERIOD_DATES(:TSET_OF_BOOKS_ID, :TPERIOD_NAME, :TSTART_DATE, :TEND_DATE, :ERRBUF); end;');
    STPROC.BIND_I(TSET_OF_BOOKS_ID);
    STPROC.BIND_I(TPERIOD_NAME);
    STPROC.BIND_O(TSTART_DATE);
    STPROC.BIND_O(TEND_DATE);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(3
                   ,TSTART_DATE);
    STPROC.RETRIEVE(4
                   ,TEND_DATE);
    STPROC.RETRIEVE(5
                   ,ERRBUF);
  END GL_GET_PERIOD_DATES;*/
  PROCEDURE GL_GET_SET_OF_BOOKS_INFO(SOBID IN NUMBER
                                    ,COAID OUT NOCOPY NUMBER
                                    ,SOBNAME OUT NOCOPY VARCHAR2
                                    ,FUNC_CURR OUT NOCOPY VARCHAR2
                                    ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
   GL_INFO.GL_GET_LEDGER_INFO(SOBID, COAID, SOBNAME, FUNC_CURR, ERRBUF);
  END GL_GET_SET_OF_BOOKS_INFO;
 /* PROCEDURE GL_GET_BUD_OR_ENC_NAME(ACTUAL_TYPE IN VARCHAR2
                                  ,TYPE_ID IN NUMBER
                                  ,NAME OUT NOCOPY VARCHAR2
                                  ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin GL_INFO.GL_GET_BUD_OR_ENC_NAME(:ACTUAL_TYPE, :TYPE_ID, :NAME, :ERRBUF); end;');
    STPROC.BIND_I(ACTUAL_TYPE);
    STPROC.BIND_I(TYPE_ID);
    STPROC.BIND_O(NAME);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(3
                   ,NAME);
    STPROC.RETRIEVE(4
                   ,ERRBUF);
  END GL_GET_BUD_OR_ENC_NAME;
 PROCEDURE GL_GET_LOOKUP_VALUE(LMODE IN VARCHAR2
                               ,CODE IN VARCHAR2
                               ,TYPE IN VARCHAR2
                               ,VALUE OUT NOCOPY VARCHAR2
                               ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin GL_INFO.GL_GET_LOOKUP_VALUE(:LMODE, :CODE, :TYPE, :VALUE, :ERRBUF); end;');
    STPROC.BIND_I(LMODE);
    STPROC.BIND_I(CODE);
    STPROC.BIND_I(TYPE);
    STPROC.BIND_O(VALUE);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(4
                   ,VALUE);
    STPROC.RETRIEVE(5
                   ,ERRBUF);
  END GL_GET_LOOKUP_VALUE;
   PROCEDURE GL_GET_FIRST_PERIOD(TSET_OF_BOOKS_ID IN NUMBER
                               ,TPERIOD_NAME IN VARCHAR2
                               ,TFIRST_PERIOD OUT NOCOPY VARCHAR2
                               ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin GL_INFO.GL_GET_FIRST_PERIOD(:TSET_OF_BOOKS_ID, :TPERIOD_NAME, :TFIRST_PERIOD, :ERRBUF); end;');
    STPROC.BIND_I(TSET_OF_BOOKS_ID);
    STPROC.BIND_I(TPERIOD_NAME);
    STPROC.BIND_O(TFIRST_PERIOD);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(3
                   ,TFIRST_PERIOD);
    STPROC.RETRIEVE(4
                   ,ERRBUF);
  END GL_GET_FIRST_PERIOD;
 PROCEDURE GL_GET_FIRST_PERIOD_OF_QUARTER(TSET_OF_BOOKS_ID IN NUMBER
                                          ,TPERIOD_NAME IN VARCHAR2
                                          ,TFIRST_PERIOD OUT NOCOPY VARCHAR2
                                          ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin GL_INFO.GL_GET_FIRST_PERIOD_OF_QUARTER(:TSET_OF_BOOKS_ID, :TPERIOD_NAME, :TFIRST_PERIOD, :ERRBUF); end;');
    STPROC.BIND_I(TSET_OF_BOOKS_ID);
    STPROC.BIND_I(TPERIOD_NAME);
    STPROC.BIND_O(TFIRST_PERIOD);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(3
                   ,TFIRST_PERIOD);
    STPROC.RETRIEVE(4
                   ,ERRBUF);
  END GL_GET_FIRST_PERIOD_OF_QUARTER;
   PROCEDURE GL_GET_CONSOLIDATION_INFO(CONS_ID IN NUMBER
                                     ,CONS_NAME OUT NOCOPY VARCHAR2
                                     ,METHOD OUT NOCOPY VARCHAR2
                                     ,CURR_CODE OUT NOCOPY VARCHAR2
                                     ,FROM_SOBID OUT NOCOPY NUMBER
                                     ,TO_SOBID OUT NOCOPY NUMBER
                                     ,DESCRIPTION OUT NOCOPY VARCHAR2
                                     ,START_DATE OUT NOCOPY DATE
                                     ,END_DATE OUT NOCOPY DATE
                                     ,ERRBUF OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin GL_INFO.GL_GET_CONSOLIDATION_INFO(:CONS_ID, :CONS_NAME, :METHOD, :CURR_CODE, :FROM_SOBID, :TO_SOBID, :DESCRIPTION, :START_DATE, :END_DATE, :ERRBUF); end;');
    STPROC.BIND_I(CONS_ID);
    STPROC.BIND_O(CONS_NAME);
    STPROC.BIND_O(METHOD);
    STPROC.BIND_O(CURR_CODE);
    STPROC.BIND_O(FROM_SOBID);
    STPROC.BIND_O(TO_SOBID);
    STPROC.BIND_O(DESCRIPTION);
    STPROC.BIND_O(START_DATE);
    STPROC.BIND_O(END_DATE);
    STPROC.BIND_O(ERRBUF);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,CONS_NAME);
    STPROC.RETRIEVE(3
                   ,METHOD);
    STPROC.RETRIEVE(4
                   ,CURR_CODE);
    STPROC.RETRIEVE(5
                   ,FROM_SOBID);
    STPROC.RETRIEVE(6
                   ,TO_SOBID);
    STPROC.RETRIEVE(7
                   ,DESCRIPTION);
    STPROC.RETRIEVE(8
                   ,START_DATE);
    STPROC.RETRIEVE(9
                   ,END_DATE);
    STPROC.RETRIEVE(10
                   ,ERRBUF);
  END GL_GET_CONSOLIDATION_INFO;
  FUNCTION GET_FORMAT_MASK(CURRENCY_CODE IN VARCHAR2
                          ,FIELD_LENGTH IN NUMBER) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := FND_CURRENCY.GET_FORMAT_MASK(:CURRENCY_CODE, :FIELD_LENGTH); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(CURRENCY_CODE);
    STPROC.BIND_I(FIELD_LENGTH);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_FORMAT_MASK;
 FUNCTION SAFE_GET_FORMAT_MASK(CURRENCY_CODE IN VARCHAR2
                               ,FIELD_LENGTH IN NUMBER) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := FND_CURRENCY.SAFE_GET_FORMAT_MASK(:CURRENCY_CODE, :FIELD_LENGTH); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(CURRENCY_CODE);
    STPROC.BIND_I(FIELD_LENGTH);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END SAFE_GET_FORMAT_MASK;*/
  PROCEDURE GET_INFO(CURRENCY_CODE IN VARCHAR2
                    ,PRECISION OUT NOCOPY NUMBER
                    ,EXT_PRECISION OUT NOCOPY NUMBER
                    ,MIN_ACCT_UNIT OUT NOCOPY NUMBER) IS
  BEGIN
  FND_CURRENCY.GET_INFO(CURRENCY_CODE, PRECISION, EXT_PRECISION, MIN_ACCT_UNIT);
  END GET_INFO;
 /* PROCEDURE BUILD_FORMAT_MASK(FORMAT_MASK OUT NOCOPY VARCHAR2
                             ,FIELD_LENGTH IN NUMBER
                             ,PRECISION IN NUMBER
                             ,MIN_ACCT_UNIT IN NUMBER
                             ,DISP_GRP_SEP IN BOOLEAN
                             ,NEG_FORMAT IN VARCHAR2
                             ,POS_FORMAT IN VARCHAR2) IS
  BEGIN
    STPROC.INIT('declare DISP_GRP_SEP BOOLEAN; begin DISP_GRP_SEP := sys.diutil.int_to_bool(:DISP_GRP_SEP); FND_CURRENCY.BUILD_FORMAT_MASK(:FORMAT_MASK, :FIELD_LENGTH, :PRECISION, :MIN_ACCT_UNIT, DISP_GRP_SEP, :NEG_FORMAT, :POS_FORMAT); end;');
    STPROC.BIND_I(DISP_GRP_SEP);
    STPROC.BIND_O(FORMAT_MASK);
    STPROC.BIND_I(FIELD_LENGTH);
    STPROC.BIND_I(PRECISION);
    STPROC.BIND_I(MIN_ACCT_UNIT);
    STPROC.BIND_I(NEG_FORMAT);
    STPROC.BIND_I(POS_FORMAT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,FORMAT_MASK);
  END BUILD_FORMAT_MASK;
  PROCEDURE SAFE_BUILD_FORMAT_MASK(FORMAT_MASK OUT NOCOPY VARCHAR2
                                  ,FIELD_LENGTH IN NUMBER
                                  ,PRECISION IN NUMBER
                                  ,MIN_ACCT_UNIT IN NUMBER
                                  ,DISP_GRP_SEP IN BOOLEAN
                                  ,NEG_FORMAT IN VARCHAR2
                                  ,POS_FORMAT IN VARCHAR2) IS
  BEGIN
    STPROC.INIT('declare DISP_GRP_SEP BOOLEAN; begin DISP_GRP_SEP := sys.diutil.int_to_bool(:DISP_GRP_SEP); FND_CURRENCY.SAFE_BUILD_FORMAT_MASK(:FORMAT_MASK, :FIELD_LENGTH, :PRECISION, :MIN_ACCT_UNIT, DISP_GRP_SEP, :NEG_FORMAT, :POS_FORMAT); end;');
    STPROC.BIND_I(DISP_GRP_SEP);
    STPROC.BIND_O(FORMAT_MASK);
    STPROC.BIND_I(FIELD_LENGTH);
    STPROC.BIND_I(PRECISION);
    STPROC.BIND_I(MIN_ACCT_UNIT);
    STPROC.BIND_I(NEG_FORMAT);
    STPROC.BIND_I(POS_FORMAT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,FORMAT_MASK);
  END SAFE_BUILD_FORMAT_MASK;
  PROCEDURE SET_NAME(APPLICATION IN VARCHAR2
                    ,NAME IN VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.SET_NAME(:APPLICATION, :NAME); end;');
    STPROC.BIND_I(APPLICATION);
    STPROC.BIND_I(NAME);
    STPROC.EXECUTE;
  END SET_NAME;
  PROCEDURE SET_TOKEN(TOKEN IN VARCHAR2
                     ,VALUE IN VARCHAR2
                     ,TRANSLATE IN BOOLEAN) IS
  BEGIN
    STPROC.INIT('declare TRANSLATE BOOLEAN; begin TRANSLATE := sys.diutil.int_to_bool(:TRANSLATE); FND_MESSAGE.SET_TOKEN(:TOKEN, :VALUE, TRANSLATE); end;');
    STPROC.BIND_I(TRANSLATE);
    STPROC.BIND_I(TOKEN);
    STPROC.BIND_I(VALUE);
    STPROC.EXECUTE;
  END SET_TOKEN; */
 /* PROCEDURE RETRIEVE(MSGOUT OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.RETRIEVE(:MSGOUT); end;');
    STPROC.BIND_O(MSGOUT);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,MSGOUT);
  END RETRIEVE;*/
/*  PROCEDURE CLEAR IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.CLEAR; end;');
    STPROC.EXECUTE;
  END CLEAR;*/
  /*FUNCTION GET_STRING(APPIN IN VARCHAR2
                     ,NAMEIN IN VARCHAR2) RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := FND_MESSAGE.GET_STRING(:APPIN, :NAMEIN); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPIN);
    STPROC.BIND_I(NAMEIN);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_STRING;*/
   /*FUNCTION GET_NUMBER(APPIN IN VARCHAR2
                     ,NAMEIN IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := FND_MESSAGE.GET_NUMBER(:APPIN, :NAMEIN); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPIN);
    STPROC.BIND_I(NAMEIN);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_NUMBER;*/
 /* FUNCTION GET RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := FND_MESSAGE.GET; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET;*/
 /* FUNCTION GET_ENCODED RETURN VARCHAR2 IS
    X0 VARCHAR2(2000);
  BEGIN
    STPROC.INIT('begin :X0 := FND_MESSAGE.GET_ENCODED; end;');
    STPROC.BIND_O(X0);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_ENCODED;*/
  /*PROCEDURE PARSE_ENCODED(ENCODED_MESSAGE IN VARCHAR2
                         ,APP_SHORT_NAME OUT NOCOPY VARCHAR2
                         ,MESSAGE_NAME OUT NOCOPY VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.PARSE_ENCODED(:ENCODED_MESSAGE, :APP_SHORT_NAME, :MESSAGE_NAME); end;');
    STPROC.BIND_I(ENCODED_MESSAGE);
    STPROC.BIND_O(APP_SHORT_NAME);
    STPROC.BIND_O(MESSAGE_NAME);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(2
                   ,APP_SHORT_NAME);
    STPROC.RETRIEVE(3
                   ,MESSAGE_NAME);
  END PARSE_ENCODED;*/
  /* PROCEDURE SET_ENCODED(ENCODED_MESSAGE IN VARCHAR2) IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.SET_ENCODED(:ENCODED_MESSAGE); end;');
    STPROC.BIND_I(ENCODED_MESSAGE);
    STPROC.EXECUTE;
  END SET_ENCODED;*/
  /*PROCEDURE RAISE_ERROR IS
  BEGIN
    STPROC.INIT('begin FND_MESSAGE.RAISE_ERROR; end;');
    STPROC.EXECUTE;
  END RAISE_ERROR;*/
 /* FUNCTION GET_NEXT_SEQUENCE(APPID IN NUMBER
                            ,CAT_CODE IN VARCHAR2
                            ,SOBID IN NUMBER
                            ,MET_CODE IN VARCHAR2
                            ,TRX_DATE IN DATE
                            ,DBSEQNM IN OUT NOCOPY VARCHAR2
                            ,DBSEQID IN OUT NOCOPY INTEGER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_SEQUENCE(:APPID, :CAT_CODE, :SOBID, :MET_CODE, :TRX_DATE, :DBSEQNM, :DBSEQID); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPID);
    STPROC.BIND_I(CAT_CODE);
    STPROC.BIND_I(SOBID);
    STPROC.BIND_I(MET_CODE);
    STPROC.BIND_I(TRX_DATE);
    STPROC.BIND_IO(DBSEQNM);
    STPROC.BIND_IO(DBSEQID);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    STPROC.RETRIEVE(7
                   ,DBSEQNM);
    STPROC.RETRIEVE(8
                   ,DBSEQID);
    RETURN X0;
  END GET_NEXT_SEQUENCE; */
 /* PROCEDURE GET_SEQ_NAME(APPID IN NUMBER
                        ,CAT_CODE IN VARCHAR2
                        ,SOBID IN NUMBER
                        ,MET_CODE IN VARCHAR2
                        ,TRX_DATE IN DATE
                        ,DBSEQNM OUT NOCOPY VARCHAR2
                        ,DBSEQID OUT NOCOPY INTEGER
                        ,SEQASSID OUT NOCOPY INTEGER) IS
  BEGIN
    STPROC.INIT('begin FND_SEQNUM.GET_SEQ_NAME(:APPID, :CAT_CODE, :SOBID, :MET_CODE, :TRX_DATE, :DBSEQNM, :DBSEQID, :SEQASSID); end;');
    STPROC.BIND_I(APPID);
    STPROC.BIND_I(CAT_CODE);
    STPROC.BIND_I(SOBID);
    STPROC.BIND_I(MET_CODE);
    STPROC.BIND_I(TRX_DATE);
    STPROC.BIND_O(DBSEQNM);
    STPROC.BIND_O(DBSEQID);
    STPROC.BIND_O(SEQASSID);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(6
                   ,DBSEQNM);
    STPROC.RETRIEVE(7
                   ,DBSEQID);
    STPROC.RETRIEVE(8
                   ,SEQASSID);
  END GET_SEQ_NAME;*/
   /*FUNCTION GET_NEXT_AUTO_SEQ(DBSEQNM IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_AUTO_SEQ(:DBSEQNM); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(DBSEQNM);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_NEXT_AUTO_SEQ; */
   /*FUNCTION GET_NEXT_AUTO_SEQUENCE(APPID IN NUMBER
                                 ,CAT_CODE IN VARCHAR2
                                 ,SOBID IN NUMBER
                                 ,MET_CODE IN VARCHAR2
                                 ,TRX_DATE IN VARCHAR2) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_AUTO_SEQUENCE(:APPID, :CAT_CODE, :SOBID, :MET_CODE, :TRX_DATE); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(APPID);
    STPROC.BIND_I(CAT_CODE);
    STPROC.BIND_I(SOBID);
    STPROC.BIND_I(MET_CODE);
    STPROC.BIND_I(TRX_DATE);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_NEXT_AUTO_SEQUENCE;*/
 /* PROCEDURE CREATE_GAPLESS_SEQUENCES IS
  BEGIN
    STPROC.INIT('begin FND_SEQNUM.CREATE_GAPLESS_SEQUENCES; end;');
    STPROC.EXECUTE;
  END CREATE_GAPLESS_SEQUENCES;*/
  /*FUNCTION CREATE_GAPLESS_SEQUENCE(SEQID IN NUMBER
                                  ,SEQASSID IN NUMBER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := FND_SEQNUM.CREATE_GAPLESS_SEQUENCE(:SEQID, :SEQASSID); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(SEQID);
    STPROC.BIND_I(SEQASSID);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END CREATE_GAPLESS_SEQUENCE;*/
 /* FUNCTION GET_NEXT_USER_SEQUENCE(FDS_USER_ID IN NUMBER
                                 ,SEQASSID IN NUMBER
                                 ,SEQID IN NUMBER) RETURN NUMBER IS
    X0 NUMBER;
  BEGIN
    STPROC.INIT('begin :X0 := FND_SEQNUM.GET_NEXT_USER_SEQUENCE(:FDS_USER_ID, :SEQASSID, :SEQID); end;');
    STPROC.BIND_O(X0);
    STPROC.BIND_I(FDS_USER_ID);
    STPROC.BIND_I(SEQASSID);
    STPROC.BIND_I(SEQID);
    STPROC.EXECUTE;
    STPROC.RETRIEVE(1
                   ,X0);
    RETURN X0;
  END GET_NEXT_USER_SEQUENCE;*/
END JL_JLCOARCR_XMLP_PKG;



/
