--------------------------------------------------------
--  DDL for Package Body PAY_US_GARN_UPGRADE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."PAY_US_GARN_UPGRADE" AS
/* $Header: pyusgrup.pkb 120.1.12010000.2 2010/02/19 10:15:06 nkjaladi ship $ */
/*****************************************************************************
   ******************************************************************
   *                                                                *
   *  Copyright (C) 1996 Oracle Corporation.                        *
   *  All rights reserved.                                          *
   *                                                                *
   *  This material has been provided pursuant to an agreement      *
   *  containing restrictions on its use.  The material is also     *
   *  protected by copyright law.  No part of this material may     *
   *  be copied or distributed, transmitted or transcribed, in      *
   *  any form or by any means, electronic, mechanical, magnetic,   *
   *  manual, or otherwise, or disclosed to third parties without   *
   *  the express written permission of Oracle Corporation,         *
   *  500 Oracle Parkway, Redwood City, CA, 94065.                  *
   *                                                                *
   ******************************************************************

    Name        : pay_us_garn_upgrade

    Description : This package is called by a concurrent program.
                  In this package we upgrade all old architectural
                  Garnishment Elements to New architecture.

                  NOTE : Customer needs to recompile all uncompiled
                         formulas after running the Upgrade Process.

    Change List
    -----------
        Date       Name     Ver     Bug No    Description
     ----------- -------- -------  ---------  -------------------------------
     30-Sep-2004 kvsankar  115.0    3549298   Created.
     21-feb-2005 djoshi    115.1    4198125   We are not deleting the
                                              input values for newly created
                                              base element in upgrade
                                              we need to delete input values
     27-Sep-2006 sudedas   115.2    5497299   Modify proc modify_calc_res_rule.
                                              Formula Result WH_FEE_AMT will
                                              feed Old Fees 'Withheld Fee Amount'
                                              Instead of New Fees.
                                              Changed cursor c_get_mig_elem_bg
                                              in proc qual_elem_upg.
     19-Feb-2010 nkjaladi  115.3    8972240   Modifed proc upgrade_garnishment
                                              to update the old element special
					      inputs element information with
					      the newly created special
					      inputs element information value
*****************************************************************************/

 /************************************************************
  ** Local Package Variables
  ************************************************************/
  type varchar2_tab is table of varchar2(100) index by binary_integer;
  type number_tab is table of number index by binary_integer;
  gv_name_not_gen        varchar2_tab;
  gv_count_name          number;
  gv_package_name        varchar2(50);
  gv_location            number;

/*****************************************************************************
  Name         : get_new_elem_name

  Description  : This function returns a new name that can be used for the
                 new element. The element name is based on the old element
                 name with suffix _New added. If the element already exists
                 then we try with combination like _New1, _New2 etc.
                 A check for New element name > 40 characters is also made.
                 Element names generated by this function will be less
                 than 40 characters. This is required so that no errors are
                 generated when we try to create a New element.
                 This function also takes into consideration the names
                 already tried. If a name errored out, it generates a
                 different name for trying.
  Return Value : Name to be used for creating a new element.
*****************************************************************************/
FUNCTION get_new_elem_name(p_old_ele_name    varchar2,
                           p_business_grp_id number) RETURN  VARCHAR2
  IS

-- Cursor to check if the name alreadt exists
cursor c_get_name_exists(c_ele_name varchar2) IS
select 'Exists'
  from pay_element_types_f
 where (upper(element_name) like upper(c_ele_name) OR
        upper(element_name) like upper(c_ele_name || ' Calculator'))
   and business_group_id = p_business_grp_id;

l_new_ele_name varchar2(80);
l_ele_suffix   varchar2(10);
l_num_suffix   number;
l_exists       varchar2(20);
l_trunc_old_name varchar2(80);
l_name_count     number;
l_regenerate     boolean;

BEGIN

   l_num_suffix     := 0;
   l_ele_suffix     := '_New';
   l_trunc_old_name := p_old_ele_name;
   l_name_count     := 0;

   --
   loop
      l_regenerate     := FALSE;
      if l_num_suffix = 0 then
         l_new_ele_name := l_trunc_old_name || l_ele_suffix;
      else
         l_new_ele_name := l_trunc_old_name || l_ele_suffix || to_char(l_num_suffix);
      end if;
      l_num_suffix := l_num_suffix + 1;

      /*
       * If length of the new element is greater than 40, then truncate
       * the name to 34 chars and then add _New suffix for the new element.
       * We cannot create elements with name > 40 characters.
       */
      if length(l_new_ele_name) > 40 then
         l_trunc_old_name := substr(p_old_ele_name ,0,34);
         l_num_suffix := 0;
         l_new_ele_name := l_trunc_old_name || l_ele_suffix;
      end if;

      open c_get_name_exists(l_new_ele_name);
      fetch c_get_name_exists into l_exists;
      if c_get_name_exists%FOUND then
          l_regenerate := TRUE;
      end if;
      close c_get_name_exists;

      /*
       * If element does not exist in database Check if it had been tried
       * earlier. If YES then generate a new name.
       */
      if NOT(l_regenerate) then
         if gv_count_name <> 0 then
            /*
             * Check if the name generated has been tried earlier.
             * If Yes regenerate New name.
             */
            for l_name_count in gv_name_not_gen.first..gv_name_not_gen.last loop
               if l_new_ele_name = gv_name_not_gen(l_name_count) then
                  l_regenerate := TRUE;
                  exit;
               end if;
            end loop;
         end if;
      end if;

      /*
       * If no need to regerate then check for existence in the database
       */
      if NOT(l_regenerate) then
         exit;
      end if;
   end loop;
   return l_new_ele_name;
END;

/*****************************************************************************
  Name        : modify_formula_text

  Description : This function modifies the Base formula of the New element.
                All references in the formuals to the New element are
                replaced by references to the corrresponding old element.
*****************************************************************************/
PROCEDURE modify_formula_text(p_old_ele_name   varchar2,
                              p_new_ele_name   varchar2,
                              p_ele_categ      varchar2,
                              p_business_grp_id  number
                             )
  IS

-- Get Formula Text for modification
cursor c_formula_text(cp_formula_name varchar2) IS
select formula_text
  from ff_formulas_f
 where formula_name = cp_formula_name
   and business_group_id = p_business_grp_id;

l_formula_name     varchar2(100);
l_cal_formula_name varchar2(100);
l_formula_text     long;
l_new_formula_text long;
BEGIN
   hr_utility.trace('Entering ' || gv_package_name || '.modify_formula_text');

   /*
    * IF ELSE condition is used to form the formula name that will be
    * modified. Replace is used for replacing the SPACES woth '_' as
    * formulas names do not have spaces.
    */
   if p_ele_categ in ('AY', 'CS', 'SS') then
      l_formula_name     := upper(replace(p_new_ele_name, ' ' ,'_')) || '_AY_BALANCE_SETUP_FORMULA';
      l_cal_formula_name := upper(replace(p_new_ele_name, ' ' ,'_')) || '_AY_CHILD_SUP_CALCULATION_FORMULA';
   elsif p_ele_categ in ('CD', 'G') then
      l_formula_name     := upper(replace(p_new_ele_name, ' ' ,'_')) || '_CD_BALANCE_SETUP_FORMULA';
      l_cal_formula_name := upper(replace(p_new_ele_name, ' ' ,'_')) || '_CD_GARN_CALCULATION_FORMULA';
   elsif p_ele_categ = 'BO' then
      l_formula_name     := upper(replace(p_new_ele_name, ' ' ,'_')) || '_BO_BALANCE_SETUP_FORMULA';
      l_cal_formula_name := upper(replace(p_new_ele_name, ' ' ,'_')) || '_BO_GARN_CALCULATION_FORMULA';
   elsif p_ele_categ = 'EL' then
      l_formula_name     := upper(replace(p_new_ele_name, ' ' ,'_')) || '_EL_BALANCE_SETUP_FORMULA';
      l_cal_formula_name := upper(replace(p_new_ele_name, ' ' ,'_')) || '_EL_BALANCE_SETUP_FORMULA';
   elsif p_ele_categ = 'ER' then
      l_formula_name     := upper(replace(p_new_ele_name, ' ' ,'_')) || '_ER_BALANCE_SETUP_FORMULA';
      l_cal_formula_name := upper(replace(p_new_ele_name, ' ' ,'_')) || '_ER_BALANCE_SETUP_FORMULA';
   elsif p_ele_categ = 'TL' then
      l_formula_name     := upper(replace(p_new_ele_name, ' ' ,'_')) || '_TL_BALANCE_SETUP_FORMULA';
      l_cal_formula_name := upper(replace(p_new_ele_name, ' ' ,'_')) || '_TL_FED_LEVY_CALCULATION_FORMULA';
   end if;

   hr_utility.trace('Modifying Formula ' || l_formula_name);

   l_formula_text := NULL;
   open c_formula_text(l_formula_name);
   fetch c_formula_text into l_formula_text;
   close c_formula_text;

   l_new_formula_text := replace(l_formula_text,
                                 upper(replace(p_new_ele_name, ' ' ,'_')),
                                 upper(replace(p_old_ele_name, ' ' ,'_')));

   update ff_formulas_f
      set formula_text = l_new_formula_text
    where formula_name = l_formula_name
      and business_group_id = p_business_grp_id;

   /*
    * Removing Entry from ff_compiled_info and ff_fdi_usages for both the formulas
    * that are created for the new element. Customer needs to recompile all the
    * formulae after running this process.
    */
   delete
     from ff_compiled_info
    where formula_id in (select formula_id
                           from ff_formulas_f
                          where formula_name in (l_formula_name,
                                                 l_cal_formula_name));
   delete
     from ff_fdi_usages
    where formula_id in (select formula_id
                           from ff_formulas_f
                          where formula_name in (l_formula_name,
                                                 l_cal_formula_name));

   hr_utility.trace('Leaving ' || gv_package_name || '.modify_formula_text');

END modify_formula_text;

/*****************************************************************************
  Name         : create_new_element

  Description  : This function creates a new element for the old element
                 passed. This uses the effective start date and effective
                 end date of the old element to create the new element. These
                 dates are passed in as parameters.
  Return Value : 0             ---> Indicates Error
                 Other than 0  ---> Element Type ID of the new element.
*****************************************************************************/
FUNCTION create_new_element(p_old_ele_type_id number,
                            p_business_grp_id number,
                            p_eff_start_date  date,
                            p_eff_end_date    date) RETURN number
  IS

-- Get the details of the old element
cursor c_get_old_ele_det(cp_eff_date date) IS
select element_name,
       reporting_name,
       description,
       benefit_classification_id,
       element_information1 category,
       processing_type,
       processing_priority,
       standard_link_flag,
       element_information3 processing_runtype,
       post_termination_rule
  from pay_element_types_f
 where element_type_id =  p_old_ele_type_id
   and business_group_id = p_business_grp_id
   and cp_eff_date between effective_start_date
                          and effective_end_date
 order by effective_start_date;

cursor c_get_new_ele_det(cp_ele_type_id  number) IS
select formula_id,                   -- Formula ID for Skip Rule
       element_information2,
       element_information5,         -- Calculator Element
       element_information8,         -- Voluntary Deductions
       element_information19,        -- Special Features
       element_information20         -- Verifier
  from pay_element_types_f
 where element_type_id = cp_ele_type_id
   and business_group_id = p_business_grp_id;


l_old_ele_name    varchar2(100);
l_new_elem_name   varchar2(100);
l_reporting_name  varchar2(200);
l_description     varchar2(400);
l_ben_class_id    number;
l_ele_cat         varchar2(10);
l_process_type    varchar2(10);
l_process_prty    number;
l_std_link_flag   varchar2(10);
l_process_runtype varchar2(10);
l_start_rule      varchar2(10);
l_stop_rule       varchar2(10);
l_amount_rule     varchar2(10);
l_ser_ee_bond     varchar2(10);
l_arrearage       varchar2(10);
l_ded_partial     varchar2(10);
l_emp_match       varchar2(10);
l_aft_tax_comp    varchar2(10);
l_srs_plan_type   varchar2(10);
l_srs_buy_back    varchar2(10);
l_catch_up_proc   varchar2(10);
l_post_term_rule  varchar2(10);
l_new_ele_type_id number;
l_count           number;
l_skip_rule       number;
l_elem_inf2       varchar2(100);
l_cal_elem        varchar2(100);
l_vol_dedn        varchar2(100);
l_spec_feat       varchar2(100);
l_verifier        varchar2(100);

BEGIN
--    hr_utility.trace_on(NULL, 'Dedn');
    hr_utility.trace('Entering ' || gv_package_name || '.create_new_element');

    /*
     * Initialization Code
     */
    l_start_rule          := 'OE';
    l_stop_rule           := 'OE';
    l_amount_rule         := 'FA';
    l_ser_ee_bond         := 'N';
    l_arrearage           := 'N';
    l_ded_partial         := 'N';
    l_emp_match           := 'N';
    l_aft_tax_comp        := 'N';
    l_srs_plan_type       := 'N';
    l_srs_buy_back        := 'N';
    l_catch_up_proc       := 'NONE';
    l_count               := 0;
    gv_count_name         := 0;
    gv_name_not_gen.delete;

   /*
    * Setting Location for identifying error
    */
    gv_location           := 1;

    /*
     * In case where there has been some date effective change done to
     * Involuntary Deduction element, the latest record is taken into account
     * for the creation of new element.
     */
    open c_get_old_ele_det(p_eff_end_date);
    fetch c_get_old_ele_det into l_old_ele_name
                                ,l_reporting_name
                                ,l_description
                                ,l_ben_class_id
                                ,l_ele_cat
                                ,l_process_type
                                ,l_process_prty
                                ,l_std_link_flag
                                ,l_process_runtype
                                ,l_post_term_rule;
    close c_get_old_ele_det;


    if l_description is NULL then
       l_description := 'New Architectural Element For ' || l_old_ele_name;
    else
       l_description := l_description || ' New Architectural Element For ' || l_old_ele_name;
    end if;


    /*
     * Trace Statements
     */
    hr_utility.trace('Old Element ' || l_old_ele_name);
    hr_utility.trace('Old Element Type ID ' || p_old_ele_type_id);
    hr_utility.trace('Effective Start Date ' || p_eff_start_date);
    hr_utility.trace('Effective End Date ' || p_eff_end_date);
--    hr_utility.trace_off();

    /*
     * This loop tries to create a New element for the Old element
     * A maximum of 10 elements are tried for a single OLD element.
     * IF the creation of ALL 10 fail we error the upgrade process for the
     * OLD element. After succesful creation of the very first New element we
     * exit out of the loop and continue the process.
     */
    loop
       begin
          /*
           * Get the new element name. If the creation the new errors out,
           * add the new element to the global table used by get_new_elem_name
           * function. The function then will return a new name other than
           * the one tried now.
           */
          l_new_elem_name := get_new_elem_name(l_old_ele_name,
                                               p_business_grp_id);
--          hr_utility.trace_on(NULL, 'Dedn');
          hr_utility.trace('Element Name Trying ' || l_new_elem_name);
--          hr_utility.trace_off();

          /*
           * Create a Savepoint. If the element creation fails half way through
           * then we need to rollback whatever is done before trying to
           * create another NEW architectural element for the same old element
           */
          savepoint ELEM_CREAT;
          l_new_ele_type_id  := pay_us_dedn_template_wrapper.create_deduction_element(
               p_element_name        => l_new_elem_name
              ,p_reporting_name      => l_reporting_name
              ,p_description         => l_description
              ,p_classification_name => 'Involuntary Deductions'
              ,p_ben_class_id        => l_ben_class_id
              ,p_category            => l_ele_cat
              ,p_processing_type     => l_process_type
              ,p_processing_priority => l_process_prty
              ,p_standard_link_flag  => l_std_link_flag
              ,p_processing_runtype  => l_process_runtype
              ,p_start_rule          => l_start_rule
              ,p_stop_rule           => l_stop_rule
              ,p_amount_rule         => l_amount_rule
              ,p_series_ee_bond      => l_ser_ee_bond
              ,p_payroll_table       => NULL
              ,p_paytab_column       => NULL
              ,p_rowtype_meaning     => NULL
              ,p_arrearage           => l_ded_partial
              ,p_deduct_partial      => l_ded_partial
              ,p_employer_match      => l_emp_match
              ,p_aftertax_component  => l_aft_tax_comp
              ,p_ele_eff_start_date  => p_eff_start_date
              ,p_ele_eff_end_date    => p_eff_end_date
              ,p_business_group_id   => p_business_grp_id
              ,p_catchup_processing  => l_catch_up_proc
              ,p_termination_rule    => l_post_term_rule
              ,p_srs_plan_type       => l_srs_plan_type
              ,p_srs_buy_back        => l_srs_buy_back
            );
       exception
          when others then
--             hr_utility.trace_on(NULL, 'Dedn');
             hr_utility.trace('Element Name Tried ' || l_new_elem_name);
--             hr_utility.trace_off();
             /*
              * Rollback to the point where the element creation was started
              */
             rollback to ELEM_CREAT;
             gv_count_name := gv_count_name + 1;
             gv_name_not_gen(gv_count_name) := l_new_elem_name;
             l_new_ele_type_id := 0;
       end; /* End Creation of element */

       /*
        * If the number of tries for creating a new element goes more than
        * 10, then we stop the upgrade process for that element and error out
        * the upgrade process for that element alone.
        */
       if l_new_ele_type_id <> 0 or gv_count_name > 10 then
          exit;
       end if;
    end loop;

    gv_count_name         := 0;
    gv_name_not_gen.delete;

--    hr_utility.trace_on(NULL, 'Dedn');
    hr_utility.trace('New Element ' || l_new_elem_name);
    hr_utility.trace('New Element Type ID ' || l_new_ele_type_id);

    if l_new_ele_type_id <> 0 then

       hr_utility.trace('Before CALL to modify_formula_text');
       /*
        * Modify The Formula text of New Base Formula
        */
       modify_formula_text(l_old_ele_name
                          ,l_new_elem_name
                          ,l_ele_cat
                          ,p_business_grp_id);

       /*
        * Modifying the OLD Base Element
        */
       open c_get_new_ele_det(l_new_ele_type_id);
       fetch c_get_new_ele_det into l_skip_rule
                                   ,l_elem_inf2
                                   ,l_cal_elem
                                   ,l_vol_dedn
                                   ,l_spec_feat
                                   ,l_verifier;
       close c_get_new_ele_det;
       update pay_element_types_f
          set formula_id = l_skip_rule
             ,element_information2 = l_elem_inf2
             ,element_information5 = l_cal_elem
             ,element_information8 = l_vol_dedn
             ,element_information19 = l_spec_feat
             ,element_information20 = l_verifier
        where element_type_id = p_old_ele_type_id
          and business_group_id = p_business_grp_id;

    end if;

    hr_utility.trace('Leaving ' || gv_package_name || '.create_new_element');
    return l_new_ele_type_id;

exception
  --
  when others then
    l_new_ele_type_id := 0;
--    hr_utility.trace_on(NULL, 'Dedn');
    hr_utility.trace('Could not create new element');
    return l_new_ele_type_id;
END;

/*****************************************************************************
  Name        : copy_result_rules

  Description : STEP 1
                This function first deletes all the formula result rules for
                the old element.
                STEP 2
                It copies the formula result rules from the Base element
                of the New element created to the Base element of the Old
                element.
*****************************************************************************/
PROCEDURE copy_result_rules(p_old_ele_type_id    number,
                            p_new_ele_type_id    number,
                            p_business_grp_id  number
                           )
  IS

-- Get processing rules that need to be copied
cursor c_get_stat_proc_rules(cp_ele_type_id number,
                             cp_bg_grp_id  number) IS
select business_group_id,
	   legislation_code,
	   legislation_subgroup,
       effective_start_date,
       effective_end_date,
	   assignment_status_type_id,
       formula_id,
	   processing_rule
 from pay_status_processing_rules_f
where element_type_id in (select element_type_id
                            from pay_element_types_f
                           where element_type_id =  cp_ele_type_id
                             and business_group_id = cp_bg_grp_id);

-- Get the formula result rules that need to be copied
cursor c_get_form_result_rules(cp_ele_type_id varchar2,
                               cp_bg_grp_id   number) IS
select pfrrf.business_group_id,
       NULL legislation_code,
       NULL legislation_sub_grp,
       pfrrf.effective_start_date,
       pfrrf.effective_end_date,
       pfrrf.input_value_id,
       pfrrf.result_name,
       pfrrf.result_rule_type,
       pfrrf.severity_level,
       pfrrf.element_type_id
  from pay_status_processing_rules_f psprf,
       pay_element_types_f petf,
       pay_formula_result_rules_f pfrrf
 where petf.element_type_id = cp_ele_type_id
   and petf.business_group_id = cp_bg_grp_id
   and psprf.element_type_id = petf.element_type_id
   and pfrrf.status_processing_rule_id = psprf.status_processing_rule_id;

l_bg_id               number;
l_leg_code            varchar2(10);
l_leg_sub_grp         varchar2(10);
l_eff_start_date      date;
l_eff_end_date        date;
l_stat_proc_rule_id   number;
l_input_val_id        number;
l_result_name         varchar2(100);
l_result_rule_type    varchar2(10);
l_severity_level      varchar2(10);
l_ele_type_id         number;
l_form_res_rule_id    number;
l_assg_stat_type_id   number;
l_formula_id          number;
l_process_rule        varchar2(10);

BEGIN
   hr_utility.trace('Entering ' || gv_package_name || '.copy_result_rules');

   /*
    * Delete the formula result rules for the Old element.
    */
   delete from pay_formula_result_rules_f
         where status_processing_rule_id in (select distinct status_processing_rule_id
                                               from pay_status_processing_rules_f psprf,
                                                    pay_element_types_f petf
                                              where petf.element_type_id = p_old_ele_type_id
                                                and psprf.element_type_id = petf.element_type_id
		                                        and petf.business_group_id = p_business_grp_id);
   delete from pay_status_processing_rules_f
         where element_type_id in (select distinct element_type_id
                                     from pay_element_types_f
                                    where element_type_id = p_old_ele_type_id
                                      and business_group_id = p_business_grp_id);

   open c_get_stat_proc_rules(p_new_ele_type_id,
                              p_business_grp_id);
   --
   fetch c_get_stat_proc_rules into l_bg_id
                                   ,l_leg_code
                                   ,l_leg_sub_grp
                                   ,l_eff_start_date
                                   ,l_eff_end_date
                                   ,l_assg_stat_type_id
                                   ,l_formula_id
                                   ,l_process_rule;
   close c_get_stat_proc_rules;

--   hr_utility.trace_off;

   /*
    * Create Processing Rule for Old Base Element. Use the Data
    * obtained in the cursor 'c_get_stat_proc_rules'
    */
   l_stat_proc_rule_id := pay_formula_results.ins_stat_proc_rule (
                               p_business_group_id          => l_bg_id
                              ,p_legislation_code           => l_leg_code
                              ,p_legislation_subgroup       => l_leg_sub_grp
                              ,p_effective_start_date       => l_eff_start_date
                              ,p_effective_end_date         => l_eff_end_date
                              ,p_element_type_id            => p_old_ele_type_id
                              ,p_assignment_status_type_id 	=> l_assg_stat_type_id
                              ,p_formula_id                 => l_formula_id
                              ,p_processing_rule            => l_process_rule);


   /*
    * Create Formula Resuls rules for the Old element
    * based on the new element's formula result rules
    */
   open c_get_form_result_rules(p_new_ele_type_id,
                                p_business_grp_id);
   loop
      fetch c_get_form_result_rules into l_bg_id
                                        ,l_leg_code
                                        ,l_leg_sub_grp
                                        ,l_eff_start_date
                                        ,l_eff_end_date
                                        ,l_input_val_id
                                        ,l_result_name
                                        ,l_result_rule_type
                                        ,l_severity_level
                                        ,l_ele_type_id;
      exit when c_get_form_result_rules%NOTFOUND;
      l_form_res_rule_id := pay_formula_results.ins_form_res_rule(
                            p_business_group_id          => l_bg_id
                           ,p_legislation_code           => l_leg_code
                           ,p_legislation_subgroup       => l_leg_sub_grp
                           ,p_effective_start_date       => l_eff_start_date
                           ,p_effective_end_date         => l_eff_end_date
                           ,p_status_processing_rule_id  => l_stat_proc_rule_id
                           ,p_input_value_id             => l_input_val_id
                           ,p_result_name                => l_result_name
                           ,p_result_rule_type           => l_result_rule_type
                           ,p_severity_level             => l_severity_level
                           ,p_element_type_id	         => l_ele_type_id);
   end loop;
   close c_get_form_result_rules;

--   hr_utility.trace_on(NULL, 'Dedn');
   hr_utility.trace('Leaving ' || gv_package_name || '.copy_result_rules');
END copy_result_rules;


/*****************************************************************************
  Name        : copy_balance_feeds

  Description : This procedure copies all the balance feeds from the new
                balances to the corresponding old balances.
*****************************************************************************/
FUNCTION copy_balance_feeds(p_old_ele_name varchar2,
                             p_new_ele_name varchar2,
                             p_business_grp_id number) RETURN BOOLEAN
  IS



-- Get Balance Type Ids
cursor c_balance_type_id(cp_ele_name varchar2,
                         cp_business_grp_id number) IS
select balance_type_id
  from pay_balance_types
 where business_group_id = cp_business_grp_id
   and balance_name in (cp_ele_name,
                        cp_ele_name || ' Accrued',
                        cp_ele_name || ' Accrued Fees',
                        cp_ele_name || ' Additional',
                        cp_ele_name || ' Arrears',
                        cp_ele_name || ' Fees',
                        cp_ele_name || ' Not Taken',
                        cp_ele_name || ' Replacement')
order by balance_name;

-- Get Input Value Ids to be transferred
cursor c_input_val_id(cp_balance_type_id number,
                        cp_business_grp_id number) IS
select effective_start_date,
       effective_end_date,
       legislation_code,
       input_value_id,
       scale,
       legislation_subgroup
  from pay_balance_feeds_f
 where business_group_id = cp_business_grp_id
   and balance_type_id = cp_balance_type_id;


-- Query to chk existence of inp val for balance type id
cursor c_chk_inp_val(cp_balance_type_id number,
                     cp_input_val_id number,
                     cp_business_grp_id number) IS
select 'Exists'
  from pay_balance_feeds_f
 where balance_type_id = cp_balance_type_id
   and input_value_id = cp_input_val_id
   and business_group_id = cp_business_grp_id;

  l_rowid                    varchar2(100);
  l_inp_val_id               number;
  l_count                    number;
  l_balance_feed_id          number;
  l_eff_start_date           date;
  l_eff_end_date             date;
  l_leg_code                 varchar2(50);
  l_scale                    varchar2(10);
  l_leg_sub_group            varchar2(50);
  l_exists                   varchar2(10);
  l_old_bal_type_id_tab      number_tab;
  l_new_bal_type_id_tab      number_tab;


  BEGIN
  hr_utility.trace('Entering ' || gv_package_name || '.copy_balance_feeds');
  hr_utility.trace('Copying Balance Feeds from ' || p_new_ele_name
                   || ' into  ' || p_old_ele_name);
--  hr_utility.trace_off;

   /*
    * Setting Location for identifying error
    */
  gv_location := 2;


  /*
   * Fetching Balance Type IDs for Old Balances
   */
  l_count := 0;
  open c_balance_type_id(p_old_ele_name,
                         p_business_grp_id);
  loop
     fetch c_balance_type_id into l_old_bal_type_id_tab(l_count);
     exit when c_balance_type_id%NOTFOUND;
     l_count := l_count + 1;
  end loop;
  close c_balance_type_id;
  hr_utility.trace('Balance Count Old Balance = ' || l_count);


  /*
   * Fetching Balance Type IDs for New Balances
   */
  l_count := 0;
  open c_balance_type_id(p_new_ele_name,
                         p_business_grp_id);
  loop
     fetch c_balance_type_id into l_new_bal_type_id_tab(l_count);
     exit when c_balance_type_id%NOTFOUND;
     l_count := l_count + 1;
  end loop;
  close c_balance_type_id;

  hr_utility.trace('Balance Count New Balance = ' || l_count);
  /*
   * This FOR loop copies the balance feeds from New Balances
   * to the corresponding Old Balances.
   * The outer FOR loop runs for the New balances. For every New balance
   * we copy the balances feeds to the corresponding Old Balance.
   */
  l_count := 0;
  for l_count in l_new_bal_type_id_tab.first..l_new_bal_type_id_tab.last
  loop
      if l_new_bal_type_id_tab.exists(l_count) then
         open c_input_val_id(l_new_bal_type_id_tab(l_count),
                             p_business_grp_id);
         loop
            fetch c_input_val_id into l_eff_start_date,
                                      l_eff_end_date,
                                      l_leg_code,
                                      l_inp_val_id,
                                      l_scale,
                                      l_leg_sub_group;
            exit when c_input_val_id%NOTFOUND;
            hr_utility.trace('Input Value ID = ' || l_inp_val_id);
            hr_utility.trace('Effective_start date ' || l_eff_start_date);
            hr_utility.trace('Effective End Date ' || l_eff_end_date);

            /*
             * Check If the balance feed already exists.
             * At this point Duplicate feed cannot exist but have added the code
             * for cheking anyway.
             */
            open c_chk_inp_val(l_old_bal_type_id_tab(l_count),
                               l_inp_val_id,
                               p_business_grp_id);
            fetch c_chk_inp_val into l_exists;
            if c_chk_inp_val%NOTFOUND and l_old_bal_type_id_tab.exists(l_count) then
               hr_utility.trace('Creating Balance Feed for ' || l_old_bal_type_id_tab(l_count));
               l_rowid := NULL;
               l_balance_feed_id := NULL;

               pay_balance_feeds_f_pkg.Insert_Row(
                           X_Rowid                   => l_rowid,
                           X_Balance_Feed_Id         => l_balance_feed_id,
                           X_Effective_Start_Date    => l_eff_start_date,
                           X_Effective_End_Date      => l_eff_end_date,
                           X_Business_Group_Id       => p_business_grp_id,
                           X_Legislation_Code        => l_leg_code,
                           X_Balance_Type_Id         => l_old_bal_type_id_tab(l_count),
                           X_Input_Value_Id          => l_inp_val_id,
                           X_Scale                   => l_scale,
                           X_Legislation_Subgroup    => l_leg_sub_group);
               if l_balance_feed_id is NULL then
                  hr_utility.raise_error;
               end if;

            end if;
            close c_chk_inp_val;
         end loop;
         close c_input_val_id;
      end if;
  end loop;
--  hr_utility.trace_on(NULL, 'Dedn');
  hr_utility.trace('Leaving ' || gv_package_name || '.copy_balance_feeds');
  return TRUE;

exception
  --
  when others then
--    hr_utility.trace_on(NULL, 'Dedn');
    hr_utility.trace('Could not Copy Balance Feed');
    return FALSE;
END copy_balance_feeds;


/*****************************************************************************
  Name        : del_balance_feeds

  Description : This procedure deletes all the balance feeds for the balances
                associated to the element passed.
*****************************************************************************/
PROCEDURE del_balance_feeds(p_new_ele_name varchar2,
                            p_business_grp_id number)
  IS

BEGIN
  hr_utility.trace('Entering ' || gv_package_name || '.del_balances');

  hr_utility.trace('Deleting Balance Feeds For Balances associated with '
                    || p_new_ele_name);
--  hr_utility.trace_off;


  /*
   * This delete statement deletes the balance feeds for the balances
   * associated with the element passed.
   */
  delete
    from pay_balance_feeds_f
   where balance_type_id in (select balance_type_id
                               from pay_balance_types
                              where balance_name in
                                     (p_new_ele_name,
                                      p_new_ele_name || ' Accrued',
                                      p_new_ele_name || ' Accrued Fees',
                                      p_new_ele_name || ' Additional',
                                      p_new_ele_name || ' Arrears',
                                      p_new_ele_name || ' Fees',
                                      p_new_ele_name || ' Not Taken',
                                      p_new_ele_name || ' Replacement')
                                and business_group_id = p_business_grp_id);

--  hr_utility.trace_on(NULL, 'Dedn');
  hr_utility.trace('Leaving ' || gv_package_name || '.del_balances');

END del_balance_feeds;

/*****************************************************************************
  Name        : modify_calc_res_rule

  Description : This procedure modifies the Calculator formula of the new
                element so that the STOP ENTRY result is passed to the 'Pay
                Value' of the old element instead of the new element.
                Also Formula Result WH_FEE_AMT will feed Old Fees
                'Withheld Fee Amount' Instead of New Fees 'Pay Value' or
                'Withheld Fee Amount'.
*****************************************************************************/
PROCEDURE modify_calc_res_rule(p_old_ele_name varchar2,
                               p_new_ele_name varchar2,
                               p_business_grp_id number)
  IS

-- Cursor to get the status_processing_rule_id
cursor c_get_stat_proc_rules(cp_ele_name varchar2,
                             cp_bg_grp_id  number) IS
select status_processing_rule_id
  from pay_status_processing_rules_f
 where element_type_id in (select element_type_id
                            from pay_element_types_f
                           where element_name =  cp_ele_name
                             and business_group_id = cp_bg_grp_id);

-- Cursor to get the input value id of the Any input Value
cursor c_get_inp_val_id_general(cp_ele_name varchar2
                               ,cp_inp_val_name varchar2
                               ,cp_business_group_id number
                                ) IS
select petf.element_type_id,
       pivf.input_value_id
  from pay_element_types_f petf,
       pay_input_values_f pivf
 where petf.element_name like cp_ele_name
   and petf.business_group_id = cp_business_group_id
   and pivf.element_type_id = petf.element_type_id
   and pivf.name = cp_inp_val_name;

l_ele_type_id       number ;
l_inp_val_id        number ;
l_stat_proc_rule_id number ;
l_old_fees_ele_type_id number ;
l_old_fees_inp_val_id  number ;

BEGIN
  hr_utility.trace('Entering ' || gv_package_name || '.modify_res_rule_calc');
  hr_utility.trace('Modifying The Formula ' || p_new_ele_name || ' Calculator');


  /*
   * Get the status processing rule id. This is then used in the Update
   * statement below'
   */
  open c_get_stat_proc_rules(p_new_ele_name || ' Calculator',
                             p_business_grp_id);
  fetch c_get_stat_proc_rules into l_stat_proc_rule_id;
  close c_get_stat_proc_rules;

  /*
   * Get the element_type_id and input_value_id of 'Pay Value' of
   * the old Base element. These values are then updated for the
   * STOP_ENTRY result in the Calculator formula
   */
  open c_get_inp_val_id_general(p_old_ele_name,
                                'Pay Value',
                                p_business_grp_id);
  fetch c_get_inp_val_id_general into l_ele_type_id
                                      ,l_inp_val_id;
  close c_get_inp_val_id_general ;

  hr_utility.trace('Modifying the STOP_ENTRY Result');

  /*
   * Updates the New Calculator formula result rule so that the
   * STOP_ENTY result goes to the 'Pay Value' of Old Base element
   */
  update pay_formula_result_rules_f
     set element_type_id = l_ele_type_id,
         input_value_id = l_inp_val_id
   where status_processing_rule_id = l_stat_proc_rule_id
     and result_name = 'STOP_ENTRY'
     and business_group_id = p_business_grp_id;

-- Modify the Formula Result Rule for Fees.
-- Formula Result WH_FEE_AMT will feed Old Fees 'Withheld Fee Amount'
-- Instead of New Fees .

/* Get Element Type ID and Input Value of the Old Fees Elements */
  open c_get_inp_val_id_general(p_old_ele_name || ' Fees',
                               'Withheld Fee Amount',
                                p_business_grp_id);
  fetch c_get_inp_val_id_general into l_old_fees_ele_type_id
                             ,l_old_fees_inp_val_id;
  close c_get_inp_val_id_general;

  hr_utility.trace('Ele Typ ID for Old Fees Ele := '||l_old_fees_ele_type_id) ;
  hr_utility.trace('Inp Val ID for Withheld Fee Amt for Old Fees Ele := '||l_old_fees_inp_val_id) ;
  hr_utility.trace('Status Proc Rule ID = '||l_stat_proc_rule_id) ;

/* Updating FRR so that WH_FEE_AMT feeds Withheld Fee Amount of Old Fees Element
   instead of New Fees
   Using Status Processing Rule ID of New Calculator Element
*/

  update pay_formula_result_rules_f
     set element_type_id = l_old_fees_ele_type_id,
         input_value_id = l_old_fees_inp_val_id
   where status_processing_rule_id = l_stat_proc_rule_id
     and result_name = 'WH_FEE_AMT'
     and business_group_id = p_business_grp_id;

  hr_utility.trace('Leaving ' || gv_package_name || '.modify_res_rule_calc');

END modify_calc_res_rule;


/*****************************************************************************
  Name        : del_base_element

  Description : This procedure deletes the base element of the New element
                created. We do not want the customer to use the Base element
                in the future for processing. We will also have to delete
                input Values associated with the base element.
*****************************************************************************/

PROCEDURE del_base_element(p_new_ele_name varchar2,
                           p_business_grp_id number)
  IS

CURSOR c_element_name(cp_element_name varchar2)  IS
     SELECT  element_Type_id
     FROM    pay_element_Types_f
     WHERE   element_name = cp_element_name
       AND    business_group_id = p_business_grp_id;

l_element_type_id number;

BEGIN
   hr_utility.trace('Entering ' || gv_package_name || '.del_base_element');

   hr_utility.trace('Deleting Base Element ' || p_new_ele_name);
--   hr_utility.trace_off;

   /* Get Element Type Id */

    OPEN c_element_name(p_new_ele_name);
    FETCH c_element_name into l_element_type_id;
    CLOSE c_element_name;


   /*
    * Delete the formula result rules associated with the New Base element
    */
    DELETE
     FROM pay_formula_result_rules_f
    WHERE  status_processing_rule_id
           IN (SELECT status_processing_rule_id
                 FROM pay_status_processing_rules_f psprf
                WHERE   psprf.element_type_id = l_element_type_id );

   DELETE
   FROM   pay_status_processing_rules_f
   WHERE  element_type_id = l_element_Type_id;

  /* Delete the Input Values associated with the Base Element */
   DELETE
   FROM  pay_input_values_f
   WHERE element_type_id = l_element_type_id;


   /*
    * Deleted the base element
    */
   DELETE
   FROM    pay_element_types_f
   WHERE   element_Type_id = l_element_type_id;


--   hr_utility.trace_on(NULL, 'Dedn');
   hr_utility.trace('Leaving ' || gv_package_name || '.del_base_element');

END del_base_element;

/*****************************************************************************
  Name        : mod_inp_vals

  Description : This procedure modifies the input values for the old element
                to be consistent with the new architecture.
*****************************************************************************/
PROCEDURE mod_inp_vals(p_ele_name        varchar2,
                       p_ele_category    varchar2,
                       p_business_grp_id number)
  IS

BEGIN
   hr_utility.trace('Entering ' || gv_package_name || '.mod_inp_vals');

   hr_utility.trace('Modifying the Display Sequence for the element ' || p_ele_name);
--   hr_utility.trace_off;

  if p_ele_category  = 'AY' OR p_ele_category = 'CS' or p_ele_category = 'SS' then
     hr_utility.trace('Setting Mandatory Flag for the Input Value Allowances');

     /*
      * Update statement for elements of category 'Alimony', 'Child Support' and
      * 'Spousal Support'.
      */
     update pay_input_values_f pivf
        set mandatory_flag = 'X'
      where pivf.element_type_id in (select distinct element_type_id
                                       from pay_element_types_f
                                      where element_name = p_ele_name
                                        and business_group_id = p_business_grp_id)
        and pivf.name in ('Allowances')
        and pivf.business_group_id = p_business_grp_id;
  elsif p_ele_category = 'CD' or p_ele_category = 'G' then
     hr_utility.trace('Setting Mandatory Flag for the Input Value Dedns at Time of Writ, Allowances and Clear Arrears.');

     /*
      * Update statement for elements of category 'Credit Debt' and 'Garnishment'.
      */
     update pay_input_values_f pivf
        set mandatory_flag = 'X'
      where pivf.element_type_id in (select distinct element_type_id
                                       from pay_element_types_f
                                      where element_name = p_ele_name
                                        and business_group_id = p_business_grp_id)
        and pivf.name in ('Dedns at Time of Writ',
                          'Allowances',
                          'Clear Arrears')
        and pivf.business_group_id = p_business_grp_id;
  elsif p_ele_category = 'BO' then
     hr_utility.trace('Setting Mandatory Flag for the Input Value Dedns at Time of Writ, Allowances and Clear Arrears.');

     /*
      * Update statement for elements of category 'Bankruptcy Order'.
      */
     update pay_input_values_f pivf
        set mandatory_flag = 'X'
      where pivf.element_type_id in (select distinct element_type_id
                                       from pay_element_types_f
                                      where element_name = p_ele_name
                                        and business_group_id = p_business_grp_id)
        and pivf.name in ('Dedns at Time of Writ',
                          'Allowances',
                          'Clear Arrears')
        and pivf.business_group_id = p_business_grp_id;
  elsif p_ele_category = 'EL' then
     hr_utility.trace('Setting Mandatory Flag for the Input Value Dedns at Time of Writ, Allowances and Clear Arrears.');

     /*
      * Update statement for elements of category 'Education Loan'.
      */
     update pay_input_values_f pivf
        set mandatory_flag = 'X'
      where pivf.element_type_id in (select distinct element_type_id
                                       from pay_element_types_f
                                      where element_name = p_ele_name
                                        and business_group_id = p_business_grp_id)
        and pivf.name in ('Dedns at Time of Writ',
                          'Filing Status',
                          'Allowances',
                          'Num Dependents',
                          'Clear Arrears')
        and pivf.business_group_id = p_business_grp_id;
  elsif p_ele_category = 'TL' then
     hr_utility.trace('Setting Mandatory Flag for the Input Value Dedns at Time of Writ, Allowances and Clear Arrears.');

     /*
      * Update statement for elements of category 'Tax Levy'.
      */
     update pay_input_values_f pivf
        set mandatory_flag = 'X'
      where pivf.element_type_id in (select distinct element_type_id
                                       from pay_element_types_f
                                      where element_name = p_ele_name
                                        and business_group_id = p_business_grp_id)
        and pivf.name in ('Percentage',
                          'Num Dependents',
                          'Clear Arrears')
        and pivf.business_group_id = p_business_grp_id;
  elsif p_ele_category = 'ER' then
     hr_utility.trace('Setting Mandatory Flag for the Input Value Dedns at Time of Writ, Allowances and Clear Arrears.');

     /*
      * Update statement for elements of category 'Employee Requested'.
      */
     update pay_input_values_f pivf
        set mandatory_flag = 'X'
      where pivf.element_type_id in (select distinct element_type_id
                                       from pay_element_types_f
                                      where element_name = p_ele_name
                                        and business_group_id = p_business_grp_id)
        and pivf.name in ('Dedns at Time of Writ',
                          'Allowances',
                          'Clear Arrears')
        and pivf.business_group_id = p_business_grp_id;
  end if;

--   hr_utility.trace_on(NULL, 'Dedn');
   hr_utility.trace('Leaving ' || gv_package_name || '.mod_inp_vals');

END mod_inp_vals;


/*****************************************************************************
  Name        : garn_upgrade

  Description : This procedure is called from the Concurrent Request. Based on
                category passed in as a parameter, we will select the elements
                that will be migrated in ine request.
*****************************************************************************/
PROCEDURE upgrade_garnishment
           (p_elem_type_id in number)
  IS

-- Get the elements that need to be migrated for the BG
-- This package will be called with the element category passed
-- to it as a parameter. This method is used to multi-thread the whole process
cursor c_get_mig_elem_bg(cp_ele_type_id number) IS
select /*+ Choose */
      petf.element_type_id, min(petf.effective_start_date), max(petf.effective_end_date)
 from pay_element_types_f petf
where petf.element_type_id = p_elem_type_id
  and petf.element_information4 is NULL
 group by petf.element_type_id;

 -- Get element name, category and Calc Ele type id
 cursor c_get_ele_name_cat (cp_ele_type_id number,
                            cp_business_grp_id number) IS
 select element_name,
        element_information1  element_category,
        element_information5  calc_ele_type_id,
	element_information18 spl_inp_ele_type_id -- Added for #8972240
   from pay_element_types_f
  where element_type_id = cp_ele_type_id
    and business_group_id = cp_business_grp_id;

-- Get the element name
cursor c_get_ele_name (cp_ele_type_id number,
                       cp_business_grp_id number) IS
select element_name
  from pay_element_types_f
 where element_type_id = cp_ele_type_id
   and business_group_id = cp_business_grp_id;

-- Local Variable Declaration
l_business_group_id    number;
l_date_of_mig          date;
l_count                number;
l_old_ele_type_id      number;
l_new_ele_type_id      number;
l_ele_category         varchar2(10);
l_old_ele_name         varchar2(100);
l_new_ele_name         varchar2(100);
l_eff_start_date       date;
l_eff_end_date         date;
l_calc_ele_type_id     number;
l_spl_inp_ele_type_id  number; -- Added for #8972240
l_flag                 boolean;
custom_exception       exception;

begin

   /*
    * Initialization Code
    */
   gv_package_name          := 'pay_us_garn_upgrade';
   l_business_group_id      := fnd_global.per_business_group_id;
   l_flag                   := TRUE;
-- Initialise Variable - 0 is SRS Success, 1 is SRS Warning, 2 is SRS Error

   /*
    * Initial Trace
    */
--   hr_utility.trace_on(NULL, 'Dedn');
   hr_utility.trace('Entering ' || gv_package_name || '.upgrade_garnishment');
   hr_utility.trace('Values Passed From The Concurrent Program');

   /*
    * Business Group Level Migration
    */

   l_date_of_mig := fnd_date.canonical_to_date('2004/01/01');
   l_count := 0;

   hr_utility.trace('Date of Migration ' || l_date_of_mig);


   open c_get_mig_elem_bg(p_elem_type_id);
   --
   loop
      fetch c_get_mig_elem_bg into l_old_ele_type_id
                                  ,l_eff_start_date
                                  ,l_eff_end_date;

      exit when c_get_mig_elem_bg%NOTFOUND;

      /*
       * STEP 1
       * Create a New Element for the Old element
       * Modify The Base Formula of the New element to refer the Old Balances.
       * Call to modify the Base Formula is inside the call to 'create_new_element'
       */

      l_new_ele_type_id := create_new_element(
                                      p_old_ele_type_id => l_old_ele_type_id,
                                      p_business_grp_id => l_business_group_id,
                                      p_eff_start_date  => l_eff_start_date,
                                      p_eff_end_date    => l_eff_end_date);
      if l_new_ele_type_id = 0 then
         hr_utility.trace('Element Not Created');
         raise custom_exception;
      end if;


      /*
       * Get the New and Old element name and category.
       * The category will be same for both the elements
       */
      open c_get_ele_name_cat(l_new_ele_type_id,
                              l_business_group_id);
      fetch c_get_ele_name_cat into l_new_ele_name,
                                    l_ele_category,
                                    l_calc_ele_type_id,
				    l_spl_inp_ele_type_id; -- Added for #8972240
      close c_get_ele_name_cat;

      open c_get_ele_name(l_old_ele_type_id,
                          l_business_group_id);
      fetch c_get_ele_name into l_old_ele_name;
      close c_get_ele_name;

      hr_utility.trace('Element Created ' || l_new_ele_name);

     /*
      * Store the New Calcualtor elements element_type_id value in the
      * element_information4 column of the Old Base element.
      */

     /*  #8972240 Also updated the special input element type id value
      *  in the element_information18 column of the Old Base element.
      */
      update pay_element_types_f
         set element_information4  = l_calc_ele_type_id,
             element_information18 = l_spl_inp_ele_type_id  -- Added for #8972240
      where element_type_id = l_old_ele_type_id;

      /*
       * STEP 2
       * Copy Formula Result rules from the New Base
       */
       copy_result_rules(l_old_ele_type_id
                        ,l_new_ele_type_id
                        ,l_business_group_id);

      /*
       * STEP 3
       * Copy Balance Feeds from New Balance To Old Balance
       */
      l_flag := copy_balance_feeds(l_old_ele_name
                                  ,l_new_ele_name
                                  ,l_business_group_id);
      if NOT(l_flag) then
         hr_utility.trace('Could Not Copy Balance Feed');
         raise custom_exception;
      end if;


      /*
       * STEP 4
       * Delete Balance Feeds for New Balances
       */
       del_balance_feeds(l_new_ele_name
                        ,l_business_group_id);


      /*
       * STEP 5
       * Modify The Formula Result Rules for the New Calculator formula
       * to feed the STOP_ENTRY result of the Old Base element instead of
       * the New Base element.
       */
       modify_calc_res_rule(l_old_ele_name
                           ,l_new_ele_name
                           ,l_business_group_id);

       /*
        * Step 6
        * Delete the New Base Element
        */
       del_base_element(l_new_ele_name,
                        l_business_group_id);

       /*
        * Modify Display Sequence
        */
       mod_inp_vals(l_old_ele_name,
                    l_ele_category,
                    l_business_group_id);

   end loop;

   close c_get_mig_elem_bg;

   hr_utility.trace('Leaving ' || gv_package_name || '.upgrade_garnishment');
   return;

EXCEPTION
when CUSTOM_EXCEPTION then
   pay_core_utils.push_message(801, 'PAY_US_GARN_UPG', 'A');
   pay_core_utils.push_token ('Element Type ID', p_elem_type_id);
   pay_core_utils.push_token ('Element Name ', l_old_ele_name);
   if gv_location = 1 then
      pay_core_utils.push_token ('Error Creating New Element ', gv_location);
   elsif gv_location = 2 then
      pay_core_utils.push_token ('Error Creating Balance Feed ', gv_location);
   end if;
   hr_utility.raise_error;
when others then
   pay_core_utils.push_message(801, 'PAY_US_GARN_UPG', 'A');
   pay_core_utils.push_token ('Element Type ID', p_elem_type_id);
   pay_core_utils.push_token ('Element Name ', l_old_ele_name);
   if gv_location = 1 then
      pay_core_utils.push_token ('Error Creating New Element ', gv_location);
   elsif gv_location = 2 then
      pay_core_utils.push_token ('Error Creating Balance Feed ', gv_location);
   end if;
   hr_utility.raise_error;
end upgrade_garnishment;

/*****************************************************************************
  Name        : qual_elem_upg

  Description : This is the qualifying procedure which determines whether
                the element passed in as a parameter needs to be migrated.
                The conditions that are checked here are
                1. Should be Involuntary Deduction element.
                2. Should have been created using Old Architecture.
                3. Should not have been already migrated.
                4. Should have the end_date > '01-JAN-2004'
*****************************************************************************/
PROCEDURE qual_elem_upg(p_object_id varchar2,
                        p_qualified    out nocopy varchar2)
  IS

-- Verify if the element is of Involuntary Deductions Category
-- and needs to be migrated
cursor c_get_mig_elem_bg(cp_ele_type_id     number,
                         cp_mig_date        date) IS
select /*+ Choose */
      'Upgrade'
 from pay_element_types_f petf,
      pay_element_classifications pec
where petf.element_type_id = cp_ele_type_id
  and petf.legislation_code is NULL
  and petf.effective_end_date > cp_mig_date
  and pec.classification_id = petf.classification_id
  and pec.classification_name = 'Involuntary Deductions'
  and petf.element_name not like '%Calculator'
  and petf.element_name not like '%Verifier'
  and petf.element_name not like '%Special Inputs'
  and petf.element_name not like '%Special Features'
  and petf.element_name not like '%Fees'
  and petf.element_name not like '%Priority'
  and petf.element_information4 is NULL
  and petf.element_information1 in ('CS', 'SS', 'AY', 'EL', 'ER', 'BO', 'CD', 'G', 'TL')
  and exists (select 'Exists'
                from pay_element_types_f petfi
               where petfi.element_name like petf.element_name || ' Verifier'
                 and petfi.business_group_id = petf.business_group_id
                 and petfi.legislation_code is NULL);

cursor c_get_curr_arch is
select parameter_value
  from pay_action_parameters
 where parameter_name = 'US_ADVANCED_WAGE_ATTACHMENT';

l_date_of_mig          date;
l_upg_stat             varchar2(10);
l_qualifier            varchar2(10);
lv_package_name        varchar2(50);
l_curr_arch            varchar2(10);

BEGIN
   /*
    * Initializing Date used for migration.
    * Element having end date before '01-JAN-2004' are not migrated.
    */
   l_date_of_mig   := fnd_date.canonical_to_date('2004/01/01');
   lv_package_name := 'pay_us_garn_upgrade';

   hr_utility.trace('Entering ' || lv_package_name || '.qual_elem_upg');


   /*
    * Check current architecture.
    * If OLD architecture is selected currently then set the value for
    * 'US_ADVANCED_WAGE_ATTACHMENT' to 'Y' and make an explicit
    * commit. This ensures all elements are created using the New
    * architecture.
    */
   open c_get_curr_arch;
   fetch c_get_curr_arch into l_curr_arch;
   if c_get_curr_arch%FOUND then
      if upper(substr(l_curr_arch,1,1)) = 'N' then
         update pay_action_parameters
            set parameter_value = 'Y'
          where parameter_name = 'US_ADVANCED_WAGE_ATTACHMENT';
         commit;
      end if;
   end if;
   close c_get_curr_arch;

   open c_get_mig_elem_bg(p_object_id
                         ,l_date_of_mig);
   fetch c_get_mig_elem_bg into l_upg_stat;
   if c_get_mig_elem_bg%NOTFOUND then
      l_qualifier := 'N';
   else
      l_qualifier := 'Y';
   end if;
   close c_get_mig_elem_bg;

   p_qualified := l_qualifier;

   if l_qualifier = 'Y' then
      hr_utility.trace('Element Type ID ' || p_object_id || 'Upgraded');
   end if;
   hr_utility.trace('Leaving ' || lv_package_name || '.qual_elem_upg');
END qual_elem_upg;

end pay_us_garn_upgrade;

/
