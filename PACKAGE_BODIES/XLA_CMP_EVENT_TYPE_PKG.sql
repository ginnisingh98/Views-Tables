--------------------------------------------------------
--  DDL for Package Body XLA_CMP_EVENT_TYPE_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."XLA_CMP_EVENT_TYPE_PKG" AS
/* $Header: xlacpevt.pkb 120.75.12010000.7 2010/02/08 23:10:52 kapkumar ship $   */
/*===========================================================================+
|             Copyright (c) 2001-2002 Oracle Corporation                     |
|                       Redwood Shores, CA, USA                              |
|                         All rights reserved.                               |
+============================================================================+
| PACKAGE NAME                                                               |
|     xla_cmp_event_type_pkg                                                 |
|                                                                            |
| DESCRIPTION                                                                |
|     This is a XLA private package, which contains all the logic required   |
|     to generate Event Class or Event Type Function                         |
|     from AMB specifcations                                                 |
|                                                                            |
|                                                                            |
| HISTORY                                                                    |
|     25-JUN-2002 K.Boussema    Created                                      |
|     25-FEB-2003 K.Boussema    Added 'dbdrv' command                        |
|     19-MAR-2003 K.Boussema    Added amb_context_code                       |
|     02-APR-2003 K.boussema    Added generation of analytical criteria      |
|     14-APR-2003 K.Bouusema    Added the error messages                     |
|     22-APR-2003 K.Boussema    Included error messages                      |
|     22-APR-2003 K.Boussema    Added SEQ_DOC_CATEGORY_CODE source           |
|     13-MAI-2003 K.Boussema    Modified the Extract according to bug 2857548|
|     02-JUN-2003 K.Boussema    Modified to fix bug 2975670 and bug 2729143  |
|     27-JUN-2003 K.Boussema    Renamed XLA_DESCRIPTION_PRIO table           |
|     17-JUL-2003 K.Boussema    Reviewd the code                             |
|     24-JUL-2003 K.Boussema    Updated the error messages                   |
|     26-AUG-2003 K.Boussema    Reviewd the generation of the extract to     |
|                               handle the use of line_number as source      |
|     10-SEP-2003 K.Boussema    Changed to fix bug3095206:Accounting Reversal|
|     17-SEP-2003 K.Boussema    Updated to Get je_category from cache:3109690|
|     09-OCT-2003 K.Boussema    Changed to accept AADs differents Extract    |
|                               specifcations                                |
|     27-OCT-2003 K.Boussema    Changed to raise Error when no data retrieved|
|                               by the extract, bug 3203657                  |
|     04-NOV-2003 K.Boussema    Added new accounting reversal indicator value|
|     01-DEC-2003 K.Boussema    Added the cache of Extract errors in code    |
|                               generated by the compiler                    |
|     12-DEC-2003 K.Boussema    Reviewed for bug 3042840                     |
|     18-DEC-2003 K.Boussema    Changed to fix bug 3042840,3307761,3268940   |
|                               3310291 and 3320689                          |
|     22-DEC-2003 K.Boussema    Replaced Extract Validations by a call to    |
|                               Extract Integrity Checker routine            |
|     02-FRB-2004 K.Boussema    Changed code generated, refer to bug 3274707 |
|     12-FEB-2004 K.Boussema    Changed to only display the extraxt error msg|
|                               of the alway_populated objects               |
|     19-FEB-2004 K.Boussema    Made changes for the FND_LOG.                |
|     12-MAR-2004 K.Boussema    Changed to incorporate the select of lookups |
|                               from the extract objects                     |
|     22-MAR-2004 K.Boussema    Added a parameter p_module to the TRACE calls|
|                               and the procedure.                           |
|     11-MAY-2004 K.Boussema  Removed the call to XLA trace routine from     |
|                             trace() procedure                              |
|     17-MAY-2004 W.Shen        Accounting Attribute Enhancement project     |
|                               check the dld for changed made to the package|
|     26-MAY-2004 W.Shen        change code for the error message            |
|     26-Jul-2004 W.Shen        bug 3786968. transaction reversal do not have|
|                               extract line. When call function             |
|                               xla_accounting_engine_pkg.CacheExtractErrors |
|                               The transaction reversal flag is passed.     |
|     23-Sep-2004 S.Singhania Made changes for the bulk peroformance. It has |
|                               changed the code at number of places.        |
|     05-Oct-2004 S.Singhania Bug 3931752: Modified constants C_EVENT_BODY   |
|                               C_BODY_LINES to set correct target_ledger_id.|
|     08-Oct-2004 S.Singhania Bug 3939231: Added code to C_EVENT_BODY to     |
|                               initialize xla_ae_lines_pkg.g_temp_line_num. |
|     12-Oct-2004 K.Boussema    Made changes for the Accounting Event Extract|
|                               Diagnostics feature.                         |
|     08-Dec-2004 K.Boussema  Updated to add diagnostic framework datamodel  |
|                             changes                                        |
|     27-DEC-2004 K.Boussema Changed the VARCHAR2 type by CLOB to handle the |
|                            large main procedure                            |
|     15-Feb-2005 W.Shen        change code ledger currency project          |
|                            remove alc object.                              |
|                            add the two calculate accounted amts, gain/loss |
|                               flags                                        |
|     07-Mar-2005 K.Boussema    Changed for ADR-enhancements.                |
|     29-Mar-2005 M.Asada       Changed for Reference Objects.               |
|     18-Jul-2005 W.Chan        4495733 - In GetEntityName, update length    |
|                               of l_name from 30 to 90                      |
|     21-JUL-2005 K.Boussema   Reviewed to handle the two cases:             |
|                                - no header Transaction objects and         |
|                                - no line Transaction objects               |
|     22-Sep-2005 S.Singhania  Bug 4544725. Implemented Business Flows and   |
|                                Reversals for Non-Upgraded JEs.             |
|     18-Oct-2005 V. Kumar    Removed code for Analytical Criteria           |
|     20-Jan-2006 A. Wan      4884853 -                                      |
|                             Modified GenerateAccRevBody to adjust Accrual  |
|                             Reversal Date before PostAccountingEngine.     |
|     10-Feb-2006 A. Wan      5019460 - redundant logic in C_EVENT_BODY      |
|     08-Mar-2006 V. Kumar    Modified C_MAIN_PROCEDURE                      |
|     09-May-2006 V. Kumar    5217187 Populating GL_DATE for Reversal        |
|     09-May-2006 A.WAn       5202219 - prevent trx rev error out.           |
|     19-May-2006 V. Kumar    5229264 Populating gl_date for Trx rev. case   |
|     09-Nov-2006 A.Wan       5648433 - init l_event_id for line_cursor.     |
+===========================================================================*/

--
--+==========================================================================+
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                    AAD templates/Global constants                        |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--+==========================================================================+
--
--
--+========================================================
--| Template of the main function CreateHeadersAndLines
--+========================================================
--
C_MAIN_PROCEDURE   CONSTANT VARCHAR2(10000) := '
--
--+============================================+
--|                                            |
--|  PRIVATE FUNCTION                          |
--|                                            |
--+============================================+
--
FUNCTION CreateHeadersAndLines
       (p_application_id         IN NUMBER
       ,p_base_ledger_id         IN NUMBER
       ,p_target_ledger_id       IN NUMBER
       ,p_pad_start_date         IN DATE
       ,p_pad_end_date           IN DATE
       ,p_primary_ledger_id      IN NUMBER)
RETURN BOOLEAN IS
l_created                   BOOLEAN:=FALSE;
l_event_id                  NUMBER;
l_event_date                DATE;
l_language                  VARCHAR2(30);
l_currency_code             VARCHAR2(30);
l_sla_ledger_id             NUMBER;
l_log_module                VARCHAR2(240);

BEGIN
--
IF g_log_enabled THEN
   l_log_module := C_DEFAULT_MODULE||''.CreateHeadersAndLines'';
END IF;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => ''BEGIN of CreateHeadersAndLines''
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

l_language         := xla_ae_journal_entry_pkg.g_cache_ledgers_info.description_language;
l_currency_code    := xla_ae_journal_entry_pkg.g_cache_ledgers_info.currency_code;
l_sla_ledger_id    := xla_ae_journal_entry_pkg.g_cache_ledgers_info.sla_ledger_id;

--
-- initialize array of lines with NULL
--
xla_ae_lines_pkg.SetNullLine;

--
-- initialize header extract count -- Bug 4865292
--
g_hdr_extract_count:= 0;

$BODY_MAIN_PROCEDURE$

 --
 -- Bug 4865292
 -- When the number of events and that of header extract do not match,
 -- set the no header extract flag to indicate there are some issues
 -- in header extract.
 --
 -- Event count context is set in xla_accounting_pkg.unit_processor.
 -- Build_Message for this error is called in xla_accounting_pkg.post_accounting
 -- to report it as a general error.
 --
 IF  xla_context_pkg.get_event_count_context <> g_hdr_extract_count
 AND xla_context_pkg.get_event_nohdr_context <> ''Y'' THEN

     IF (C_LEVEL_STATEMENT >= g_log_level) THEN
        trace
          (p_msg      => ''# of extracted headers and events does not match''
          ,p_level    => C_LEVEL_STATEMENT
          ,p_module   => l_log_module);

        trace
          (p_msg      => ''# of extracted headers: ''
                         ||g_hdr_extract_count
          ,p_level    => C_LEVEL_STATEMENT
          ,p_module   => l_log_module);

        trace
          (p_msg      => ''# of events in xla_events_gt: ''
                         ||xla_context_pkg.get_event_count_context
          ,p_level    => C_LEVEL_STATEMENT
          ,p_module   => l_log_module);

        trace
          (p_msg      => ''Event No Header Extract Context: ''
                         ||xla_context_pkg.get_event_nohdr_context
          ,p_level    => C_LEVEL_STATEMENT
          ,p_module   => l_log_module);

     END IF;


     xla_context_pkg.set_event_nohdr_context
       (p_nohdr_extract_flag => ''Y''
       ,p_client_id => sys_context(''USERENV'',''CLIENT_IDENTIFIER''));

     IF (C_LEVEL_STATEMENT >= g_log_level) THEN
        trace
          (p_msg      => ''No Header Extract Flag is set to Y''
          ,p_level    => C_LEVEL_STATEMENT
          ,p_module   => l_log_module);
     END IF;

 END IF;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => ''END of CreateHeadersAndLines''
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

RETURN l_created;
EXCEPTION
WHEN xla_exceptions_pkg.application_exception THEN
   RAISE;
WHEN OTHERS THEN
   xla_exceptions_pkg.raise_message
      (p_location => ''$PACKAGE_NAME$.CreateHeadersAndLines'');
END CreateHeadersAndLines;
--
--
';
--
--+=============================================================
--| Template of ELSE ... END IF; in CreateHeadersAndLines
--+=============================================================
--
C_END_IF          CONSTANT VARCHAR2(10000) := '
ELSE
   --
   -- Product error No PAD defined for this event type
   --
   xla_ae_journal_entry_pkg.g_global_status      :=  xla_ae_journal_entry_pkg.C_INVALID;

   xla_accounting_err_pkg.build_message
            (p_appli_s_name             => ''XLA''
             ,p_msg_name                => ''XLA_AP_INV_SYST_EVENT_TYPE''
             ,p_token_1                 => ''EVENT_TYPE_NAME''
             ,p_value_1                 => xla_ae_journal_entry_pkg.g_cache_event_tl.session_event_type
             ,p_token_2                 => ''PAD_NAME''
             ,p_value_2                 => xla_ae_journal_entry_pkg.g_cache_pad.pad_session_name
             ,p_token_3                 => ''PAD_OWNER''
             ,p_value_3                 => xla_lookups_pkg.get_meaning(
                                            ''XLA_OWNER_TYPE''
                                            ,xla_ae_journal_entry_pkg.g_cache_pad.product_rule_type_code
                                             )
             ,p_token_4                 => ''PRODUCT_NAME''
             ,p_value_4                 => xla_ae_journal_entry_pkg.g_cache_event.application_name
             ,p_entity_id               => xla_ae_journal_entry_pkg.g_cache_event.entity_id
             ,p_event_id                => xla_ae_journal_entry_pkg.g_cache_event.event_id
             ,p_ledger_id               => p_base_ledger_id
         );
    --
   l_created := FALSE;
   --
END IF;
--'
;
--
--+=======================================
--| Template of Event Type Function
--+=======================================
--
C_EVENT_TYPE_PROC                 CONSTANT      VARCHAR2(10000):= '
---------------------------------------
--
-- PRIVATE FUNCTION
--         Event$EVENT_ID$
--
----------------------------------------
--
FUNCTION Event$EVENT_ID$
       (p_application_id         IN NUMBER
       ,p_base_ledger_id         IN NUMBER
       ,p_target_ledger_id       IN NUMBER
       ,p_language               IN VARCHAR2
       ,p_currency_code          IN VARCHAR2
       ,p_sla_ledger_id          IN NUMBER
       ,p_pad_start_date         IN DATE
       ,p_pad_end_date           IN DATE
       ,p_primary_ledger_id      IN NUMBER)
RETURN BOOLEAN IS
--
C_EVENT_TYPE_CODE    CONSTANT  VARCHAR2(30)  := ''$event_type_code$'';
C_EVENT_CLASS_CODE    CONSTANT  VARCHAR2(30) := ''$event_class_code$'';

l_calculate_acctd_flag   VARCHAR2(1) :=''$calculate_acctd_flag$'';
l_calculate_g_l_flag     VARCHAR2(1) :=''$calculate_g_l_flag$'';
--
l_array_legal_entity_id                XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;
l_array_entity_id                      XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;
l_array_entity_code                    XLA_AE_JOURNAL_ENTRY_PKG.t_array_V30L;
l_array_transaction_num                XLA_AE_JOURNAL_ENTRY_PKG.t_array_V240L;
l_array_event_id                       XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;
l_array_class_code                     XLA_AE_JOURNAL_ENTRY_PKG.t_array_V30L;
l_array_event_type                     XLA_AE_JOURNAL_ENTRY_PKG.t_array_V30L;
l_array_event_number                   XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;
l_array_event_date                     XLA_AE_JOURNAL_ENTRY_PKG.t_array_Date;
l_array_transaction_date               XLA_AE_JOURNAL_ENTRY_PKG.t_array_Date;
l_array_reference_num_1                XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;
l_array_reference_num_2                XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;
l_array_reference_num_3                XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;
l_array_reference_num_4                XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;
l_array_reference_char_1               XLA_AE_JOURNAL_ENTRY_PKG.t_array_V240L;
l_array_reference_char_2               XLA_AE_JOURNAL_ENTRY_PKG.t_array_V240L;
l_array_reference_char_3               XLA_AE_JOURNAL_ENTRY_PKG.t_array_V240L;
l_array_reference_char_4               XLA_AE_JOURNAL_ENTRY_PKG.t_array_V240L;
l_array_reference_date_1               XLA_AE_JOURNAL_ENTRY_PKG.t_array_Date;
l_array_reference_date_2               XLA_AE_JOURNAL_ENTRY_PKG.t_array_Date;
l_array_reference_date_3               XLA_AE_JOURNAL_ENTRY_PKG.t_array_Date;
l_array_reference_date_4               XLA_AE_JOURNAL_ENTRY_PKG.t_array_Date;
l_array_event_created_by               XLA_AE_JOURNAL_ENTRY_PKG.t_array_V100L;
l_array_budgetary_control_flag         XLA_AE_JOURNAL_ENTRY_PKG.t_array_V30L;
l_array_header_events                  XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;  --added
l_array_duplicate_checker              XLA_AE_JOURNAL_ENTRY_PKG.t_array_Num;  --added

l_event_id                             NUMBER;
l_previous_event_id                    NUMBER;
l_first_event_id                       NUMBER;
l_last_event_id                        NUMBER;

l_rec_acct_attrs                       XLA_AE_HEADER_PKG.t_rec_acct_attrs;
l_rec_rev_acct_attrs                   XLA_AE_LINES_PKG.t_rec_acct_attrs;
--
--
l_result                    BOOLEAN := TRUE;
l_rows                      NUMBER  := 500;
l_event_type_name           VARCHAR2(80) := ''$event_type_name$'';
l_event_class_name          VARCHAR2(80) := ''$event_class_name$'';
l_description               VARCHAR2(4000);
l_transaction_reversal      NUMBER;
l_ae_header_id              NUMBER;
l_array_extract_line_num    xla_ae_journal_entry_pkg.t_array_Num;
l_log_module                VARCHAR2(240);
--
l_acct_reversal_source      VARCHAR2(30);
l_trx_reversal_source       VARCHAR2(30);

l_continue_with_lines       BOOLEAN := TRUE;
--
l_acc_rev_gl_date_source    DATE;                      -- 4262811
--
type t_array_event_id is table of number index by binary_integer;

l_rec_array_event                    t_rec_array_event;
l_null_rec_array_event               t_rec_array_event;
l_array_ae_header_id                 xla_number_array_type;
l_actual_flag                        VARCHAR2(1) := NULL;
l_actual_gain_loss_ref               VARCHAR2(30) := ''#####'';
l_balance_type_code                  VARCHAR2(1) :=NULL;
l_gain_or_loss_ref                   VARCHAR2(30) :=NULL;

--
TYPE t_array_lookup_meaning IS TABLE OF fnd_lookup_values.meaning%TYPE INDEX BY BINARY_INTEGER;
--
$header_types$
$line_types$
$header_variables$
$line_variables$
$header_cursor$
$line_cursor$
--
BEGIN
IF g_log_enabled THEN
   l_log_module := C_DEFAULT_MODULE||''.Event$EVENT_ID$'';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => ''BEGIN of Event$EVENT_ID$''
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
   trace
      (p_msg      => ''p_application_id = ''||p_application_id||
                     '' - p_base_ledger_id = ''||p_base_ledger_id||
                     '' - p_target_ledger_id  = ''||p_target_ledger_id||
                     '' - p_language = ''||p_language||
                     '' - p_currency_code = ''||p_currency_code||
                     '' - p_sla_ledger_id = ''||p_sla_ledger_id
      ,p_level    => C_LEVEL_STATEMENT
      ,p_module   => l_log_module);
END IF;
--
-- initialze arrays
--
g_array_event.DELETE;
l_rec_array_event := l_null_rec_array_event;
--
--------------------------------------
-- 4262811 Initialze MPA Line Number
--------------------------------------
XLA_AE_HEADER_PKG.g_mpa_line_num := 0;

--
$event_body$
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => ''END of Event$EVENT_ID$''
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;
--
RETURN l_result;
EXCEPTION
WHEN xla_exceptions_pkg.application_exception THEN
   $close_header_cursor$
   $close_line_cursor$
   RAISE;

WHEN NO_DATA_FOUND THEN

   $no_data_exception$

   xla_exceptions_pkg.raise_message
      (p_location => ''$package_name$.Event$EVENT_ID$'');


WHEN OTHERS THEN
   xla_exceptions_pkg.raise_message
      (p_location => ''$package_name$.Event$EVENT_ID$'');
END Event$EVENT_ID$;
--
';
--
--+==========================================================================+
--|                                                                          |
--| Template to close header and line Cursors, if program fails              |
--|                                                                          |
--+==========================================================================+
--
-- Close header cursour
--
C_CLOSE_HEADER_CURSOR                    CONSTANT      VARCHAR2(1000):= '
IF header_cur%ISOPEN THEN CLOSE header_cur; END IF;
';
--
-- Close line cursor
--
C_CLOSE_LINE_CURSOR                    CONSTANT      VARCHAR2(1000):= '
IF line_cur%ISOPEN   THEN CLOSE line_cur;   END IF;
';


C_NO_DATA_EXCEPTION      CONSTANT VARCHAR2(10000) := '

IF header_cur%ISOPEN THEN CLOSE header_cur; END IF;
IF line_cur%ISOPEN   THEN CLOSE line_cur;   END IF;

FOR header_record IN header_cur
LOOP
    l_array_header_events(header_record.event_id) := header_record.event_id;
END LOOP;

l_first_event_id := l_array_header_events(l_array_header_events.FIRST);
l_last_event_id := l_array_header_events(l_array_header_events.LAST);

fnd_file.put_line(fnd_file.LOG, ''                    '');
fnd_file.put_line(fnd_file.LOG, ''***************************************************************************'');
fnd_file.put_line(fnd_file.LOG, ''EVENT CLASS CODE = '' || C_EVENT_CLASS_CODE );
fnd_file.put_line(fnd_file.LOG, ''The following events are present in the line extract but MISSING in the header extract: '');

FOR line_record IN line_cur(l_first_event_id, l_last_event_id)
LOOP
	IF (NOT l_array_header_events.EXISTS(line_record.event_id))  AND (NOT l_array_duplicate_checker.EXISTS(line_record.event_id)) THEN
	fnd_file.put_line(fnd_file.log, ''Event_id = '' || line_record.event_id);
        l_array_duplicate_checker(line_record.event_id) := line_record.event_id;
	END IF;
END LOOP;

fnd_file.put_line(fnd_file.LOG, ''***************************************************************************'');
fnd_file.put_line(fnd_file.LOG, ''                    '');
';


--
--+==========================================================================+
--|                                                                          |
--| HEADER BODY TEMPLATE, WHEN THIRD PARTY CHANGE OPTION IS NOT USED         |
--|                                                                          |
--+==========================================================================+
--
-- when header extract objects exist
--
C_EVENT_BODY                    CONSTANT      VARCHAR2(10000):= '
--
OPEN header_cur;
--
IF (C_LEVEL_STATEMENT >= g_log_level) THEN
   trace
   (p_msg      => ''SQL - FETCH header_cur''
   ,p_level    => C_LEVEL_STATEMENT
   ,p_module   => l_log_module);
END IF;
--
LOOP
FETCH header_cur BULK COLLECT INTO
        l_array_entity_id
      , l_array_legal_entity_id
      , l_array_entity_code
      , l_array_transaction_num
      , l_array_event_id
      , l_array_class_code
      , l_array_event_type
      , l_array_event_number
      , l_array_event_date
      , l_array_transaction_date
      , l_array_reference_num_1
      , l_array_reference_num_2
      , l_array_reference_num_3
      , l_array_reference_num_4
      , l_array_reference_char_1
      , l_array_reference_char_2
      , l_array_reference_char_3
      , l_array_reference_char_4
      , l_array_reference_date_1
      , l_array_reference_date_2
      , l_array_reference_date_3
      , l_array_reference_date_4
      , l_array_event_created_by
      , l_array_budgetary_control_flag $header_var$
      LIMIT l_rows;
--
IF (C_LEVEL_EVENT >= g_log_level) THEN
   trace
   (p_msg      => ''# rows extracted from header extract objects = ''||TO_CHAR(header_cur%ROWCOUNT)
   ,p_level    => C_LEVEL_EVENT
   ,p_module   => l_log_module);
END IF;
--
EXIT WHEN l_array_entity_id.COUNT = 0;

-- initialize arrays
XLA_AE_HEADER_PKG.g_rec_header_new        := NULL;
XLA_AE_LINES_PKG.g_rec_lines              := NULL;

--
-- Bug 4458708
--
XLA_AE_LINES_PKG.g_LineNumber := 0;


-- 4262811 - when creating Accrual Reversal or MPA, use g_last_hdr_idx to increment for next header id
g_last_hdr_idx := l_array_event_id.LAST;
--
-- loop for the headers. Each iteration is for each header extract row
-- fetched in header cursor
--
FOR hdr_idx IN l_array_event_id.FIRST .. l_array_event_id.LAST LOOP

--
-- set event info as cache for other routines to refer event attributes
--
XLA_AE_JOURNAL_ENTRY_PKG.set_event_info
   (p_application_id           => p_application_id
   ,p_primary_ledger_id        => p_primary_ledger_id
   ,p_base_ledger_id           => p_base_ledger_id
   ,p_target_ledger_id         => p_target_ledger_id
   ,p_entity_id                => l_array_entity_id(hdr_idx)
   ,p_legal_entity_id          => l_array_legal_entity_id(hdr_idx)
   ,p_entity_code              => l_array_entity_code(hdr_idx)
   ,p_transaction_num          => l_array_transaction_num(hdr_idx)
   ,p_event_id                 => l_array_event_id(hdr_idx)
   ,p_event_class_code         => l_array_class_code(hdr_idx)
   ,p_event_type_code          => l_array_event_type(hdr_idx)
   ,p_event_number             => l_array_event_number(hdr_idx)
   ,p_event_date               => l_array_event_date(hdr_idx)
   ,p_transaction_date         => l_array_transaction_date(hdr_idx)
   ,p_reference_num_1          => l_array_reference_num_1(hdr_idx)
   ,p_reference_num_2          => l_array_reference_num_2(hdr_idx)
   ,p_reference_num_3          => l_array_reference_num_3(hdr_idx)
   ,p_reference_num_4          => l_array_reference_num_4(hdr_idx)
   ,p_reference_char_1         => l_array_reference_char_1(hdr_idx)
   ,p_reference_char_2         => l_array_reference_char_2(hdr_idx)
   ,p_reference_char_3         => l_array_reference_char_3(hdr_idx)
   ,p_reference_char_4         => l_array_reference_char_4(hdr_idx)
   ,p_reference_date_1         => l_array_reference_date_1(hdr_idx)
   ,p_reference_date_2         => l_array_reference_date_2(hdr_idx)
   ,p_reference_date_3         => l_array_reference_date_3(hdr_idx)
   ,p_reference_date_4         => l_array_reference_date_4(hdr_idx)
   ,p_event_created_by         => l_array_event_created_by(hdr_idx)
   ,p_budgetary_control_flag   => l_array_budgetary_control_flag(hdr_idx));

--
-- set the status of entry to C_VALID (0)
--
XLA_AE_JOURNAL_ENTRY_PKG.g_global_status    := XLA_AE_JOURNAL_ENTRY_PKG.C_VALID;

--
-- initialize a row for ae header
--
XLA_AE_HEADER_PKG.InitHeader(hdr_idx);

l_event_id := l_array_event_id(hdr_idx);

--
-- storing the hdr_idx for event. May be used by line cursor.
--
g_array_event(l_event_id).array_value_num(''header_index'') := hdr_idx;

--
-- store sources from header extract. This can be improved to
-- store only those sources from header extract that may be used in lines
--
$cache_header_sources$

--
-- initilaize the status of ae headers for diffrent balance types
-- the status is initialised to C_NOT_CREATED (2)
--
--g_array_event(l_event_id).array_value_num(''actual_je_status'') := XLA_AE_JOURNAL_ENTRY_PKG.C_NOT_CREATED;
--g_array_event(l_event_id).array_value_num(''budget_je_status'') := XLA_AE_JOURNAL_ENTRY_PKG.C_NOT_CREATED;
--g_array_event(l_event_id).array_value_num(''encumbrance_je_status'') := XLA_AE_JOURNAL_ENTRY_PKG.C_NOT_CREATED;

--
-- call api to validate and store accounting attributes for header
--
$hdr_accounting_attributes$

XLA_AE_HEADER_PKG.SetHdrAcctAttrs(l_rec_acct_attrs);

XLA_AE_HEADER_PKG.SetJeCategoryName;

XLA_AE_HEADER_PKG.g_rec_header_new.array_event_type_code(hdr_idx)  := l_array_event_type(hdr_idx);
XLA_AE_HEADER_PKG.g_rec_header_new.array_event_id(hdr_idx)         := l_array_event_id(hdr_idx);
XLA_AE_HEADER_PKG.g_rec_header_new.array_entity_id(hdr_idx)        := l_array_entity_id(hdr_idx);
XLA_AE_HEADER_PKG.g_rec_header_new.array_event_number(hdr_idx)     := l_array_event_number(hdr_idx);
XLA_AE_HEADER_PKG.g_rec_header_new.array_target_ledger_id(hdr_idx) := p_target_ledger_id;

$call_header_description$
$call_hdr_analytic_criteria$

--
--accounting attribute enhancement, bug 3612931
--
l_trx_reversal_source := SUBSTR($trx_reversal_source$, 1,30);

IF NVL(l_trx_reversal_source, ''N'') NOT IN (''N'',''Y'') THEN
   xla_ae_journal_entry_pkg.g_global_status      :=  xla_ae_journal_entry_pkg.C_INVALID;

   xla_accounting_err_pkg.build_message
      (p_appli_s_name            => ''XLA''
      ,p_msg_name                => ''XLA_AP_INVALID_HDR_ATTR''
      ,p_token_1                 => ''ACCT_ATTR_NAME''
      ,p_value_1                 => xla_ae_sources_pkg.GetAccountingSourceName(''TRX_ACCT_REVERSAL_OPTION'')
      ,p_token_2                 => ''PRODUCT_NAME''
      ,p_value_2                 => xla_ae_journal_entry_pkg.g_cache_event.application_name
      ,p_entity_id               => xla_ae_journal_entry_pkg.g_cache_event.entity_id
      ,p_event_id                => xla_ae_journal_entry_pkg.g_cache_event.event_id
      ,p_ledger_id               => xla_ae_journal_entry_pkg.g_cache_event.target_ledger_id);

ELSIF NVL(l_trx_reversal_source, ''N'') = ''Y'' THEN
   --
   -- following sets the accounting attributes needed to reverse
   -- accounting for a distributeion
   --
   xla_ae_lines_pkg.SetTrxReversalAttrs
      (p_event_id              => l_event_id
      ,p_gl_date               => XLA_AE_HEADER_PKG.g_rec_header_new.array_gl_date(hdr_idx)
      ,p_trx_reversal_source   => l_trx_reversal_source);

END IF;


----------------------------------------------------------------
-- 4262811 -  update the header statuses to invalid in need be
----------------------------------------------------------------
--
XLA_AE_JOURNAL_ENTRY_PKG.UpdateJournalEntryStatus (p_hdr_idx => hdr_idx);

$accrual_reversal_body$
----------------------------------------------------------------

--
-- this ends the header loop iteration for one bulk fetch
--
END LOOP;

l_first_event_id   := l_array_event_id(l_array_event_id.FIRST);
l_last_event_id    := l_array_event_id(l_array_event_id.LAST);

--
-- insert dummy rows into lines gt table that were created due to
-- transaction reversals
--
IF XLA_AE_LINES_PKG.g_rec_lines.array_ae_header_id.COUNT > 0 THEN
   l_result := XLA_AE_LINES_PKG.InsertLines;
END IF;

--
-- reset the temp_line_num for each set of events fetched from header
-- cursor rather than doing it for each new event in line cursor
-- Bug 3939231
--
xla_ae_lines_pkg.g_temp_line_num := 0;


$lines_body$

--
-- insert headers into xla_ae_headers_gt table
--
l_result := XLA_AE_HEADER_PKG.InsertHeaders ;

-- insert into errors table here.

END LOOP;

--
-- 4865292
--
-- Compare g_hdr_extract_count with event count in
-- CreateHeadersAndLines.
--
g_hdr_extract_count := g_hdr_extract_count + header_cur%ROWCOUNT;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
   trace (p_msg     => ''# rows extracted from header extract objects ''
                    || '' (running total): ''
                    || g_hdr_extract_count
         ,p_level   => C_LEVEL_STATEMENT
         ,p_module  => l_log_module);
END IF;

CLOSE header_cur;
--
';  -- C_EVENT_BODY

--
--

--
--+==========================================================================+
--|                                                                          |
--| HEADER BODY TEMPLATE, WHEN THIRD PARTY CHANGE OPTION IS USED             |
--|                                                                          |
--+==========================================================================+
--
--
C_THIRD_PARTY_CHANGE_BODY                    CONSTANT      VARCHAR2(10000):= '
--
  --
  IF $third_party_change$ = ''Y'' THEN
  --
     xla_ae_header_pkg.change_third_party;
  --
  ELSIF NVL($third_party_change$,''N'') <> ''N'' THEN
  --
    xla_ae_journal_entry_pkg.g_global_status      :=  xla_ae_journal_entry_pkg.C_INVALID;
             --
    xla_accounting_err_pkg.build_message
                           (p_appli_s_name            => ''XLA''
                           ,p_msg_name                => ''XLA_AP_THIRD_PARTY_OPTION''
                           ,p_token_1                 => ''PRODUCT_NAME''
                           ,p_value_1                 => xla_ae_journal_entry_pkg.g_cache_event.application_name
                           ,p_entity_id               => xla_ae_journal_entry_pkg.g_cache_event.entity_id
                           ,p_event_id                => xla_ae_journal_entry_pkg.g_cache_event.event_id
                           ,p_ledger_id               => xla_ae_journal_entry_pkg.g_cache_event.target_ledger_id
           );
  END IF;
  --
';
--
--+==========================================================================+
--|                                                                          |
--| LINES BODY TEMPLATE, WHEN ACCOUNTING REVERSAL OPTION IS NOT USED         |
--|                                                                          |
--+==========================================================================+
--
-- Extract line Objects defined
--
C_BODY_LINES           CONSTANT      VARCHAR2(10000):= '
--
OPEN line_cur(x_first_event_id  => l_first_event_id, x_last_event_id  => l_last_event_id);
--
--
IF (C_LEVEL_STATEMENT >= g_log_level) THEN

      trace
         (p_msg      => ''SQL - FETCH line_cur''
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);

END IF;
--
--
LOOP
  --
  FETCH line_cur BULK COLLECT INTO
        l_array_entity_id
      , l_array_legal_entity_id
      , l_array_entity_code
      , l_array_transaction_num
      , l_array_event_id
      , l_array_class_code
      , l_array_event_type
      , l_array_event_number
      , l_array_event_date
      , l_array_transaction_date
      , l_array_reference_num_1
      , l_array_reference_num_2
      , l_array_reference_num_3
      , l_array_reference_num_4
      , l_array_reference_char_1
      , l_array_reference_char_2
      , l_array_reference_char_3
      , l_array_reference_char_4
      , l_array_reference_date_1
      , l_array_reference_date_2
      , l_array_reference_date_3
      , l_array_reference_date_4
      , l_array_event_created_by
      , l_array_budgetary_control_flag
$line_var$
      LIMIT l_rows;

  --
  IF (C_LEVEL_EVENT >= g_log_level) THEN
            trace
               (p_msg      => ''# rows extracted from line extract objects = ''||TO_CHAR(line_cur%ROWCOUNT)
               ,p_level    => C_LEVEL_EVENT
               ,p_module   => l_log_module);
  END IF;
  --
  EXIT WHEN l_array_entity_id.count = 0;

  XLA_AE_LINES_PKG.g_rec_lines := null;

--
-- Bug 4458708
--
XLA_AE_LINES_PKG.g_LineNumber := 0;
--
--

FOR Idx IN 1..l_array_event_id.count LOOP
   --
   -- 5648433 (move l_event_id out of IF statement)  set l_event_id to be used inside IF condition
   --
   l_event_id := l_array_event_id(idx);  -- 5648433

   --
   -- Bug 4872078 - Do nothing if the event is meant for transaction reversal
   --

   IF NVL(xla_ae_header_pkg.g_rec_header_new.array_trx_acct_reversal_option
             (g_array_event(l_event_id).array_value_num(''header_index''))
         ,''N''
         ) <> ''Y''
   THEN
      IF (C_LEVEL_STATEMENT >= g_log_level) THEN
         trace
            (p_msg      => ''Trancaction revesal option is not Y ''
            ,p_level    => C_LEVEL_STATEMENT
            ,p_module   => l_log_module);
      END IF;

--
-- set the XLA_AE_JOURNAL_ENTRY_PKG.g_global_status to C_VALID (0)
--
XLA_AE_JOURNAL_ENTRY_PKG.g_global_status := XLA_AE_JOURNAL_ENTRY_PKG.C_VALID;
--
-- set event info as cache for other routines to refer event attributes
--

IF l_event_id <> NVL(l_previous_event_id, -1) THEN
   l_previous_event_id := l_event_id;

   XLA_AE_JOURNAL_ENTRY_PKG.set_event_info
      (p_application_id           => p_application_id
      ,p_primary_ledger_id        => p_primary_ledger_id
      ,p_base_ledger_id           => p_base_ledger_id
      ,p_target_ledger_id         => p_target_ledger_id
      ,p_entity_id                => l_array_entity_id(Idx)
      ,p_legal_entity_id          => l_array_legal_entity_id(Idx)
      ,p_entity_code              => l_array_entity_code(Idx)
      ,p_transaction_num          => l_array_transaction_num(Idx)
      ,p_event_id                 => l_array_event_id(Idx)
      ,p_event_class_code         => l_array_class_code(Idx)
      ,p_event_type_code          => l_array_event_type(Idx)
      ,p_event_number             => l_array_event_number(Idx)
      ,p_event_date               => l_array_event_date(Idx)
      ,p_transaction_date         => l_array_transaction_date(Idx)
      ,p_reference_num_1          => l_array_reference_num_1(Idx)
      ,p_reference_num_2          => l_array_reference_num_2(Idx)
      ,p_reference_num_3          => l_array_reference_num_3(Idx)
      ,p_reference_num_4          => l_array_reference_num_4(Idx)
      ,p_reference_char_1         => l_array_reference_char_1(Idx)
      ,p_reference_char_2         => l_array_reference_char_2(Idx)
      ,p_reference_char_3         => l_array_reference_char_3(Idx)
      ,p_reference_char_4         => l_array_reference_char_4(Idx)
      ,p_reference_date_1         => l_array_reference_date_1(Idx)
      ,p_reference_date_2         => l_array_reference_date_2(Idx)
      ,p_reference_date_3         => l_array_reference_date_3(Idx)
      ,p_reference_date_4         => l_array_reference_date_4(Idx)
      ,p_event_created_by         => l_array_event_created_by(Idx)
      ,p_budgetary_control_flag   => l_array_budgetary_control_flag(Idx));
       --
END IF;



--
xla_ae_lines_pkg.SetExtractLine(p_extract_line => l_array_extract_line_num(Idx));

l_acct_reversal_source := SUBSTR($acct_reversal_source$, 1,30);

IF l_continue_with_lines THEN
   IF NVL(l_acct_reversal_source, ''N'') NOT IN (''N'',''Y'',''B'') THEN
      xla_ae_journal_entry_pkg.g_global_status      :=  xla_ae_journal_entry_pkg.C_INVALID;

      xla_accounting_err_pkg.build_message
         (p_appli_s_name            => ''XLA''
         ,p_msg_name                => ''XLA_AP_INVALID_REVERSAL_OPTION''
         ,p_token_1                 => ''LINE_NUMBER''
         ,p_value_1                 => l_array_extract_line_num(Idx)
         ,p_token_2                 => ''PRODUCT_NAME''
         ,p_value_2                 => xla_ae_journal_entry_pkg.g_cache_event.application_name
         ,p_entity_id               => xla_ae_journal_entry_pkg.g_cache_event.entity_id
         ,p_event_id                => xla_ae_journal_entry_pkg.g_cache_event.event_id
         ,p_ledger_id               => xla_ae_journal_entry_pkg.g_cache_event.target_ledger_id);

   ELSIF NVL(l_acct_reversal_source, ''N'') IN (''Y'',''B'') THEN
      --
      -- following sets the accounting attributes needed to reverse
      -- accounting for a distributeion
      --

      --
      -- 5217187
      --
      l_rec_rev_acct_attrs.array_acct_attr_code(1):= ''GL_DATE'';
      l_rec_rev_acct_attrs.array_date_value(1) := XLA_AE_HEADER_PKG.g_rec_header_new.array_gl_date(
                                       g_array_event(l_event_id).array_value_num(''header_index''));
      --
      --

$acct_reversal_code$

      xla_ae_lines_pkg.SetAcctReversalAttrs
         (p_event_id             => l_event_id
         ,p_rec_acct_attrs       => l_rec_rev_acct_attrs
         ,p_calculate_acctd_flag => l_calculate_acctd_flag
         ,p_calculate_g_l_flag   => l_calculate_g_l_flag);
   END IF;

   IF NVL(l_acct_reversal_source, ''N'') IN (''N'',''B'') THEN
      $call_alts$
      -- only execute it if calculate g/l flag is yes, and primary or secondary ledger
      -- or secondary ledger that has different currency with primary
      -- or alc that is calculated by sla
      IF (((l_calculate_g_l_flag = ''Y'' AND XLA_AE_JOURNAL_ENTRY_PKG.g_cache_ledgers_info.ledger_category_code <> ''ALC'') or
            (XLA_AE_JOURNAL_ENTRY_PKG.g_cache_ledgers_info.ledger_category_code in (''ALC'', ''SECONDARY'') AND XLA_AE_JOURNAL_ENTRY_PKG.g_cache_ledgers_info.calculate_amts_flag=''Y''))

--      IF((l_calculate_g_l_flag=''Y'' or XLA_AE_JOURNAL_ENTRY_PKG.g_cache_event.target_ledger_id <>
--                    XLA_AE_JOURNAL_ENTRY_PKG.g_cache_event.ledger_id)
          AND (l_actual_flag = ''A'')) THEN
        XLA_AE_LINES_PKG.CreateGainOrLossLines(
          p_event_id         => xla_ae_journal_entry_pkg.g_cache_event.event_id
         ,p_application_id   => p_application_id
         ,p_amb_context_code => ''$amb_context_code$''
         ,p_entity_code      => xla_ae_journal_entry_pkg.g_cache_event.entity_code
         ,p_event_class_code => C_EVENT_CLASS_CODE
         ,p_event_type_code  => C_EVENT_TYPE_CODE
         $gain_loss_account_params$
         ,p_actual_flag      => l_actual_flag
         ,p_enc_flag         => null
         ,p_actual_g_l_ref   => l_actual_gain_loss_ref
         ,p_enc_g_l_ref      => null
         );
      END IF;
   END IF;
END IF;

   ELSE
      --
      -- Bug 4872078 - Do nothing if the event is meant for transaction reversal
      --
      IF (C_LEVEL_STATEMENT >= g_log_level) THEN
         trace
            (p_msg      => ''Trancaction revesal option is Y''
            ,p_level    => C_LEVEL_STATEMENT
            ,p_module   => l_log_module);
      END IF;
   END IF;

END LOOP;
l_result := XLA_AE_LINES_PKG.InsertLines ;
end loop;
close line_cur;
';


--+=============================================================================+
--|                                                                             |
--| 4262811                                                                     |
--| Template for the accrual reversal code in the EventType/EventClass_xxx API. |
--|                                                                             |
--+=============================================================================+
--
C_ACC_REV_BODY         CONSTANT      VARCHAR2(10000) := '
--
-- Generate the accrual reversal headers
--
IF NVL(l_trx_reversal_source, ''N'') = ''N'' THEN

$if_cond$

-- indicate that the accrual entry has a reversal entry
XLA_AE_HEADER_PKG.g_rec_header_new.array_accrual_reversal_flag(hdr_idx) := ''Y'';

--
-- initialize a row for ae header
--
g_last_hdr_idx := g_last_hdr_idx + 1;
XLA_AE_HEADER_PKG.CopyHeaderInfo (p_parent_hdr_idx => hdr_idx,
                                  p_hdr_idx        => g_last_hdr_idx) ;
XLA_AE_HEADER_PKG.g_rec_header_new.array_header_num      (g_last_hdr_idx) := 1;
XLA_AE_HEADER_PKG.g_rec_header_new.array_parent_header_id(g_last_hdr_idx) :=
               XLA_AE_HEADER_PKG.g_rec_header_new.array_event_id(hdr_idx);

--
-- record the index for the reversal entry, it will be used by the journal
-- line creation
--
g_array_event(l_event_id).array_value_num(''acc_rev_header_index'') := g_last_hdr_idx;

--
-- Populate the GL Date and override the GL date defined in the
-- SetHdrAcctAttrs if necessary
--
$accrual_reversal_body2$

--
-- Update the header status
--
XLA_AE_JOURNAL_ENTRY_PKG.updateJournalEntryStatus (p_hdr_idx => g_last_hdr_idx);

$end_if$

END IF;

';




--+=============================================================================+
--|                                                                             |
--| 4262811                                                                     |
--| Template to populate accrual reversal GL date accounting attribut in the    |
--| EventType/EventClass_xxx API.                                               |
--|                                                                             |
--+=============================================================================+
--
C_HDR_ACCT_BODY     CONSTANT      VARCHAR2(10000) := '
------------------------------------------------------------
-- Accrual Reversal : to get date for Standard Source (NONE)
------------------------------------------------------------
l_acc_rev_gl_date_source := $acc_rev_gl_date_source$;

';

--
------------------------------------------------------------------------------
--
--
--
--
--
--       Transaction Objects Diagnostics Constants/Templates
--
--
--
--
--
------------------------------------------------------------------------------
--
--
--
C_INSERT_SOURCES_PROC                 CONSTANT      CLOB:= '
---------------------------------------
--
-- PRIVATE PROCEDURE
--         insert_sources_$EVENT_INDEX$
--
----------------------------------------
--
PROCEDURE insert_sources_$EVENT_INDEX$(
                                p_target_ledger_id       IN NUMBER
                              , p_language               IN VARCHAR2
                              , p_sla_ledger_id          IN NUMBER
                              , p_pad_start_date         IN DATE
                              , p_pad_end_date           IN DATE
                         )
IS

C_EVENT_TYPE_CODE    CONSTANT  VARCHAR2(30)  := ''$event_type_code$'';
C_EVENT_CLASS_CODE   CONSTANT  VARCHAR2(30) := ''$event_class_code$'';
p_apps_owner                   VARCHAR2(30);
l_log_module                   VARCHAR2(240);
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||''.insert_sources_$EVENT_INDEX$'';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN

      trace
         (p_msg      => ''BEGIN of insert_sources_$EVENT_INDEX$''
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;

-- select APPS owner
SELECT oracle_username
  INTO p_apps_owner
  FROM fnd_oracle_userid
 WHERE read_only_flag = ''U''
;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => ''p_target_ledger_id = ''||p_target_ledger_id||
                        '' - p_language = ''||p_language||
                        '' - p_sla_ledger_id  = ''||p_sla_ledger_id ||
                        '' - p_pad_start_date = ''||TO_CHAR(p_pad_start_date)||
                        '' - p_pad_end_date = ''||TO_CHAR(p_pad_end_date)||
                        '' - p_apps_owner = ''||TO_CHAR(p_apps_owner)
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

$insert_header_sources$

$insert_line_sources$

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => ''END of insert_sources_$EVENT_INDEX$''
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
EXCEPTION
  WHEN xla_exceptions_pkg.application_exception THEN
      IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => ''ERROR: XLA_CMP_COMPILER_ERROR = ''||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
      END IF;
      RAISE;
  WHEN OTHERS THEN
      IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => ''ERROR: XLA_CMP_COMPILER_ERROR = ''||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
       END IF;
       xla_exceptions_pkg.raise_message
           (p_location => ''$package_name$.insert_sources_$EVENT_INDEX$'');
END insert_sources_$EVENT_INDEX$;
--
';
--
--
--+==========================================================================+
--|                                                                          |
--| Private global constant or variable declarations                         |
--|                                                                          |
--+==========================================================================+
--
g_package_name            VARCHAR2(30);
g_product_rule_code       VARCHAR2(30);
g_product_rule_type_code  VARCHAR2(1);
g_product_rule_version    VARCHAR2(30);
g_product_rule_name       VARCHAR2(80);

g_chr_newline      CONSTANT VARCHAR2(10):= xla_environment_pkg.g_chr_newline;
--=============================================================================
--
--
--
--
--
--
--
--
--
--                               FND_LOG trace
--
--
--
--
--
--
--
--
--
--
--
--=============================================================================

--
--=============================================================================
--               *********** Local Trace Routine **********
--=============================================================================

C_LEVEL_STATEMENT     CONSTANT NUMBER := FND_LOG.LEVEL_STATEMENT;
C_LEVEL_PROCEDURE     CONSTANT NUMBER := FND_LOG.LEVEL_PROCEDURE;
C_LEVEL_EVENT         CONSTANT NUMBER := FND_LOG.LEVEL_EVENT;
C_LEVEL_EXCEPTION     CONSTANT NUMBER := FND_LOG.LEVEL_EXCEPTION;
C_LEVEL_ERROR         CONSTANT NUMBER := FND_LOG.LEVEL_ERROR;
C_LEVEL_UNEXPECTED    CONSTANT NUMBER := FND_LOG.LEVEL_UNEXPECTED;

C_LEVEL_LOG_DISABLED  CONSTANT NUMBER := 99;
C_DEFAULT_MODULE      CONSTANT VARCHAR2(240) := 'xla.plsql.XLA_CMP_EVENT_TYPE_PKG';

g_log_level           NUMBER;
g_log_enabled         BOOLEAN;

PROCEDURE trace
           (p_msg                        IN VARCHAR2
           ,p_level                      IN NUMBER
           ,p_module                     IN VARCHAR2)
IS
BEGIN
IF (p_msg IS NULL AND p_level >= g_log_level) THEN
          fnd_log.message(p_level, p_module);
ELSIF p_level >= g_log_level THEN
          fnd_log.string(p_level, p_module, p_msg);
END IF;

EXCEPTION
       WHEN xla_exceptions_pkg.application_exception THEN
          RAISE;
       WHEN OTHERS THEN
          xla_exceptions_pkg.raise_message
             (p_location   => 'XLA_CMP_EVENT_TYPE_PKG.trace');
END trace;

--+==========================================================================+
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--+==========================================================================+


/*------------------------------------------------------------+
|                                                             |
|  Private procedure                                          |
|                                                             |
|    GetEventClassEventType                                   |
|                                                             |
|  Retrieves the event classes and event types defined in AAD |
|                                                             |
+------------------------------------------------------------*/

PROCEDURE GetEventClassEventType(
                    p_application_id                  IN NUMBER
                  , p_amb_context_code                IN VARCHAR2
                  , p_product_rule_code               IN VARCHAR2
                  , p_product_rule_type_code          IN VARCHAR2
                  , p_array_entity                   OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
                  , p_array_event_class              OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
                  , p_array_event_type               OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
                  , p_array_event_class_acctd_flag   OUT NOCOPY xla_cmp_source_pkg.t_array_VL1
                  , p_array_event_class_g_l_flag     OUT NOCOPY xla_cmp_source_pkg.t_array_VL1
)
IS
--
-- get event_type belong entered product rule
--
CURSOR event_type_cur
IS
SELECT  DISTINCT
          xpah.event_type_code
        , xpah.event_class_code
        , xpah.entity_code
        , xeca.calculate_acctd_amts_flag
        , xeca.calculate_g_l_amts_flag
  FROM  xla_prod_acct_headers     xpah
      , xla_event_types_b         xetb
      , xla_event_class_attrs     xeca
 WHERE  xpah.product_rule_code        = p_product_rule_code
   AND  xpah.product_rule_type_code   = p_product_rule_type_code
   AND  xpah.application_id           = p_application_id
   AND  xpah.amb_context_code         = p_amb_context_code
   AND  xpah.application_id           = xetb.application_id
   AND  xpah.entity_code              = xetb.entity_code
   AND  xpah.event_class_code         = xetb.event_class_code
   AND  (xetb.event_type_code         = xpah.event_type_code
        OR
         xetb.event_type_code         = xpah.event_class_code||'_ALL'
        )
   AND  xetb.accounting_flag          = xpah.accounting_required_flag
   AND  xpah.accounting_required_flag = 'Y'
   AND  xpah.validation_status_code   = 'R'   -- Running
   AND  xetb.enabled_flag             = 'Y'
   AND  xeca.application_id           = xetb.application_id
   AND  xeca.event_class_code         = xetb.event_class_code
   AND  xeca.entity_code              = xetb.entity_code
ORDER BY xpah.event_type_code
;
--
CURSOR event_type_bc_cur
IS
SELECT  DISTINCT
          xpah.event_type_code
        , xpah.event_class_code
        , xpah.entity_code
        , xeca.calculate_acctd_amts_flag
        , xeca.calculate_g_l_amts_flag
  FROM  xla_prod_acct_headers     xpah
      , xla_event_types_b         xetb
      , xla_event_class_attrs     xeca
      , xla_aad_line_defn_assgns  xald
      , xla_line_definitions_b     xld
 WHERE  xpah.product_rule_code        = p_product_rule_code
   AND  xpah.product_rule_type_code   = p_product_rule_type_code
   AND  xpah.application_id           = p_application_id
   AND  xpah.amb_context_code         = p_amb_context_code
   AND  xpah.application_id           = xetb.application_id
   AND  xpah.entity_code              = xetb.entity_code
   AND  xpah.event_class_code         = xetb.event_class_code
   AND  (xetb.event_type_code         = xpah.event_type_code
        OR
         xetb.event_type_code         = xpah.event_class_code||'_ALL'
        )
   AND  xetb.accounting_flag          = xpah.accounting_required_flag
   AND  xpah.accounting_required_flag = 'Y'
   AND  xpah.validation_status_code   = 'R'   -- Running
   AND  xetb.enabled_flag             = 'Y'
   AND  xeca.application_id           = xetb.application_id
   AND  xeca.event_class_code         = xetb.event_class_code
   AND  xeca.entity_code              = xetb.entity_code
   AND  xald.application_id          = xpah.application_id
   AND  xald.amb_context_code        = xpah.amb_context_code
   AND  xald.event_class_code        = xpah.event_class_code
   AND  xald.event_type_code         = xpah.event_type_code
   AND  xald.product_rule_type_code = xpah.product_rule_type_code
   AND  xald.product_rule_code       = xpah.product_rule_code
   AND xald.application_id         = xld.application_id
   AND xald.amb_context_code       = xld.amb_context_code
   AND xald.event_class_code       = xld.event_class_code
   AND xald.event_type_code        = xld.event_type_code
   AND xald.line_definition_owner_code = xld.line_definition_owner_code
   AND xald.line_definition_code  = xld.line_definition_code
   AND xld.budgetary_control_flag = 'Y'
 ORDER BY xpah.event_type_code;
--
l_array_event_type                xla_cmp_source_pkg.t_array_VL30;
l_array_event_class               xla_cmp_source_pkg.t_array_VL30;
l_array_entity                    xla_cmp_source_pkg.t_array_VL30;
l_array_event_class_acctd_flag    xla_cmp_source_pkg.t_array_VL1;
l_array_event_class_g_l_flag      xla_cmp_source_pkg.t_array_VL1;
l_log_module                      VARCHAR2(240);
--
BEGIN

IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetEventClassEventType';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetEventClassEventType'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN

      trace
         (p_msg      => 'SQL - Select from xla_prod_acct_headers '
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);

END IF;
--
IF (XLA_CMP_PAD_PKG.g_bc_pkg_flag = 'N') THEN
   OPEN  event_type_cur;
   FETCH event_type_cur BULK COLLECT INTO   l_array_event_type
                                          , l_array_event_class
                                          , l_array_entity
                                          , l_array_event_class_acctd_flag
                                          , l_array_event_class_g_l_flag
                                          ;
   CLOSE event_type_cur;
ELSE
   OPEN  event_type_bc_cur;
   FETCH event_type_bc_cur BULK COLLECT INTO l_array_event_type
                                           , l_array_event_class
                                           , l_array_entity
                                           , l_array_event_class_acctd_flag
                                           , l_array_event_class_g_l_flag
                                           ;
   CLOSE event_type_bc_cur;
END IF;
--
p_array_event_type       := l_array_event_type;
p_array_event_class      := l_array_event_class;
p_array_entity           := l_array_entity;
p_array_event_class_acctd_flag := l_array_event_class_acctd_flag;
p_array_event_class_g_l_flag   := l_array_event_class_g_l_flag;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN

      trace
         (p_msg      => 'END of GetEventClassEventType'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;
--
EXCEPTION
  WHEN xla_exceptions_pkg.application_exception   THEN
       IF event_type_cur%ISOPEN THEN CLOSE event_type_cur; END IF;
       IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
       END IF;
       RAISE;
  WHEN OTHERS    THEN
       IF event_type_cur%ISOPEN THEN CLOSE event_type_cur; END IF;
       xla_exceptions_pkg.raise_message
            (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetEventClassEventType');
END GetEventClassEventType;

/*------------------------------------------------------------+
|                                                             |
|  Private procedure                                          |
|                                                             |
|    GetNoAccountEventTypes                                   |
|                                                             |
|  Retrieves the non accounting event types defined in AAD    |
|                                                             |
+------------------------------------------------------------*/

PROCEDURE GetNoAccountEventTypes(
                    p_application_id          IN NUMBER
                  , p_amb_context_code        IN VARCHAR2
                  , p_product_rule_code       IN VARCHAR2
                  , p_product_rule_type_code  IN VARCHAR2
                  , p_array_event_type        OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
)
IS
--
-- get event_type belong entered product rule
--
CURSOR event_type_cur
IS
SELECT  DISTINCT
          xetb.event_type_code
  FROM  xla_prod_acct_headers xpah
      , xla_event_types_b     xetb
 WHERE  xpah.product_rule_code         = p_product_rule_code
   AND  xpah.product_rule_type_code    = p_product_rule_type_code
   AND  xpah.application_id            = p_application_id
   AND  xpah.amb_context_code          = p_amb_context_code
   AND  xpah.application_id            = xetb.application_id
   AND  xpah.entity_code               = xetb.entity_code
   AND  xpah.event_class_code          = xetb.event_class_code
   AND  xetb.event_type_code           = DECODE( xpah.event_type_code
                                               , xpah.event_class_code ||'_ALL',xetb.event_type_code
                                               , xpah.event_type_code
                                               )
   AND  xetb.event_type_code           <> xetb.event_class_code || '_ALL'
   AND  xetb.accounting_flag           = 'Y'
   AND  xetb.enabled_flag              = 'Y'
   AND  (xpah.accounting_required_flag = 'N'
         OR
         xpah.validation_status_code   <> 'R')  -- not Running
  ;
--
l_array_event_type                xla_cmp_source_pkg.t_array_VL30;
l_log_module                      VARCHAR2(240);
--
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetNoAccountEventTypes';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetNoAccountEventTypes'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'SQL - SELECT from xla_prod_acct_headers'
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

OPEN  event_type_cur;

FETCH event_type_cur BULK COLLECT INTO   l_array_event_type
                                       ;
CLOSE event_type_cur;

p_array_event_type       := l_array_event_type;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetNoAccountEventTypes ='||p_array_event_type.COUNT
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
EXCEPTION
  WHEN xla_exceptions_pkg.application_exception   THEN
       IF event_type_cur%ISOPEN THEN CLOSE event_type_cur; END IF;
       IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
       RAISE;
  WHEN OTHERS    THEN
       IF event_type_cur%ISOPEN THEN CLOSE event_type_cur; END IF;
       xla_exceptions_pkg.raise_message
            (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetNoAccountEventTypes');
END GetNoAccountEventTypes;

/*------------------------------------------------------------+
|                                                             |
|  Private procedure                                          |
|                                                             |
|    GetEventType                                             |
|                                                             |
|  Retrieves the event types belong entered event class       |
|                                                             |
+------------------------------------------------------------*/

PROCEDURE GetEventType(
                    p_application_id          IN NUMBER
                  , p_entity_code             IN VARCHAR2
                  , p_event_class_code        IN VARCHAR2
                  , p_array_event_type        OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
)
IS
l_array_event_type                xla_cmp_source_pkg.t_array_VL30;

CURSOR event_type_cur
IS
SELECT  DISTINCT
        xetb.event_type_code
  FROM  xla_event_types_b xetb
 WHERE  xetb.entity_code              = p_entity_code
   AND  xetb.event_class_code         = p_event_class_code
   AND  xetb.application_id           = p_application_id
   AND  xetb.accounting_flag          = 'Y'
   AND  xetb.enabled_flag             = 'Y'
   AND  xetb.event_type_code         <>  xetb.event_class_code || '_ALL'
 ORDER BY xetb.event_type_code
   ;
l_log_module                      VARCHAR2(240);
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetEventType';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetEventType'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'SQL - SELECT from xla_event_types_b'
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

OPEN  event_type_cur;

FETCH event_type_cur BULK COLLECT INTO l_array_event_type;

CLOSE event_type_cur;

p_array_event_type := l_array_event_type;


IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetEventType = '||p_array_event_type.COUNT
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;
EXCEPTION
  WHEN xla_exceptions_pkg.application_exception   THEN
       IF event_type_cur%ISOPEN THEN CLOSE event_type_cur; END IF;
       IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
       END IF;
       RAISE;
  WHEN OTHERS    THEN
       IF event_type_cur%ISOPEN THEN CLOSE event_type_cur; END IF;
       xla_exceptions_pkg.raise_message
            (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetEventType');
END GetEventType;

/*------------------------------------------------------------+
|                                                             |
|  Private function                                           |
|                                                             |
|    GetEventTypeName                                         |
|                                                             |
|  Retrieves the event type name                              |
|                                                             |
+------------------------------------------------------------*/

FUNCTION GetEventTypeName(
  p_application_id            IN NUMBER
, p_entity_code               IN VARCHAR2
, p_event_class_code          IN VARCHAR2
, p_event_type_code           IN VARCHAR2
)
RETURN VARCHAR2
IS
l_name                   VARCHAR2(160);
l_log_module                      VARCHAR2(240);
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetEventTypeName';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetEventTypeName'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;

BEGIN
   SELECT  REPLACE(xect.name , '''','''''')
     INTO  l_name
     FROM  xla_event_types_tl  xect
    WHERE  xect.application_id     = p_application_id
      AND  xect.entity_code        = p_entity_code
      AND  xect.event_class_code   = p_event_class_code
      AND  xect.event_type_code    = p_event_type_code
      AND  xect.language           = USERENV('LANG')
   ;
EXCEPTION
WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN
   l_name := NULL;
END;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetEventTypeName'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
RETURN l_name;
EXCEPTION
 WHEN xla_exceptions_pkg.application_exception   THEN
        RETURN NULL;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetEventTypeName ');
END GetEventTypeName;

/*------------------------------------------------------------+
|                                                             |
|  Private function                                           |
|                                                             |
|    GetEntityName                                            |
|                                                             |
|  Retrieves the entity name                                  |
|                                                             |
+------------------------------------------------------------*/

FUNCTION GetEntityName( p_entity         IN VARCHAR2
                      , p_application_id IN NUMBER
                    )
RETURN VARCHAR2
IS
l_name                            VARCHAR2(160);
l_log_module                      VARCHAR2(240);
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetEntityName';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetEntityName'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

BEGIN
  SELECT REPLACE(xett.name , '''','''''')
    INTO l_name
    FROM xla_entity_types_tl             xett
   WHERE  xett.application_id           = p_application_id
     AND  xett.entity_code              = p_entity
     AND  xett.LANGUAGE                 = USERENV('LANG')
 ;
EXCEPTION
WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN
   l_name := NULL;
END;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetEntityName'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
RETURN l_name;
EXCEPTION
 WHEN xla_exceptions_pkg.application_exception   THEN
        RETURN NULL;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetEntityName ');
END GetEntityName;

/*------------------------------------------------------------+
|                                                             |
|  Private function                                           |
|                                                             |
|    GetEventClassName                                        |
|                                                             |
|  Retrieves the event class name                             |
|                                                             |
+------------------------------------------------------------*/

FUNCTION GetEventClassName(
  p_application_id            IN NUMBER
, p_entity_code               IN VARCHAR2
, p_event_class_code          IN VARCHAR2
)
RETURN VARCHAR2
IS
l_name                            VARCHAR2(160);
l_log_module                      VARCHAR2(240);
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetEventClassName';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetEventClassName'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

BEGIN
  SELECT  REPLACE(xect.name , '''','''''')
    INTO  l_name
    FROM  xla_event_classes_tl  xect
   WHERE  xect.application_id     = p_application_id
     AND  xect.entity_code        = p_entity_code
     AND  xect.event_class_code   = p_event_class_code
     AND  xect.language           = USERENV('LANG')
   ;
EXCEPTION
WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN
   l_name := NULL;
END;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetEventClassName'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;
RETURN l_name;
EXCEPTION
 WHEN xla_exceptions_pkg.application_exception   THEN
        RETURN NULL;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetEventClassName ');
END GetEventClassName;
--
--+==========================================================================+
--|                                                                          |
--| COLLECT THE NEEDED SOURCES                                               |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--+==========================================================================+
--
--
--+==========================================================================+
--|                                                                          |
--| PRIVATE procedure                                                        |
--|                                                                          |
--|  Add third_party_chage_option and accounting_reversal_option to the list |
--|  of sources to extract from the Product tables/views                     |
--|                                                                          |
--+==========================================================================+
--
--
--+==========================================================================+
--|                                                                          |
--| PRIVATE function                                                         |
--|                                                                          |
--|      Check if Option Flag party_change_option                            |
--|      or accounting_reversal_option is defined in                         |
--|      Transaction Objects                                                 |
--|                                                                          |
--+==========================================================================+
--
FUNCTION IsOptionFlagInEventExtract (
    p_source_option                IN VARCHAR2
  , p_array_source_code            IN xla_cmp_source_pkg.t_array_VL30
)
RETURN NUMBER
IS

l_IsSourceExists             NUMBER;
l_array_source_code          xla_cmp_source_pkg.t_array_VL30;
l_log_module                 VARCHAR2(240);

BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.IsOptionFlagInEventExtract';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => 'BEGIN of IsOptionFlagInEventExtract'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'p_source_option = '||p_source_option
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
      trace
         (p_msg      => '# of sources = '||p_array_source_code.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

l_array_source_code := p_array_source_code;
l_IsSourceExists    := NULL;

IF l_array_source_code.COUNT > 0 THEN

FOR Idx IN l_array_source_code.FIRST .. l_array_source_code.LAST LOOP

  IF l_array_source_code.EXISTS(Idx) AND l_array_source_code(Idx) = p_source_option
  THEN
     l_IsSourceExists := Idx;
  END IF;

END LOOP;

END IF;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
   trace
      (p_msg      => 'return value, Source Index  = '||l_IsSourceExists
      ,p_level    => C_LEVEL_STATEMENT
      ,p_module   => l_log_module);
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of IsOptionFlagInEventExtract'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
RETURN l_IsSourceExists;
EXCEPTION
   WHEN xla_exceptions_pkg.application_exception   THEN
        RETURN NULL;
   WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.IsOptionFlagInEventExtract');
END IsOptionFlagInEventExtract;
--
--+==========================================================================+
--|                                                                          |
--| PRIVATE Procedure                                                        |
--|                                                                          |
--|      Get Index and level (Header or line) of Option Flags                |
--|      party_change_option and accounting_reversal_option                  |
--|                                                                          |
--+==========================================================================+
--
PROCEDURE GetIndexOfOptionFlags (
  p_array_hdr_acctg_source           IN xla_cmp_source_pkg.t_array_VL30
, p_array_hdr_acct_attr_source       IN xla_cmp_source_pkg.t_array_int
, p_array_line_acctg_source          IN xla_cmp_source_pkg.t_array_VL30
, p_array_line_acct_attr_source      IN xla_cmp_source_pkg.t_array_int
, p_ThirdPartyIdx                    OUT NOCOPY NUMBER
, p_AcctReversalIdx                  OUT NOCOPY NUMBER
, p_TrxReversalIdx                   OUT NOCOPY NUMBER
)
IS
--
l_log_module                 VARCHAR2(240);
BEGIN
--
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetIndexOfOptionFlags';
END IF;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetIndexOfOptionFlags'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
--
p_ThirdPartyIdx            := NULL;
p_AcctReversalIdx          := NULL;
p_TrxReversalIdx           := NULL;
--
p_ThirdPartyIdx      := IsOptionFlagInEventExtract(
                              p_source_option          =>'PARTY_CHANGE_OPTION'
                            , p_array_source_code      => p_array_hdr_acctg_source
                            );
--
--
p_AcctReversalIdx := IsOptionFlagInEventExtract(
                              p_source_option          =>'ACCOUNTING_REVERSAL_OPTION'
                            , p_array_source_code      => p_array_line_acctg_source
                            );
--
--
p_TrxReversalIdx := IsOptionFlagInEventExtract(
                              p_source_option          =>'TRX_ACCT_REVERSAL_OPTION'
                            , p_array_source_code      => p_array_hdr_acctg_source
                            );
--
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetIndexOfOptionFlags'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
--
EXCEPTION
   WHEN xla_exceptions_pkg.application_exception   THEN
      p_ThirdPartyIdx            := NULL;
      p_AcctReversalIdx          := NULL;
      p_TrxReversalIdx           := NULL;
   WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetIndexOfOptionFlags');
END GetIndexOfOptionFlags;

/*--------------------------------------------------------------------+
|                                                                     |
|  Private procedure                                                  |
|                                                                     |
|    GetHeaderAcctgSources                                            |
|                                                                     |
|  Get sources assigned to header accounting attributes.              |
|                                                                     |
+--------------------------------------------------------------------*/

PROCEDURE GetHeaderAcctgSources (
    p_entity                       IN VARCHAR2
  , p_event_class                  IN VARCHAR2
  , p_event_type                   IN VARCHAR2
  , p_application_id               IN NUMBER
  , p_amb_context_code             IN VARCHAR2
  , p_product_rule_type_code       IN VARCHAR2
  , p_product_rule_code            IN VARCHAR2
  --
  , p_array_evt_source_index       IN OUT NOCOPY xla_cmp_source_pkg.t_array_ByInt
  , p_array_hdr_acctg_source       OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
  , p_array_hdr_acctg_source_type  OUT NOCOPY xla_cmp_source_pkg.t_array_VL1
  , p_array_hdr_acct_attr_source   OUT NOCOPY xla_cmp_source_pkg.t_array_int
  --
  , p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
)
IS
--
--
CURSOR source_cur
IS
SELECT      eca.accounting_attribute_code
          , eca.source_application_id
          , eca.source_type_code
          , eca.source_code
          , DECODE(nvl(xes.level_code, 'H'),'H','H','L')
  FROM xla_evt_class_acct_attrs   eca
     , xla_event_sources          xes
     , xla_acct_attributes_b      xasb
     , xla_sources_b              xsb
WHERE  eca.application_id             = p_application_id
   AND eca.event_class_code           = p_event_class
   AND xasb.accounting_attribute_code = eca.accounting_attribute_code
   AND xasb.assignment_level_code     = 'EVT_CLASS_ONLY'
   AND xes.application_id(+)          = p_application_id
   AND xes.entity_code(+)             = p_entity
   AND xes.event_class_code(+)        = p_event_class
   AND xes.source_application_id(+)   = eca.source_application_id
   AND xes.source_type_code(+)        = eca.source_type_code
   AND xes.source_code(+)             = eca.source_code
   AND xasb.journal_entry_level_code  = 'H'
   AND xes.active_flag(+)             = 'Y'
   AND xsb.application_id             = eca.source_application_id
   AND xsb.source_type_code           = eca.source_type_code
   AND xsb.source_code                = eca.source_code
UNION
SELECT      aha.accounting_attribute_code
          , aha.source_application_id
          , aha.source_type_code
          , aha.source_code
          , DECODE(xes.level_code,'H','H','L')
  FROM xla_aad_hdr_acct_attrs   aha
     , xla_event_sources        xes
     , xla_acct_attributes_b    xasb
     , xla_sources_b   xsb
WHERE  aha.application_id             = p_application_id
   AND aha.amb_context_code           = p_amb_context_code
   AND aha.product_rule_type_code     = p_product_rule_type_code
   AND aha.product_rule_code          = p_product_rule_code
   AND aha.event_class_code           = p_event_class
   AND aha.event_type_code            = p_event_type
   AND xasb.accounting_attribute_code = aha.accounting_attribute_code
   AND xasb.assignment_level_code     IN ('AAD_ONLY','EVT_CLASS_AAD')
   AND xes.application_id(+)          = p_application_id
   AND xes.entity_code(+)             = p_entity
   AND xes.event_class_code(+)        = p_event_class
   AND xes.source_application_id(+)   = aha.source_application_id
   AND xes.source_type_code(+)        = aha.source_type_code
   AND xes.source_code(+)             = aha.source_code
   AND xes.active_flag (+)            = 'Y'
   AND xsb.application_id             = aha.source_application_id
   AND xsb.source_type_code           = aha.source_type_code
   AND xsb.source_code                = aha.source_code
;
--
--
l_SourceIdx                     BINARY_INTEGER;
l_accounting_source             xla_cmp_source_pkg.t_array_VL30;
l_accounting_source_type        xla_cmp_source_pkg.t_array_VL1;
l_source_application_id         xla_cmp_source_pkg.t_array_Num;
l_source_type_code              xla_cmp_source_pkg.t_array_VL1;
l_source_code                   xla_cmp_source_pkg.t_array_VL30;
l_log_module                    VARCHAR2(240);
--
BEGIN
--
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetHeaderAcctgSources';
END IF;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN

      trace
         (p_msg      => 'BEGIN of GetHeaderAcctgSources'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;

IF (C_LEVEL_STATEMENT>= g_log_level) THEN
      trace
         (p_msg      => 'entity:'||p_entity||
                        ' - class:'||p_event_class||
                        ' - type:'||p_event_type||
                        ' - amb_context_code:'||p_amb_context_code||
                        ' - rule_type_code:'||p_product_rule_type_code||
                        ' - rule_code:'||p_product_rule_code
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

OPEN source_cur;

FETCH source_cur BULK COLLECT INTO l_accounting_source
                                 , l_source_application_id
                                 , l_source_type_code
                                 , l_source_code
                                 , l_accounting_source_type
                                 ;

CLOSE source_cur;
--
--
IF l_accounting_source.EXISTS(NVL(l_accounting_source.FIRST,1)) THEN

FOR Idx IN l_accounting_source.FIRST .. l_accounting_source.LAST LOOP

 IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'Accouting sources  = '||l_accounting_source(Idx)||
                        ' - Source Code  = '||l_source_code(Idx)
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
 END IF;
 IF l_source_code.EXISTS(Idx) AND l_source_code(Idx) IS NOT NULL THEN

  l_SourceIdx := xla_cmp_source_pkg.StackSource(
                p_source_code                => l_source_code(Idx)
              , p_source_type_code           => l_source_type_code(Idx)
              , p_source_application_id      => l_source_application_id(Idx)
              , p_array_source_index         => p_array_evt_source_index
              , p_rec_sources                => p_rec_sources
              );

  p_array_hdr_acctg_source(Idx)      := l_accounting_source(Idx);
  p_array_hdr_acctg_source_type(Idx) := l_accounting_source_type(Idx);
  p_array_hdr_acct_attr_source(Idx)  := l_SourceIdx;

 END IF;
END LOOP;
END IF;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetHeaderAcctgSources ='||l_accounting_source.COUNT
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
EXCEPTION
   WHEN xla_exceptions_pkg.application_exception   THEN
        IF source_cur%ISOPEN THEN CLOSE source_cur; END IF;
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
   WHEN OTHERS    THEN
      IF source_cur%ISOPEN THEN CLOSE source_cur; END IF;
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetHeaderAcctgSources ');
END GetHeaderAcctgSources;

/*--------------------------------------------------------------------+
|                                                                     |
|  Private procedure                                                  |
|                                                                     |
|    GetLineAcctgSources                                              |
|                                                                     |
|  Get sources assigned to Reversal line accounting attributes.       |
|                                                                     |
+--------------------------------------------------------------------*/

PROCEDURE GetLineAcctgSources (
    p_entity                       IN VARCHAR2
  , p_event_class                  IN VARCHAR2
  , p_application_id               IN NUMBER
  --
  , p_array_evt_source_index       IN OUT NOCOPY xla_cmp_source_pkg.t_array_ByInt
  , p_array_line_acctg_source      OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
  , p_array_line_acctg_source_type OUT NOCOPY xla_cmp_source_pkg.t_array_VL1
  , p_array_line_acct_attr_source  OUT NOCOPY xla_cmp_source_pkg.t_array_int
  --
  , p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
)
IS
--
CURSOR source_cur
IS
SELECT      eca.accounting_attribute_code
          , eca.source_application_id
          , eca.source_type_code
          , eca.source_code
          , DECODE(nvl(xes.level_code, 'H'),'H','H','L')
  FROM xla_evt_class_acct_attrs   eca
     , xla_event_sources      xes
     , xla_acct_attributes_b  xasb
     , xla_sources_b   xsb
WHERE  eca.application_id             = p_application_id
   AND eca.event_class_code           = p_event_class
   AND xasb.accounting_attribute_code = eca.accounting_attribute_code
   AND xasb.assignment_level_code     = 'EVT_CLASS_ONLY'
   AND xes.application_id (+)         = p_application_id
   AND xes.entity_code (+)            = p_entity
   AND xes.event_class_code(+)        = p_event_class
   AND xes.source_application_id(+)   = eca.source_application_id
   AND xes.source_type_code(+)        = eca.source_type_code
   AND xes.source_code(+)             = eca.source_code
   AND xasb.journal_entry_level_code  in ('L', 'C')
   AND xes.active_flag(+)             = 'Y'
   AND xsb.application_id             = eca.source_application_id
   AND xsb.source_type_code           = eca.source_type_code
   AND xsb.source_code                = eca.source_code
;
--
l_SourceIdx                      BINARY_INTEGER;
l_accounting_source              xla_cmp_source_pkg.t_array_VL30;
l_accounting_source_type         xla_cmp_source_pkg.t_array_VL1;
l_source_application_id          xla_cmp_source_pkg.t_array_Num;
l_source_type_code               xla_cmp_source_pkg.t_array_VL1;
l_source_code                    xla_cmp_source_pkg.t_array_VL30;
l_number                         NUMBER;
l_log_module                     VARCHAR2(240);
--
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetLineAcctgSources';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetLineAcctgSources'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

l_number  := 0;
--
-- check if the accounting reversal option exists
--
SELECT  count(xes.accounting_attribute_code)
  INTO  l_number
  FROM  xla_evt_class_acct_attrs xes
 WHERE  xes.application_id        =  p_application_id
--   AND  xes.entity_code           =  p_entity
   AND xes.event_class_code       =  p_event_class
--   AND xes.active_flag            = 'Y'
   AND xes.accounting_attribute_code = 'ACCOUNTING_REVERSAL_OPTION'
   ;

IF l_number > 0 THEN
--
OPEN source_cur;
--
IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'SQL - SELECT from xla_event_sources and xla_acctg_sources_b'
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

FETCH source_cur BULK COLLECT INTO l_accounting_source
                                 , l_source_application_id
                                 , l_source_type_code
                                 , l_source_code
                                 , l_accounting_source_type
                                 ;

CLOSE source_cur;

IF l_accounting_source.COUNT > 0 THEN

FOR Idx IN l_accounting_source.FIRST .. l_accounting_source.LAST LOOP

   IF l_source_code.EXISTS(Idx) AND l_source_code(Idx) IS NOT NULL THEN

        l_SourceIdx := xla_cmp_source_pkg.StackSource (
                p_source_code            => l_source_code(Idx)
              , p_source_type_code       => l_source_type_code(Idx)
              , p_source_application_id  => l_source_application_id(Idx)
              , p_array_source_index     => p_array_evt_source_index
              , p_rec_sources            => p_rec_sources
              );

        p_array_line_acctg_source(Idx)      := l_accounting_source(Idx);
        p_array_line_acctg_source_type(Idx) := l_accounting_source_type(Idx);
        p_array_line_acct_attr_source(Idx)  := l_SourceIdx;

    END IF;

END LOOP;
END IF;

END IF;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetLineAcctgSources = '||l_accounting_source.COUNT
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
EXCEPTION
   WHEN xla_exceptions_pkg.application_exception   THEN
        IF source_cur%ISOPEN THEN CLOSE source_cur; END IF;
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
   WHEN OTHERS    THEN
      IF source_cur%ISOPEN THEN CLOSE source_cur; END IF;
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetLineAcctgSources ');
END GetLineAcctgSources;


/*--------------------------------------------------------------------+
|                                                                     |
|  Private procedure                                                  |
|                                                                     |
|    GetSourcesDefinedInHeader                                        |
|                                                                     |
|  Get header sources defined in header description.                  |
|                                                                     |
+--------------------------------------------------------------------*/

PROCEDURE GetSourcesDefinedInHeader(
    p_entity                       IN VARCHAR2
  , p_event_class                  IN VARCHAR2
  , p_event_type                   IN VARCHAR2
  , p_application_id               IN NUMBER
  , p_product_rule_code            IN VARCHAR2
  , p_product_rule_type_code       IN VARCHAR2
  , p_amb_context_code             IN VARCHAR2
  , p_array_evt_source_index       IN OUT NOCOPY xla_cmp_source_pkg.t_array_ByInt
  , p_hdr_description_index        IN OUT NOCOPY BINARY_INTEGER
  , p_rec_aad_objects              IN OUT NOCOPY xla_cmp_source_pkg.t_rec_aad_objects
)
IS
--
l_description_type_code      VARCHAR2(1);
l_description_code           VARCHAR2(30);
l_ObjectIndex                BINARY_INTEGER;
l_log_module                 VARCHAR2(240);

BEGIN

IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetSourcesDefinedInHeader';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetSourcesDefinedInHeader'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

SELECT   xpah.description_code
       , xpah.description_type_code
    INTO l_description_code
       , l_description_type_code
    FROM xla_prod_acct_headers xpah
   WHERE xpah.product_rule_type_code    = p_product_rule_type_code
     AND xpah.product_rule_code         = p_product_rule_code
     AND xpah.entity_code               = p_entity
     AND xpah.event_class_code          = p_event_class
     AND xpah.event_type_code           = p_event_type
     AND xpah.application_id            = p_application_id
     AND xpah.amb_context_code          = p_amb_context_code
     AND xpah.accounting_required_flag  = 'Y'
;

l_ObjectIndex :=xla_cmp_source_pkg.GetAADObjectPosition(
               p_object                   => xla_cmp_source_pkg.C_DESC
             , p_object_code              => l_description_code
             , p_object_type_code         => l_description_type_code
             , p_application_id           => p_application_id
             , p_event_class_code         => NULL
             , p_event_type_code          => NULL
             , p_rec_aad_objects          => p_rec_aad_objects
              );

IF l_ObjectIndex IS NOT NULL THEN

        xla_cmp_source_pkg.GetSourcesInAADObject(
                             p_object              => xla_cmp_source_pkg.C_DESC
                           , p_object_code         => l_description_code
                           , p_object_type_code    => l_description_type_code
                           , p_application_id      => p_application_id
                           , p_event_class_code    => NULL
                           , p_event_type_code     => NULL
                           , p_array_source_Index  => p_array_evt_source_index
                           , p_rec_aad_objects     => p_rec_aad_objects
                          );

END IF;

p_hdr_description_index := l_ObjectIndex;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetSourcesDefinedInHeader = '||p_hdr_description_index
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
EXCEPTION
   WHEN NO_DATA_FOUND THEN
    IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetSourcesDefinedInHeader (no header description)'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
     END IF;
     p_hdr_description_index := NULL;
   WHEN TOO_MANY_ROWS THEN
    IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = two_many_rows '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
     RAISE;
   WHEN xla_exceptions_pkg.application_exception   THEN
       IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
   WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetSourcesDefinedInHeader');
END GetSourcesDefinedInHeader;

/*--------------------------------------------------------------------+
|                                                                     |
|  Private procedure                                                  |
|                                                                     |
|    GetSourcesDefinedInAcctgLine                                     |
|                                                                     |
|  Get header sources defined in Jorunal Line Definitions.            |
|                                                                     |
+--------------------------------------------------------------------*/

PROCEDURE GetSourcesDefinedInAcctgLine (
    p_entity                       IN VARCHAR2
  , p_event_class                  IN VARCHAR2
  , p_event_type                   IN VARCHAR2
  , p_application_id               IN NUMBER
  , p_product_rule_code            IN VARCHAR2
  , p_product_rule_type_code       IN VARCHAR2
  , p_amb_context_code             IN VARCHAR2
  , p_array_evt_source_index       IN OUT NOCOPY xla_cmp_source_pkg.t_array_ByInt
  , p_array_alt_index              IN OUT NOCOPY xla_cmp_source_pkg.t_array_ByInt
  , p_rec_aad_objects              IN OUT NOCOPY xla_cmp_source_pkg.t_rec_aad_objects
)
IS
--
CURSOR alt_cur
IS
 SELECT  DISTINCT
         xldj.accounting_line_code
       , xldj.accounting_line_type_code
       , xldj.line_definition_code
       , xldj.line_definition_owner_code
    FROM xla_aad_line_defn_assgns xald
       , xla_line_defn_jlt_assgns xldj
       , xla_prod_acct_headers    xpah
       , xla_line_definitions_b   xld
   WHERE xldj.line_definition_owner_code = xald.line_definition_owner_code
     AND xldj.line_definition_code       = xald.line_definition_code
     AND xldj.event_class_code           = xald.event_class_code
     AND xldj.event_type_code            = xald.event_type_code
     AND xldj.application_id             = xald.application_id
     AND xldj.amb_context_code           = xald.amb_context_code
     AND xldj.active_flag                = 'Y'
     --
     AND xld.line_definition_owner_code = xald.line_definition_owner_code
     AND xld.line_definition_code       = xald.line_definition_code
     AND xld.event_class_code           = xald.event_class_code
     AND xld.event_type_code            = xald.event_type_code
     AND xld.application_id             = xald.application_id
     AND xld.amb_context_code           = xald.amb_context_code
     AND xld.budgetary_control_flag     = XLA_CMP_PAD_PKG.g_bc_pkg_flag
     --
     AND xald.product_rule_type_code     = xpah.product_rule_type_code
     AND xald.product_rule_code          = xpah.product_rule_code
     AND xald.event_class_code           = xpah.event_class_code
     AND xald.event_type_code            = xpah.event_type_code
     AND xald.application_id             = xpah.application_id
     AND xald.amb_context_code           = xpah.amb_context_code
     --
     AND xpah.product_rule_type_code     = p_product_rule_type_code
     AND xpah.product_rule_code          = p_product_rule_code
     AND xpah.entity_code                = p_entity
     AND xpah.event_class_code           = p_event_class
     AND xpah.event_type_code            = p_event_type
     AND xpah.application_id             = p_application_id
     AND xpah.amb_context_code           = p_amb_context_code
     AND xpah.accounting_required_flag   = 'Y'
ORDER BY xldj.accounting_line_type_code, xldj.accounting_line_code
       , xldj.line_definition_owner_code, xldj.line_definition_code
;
--
l_array_alt_code         xla_cmp_source_pkg.t_array_VL30;
l_array_alt_type_code    xla_cmp_source_pkg.t_array_VL1;
l_array_jld_code         xla_cmp_source_pkg.t_array_VL30;
l_array_jld_owner_code   xla_cmp_source_pkg.t_array_VL1;
l_ObjectIndex            BINARY_INTEGER;
l_log_module             VARCHAR2(240);
invalid_jlt              EXCEPTION;
--
BEGIN
--
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetSourcesDefinedInAcctgLine';
END IF;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN

      trace
         (p_msg      => 'BEGIN of GetSourcesDefinedInAcctgLine'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;
--
OPEN alt_cur;
--
FETCH alt_cur BULK COLLECT INTO l_array_alt_code
                              , l_array_alt_type_code
                              , l_array_jld_code
                              , l_array_jld_owner_code
                              ;

CLOSE alt_cur;

IF l_array_alt_code.COUNT > 0 THEN

FOR Idx IN l_array_alt_code.FIRST .. l_array_alt_code.LAST LOOP

   IF l_array_alt_code.EXISTS(Idx) THEN

       l_ObjectIndex :=xla_cmp_source_pkg.GetAADObjectPosition(
                        p_object                       => xla_cmp_source_pkg.C_ALT
                      , p_object_code                  => l_array_alt_code(Idx)
                      , p_object_type_code             => l_array_alt_type_code(Idx)
                      , p_application_id               => p_application_id
                      , p_line_definition_code         => l_array_jld_code(Idx)
                      , p_line_definition_owner_code   => l_array_jld_owner_code(Idx)
                      , p_event_class_code             => p_event_class
                      , p_event_type_code              => p_event_type
                      , p_rec_aad_objects              => p_rec_aad_objects
                     );

       IF l_ObjectIndex IS NOT NULL THEN

             xla_cmp_source_pkg.GetSourcesInAADObject(
                             p_object                       => xla_cmp_source_pkg.C_ALT
                           , p_object_code                  => l_array_alt_code(Idx)
                           , p_object_type_code             => l_array_alt_type_code(Idx)
                           , p_application_id               => p_application_id
                           , p_line_definition_code         => l_array_jld_code(Idx)
                           , p_line_definition_owner_code   => l_array_jld_owner_code(Idx)
                           , p_event_class_code             => p_event_class
                           , p_event_type_code              => p_event_type
                           , p_array_source_Index           => p_array_evt_source_index
                           , p_rec_aad_objects              => p_rec_aad_objects
                          );

       ELSE

        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = Journal Line Type not cached = '||
                              'JLT ='||l_array_alt_code(Idx)||' - '||l_array_alt_type_code(Idx)||
                              ' - JLD ='||l_array_jld_code(Idx)||' - '||l_array_jld_owner_code(Idx)
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE invalid_jlt;

       END IF;

       p_array_alt_index(Idx) := l_ObjectIndex;

   END IF;

END LOOP;

END IF;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GetSourcesDefinedInAcctgLine = '|| p_array_alt_index.COUNT
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
EXCEPTION
   WHEN invalid_jlt THEN
       IF alt_cur%ISOPEN THEN CLOSE alt_cur; END IF;
       RAISE;
   WHEN xla_exceptions_pkg.application_exception   THEN
        IF alt_cur%ISOPEN THEN CLOSE alt_cur; END IF;
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
   WHEN OTHERS    THEN
      IF alt_cur%ISOPEN THEN CLOSE alt_cur; END IF;
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetSourcesDefinedInAcctgLine');
END GetSourcesDefinedInAcctgLine;

/*--------------------------------------------------------------------+
|                                                                     |
|  Private procedure                                                  |
|                                                                     |
|    CollectHeaderAndLineSources                                      |
|                                                                     |
| Collect header and line sources to extract from the Transaction     |
| Objects                                                             |
|                                                                     |
+--------------------------------------------------------------------*/

PROCEDURE CollectHeaderAndLineSources (
    p_entity                       IN VARCHAR2
  , p_event_class                  IN VARCHAR2
  , p_event_type                   IN VARCHAR2
  , p_application_id               IN NUMBER
  , p_product_rule_code            IN VARCHAR2
  , p_product_rule_type_code       IN VARCHAR2
  , p_amb_context_code             IN VARCHAR2
  , p_array_evt_source_index       IN OUT NOCOPY xla_cmp_source_pkg.t_array_ByInt
  , p_array_hdr_acctg_source       OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
  , p_array_hdr_acctg_source_type  OUT NOCOPY xla_cmp_source_pkg.t_array_VL1
  , p_array_hdr_acct_attr_source   OUT NOCOPY xla_cmp_source_pkg.t_array_int
  , p_array_line_acctg_source      OUT NOCOPY xla_cmp_source_pkg.t_array_VL30
  , p_array_line_acctg_source_type OUT NOCOPY xla_cmp_source_pkg.t_array_VL1
  , p_array_line_acct_attr_source  OUT NOCOPY xla_cmp_source_pkg.t_array_int
  , p_hdr_description_index        IN OUT NOCOPY BINARY_INTEGER
  , p_array_alt_index              IN OUT NOCOPY xla_cmp_source_pkg.t_array_ByInt
  , p_rec_aad_objects              IN OUT NOCOPY xla_cmp_source_pkg.t_rec_aad_objects
  , p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
)
IS

l_Idx            BINARY_INTEGER;
l_log_module     VARCHAR2(240);

BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.CollectHeaderAndLineSources';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of CollectHeaderAndLineSources'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => '# number of sources = '||p_array_evt_source_index.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
      trace
         (p_msg      => 'Get header description sources'
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

GetSourcesDefinedInHeader(
  p_entity                     => p_entity
, p_event_class                => p_event_class
, p_event_type                 => p_event_type
, p_application_id             => p_application_id
, p_product_rule_code          => p_product_rule_code
, p_product_rule_type_code     => p_product_rule_type_code
, p_amb_context_code           => p_amb_context_code
, p_array_evt_source_index     => p_array_evt_source_index
, p_hdr_description_index      => p_hdr_description_index
, p_rec_aad_objects            => p_rec_aad_objects
);

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'Get header accounting attribute sources'
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);

      trace
         (p_msg      => '# number of sources  = '||p_array_evt_source_index.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

GetHeaderAcctgSources (
  p_entity                       => p_entity
, p_event_class                  => p_event_class
, p_event_type                   => p_event_type
, p_application_id               => p_application_id
, p_amb_context_code             => p_amb_context_code
, p_product_rule_code            => p_product_rule_code
, p_product_rule_type_code       => p_product_rule_type_code
, p_array_evt_source_index       => p_array_evt_source_index
, p_array_hdr_acctg_source       => p_array_hdr_acctg_source
, p_array_hdr_acctg_source_type  => p_array_hdr_acctg_source_type
, p_array_hdr_acct_attr_source   => p_array_hdr_acct_attr_source
, p_rec_sources                  => p_rec_sources
)
;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'Get Journal Line Definition sources'
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
      trace
         (p_msg      => '# number of sources  = '||p_array_evt_source_index.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;


xla_cmp_analytic_criteria_pkg.GetAnalyticalCriteriaSources (
  p_entity                     => p_entity
, p_event_class                => p_event_class
, p_event_type                 => p_event_type
, p_application_id             => p_application_id
, p_product_rule_code          => p_product_rule_code
, p_product_rule_type_code     => p_product_rule_type_code
, p_amb_context_code           => p_amb_context_code
, p_array_evt_source_index     => p_array_evt_source_index
, p_rec_sources                => p_rec_sources           );


GetSourcesDefinedInAcctgLine(
  p_entity                      => p_entity
, p_event_class                 => p_event_class
, p_event_type                  => p_event_type
, p_application_id              => p_application_id
, p_product_rule_code           => p_product_rule_code
, p_product_rule_type_code      => p_product_rule_type_code
, p_amb_context_code            => p_amb_context_code
, p_array_evt_source_index      => p_array_evt_source_index
, p_array_alt_index             => p_array_alt_index
, p_rec_aad_objects             => p_rec_aad_objects
);

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
     trace
         (p_msg      => 'Get Reversal Line Accounting Attribute sources'
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
      trace
         (p_msg      => '# number of sources  = '||p_array_evt_source_index.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

GetLineAcctgSources (
  p_entity                       => p_entity
, p_event_class                  => p_event_class
, p_application_id               => p_application_id
, p_array_evt_source_index       => p_array_evt_source_index
, p_array_line_acctg_source      => p_array_line_acctg_source
, p_array_line_acctg_source_type => p_array_line_acctg_source_type
, p_array_line_acct_attr_source  => p_array_line_acct_attr_source
, p_rec_sources                  => p_rec_sources
)
;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => '# of header and line sources = '||p_array_evt_source_index.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of CollectHeaderAndLineSources'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
EXCEPTION
   WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
   WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.CollectHeaderAndLineSources');
END CollectHeaderAndLineSources;

/*-----------------------------------------------------------------------+
|                                                                        |
|  Private function                                                      |
|                                                                        |
|   GenerateHdrDescription                                               |
|                                                                        |
| Generates in EventClass_x()/EventType_x() a call to header description |
|                                                                        |
+-----------------------------------------------------------------------*/

FUNCTION GenerateHdrDescription  (
   p_hdr_description_index    IN BINARY_INTEGER
 , p_rec_aad_objects          IN xla_cmp_source_pkg.t_rec_aad_objects
 , p_rec_sources              IN xla_cmp_source_pkg.t_rec_sources
)
RETURN CLOB
IS

C_CALL_HDR_DESC                    CONSTANT      VARCHAR2(10000):= '
--
xla_ae_header_pkg.SetHdrDescription(
   p_description => Description_$desc_code$ (
   p_application_id => p_application_id $parameters$
   )
);
--
';

l_hdr_desc                         CLOB;
l_log_module                       VARCHAR2(240);
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateHdrDescription';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateHdrDescription'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

l_hdr_desc := NULL;

IF nvl(p_hdr_description_index,0) <> 0  THEN

   l_hdr_desc := C_CALL_HDR_DESC;
   l_hdr_desc := xla_cmp_string_pkg.replace_token(l_hdr_desc,'$desc_code$', TO_CHAR(p_hdr_description_index));  -- 4417664
   l_hdr_desc := xla_cmp_string_pkg.replace_token(l_hdr_desc,'$parameters$',
                 xla_cmp_call_fct_pkg.GetHeaderParameters(
                     p_array_source_index => p_rec_aad_objects.array_array_object(p_hdr_description_index)
                   , p_rec_sources        => p_rec_sources
                  )
                );

END IF;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GenerateHdrDescription'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
RETURN l_hdr_desc;
EXCEPTION
   WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
   WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateHdrDescription');
END  GenerateHdrDescription;

/*-----------------------------------------------------------------------+
|                                                                        |
|  Private function                                                      |
|                                                                        |
|   GenerateHdrAcctgSources                                              |
|                                                                        |
| Generates in EventClass_x()/EventType_x() the set of Header Accounting |
| Attributes.                                                            |
|                                                                        |
+-----------------------------------------------------------------------*/

FUNCTION GenerateHdrAcctgSources (
    p_array_hdr_acctg_source       IN xla_cmp_source_pkg.t_array_VL30
  , p_array_hdr_acctg_source_type  IN xla_cmp_source_pkg.t_array_VL1
  , p_array_hdr_acct_attr_source   IN xla_cmp_source_pkg.t_array_int
  , p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
)
RETURN CLOB
IS
--
C_SET_HDR_ACCT_SOURCES                CONSTANT       VARCHAR2(10000):=
'     l_rec_acct_attrs.array_acct_attr_code($index$)   := ''$accounting_attribute$'';
      l_rec_acct_attrs.array_$datatype$_value($index$) := $source$;
';
--
l_hdr_acctg_sources     CLOB;
l_hdr_acctg_source      VARCHAR2(32000) ;
l_source                VARCHAR2(2000);
l_log_module            VARCHAR2(240);
--
l_index                 NUMBER;
BEGIN
   IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateHdrAcctgSources';
   END IF;
   IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateHdrAcctgSources'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
   END IF;

   l_index              := 0;
   l_hdr_acctg_sources  := C_HDR_ACCT_BODY;   -- 4262811

   IF (C_LEVEL_STATEMENT>= g_log_level) THEN
      trace
         (p_msg      => 'p_array_hdr_acctg_source.count is:'||to_char(p_array_hdr_acctg_source.COUNT)
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
   END IF;

   IF p_array_hdr_acctg_source.COUNT > 0 THEN

      FOR Idx IN p_array_hdr_acctg_source.FIRST .. p_array_hdr_acctg_source.LAST LOOP

         IF p_array_hdr_acctg_source.EXISTS(Idx)      AND
            p_array_hdr_acctg_source_type.EXISTS(Idx) THEN

          --l_index := l_index + 1;  -- 4262811 Move to below to avoid index starting at 2,3,,,

            IF p_array_hdr_acctg_source(Idx) not in ('EXCHANGE_GAIN_CCID', 'EXCHANGE_LOSS_CCID') THEN
              IF p_array_hdr_acctg_source(Idx) <> 'ACCRUAL_REVERSAL_GL_DATE' THEN  -- 4262811
                 l_index := l_index + 1;  -- 4262811

                 l_source := xla_cmp_source_pkg.GenerateSource(
                                                p_Index            => p_array_hdr_acct_attr_source(Idx)
                                              , p_rec_sources      => p_rec_sources
                                              , p_variable         => p_array_hdr_acctg_source_type(Idx)
                                              , p_translated_flag  => 'N') ;

                 l_hdr_acctg_source  := REPLACE(C_SET_HDR_ACCT_SOURCES,'$index$',to_char(l_index));

                 l_hdr_acctg_source  := REPLACE(l_hdr_acctg_source,'$accounting_attribute$', p_array_hdr_acctg_source(Idx));

                 l_hdr_acctg_source  := REPLACE(l_hdr_acctg_source,'$source$', l_source);

                 CASE p_rec_sources.array_datatype_code(p_array_hdr_acct_attr_source(Idx))
                     when 'F' then
                        l_hdr_acctg_source  := REPLACE(l_hdr_acctg_source,'$datatype$','num') ;
                     when 'I' then
                        l_hdr_acctg_source  := REPLACE(l_hdr_acctg_source,'$datatype$','num') ;
                     when 'N' then
                        l_hdr_acctg_source  := REPLACE(l_hdr_acctg_source,'$datatype$','num') ;
                     when 'C' then
                        l_hdr_acctg_source  := REPLACE(l_hdr_acctg_source,'$datatype$','char') ;
                     when 'D' then
                        l_hdr_acctg_source  := REPLACE(l_hdr_acctg_source,'$datatype$','date') ;
                     else
                        l_hdr_acctg_source  := REPLACE(l_hdr_acctg_source,'$datatype$',
                           p_rec_sources.array_datatype_code(p_array_hdr_acct_attr_source(Idx))) ;
                 END CASE;

                 l_hdr_acctg_sources := l_hdr_acctg_sources || l_hdr_acctg_source;

              ELSE  -- 4262811

              -- IF p_rec_sources.array_source_code (Idx) NOT IN ('XLA_NEXT_DAY',
              --                                                  'XLA_FIRST_DAY_NEXT_GL_PERIOD',
              --                                                  'XLA_LAST_DAY_NEXT_GL_PERIOD') OR
                 IF p_rec_sources.array_source_code (p_array_hdr_acct_attr_source(Idx)) NOT IN
                                                                 ('XLA_NEXT_DAY',
                                                                  'XLA_FIRST_DAY_NEXT_GL_PERIOD',
                                                                  'XLA_LAST_DAY_NEXT_GL_PERIOD') AND
                   (p_rec_sources.array_source_type_code (Idx) <> 'Y' OR
                    p_rec_sources.array_application_id (Idx) <> 602) THEN

                    l_source := xla_cmp_source_pkg.GenerateSource(
                                                  p_Index            => p_array_hdr_acct_attr_source(Idx)
                                                , p_rec_sources      => p_rec_sources
                                                , p_variable         => p_array_hdr_acctg_source_type(Idx)
                                                , p_translated_flag  => 'N') ;

                    l_hdr_acctg_sources := xla_cmp_string_pkg.replace_token(l_hdr_acctg_sources,
                                                          '$acc_rev_gl_date_source$', l_source);
                 END IF;

              END IF; -- p_array_hdr_acctg_source(Idx) <> 'ACCRUAL_REVERSAL_GL_DATE'
            END IF;

         END IF;  --  p_array_hdr_acctg_source.EXISTS(Idx)

      END LOOP;

      -------------------------------------------------------------------------------------
      -- 4262811
      -------------------------------------------------------------------------------------
      -- If the acc_rev_gl_date_source token is not replaced, the ACCRUAL_REVERSAL_GL_DATE
      -- attribute is not found.  Then replace the accounting attribute by NULL
      -------------------------------------------------------------------------------------
      l_hdr_acctg_sources := xla_cmp_string_pkg.replace_token(l_hdr_acctg_sources,'$acc_rev_gl_date_source$','NULL');

   END IF;  -- p_array_hdr_acctg_source.COUNT > 0

   IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GenerateHdrAcctgSources'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
   END IF;

   RETURN l_hdr_acctg_sources;

EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG. GenerateHdrAcctgSources');
END GenerateHdrAcctgSources;

/*-----------------------------------------------------------------------+
|                                                                        |
|  Private function                                                      |
|                                                                        |
|   GenerateGainLossAcctSources                                  |
|                                                                        |
| Generates in EventClass_x()/EventType_x() the default gain/loss ccid   |
| calling parameters                                                     |
|                                                                        |
+-----------------------------------------------------------------------*/

FUNCTION GenerateGainLossAcctSources(
    p_array_hdr_acctg_source       IN xla_cmp_source_pkg.t_array_VL30
  , p_array_hdr_acctg_source_type  IN xla_cmp_source_pkg.t_array_VL1
  , p_array_hdr_acct_attr_source   IN xla_cmp_source_pkg.t_array_int
  , p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
)
RETURN CLOB
IS
--
C_CALLING_PARAMS                      CONSTANT       VARCHAR2(10000):='
         ,p_gain_ccid        => $gain_ccid_source$
         ,p_loss_ccid        => $loss_ccid_source$
';
--
l_gain_or_loss_source   VARCHAR2(30000);
l_hdr_acctg_source      VARCHAR2(32000) ;
l_source                VARCHAR2(2000);
l_log_module            VARCHAR2(240);
--
l_index                 NUMBER;
BEGIN
   IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateGainLossAcctSources';
   END IF;
   IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateGainLossAcctSources'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
   END IF;

   l_index               := 0;
   l_gain_or_loss_source := C_CALLING_PARAMS;

   IF (C_LEVEL_STATEMENT>= g_log_level) THEN
      trace
         (p_msg      => 'p_array_hdr_acctg_source.count is:'||to_char(p_array_hdr_acctg_source.COUNT)
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
   END IF;

   IF p_array_hdr_acctg_source.COUNT > 0 THEN
      l_index := 0;

      FOR Idx IN p_array_hdr_acctg_source.FIRST .. p_array_hdr_acctg_source.LAST LOOP
         IF(l_index = 3) THEN
           EXIT;
         END IF;

         IF p_array_hdr_acctg_source.EXISTS(Idx)      AND
            p_array_hdr_acctg_source_type.EXISTS(Idx) THEN

            IF p_array_hdr_acctg_source(Idx) in ('EXCHANGE_GAIN_CCID', 'EXCHANGE_LOSS_CCID') THEN

               l_source := xla_cmp_source_pkg.GenerateSource(
                                                p_Index            => p_array_hdr_acct_attr_source(Idx)
                                              , p_rec_sources      => p_rec_sources
                                              , p_variable         => p_array_hdr_acctg_source_type(Idx)
                                              , p_translated_flag  => 'N') ;

               IF p_array_hdr_acctg_source(Idx) = 'EXCHANGE_GAIN_CCID' THEN
                 l_index := l_index + 1;
                 l_gain_or_loss_source:= REPLACE(l_gain_or_loss_source,'$gain_ccid_source$', l_source);
               ELSE
                 l_index := l_index + 2;
                 l_gain_or_loss_source:= REPLACE(l_gain_or_loss_source,'$loss_ccid_source$', l_source);
               END IF;

            END IF;
         END IF;  --  p_array_hdr_acctg_source.EXISTS(Idx)

      END LOOP;

   END IF;  -- p_array_hdr_acctg_source.COUNT > 0

   IF(l_index <3) THEN
     IF(l_index = 0 ) THEN
       l_gain_or_loss_source:= REPLACE(l_gain_or_loss_source,'$gain_ccid_source$', '-1');
       l_gain_or_loss_source:= REPLACE(l_gain_or_loss_source,'$loss_ccid_source$', '-1');
     ELSIF(l_index = 1 ) THEN
       l_gain_or_loss_source:= REPLACE(l_gain_or_loss_source,'$loss_ccid_source$', '-1');
     ELSE
       l_gain_or_loss_source:= REPLACE(l_gain_or_loss_source,'$gain_ccid_source$', '-1');
     END IF;
   END IF;


   IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GenerateHdrAcctgSources'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
   END IF;

   RETURN l_gain_or_loss_source;

EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateGainLossAcctSources');
END GenerateGainLossAcctSources;

/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GenerateReversalAcctgSources                                 |
|                                                                |
| Generates in EventClass_x()/EventType_x() the set of Reversal  |
| Accounting Attributes.                                         |
|                                                                |
+---------------------------------------------------------------*/

FUNCTION GenerateReversalAcctgSources (
    p_array_line_acctg_source      IN xla_cmp_source_pkg.t_array_VL30
  , p_array_line_acctg_source_type IN xla_cmp_source_pkg.t_array_VL1
  , p_array_line_acct_attr_source  IN xla_cmp_source_pkg.t_array_int
  , p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
)
RETURN CLOB
IS

C_SET_REV_ACCT_SOURCES                CONSTANT       VARCHAR2(10000):=
'      l_rec_rev_acct_attrs.array_acct_attr_code($index$) := ''$accounting_attribute$'';
      l_rec_rev_acct_attrs.array_$datatype$_value($index$)  := $source$;
';

l_line_acctg_sources     CLOB;
l_line_acctg_source      VARCHAR2(32000) ;
l_log_module             VARCHAR2(240);
--
l_index                  NUMBER;
BEGIN

IF g_log_enabled THEN
   l_log_module := C_DEFAULT_MODULE||'.GenerateReversalAcctgSources';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => 'BEGIN of GenerateReversalAcctgSources'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

l_index               := 1;   --5217187
l_line_acctg_sources  := NULL;

FOR Idx IN 1..(p_array_line_acctg_source.COUNT) LOOP

  IF p_array_line_acct_attr_source.EXISTS(Idx) AND
     p_array_line_acct_attr_source(Idx) IS NOT NULL
  THEN
     IF (C_LEVEL_STATEMENT >= g_log_level) THEN
        trace
        (p_msg      => 'accounting attribute = '||p_array_line_acctg_source(Idx)
        ,p_level    => C_LEVEL_STATEMENT
        ,p_module   => l_log_module);
     END IF;

     l_index := l_index + 1;

     l_line_acctg_source  := REPLACE(C_SET_REV_ACCT_SOURCES ,'$accounting_attribute$',
                                       p_array_line_acctg_source(Idx));

     l_line_acctg_source  := REPLACE(l_line_acctg_source , '$source$',
                                xla_cmp_source_pkg.GenerateSource(
                                         p_Index                     => p_array_line_acct_attr_source(Idx)
                                       , p_rec_sources               => p_rec_sources
                                       , p_variable                  => p_array_line_acctg_source_type(Idx)
                                       , p_translated_flag           => 'N')
                                       );
    --
    l_line_acctg_source  := REPLACE(l_line_acctg_source,'$index$',to_char(l_index));

    CASE p_rec_sources.array_datatype_code(p_array_line_acct_attr_source(Idx))
       when 'F' then
          l_line_acctg_source  := REPLACE(l_line_acctg_source,'$datatype$','num') ;
       when 'I' then
          l_line_acctg_source  := REPLACE(l_line_acctg_source,'$datatype$','num') ;
       when 'N' then
          l_line_acctg_source  := REPLACE(l_line_acctg_source,'$datatype$','num') ;
       when 'C' then
          l_line_acctg_source  := REPLACE(l_line_acctg_source,'$datatype$','char') ;
       when 'D' then
          l_line_acctg_source  := REPLACE(l_line_acctg_source,'$datatype$','date') ;
       else
          l_line_acctg_source  := REPLACE(l_line_acctg_source,'$datatype$',
                p_rec_sources.array_datatype_code(p_array_line_acct_attr_source(Idx))) ;
    END CASE;

    l_line_acctg_sources := l_line_acctg_sources || l_line_acctg_source;

  END IF;
END LOOP;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => 'END of GenerateReversalAcctgSources'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;
RETURN l_line_acctg_sources;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG. GenerateReversalAcctgSources');
END GenerateReversalAcctgSources;

/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GenerateAcctLinetypes                                        |
|                                                                |
| Generates in EventClass_x()/EventType_x() the calls to Journal |
| Line Types procedures/ AcctLineType_xxx()                      |
|                                                                |
+---------------------------------------------------------------*/

FUNCTION GenerateAcctLinetypes  (
   p_array_alt_index          IN xla_cmp_source_pkg.t_array_ByInt
 , p_array_evt_source_Level   IN xla_cmp_source_pkg.t_array_VL1
 , p_rec_aad_objects          IN xla_cmp_source_pkg.t_rec_aad_objects
 , p_rec_sources              IN xla_cmp_source_pkg.t_rec_sources
)
RETURN CLOB
IS

C_ALT_PROC                    CONSTANT      VARCHAR2(10000):= '
--
AcctLineType_$alt_code$ (
 p_application_id  => p_application_id
 ,p_event_id     => l_event_id
 ,p_calculate_acctd_flag => l_calculate_acctd_flag
 ,p_calculate_g_l_flag => l_calculate_g_l_flag
 ,p_actual_flag => l_actual_flag
 ,p_balance_type_code => l_balance_type_code
 ,p_gain_or_loss_ref=> l_gain_or_loss_ref
 $parameters$
 );
If(l_balance_type_code = ''A'') THEN
  l_actual_gain_loss_ref := l_gain_or_loss_ref;
END IF;

--
';

l_alts                         CLOB;
l_alt                          CLOB;
l_log_module                   VARCHAR2(240);
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateAcctLinetypes';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateAcctLinetypes'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;

l_alts := ' l_actual_flag := NULL;  l_actual_gain_loss_ref := ''#####'';';
l_alt  := NULL;

IF p_array_alt_index.COUNT > 0 THEN

FOR Idx IN p_array_alt_index.FIRST .. p_array_alt_index.LAST LOOP

  IF p_array_alt_index.EXISTS(Idx) THEN

     l_alt  := C_ALT_PROC ;
     l_alt  := xla_cmp_string_pkg.replace_token(l_alt ,'$alt_code$', TO_CHAR( p_array_alt_index(Idx) ));  -- 4417664

     l_alt  := xla_cmp_string_pkg.replace_token (l_alt ,'$parameters$'
                ,xla_cmp_call_fct_pkg.GetLineParameters(
                    p_array_source_index   => p_rec_aad_objects.array_array_object(p_array_alt_index(Idx))
                  , p_array_source_level   => p_array_evt_source_Level
                  , p_rec_sources          => p_rec_sources)
                );
     l_alts := l_alts || g_chr_newline|| l_alt;

  END IF;

END LOOP;

END IF;

IF l_alts IS NULL THEN l_alts:=' null;';END IF;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GenerateAcctLinetypes'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
RETURN l_alts;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateAcctLinetypes ');
END GenerateAcctLinetypes;



/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GenerateAccRevBody                                           |
|                                                                |
|   4262811 -                                                    |
|   Retrieve the source of the accrual reversal GL date          |
|   accounting attribute.                                        |
|                                                                |
|   4884853 - add logic to get array_gl_date for accrual reversal|
|                                                                |
+---------------------------------------------------------------*/
FUNCTION GenerateAccRevBody (
    p_array_hdr_acctg_source       IN xla_cmp_source_pkg.t_array_VL30
  , p_array_hdr_acct_attr_source   IN xla_cmp_source_pkg.t_array_int  -- (to generate ACCRUAL_REVERSAL_GL_DATE)
  , p_rec_sources                  IN xla_cmp_source_pkg.t_rec_sources
)
RETURN CLOB
IS

l_body               CLOB;
l_log_module         VARCHAR2(240);

l_AccRevGlDateIdx    NUMBER;
l_source_code         VARCHAR2(30);
l_source_type_code    VARCHAR2(1);

BEGIN

IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateAccRevBody';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateAccRevBody'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

l_body := NULL;
l_AccRevGlDateIdx  := IsOptionFlagInEventExtract(
                      p_source_option         => 'ACCRUAL_REVERSAL_GL_DATE' -- value in this attr indicates to reverse
                    , p_array_source_code     => p_array_hdr_acctg_source);


IF (l_AccRevGlDateIdx IS NULL) THEN
  l_body := '
  -----------------------------------------------
  -- No accrual reversal for the event class/type
  -----------------------------------------------';
ELSE

   l_body := C_ACC_REV_BODY;
-- l_source_type_code := p_rec_sources.array_source_type_code(l_AccRevGlDateIdx);
-- l_source_code      := p_rec_sources.array_source_code(l_AccRevGlDateIdx);
   l_source_type_code := p_rec_sources.array_source_type_code(p_array_hdr_acct_attr_source(l_AccRevGlDateIdx));
   l_source_code      := p_rec_sources.array_source_code     (p_array_hdr_acct_attr_source(l_AccRevGlDateIdx));

   IF (l_source_type_code = 'Y' and l_source_code = 'XLA_NEXT_DAY') THEN
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$if_cond$','');
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$end_if$', '');
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$accrual_reversal_body2$'
              ,'
              ---------------------- XLA_NEXT_DAY ----------------------
              XLA_AE_HEADER_PKG.g_rec_header_new.array_acc_rev_gl_date_option(g_last_hdr_idx) := ''XLA_NEXT_DAY'';
              XLA_AE_HEADER_PKG.GetAccrualRevDate(g_last_hdr_idx
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_target_ledger_id(g_last_hdr_idx)
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_gl_date(hdr_idx)
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_acc_rev_gl_date_option(g_last_hdr_idx));
              ');
   ELSIF (l_source_type_code = 'Y' and l_source_code = 'XLA_FIRST_DAY_NEXT_GL_PERIOD') THEN
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$if_cond$','');
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$accrual_reversal_body2$'
              ,'
              ---------------------- XLA_FIRST_DAY_NEXT_GL_PERIOD ----------------------
              XLA_AE_HEADER_PKG.g_rec_header_new.array_acc_rev_gl_date_option(g_last_hdr_idx) := ''XLA_FIRST_DAY_NEXT_GL_PERIOD'';
              XLA_AE_HEADER_PKG.GetAccrualRevDate(g_last_hdr_idx
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_target_ledger_id(g_last_hdr_idx)
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_gl_date(hdr_idx)
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_acc_rev_gl_date_option(g_last_hdr_idx));
              ');
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$end_if$', '');

   ELSIF (l_source_type_code = 'Y' and l_source_code = 'XLA_LAST_DAY_NEXT_GL_PERIOD') THEN
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$if_cond$','');
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$accrual_reversal_body2$'
              ,'
              ---------------------- XLA_LAST_DAY_NEXT_GL_PERIOD ----------------------
              XLA_AE_HEADER_PKG.g_rec_header_new.array_acc_rev_gl_date_option(g_last_hdr_idx) := ''XLA_LAST_DAY_NEXT_GL_PERIOD'';
              XLA_AE_HEADER_PKG.GetAccrualRevDate(g_last_hdr_idx
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_target_ledger_id(g_last_hdr_idx)
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_gl_date(hdr_idx)
                                       ,XLA_AE_HEADER_PKG.g_rec_header_new.array_acc_rev_gl_date_option(g_last_hdr_idx));
              ');
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$end_if$', '');

   ELSE
       l_body := xla_cmp_string_pkg.replace_token (l_body ,'$if_cond$' ,'IF l_acc_rev_gl_date_source IS NOT NULL THEN ');
       l_body := xla_cmp_string_pkg.replace_token (l_body,'$accrual_reversal_body2$'
              ,'
              ---------------------- NONE - Standard Source  ----------------------
              IF l_acc_rev_gl_date_source < XLA_AE_HEADER_PKG.g_rec_header_new.array_gl_date(hdr_idx) THEN
                 xla_accounting_err_pkg.build_message
                           (p_appli_s_name            => ''XLA''
                           ,p_msg_name                => ''XLA_MA_INVALID_GL_DATE''
                           ,p_token_1                 => ''ACCRUAL_REVERSAL_DATE''
                           ,p_value_1                 => l_acc_rev_gl_date_source
                           ,p_token_2                 => ''ACCRUAL_GL_DATE''    -- 4262811
                           ,p_value_2                 => XLA_AE_HEADER_PKG.g_rec_header_new.array_gl_date(hdr_idx)
                           ,p_entity_id               => xla_ae_journal_entry_pkg.g_cache_event.entity_id
                           ,p_event_id                => xla_ae_journal_entry_pkg.g_cache_event.event_id
                           ,p_ledger_id               => xla_ae_journal_entry_pkg.g_cache_event.target_ledger_id
                          );
              END IF;
              XLA_AE_HEADER_PKG.g_rec_header_new.array_acc_rev_gl_date_option(g_last_hdr_idx) := ''NONE'';
              XLA_AE_HEADER_PKG.g_rec_header_new.array_gl_date(g_last_hdr_idx) := trunc(l_acc_rev_gl_date_source);
              ');
       l_body := xla_cmp_string_pkg.replace_token (l_body ,'$end_if$' , 'END IF;');

   END IF;
END IF;
RETURN l_body;

EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateAccRevBody ');
END GenerateAccRevBody;


/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GenerateProcedureBody                                        |
|                                                                |
| Generates EventClass_x()/EventType_x() body function           |
|                                                                |
+---------------------------------------------------------------*/

FUNCTION GenerateProcedureBody  (
  p_application_id               IN NUMBER
, p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_amb_context_code             IN VARCHAR2
, p_entity                       IN VARCHAR2
, p_event_class                  IN VARCHAR2
, p_event_type                   IN VARCHAR2

, p_hdr_description_index        IN BINARY_INTEGER
, p_array_alt_index              IN xla_cmp_source_pkg.t_array_ByInt
, p_array_evt_source_Level       IN xla_cmp_source_pkg.t_array_VL1

, p_array_hdr_acctg_source       IN xla_cmp_source_pkg.t_array_VL30
, p_array_hdr_acctg_source_type  IN xla_cmp_source_pkg.t_array_VL1
, p_array_hdr_acct_attr_source   IN xla_cmp_source_pkg.t_array_int
, p_array_line_acctg_source      IN xla_cmp_source_pkg.t_array_VL30
, p_array_line_acctg_source_type IN xla_cmp_source_pkg.t_array_VL1
, p_array_line_acct_attr_source  IN xla_cmp_source_pkg.t_array_int

, p_array_table_name             IN xla_cmp_source_pkg.t_array_VL30
, p_array_table_type             IN xla_cmp_source_pkg.t_array_VL30
, p_array_table_hash             IN xla_cmp_source_pkg.t_array_VL30
, p_array_populated_flag         IN xla_cmp_source_pkg.t_array_VL1

, p_array_h_source_index         IN xla_cmp_source_pkg.t_array_ByInt
, p_array_h_table_index          IN xla_cmp_source_pkg.t_array_ByInt

, p_array_h_mls_source_index     IN xla_cmp_source_pkg.t_array_ByInt
, p_array_h_mls_table_index      IN xla_cmp_source_pkg.t_array_ByInt

, p_array_l_source_index         IN xla_cmp_source_pkg.t_array_ByInt
, p_array_l_table_index          IN xla_cmp_source_pkg.t_array_ByInt

, p_array_l_mls_source_index     IN xla_cmp_source_pkg.t_array_ByInt
, p_array_l_mls_table_index      IN xla_cmp_source_pkg.t_array_ByInt

, p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
, p_rec_aad_objects              IN xla_cmp_source_pkg.t_rec_aad_objects
)
RETURN CLOB
IS

l_body                         CLOB;
l_ThirdPartyIdx                NUMBER;
l_AcctReversalIdx              NUMBER;
l_TrxReversalIdx               NUMBER;
l_count                        INTEGER;
l_log_module                   VARCHAR2(240);

BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateProcedureBody';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateProcedureBody'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
      trace
         (p_msg      => 'event class:'||p_event_class
                      ||', event type:'||p_event_type
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;

GetIndexOfOptionFlags(
  p_array_hdr_acctg_source            => p_array_hdr_acctg_source
, p_array_hdr_acct_attr_source        => p_array_hdr_acct_attr_source
, p_array_line_acctg_source           => p_array_line_acctg_source
, p_array_line_acct_attr_source       => p_array_line_acct_attr_source
, p_ThirdPartyIdx                     => l_ThirdPartyIdx
, p_AcctReversalIdx                   => l_AcctReversalIdx
, p_TrxReversalIdx                    => l_TrxReversalIdx);

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
   trace
      (p_msg      => 'l_ThirdPartyIdx = '||l_ThirdPartyIdx
                   ||', l_AcctReversalIdx = '||l_AcctReversalIdx
                   ||', l_TrxReversalIdx = '||l_TrxReversalIdx
      ,p_level    => C_LEVEL_STATEMENT
      ,p_module   => l_log_module);
END IF;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
   l_count := p_array_h_source_index.COUNT + p_array_h_mls_source_index.COUNT;
   trace
      (p_msg      => 'generate = '||l_count
      ,p_level    => C_LEVEL_STATEMENT
      ,p_module   => l_log_module);
END IF;

l_body := C_EVENT_BODY;

--bug 4492149
--IF (p_array_h_source_index.COUNT + p_array_h_mls_source_index.COUNT > 0) THEN

   IF l_ThirdPartyIdx IS NOT NULL AND
      p_array_hdr_acct_attr_source.EXISTS(l_ThirdPartyIdx) AND
      p_array_hdr_acct_attr_source(l_ThirdPartyIdx) IS NOT NULL THEN
      --
      -- Change third party process
      --
      l_body := xla_cmp_string_pkg.replace_token
                   (l_body,'$third_party_code$', C_THIRD_PARTY_CHANGE_BODY);

      l_body := xla_cmp_string_pkg.replace_token(l_body
                 ,'$third_party_change$'
                 , xla_cmp_source_pkg.GenerateSource(
                           p_Index            => p_array_hdr_acct_attr_source(l_ThirdPartyIdx)
                         , p_rec_sources      => p_rec_sources
                         , p_variable         => p_array_hdr_acctg_source_type(l_ThirdPartyIdx)
                         , p_translated_flag  => 'N'
                         ));
   ELSE
      l_body := xla_cmp_string_pkg.replace_token(l_body   -- 4417664
                       ,'$third_party_code$'
                       ,'-- No Third Party Code generated');
   END IF;


   IF l_TrxReversalIdx IS NOT NULL AND
      p_array_hdr_acct_attr_source.EXISTS(l_TrxReversalIdx) AND
      p_array_hdr_acct_attr_source(l_TrxReversalIdx) IS NOT NULL
   THEN
      l_body := xla_cmp_string_pkg.replace_token
                   (l_body,'$trx_reversal_source$'
                   ,xla_cmp_source_pkg.GenerateSource(
                        p_Index             => p_array_hdr_acct_attr_source(l_TrxReversalIdx)
                       ,p_rec_sources       => p_rec_sources
                       ,p_variable          => p_array_hdr_acctg_source_type(l_TrxReversalIdx)
                       ,p_translated_flag   => 'N')
                   );

   ELSE
      l_body := xla_cmp_string_pkg.replace_token(l_body,'$trx_reversal_source$','NULL');  -- 4417664
   END IF;

   IF (C_LEVEL_STATEMENT >= g_log_level) THEN
        trace
           (p_msg      => '-> CALL xla_cmp_extract_pkg.GenerateFetchHeaderCursor API'
           ,p_level    => C_LEVEL_STATEMENT
           ,p_module   => l_log_module);
   END IF;
   --
   -- generate 'Open header cursor'
   --
    l_body := xla_cmp_string_pkg.replace_token
               (l_body
               ,'$header_var$'
               ,xla_cmp_extract_pkg.GenerateFetchHeaderCursor
                   (p_array_h_source_index       =>  p_array_h_source_index
                   ,p_array_h_mls_source_index   =>  p_array_h_mls_source_index
                   ,p_array_lookup_type          =>  p_rec_sources.array_lookup_type
                   ,p_array_view_application_id  =>  p_rec_sources.array_view_application_id)
               );

  --
  -- generate the code to cache header sources
  l_body := xla_cmp_string_pkg.replace_token
               (l_body
               ,'$cache_header_sources$'
               ,xla_cmp_extract_pkg.GenerateCacheHdrSources
                   (p_array_h_source_index       =>  p_array_h_source_index
                   ,p_array_h_mls_source_index   =>  p_array_h_mls_source_index
                   ,p_array_lookup_type          =>  p_rec_sources.array_lookup_type
                   ,p_array_view_application_id  =>  p_rec_sources.array_view_application_id
                   ,p_array_datatype_code        =>  p_rec_sources.array_datatype_code)
               );

   -- generate 'header accounting sources'
   --
   l_body := xla_cmp_string_pkg.replace_token
                (l_body
                ,'$hdr_accounting_attributes$'
                ,REPLACE(GenerateHdrAcctgSources
	        (p_array_hdr_acctg_source       => p_array_hdr_acctg_source
                    ,p_array_hdr_acctg_source_type  => p_array_hdr_acctg_source_type
                    ,p_array_hdr_acct_attr_source   => p_array_hdr_acct_attr_source
                    ,p_rec_sources                  => p_rec_sources), '(Idx)', '(hdr_idx)')
                ); --7046458 Replaced Idx with hdr_idx.

   -------------------------------------------------------------------
   -- 4262811 Generate Accrual Reversal
   -------------------------------------------------------------------
   l_body := xla_cmp_string_pkg.replace_token
                (l_body
                ,'$accrual_reversal_body$'
                ,GenerateAccRevBody(
                     p_array_hdr_acctg_source      => p_array_hdr_acctg_source
                    ,p_array_hdr_acct_attr_source  => p_array_hdr_acct_attr_source
                    ,p_rec_sources                 => p_rec_sources
                        ));
   --
   -- generate 'header Description'
   --
   l_body := xla_cmp_string_pkg.replace_token
                (l_body
                ,'$call_header_description$'
                , GenerateHdrDescription  (
                     p_hdr_description_index    => p_hdr_description_index
                   , p_rec_aad_objects          => p_rec_aad_objects
                   , p_rec_sources              => p_rec_sources
                    )
                );

   --
   -- generate  'header Analytical criteria'
   --
   IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => '-> CALL xla_cmp_analytic_criteria_pkg.GenerateHdrAnalyticCriteria API'
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
   END IF;

   l_body := xla_cmp_string_pkg.replace_token
                (l_body
                ,'$call_hdr_analytic_criteria$'
                ,xla_cmp_analytic_criteria_pkg.GenerateHdrAnalyticCriteria
                   (p_application_id               => p_application_id
                   ,p_product_rule_code            => p_product_rule_code
                   ,p_product_rule_type_code       => p_product_rule_type_code
                   ,p_amb_context_code             => p_amb_context_code
                   ,p_entity                       => p_entity
                   ,p_event_class                  => p_event_class
                   ,p_event_type                   => p_event_type
                   ,p_rec_sources                  => p_rec_sources)
                 );

--END IF;

--bug 4492149
--IF (p_array_l_source_index.COUNT +  p_array_l_mls_source_index.COUNT > 0 ) THEN
    l_body  := xla_cmp_string_pkg.replace_token
                  (l_body
                  ,'$lines_body$'
                  ,C_BODY_LINES);

    l_body := xla_cmp_string_pkg.replace_token
                 (l_body
                 ,'$gain_loss_account_params$'
                 ,GenerateGainLossAcctSources
                    (p_array_hdr_acctg_source       => p_array_hdr_acctg_source
                    ,p_array_hdr_acctg_source_type  => p_array_hdr_acctg_source_type
                    ,p_array_hdr_acct_attr_source   => p_array_hdr_acct_attr_source
                    ,p_rec_sources                  => p_rec_sources)
                 );

    IF (C_LEVEL_STATEMENT >= g_log_level) THEN
       trace
          (p_msg      => '-> CALL xla_cmp_extract_pkg.GenerateFetchLineCursor API'
          ,p_level    => C_LEVEL_STATEMENT
          ,p_module   => l_log_module);
    END IF;
    --
    -- Generate 'Open Line cursor'
    --
    l_body := xla_cmp_string_pkg.replace_token
                 (l_body
                 ,'$line_var$'
                 ,xla_cmp_extract_pkg.GenerateFetchLineCursor
                     (p_array_l_source_index        => p_array_l_source_index
                     ,p_array_l_mls_source_index    => p_array_l_mls_source_index
                     ,p_array_source_code           => p_rec_sources.array_source_code
                     ,p_array_lookup_type           => p_rec_sources.array_lookup_type
                     ,p_array_view_application_id   => p_rec_sources.array_view_application_id)
                  );
    --
    -- generate 'Accounting line type procedures'
    --
    l_body := xla_cmp_string_pkg.replace_token
                 (l_body
                 ,'$call_alts$'
                 ,  GenerateAcctLinetypes  (
                     p_array_alt_index          => p_array_alt_index
                   , p_array_evt_source_Level   => p_array_evt_source_Level
                   , p_rec_aad_objects          => p_rec_aad_objects
                   , p_rec_sources              => p_rec_sources
                   )
                 );
    --
    -- replace amb_context_code
    --
    l_body := xla_cmp_string_pkg.replace_token
                 (l_body
                 ,'$amb_context_code$'
                 ,  p_amb_context_code
                 );
    --
    -- generate line level reversal code
    --

    IF l_AcctReversalIdx IS NOT NULL OR
       p_array_line_acct_attr_source.EXISTS(l_AcctReversalIdx) AND
       p_array_line_acct_attr_source(l_AcctReversalIdx) IS NOT NULL
    THEN
       l_body := xla_cmp_string_pkg.replace_token      -- 4417664
                   (l_body,'$acct_reversal_source$'
                   , xla_cmp_source_pkg.GenerateSource
                       (p_Index            => p_array_line_acct_attr_source(l_AcctReversalIdx)
                       ,p_rec_sources      => p_rec_sources
                       ,p_variable         => p_array_line_acctG_source_type(l_AcctReversalIdx)
                       ,p_translated_flag  => 'N')
                   );


       l_body := xla_cmp_string_pkg.replace_token
                    (l_body,'$acct_reversal_code$'
                       ,GenerateReversalAcctgSources
                        (p_array_line_acctg_source      => p_array_line_acctg_source
                        ,p_array_line_acctg_source_type => p_array_line_acctg_source_type
                        ,p_array_line_acct_attr_source  => p_array_line_acct_attr_source
                        ,p_rec_sources                  => p_rec_sources)
                    );
    ELSE
       l_body := xla_cmp_string_pkg.replace_token(l_body,'$acct_reversal_source$','NULL');  -- 4417664
       l_body := xla_cmp_string_pkg.replace_token(l_body,'$acct_reversal_code$','      -- No reversal code generated');  -- 4417664
    END IF;


--END IF;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GenerateProcedureBody'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
      trace
         (p_msg      => 'l_body:'||to_char(length(l_body))
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
RETURN l_body;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateProcedureBody ');
END GenerateProcedureBody;

/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   PopulateBCObjectNames                                         |
|                                                                |
| Generates Event_$Index$() function                             |
|                                                                |
+---------------------------------------------------------------*/

PROCEDURE PopulateBCObjectNames(
p_array_table_name     IN OUT NOCOPY xla_cmp_source_pkg.t_array_VL30,
p_array_join_condition IN OUT NOCOPY xla_cmp_source_pkg.t_array_VL2000
)
IS
l_log_module                    VARCHAR2(240);
BEGIN

IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.PopulateBCObjectNames';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of PopulateBCObjectNames'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

For idx in 1..p_array_table_name.COUNT loop
  IF p_array_table_name(idx) = 'AP_INVOICE_EXTRACT_DETAILS_V' THEN
    P_array_table_name(idx) := 'AP_EXTRACT_INVOICE_DTLS_BC_V';
  ELSIF p_array_table_name(idx) = 'AP_PREPAYAPP_EXTRACT_DETAILS_V' THEN
    P_array_table_name(idx) := 'AP_PREPAYAPP_EXTRACT_DTLS_BC_V';
  END IF;
End loop;

For idx in 1..p_array_join_condition.COUNT loop
  p_array_join_condition(idx) := replace(p_array_join_condition(idx)
                                        ,'AP_INVOICE_EXTRACT_DETAILS_V'
                                        ,'AP_EXTRACT_INVOICE_DTLS_BC_V');
  p_array_join_condition(idx) := replace(p_array_join_condition(idx)
                                        ,'AP_PREPAYAPP_EXTRACT_DETAILS_V'
                                        ,'AP_PREPAYAPP_EXTRACT_DTLS_BC_V');
End loop;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of PopulateBCObjectNames'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
EXCEPTION
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.PopulateBCObjectNames ');
END PopulateBCObjectNames;



/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GenerateOneProcedure                                         |
|                                                                |
| Generates Event_$Index$() function                             |
|                                                                |
+---------------------------------------------------------------*/

FUNCTION GenerateOneProcedure  (
  p_application_id               IN NUMBER
, p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_amb_context_code             IN VARCHAR2
, p_entity                       IN VARCHAR2
, p_event_class                  IN VARCHAR2
, p_event_type                   IN VARCHAR2
--
, p_hdr_description_index        IN BINARY_INTEGER
, p_array_alt_index              IN xla_cmp_source_pkg.t_array_ByInt
, p_array_evt_source_Level       IN xla_cmp_source_pkg.t_array_VL1
--
, p_array_hdr_acctg_source       IN xla_cmp_source_pkg.t_array_VL30
, p_array_hdr_acctg_source_type  IN xla_cmp_source_pkg.t_array_VL1
, p_array_hdr_acct_attr_source   IN xla_cmp_source_pkg.t_array_int
, p_array_line_acctg_source      IN xla_cmp_source_pkg.t_array_VL30
, p_array_line_acctg_source_type IN xla_cmp_source_pkg.t_array_VL1
, p_array_line_acct_attr_source  IN xla_cmp_source_pkg.t_array_int
--
, p_array_table_name             IN xla_cmp_source_pkg.t_array_VL30
, p_array_parent_table_index           IN xla_cmp_source_pkg.t_array_ByInt
, p_array_table_type             IN xla_cmp_source_pkg.t_array_VL30
, p_array_table_hash             IN xla_cmp_source_pkg.t_array_VL30
, p_array_populated_flag         IN xla_cmp_source_pkg.t_array_VL1
--
, p_array_ref_obj_flag           IN xla_cmp_source_pkg.t_array_VL1
, p_array_join_condition         IN xla_cmp_source_pkg.t_array_VL2000
--
, p_array_h_source_index         IN xla_cmp_source_pkg.t_array_ByInt
, p_array_h_table_index          IN xla_cmp_source_pkg.t_array_ByInt
--
, p_array_h_mls_source_index     IN xla_cmp_source_pkg.t_array_ByInt
, p_array_h_mls_table_index      IN xla_cmp_source_pkg.t_array_ByInt
--
, p_array_l_source_index         IN xla_cmp_source_pkg.t_array_ByInt
, p_array_l_table_index          IN xla_cmp_source_pkg.t_array_ByInt
--
, p_array_l_mls_source_index     IN xla_cmp_source_pkg.t_array_ByInt
, p_array_l_mls_table_index      IN xla_cmp_source_pkg.t_array_ByInt
--
, p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
, p_rec_aad_objects              IN xla_cmp_source_pkg.t_rec_aad_objects
--
, p_extract_status               IN BOOLEAN
, p_procedure                    IN VARCHAR2
)
RETURN CLOB
IS
l_event                         CLOB;
l_log_module                    VARCHAR2(240);
BEGIN

IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateOneProcedure';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateOneProcedure'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

l_event     := C_EVENT_TYPE_PROC;

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'p_extract_status = '||
           CASE WHEN p_extract_status THEN 'TRUE' ELSE 'FALSE' END
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

IF NOT p_extract_status THEN

   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$header_types$',  ' ');  -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$line_types$',  ' ');  -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$header_variables$'  ,  ' ');  -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$line_variables$'   ,  ' ');  -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$header_cursor$',  ' ');  -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$line_cursor$'  ,  ' ');  -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$close_header_cursor$', ' ' );  -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$close_line_cursor$',  ' ' );  -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$event_body$'   ,  'NULL;');  -- 4417664

   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$no_data_exception$', ' ' );  -- 4417664

ELSE

   l_event     := xla_cmp_string_pkg.replace_token
                     (l_event
                     ,'$event_body$'
                     ,GenerateProcedureBody
                         (p_application_id               => p_application_id
                         ,p_product_rule_code            => p_product_rule_code
                         ,p_product_rule_type_code       => p_product_rule_type_code
                         ,p_amb_context_code             => p_amb_context_code
                         ,p_entity                       => p_entity
                         ,p_event_class                  => p_event_class
                         ,p_event_type                   => p_event_type
                         --
                         ,p_hdr_description_index        => p_hdr_description_index
                         ,p_array_alt_index              => p_array_alt_index
                        , p_array_evt_source_Level       => p_array_evt_source_Level
                         --
                         ,p_array_hdr_acctg_source       => p_array_hdr_acctg_source
                         ,p_array_hdr_acctg_source_type  => p_array_hdr_acctg_source_type
                         ,p_array_hdr_acct_attr_source   => p_array_hdr_acct_attr_source
                         ,p_array_line_acctg_source      => p_array_line_acctg_source
                         ,p_array_line_acctg_source_type => p_array_line_acctg_source_type
                         ,p_array_line_acct_attr_source  => p_array_line_acct_attr_source
                         --
                         ,p_array_table_name             => p_array_table_name
                         ,p_array_table_type             => p_array_table_type
                         ,p_array_table_hash             => p_array_table_hash
                         ,p_array_populated_flag         => p_array_populated_flag
                         --
                         ,p_array_h_source_index         => p_array_h_source_index
                         ,p_array_h_table_index          => p_array_h_table_index
                         --
                         ,p_array_h_mls_source_index     => p_array_h_mls_source_index
                         ,p_array_h_mls_table_index      => p_array_h_mls_table_index
                         --
                         ,p_array_l_source_index         => p_array_l_source_index
                         ,p_array_l_table_index          => p_array_l_table_index
                         --
                         ,p_array_l_mls_source_index     => p_array_l_mls_source_index
                         ,p_array_l_mls_table_index      => p_array_l_mls_table_index
                         --
                         ,p_rec_sources                  => p_rec_sources
                         ,p_rec_aad_objects              => p_rec_aad_objects)
                     );

  IF (C_LEVEL_PROCEDURE >= g_log_level) THEN

      trace
         (p_msg      => 'after generateprocedurebody length of l_event:'||to_char(length(l_event))
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

  END IF;

  IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'COUNT: p_array_h_source_index = '||p_array_h_source_index.COUNT
                      ||', p_array_h_mls_source_index = '||p_array_h_mls_source_index.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
  END IF;

  -- generate the declaration of header variables and header cursor
  --
   /*  --4492149
    IF (p_array_h_source_index.COUNT +  p_array_h_mls_source_index.COUNT > 0
     ) THEN
    */
     --
     -- generate array strucnture definitions for header sources
     --
     l_event     :=
        xla_cmp_string_pkg.replace_token
           (l_event, '$header_types$'
           ,xla_cmp_extract_pkg.GenerateHdrStructure
              (p_array_table_name             => p_array_table_name
              ,p_array_source_code            => p_rec_sources.array_source_code
              ,p_array_h_source_index         => p_array_h_source_index
              ,p_array_h_table_index          => p_array_h_table_index
              ,p_array_h_mls_source_index     => p_array_h_mls_source_index
              ,p_array_h_mls_table_index      => p_array_h_mls_table_index)
           );

      IF (C_LEVEL_STATEMENT >= g_log_level) THEN
          trace
             (p_msg      => 'after GenerateHdrStructure length of l_event = '||to_char(length(l_event))
             ,p_level    => C_LEVEL_PROCEDURE
             ,p_module   => l_log_module);
      END IF;
     --
     -- generate the declaration of header variables
     --
     l_event     :=
        xla_cmp_string_pkg.replace_token
           (l_event, '$header_variables$'
           ,xla_cmp_extract_pkg.GenerateHdrVariables
               (p_array_h_source_index         => p_array_h_source_index
               ,p_array_h_mls_source_index     => p_array_h_mls_source_index
               ,p_array_source_code            => p_rec_sources.array_source_code
               ,p_array_lookup_type            => p_rec_sources.array_lookup_type
               ,p_array_view_application_id    => p_rec_sources.array_view_application_id)
            );

      IF (C_LEVEL_STATEMENT >= g_log_level) THEN
          trace
             (p_msg      => 'after GenerateHdrVariables length of l_event = '||to_char(length(l_event))
             ,p_level    => C_LEVEL_PROCEDURE
             ,p_module   => l_log_module);
      END IF;

     --
     -- generate the header cursor
     --
     l_event     := xla_cmp_string_pkg.replace_token
                       (l_event
                       ,'$header_cursor$'
                       ,XLA_cmp_extract_pkg.GenerateHeaderCursor
                           (p_array_table_name           => p_array_table_name
                           ,p_array_parent_table_index         => p_array_parent_table_index
                           ,p_array_table_hash           => p_array_table_hash
                           ,p_array_populated_flag       => p_array_populated_flag
                           ,p_array_ref_obj_flag         => p_array_ref_obj_flag
                           ,p_array_join_condition       => p_array_join_condition
                           ,p_array_h_source_index       => p_array_h_source_index
                           ,p_array_h_table_index        => p_array_h_table_index
                           ,p_array_h_mls_source_index   => p_array_h_mls_source_index
                           ,p_array_h_mls_table_index    => p_array_h_mls_table_index
                           ,p_array_source_code          => p_rec_sources.array_source_code
                           ,p_array_lookup_type          => p_rec_sources.array_lookup_type
                           ,p_array_view_application_id  => p_rec_sources.array_view_application_id
                           ,p_procedure                  => p_procedure)
                       );

     IF (C_LEVEL_STATEMENT >= g_log_level) THEN

             trace
                (p_msg      => 'after generateheadercursor length of l_event:'||to_char(length(l_event))
                ,p_level    => C_LEVEL_PROCEDURE
                ,p_module   => l_log_module);

     END IF;
     l_event     := xla_cmp_string_pkg.replace_token (l_event, '$close_header_cursor$', C_CLOSE_HEADER_CURSOR );-- 4417664
  /* --4492149
  ELSE
     l_event     := xla_cmp_string_pkg.replace_token (l_event, '$header_types$',' ');-- 4417664
     l_event     := xla_cmp_string_pkg.replace_token (l_event, '$header_variables$',' ');-- 4417664
     l_event     := xla_cmp_string_pkg.replace_token (l_event, '$header_cursor$',' ');-- 4417664
     l_event     := xla_cmp_string_pkg.replace_token (l_event, '$close_header_cursor$',  ' ' );-- 4417664
   END IF;
   */
   --
   -- generate line structures, line variables and line cursor
   --
   /* --4492149
     IF (p_array_l_source_index.COUNT +
       p_array_l_mls_source_index.COUNT > 0 )
    THEN
   */
     --
     -- generate the structure of line variables
     --
     --
     IF (C_LEVEL_STATEMENT >= g_log_level) THEN

              trace
                 (p_msg      => '-> CALL xla_cmp_extract_pkg.GenerateLineStructure API'
                 ,p_level    => C_LEVEL_STATEMENT
                 ,p_module   => l_log_module);

     END IF;
     --
     l_event     := xla_cmp_string_pkg.replace_token
                       (l_event
                       ,'$line_types$'
                       ,xla_cmp_extract_pkg.GenerateLineStructure
                           (p_array_table_name             => p_array_table_name
                           ,p_array_source_code            => p_rec_sources.array_source_code
                           ,p_array_l_source_index         => p_array_l_source_index
                           ,p_array_l_table_index          => p_array_l_table_index
                           ,p_array_l_mls_source_index     => p_array_l_mls_source_index
                           ,p_array_l_mls_table_index      => p_array_l_mls_table_index)
                       );

     --
     -- generate the declaration of line variables
     --
     IF (C_LEVEL_STATEMENT >= g_log_level) THEN

             trace
                (p_msg      => 'after generatelineStructure length of l_event:'||to_char(length(l_event))
                ,p_level    => C_LEVEL_PROCEDURE
                ,p_module   => l_log_module);
              trace
                 (p_msg      => '-> CALL xla_cmp_extract_pkg.GenerateLineVariables API'
                 ,p_level    => C_LEVEL_STATEMENT
                 ,p_module   => l_log_module);

     END IF;
     --
     l_event     := xla_cmp_string_pkg.replace_token
                       (l_event
                       ,'$line_variables$'
                       ,xla_cmp_extract_pkg.GenerateLineVariables
                           (p_array_l_source_index         => p_array_l_source_index
                           ,p_array_l_mls_source_index     => p_array_l_mls_source_index
                           ,p_array_source_code            => p_rec_sources.array_source_code
                           ,p_array_lookup_type            => p_rec_sources.array_lookup_type
                           ,p_array_view_application_id    => p_rec_sources.array_view_application_id)
                       );
     --
     -- generate the declaration of line cursor
     --
     --
     IF (C_LEVEL_STATEMENT >= g_log_level) THEN

             trace
                (p_msg      => 'after generatelinevariables length of l_event:'||to_char(length(l_event))
                ,p_level    => C_LEVEL_PROCEDURE
                ,p_module   => l_log_module);
              trace
                 (p_msg      => '-> CALL xla_cmp_extract_pkg.GenerateLineCursor API'
                 ,p_level    => C_LEVEL_STATEMENT
                 ,p_module   => l_log_module);

     END IF;
     --
     l_event     := xla_cmp_string_pkg.replace_token
                       (l_event
                       ,'$line_cursor$'
                       ,xla_cmp_extract_pkg.GenerateLineCursor
                           (p_application_id             => p_application_id
                           ,p_array_table_name           => p_array_table_name
                           ,p_array_parent_table_index         => p_array_parent_table_index
                           ,p_array_table_hash           => p_array_table_hash
                           ,p_array_populated_flag       => p_array_populated_flag
                           ,p_array_ref_obj_flag         => p_array_ref_obj_flag
                           ,p_array_join_condition       => p_array_join_condition
                           ,p_array_l_source_index       => p_array_l_source_index
                           ,p_array_l_table_index        => p_array_l_table_index
                           ,p_array_l_mls_source_index   => p_array_l_mls_source_index
                           ,p_array_l_mls_table_index    => p_array_l_mls_table_index
                           ,p_array_source_code          => p_rec_sources.array_source_code
                           ,p_array_lookup_type          => p_rec_sources.array_lookup_type
                           ,p_array_view_application_id  => p_rec_sources.array_view_application_id
                           ,p_procedure                  => p_procedure)
                       );

     IF (C_LEVEL_STATEMENT >= g_log_level) THEN

             trace
                (p_msg      => 'after generatelinecursor length of l_event:'||to_char(length(l_event))
                ,p_level    => C_LEVEL_PROCEDURE
                ,p_module   => l_log_module);
              trace
                 (p_msg      => '-> CALL xla_cmp_extract_pkg.GenerateLineCursor API'
                 ,p_level    => C_LEVEL_STATEMENT
                 ,p_module   => l_log_module);

     END IF;
     l_event   := xla_cmp_string_pkg.replace_token (l_event, '$close_line_cursor$', C_CLOSE_LINE_CURSOR ); --4262811 awan

     l_event   := xla_cmp_string_pkg.replace_token (l_event, '$no_data_exception$', C_NO_DATA_EXCEPTION);
  --
/*  --4492149
   ELSE
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$line_types$',' ');          -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$line_variables$', ' ');     -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$line_cursor$',' ');         -- 4417664
   l_event     := xla_cmp_string_pkg.replace_token (l_event, '$close_line_cursor$',  ' ' );-- 4417664
  END IF;
*/
--
END IF;

--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GenerateOneProcedure'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
      trace
         (p_msg      => 'length of l_event:'||to_char(length(l_event))
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
RETURN l_event;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateOneProcedure');
END GenerateOneProcedure;

/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GenerateProcedure                                            |
|                                                                |
| Generates EventType_xxx() or EventClass_xxx() function         |
|                                                                |
+---------------------------------------------------------------*/

FUNCTION GenerateProcedure  (
  p_entity                       IN VARCHAR2
, p_event_class                  IN VARCHAR2
, p_event_type                   IN VARCHAR2
, p_application_id               IN NUMBER
, p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_amb_context_code             IN VARCHAR2
, p_acctd_flag                   IN VARCHAR2
, p_g_l_flag                     IN VARCHAR2
--
, p_hdr_description_index        IN BINARY_INTEGER
, p_array_alt_index              IN xla_cmp_source_pkg.t_array_ByInt
, p_array_evt_source_Level       IN xla_cmp_source_pkg.t_array_VL1
--
, p_array_hdr_acctg_source       IN xla_cmp_source_pkg.t_array_VL30
, p_array_hdr_acctg_source_type  IN xla_cmp_source_pkg.t_array_VL1
, p_array_hdr_acct_attr_source   IN xla_cmp_source_pkg.t_array_int
, p_array_line_acctg_source      IN xla_cmp_source_pkg.t_array_VL30
, p_array_line_acctg_source_type IN xla_cmp_source_pkg.t_array_VL1
, p_array_line_acct_attr_source  IN xla_cmp_source_pkg.t_array_int
--
, p_array_table_name             IN xla_cmp_source_pkg.t_array_VL30
, p_array_parent_table_index           IN xla_cmp_source_pkg.t_array_ByInt
, p_array_table_type             IN xla_cmp_source_pkg.t_array_VL30
, p_array_table_hash             IN xla_cmp_source_pkg.t_array_VL30
, p_array_populated_flag         IN xla_cmp_source_pkg.t_array_VL1
--
, p_array_ref_obj_flag           IN xla_cmp_source_pkg.t_array_VL1
, p_array_join_condition         IN xla_cmp_source_pkg.t_array_VL2000
--
, p_array_h_source_index         IN xla_cmp_source_pkg.t_array_ByInt
, p_array_h_table_index          IN xla_cmp_source_pkg.t_array_ByInt
--
, p_array_h_mls_source_index     IN xla_cmp_source_pkg.t_array_ByInt
, p_array_h_mls_table_index      IN xla_cmp_source_pkg.t_array_ByInt
--
, p_array_l_source_index         IN xla_cmp_source_pkg.t_array_ByInt
, p_array_l_table_index          IN xla_cmp_source_pkg.t_array_ByInt
--
, p_array_l_mls_source_index     IN xla_cmp_source_pkg.t_array_ByInt
, p_array_l_mls_table_index      IN xla_cmp_source_pkg.t_array_ByInt

, p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
, p_rec_aad_objects              IN xla_cmp_source_pkg.t_rec_aad_objects
--
, p_extract_status               IN BOOLEAN
, p_procedure                    IN VARCHAR2
)
RETURN CLOB
IS
l_event                         CLOB;
l_log_module                    VARCHAR2(240);
BEGIN
--
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateProcedure';
END IF;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN

      trace
         (p_msg      => 'BEGIN of GenerateProcedure '
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;
--
l_event     := GenerateOneProcedure(
  p_application_id               => p_application_id
, p_product_rule_code            => p_product_rule_code
, p_product_rule_type_code       => p_product_rule_type_code
, p_amb_context_code             => p_amb_context_code
, p_entity                       => p_entity
, p_event_class                  => p_event_class
, p_event_type                   => p_event_type
--
, p_hdr_description_index        => p_hdr_description_index
, p_array_alt_index              => p_array_alt_index
, p_array_evt_source_Level       => p_array_evt_source_Level
--
, p_array_hdr_acctg_source       => p_array_hdr_acctg_source
, p_array_hdr_acctg_source_type  => p_array_hdr_acctg_source_type
, p_array_hdr_acct_attr_source   => p_array_hdr_acct_attr_source
, p_array_line_acctg_source      => p_array_line_acctg_source
, p_array_line_acctg_source_type => p_array_line_acctg_source_type
, p_array_line_acct_attr_source  => p_array_line_acct_attr_source
--
, p_array_table_name             => p_array_table_name
, p_array_parent_table_index           => p_array_parent_table_index
, p_array_table_type             => p_array_table_type
, p_array_table_hash             => p_array_table_hash
, p_array_populated_flag         => p_array_populated_flag
--
, p_array_ref_obj_flag           => p_array_ref_obj_flag
, p_array_join_condition         => p_array_join_condition
--
, p_array_h_source_index         => p_array_h_source_index
, p_array_h_table_index          => p_array_h_table_index
--
, p_array_h_mls_source_index     => p_array_h_mls_source_index
, p_array_h_mls_table_index      => p_array_h_mls_table_index
--
, p_array_l_source_index         => p_array_l_source_index
, p_array_l_table_index          => p_array_l_table_index
--
, p_array_l_mls_source_index     => p_array_l_mls_source_index
, p_array_l_mls_table_index      => p_array_l_mls_table_index
--
, p_rec_sources                  => p_rec_sources
, p_rec_aad_objects              => p_rec_aad_objects
--
, p_extract_status               => p_extract_status
, p_procedure                    => p_procedure
);
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => 'length of l_event:'||to_char(length(l_event))
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;
--
l_event     := xla_cmp_string_pkg.replace_token(l_event,'$event_class_code$', p_event_class);  -- 4417664
l_event     := xla_cmp_string_pkg.replace_token(l_event,'$event_type_code$',p_event_type);  -- 4417664
l_event     := xla_cmp_string_pkg.replace_token(l_event,'$calculate_acctd_flag$',p_acctd_flag);  -- 4417664
l_event     := xla_cmp_string_pkg.replace_token(l_event,'$calculate_g_l_flag$',p_g_l_flag);  -- 4417664

l_event     :=
   xla_cmp_string_pkg.replace_token   -- 4417664
      (l_event,'$event_class_name$'
      ,GetEventClassName
          (p_application_id   => p_application_id
          ,p_entity_code      => p_entity
          ,p_event_class_code => p_event_class)
      );

l_event     :=
   xla_cmp_string_pkg.replace_token   -- 4417664
      (l_event,'$event_type_name$'
      ,GetEventTypeName
          (p_application_id   => p_application_id
          ,p_entity_code      => p_entity
          ,p_event_class_code => p_event_class
          ,p_event_type_code  => p_event_type)
      );

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => 'END of GenerateProcedure'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;
--
RETURN l_event;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN OTHERS    THEN
   xla_exceptions_pkg.raise_message
      (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateProcedure');
END GenerateProcedure;

/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GetEventTypeClassProc                                        |
|                                                                |
| Generates EventType_xxx() and EventClass_xxx() functions       |
|                                                                |
+---------------------------------------------------------------*/
--
FUNCTION GetEventTypeClassProc  (
  p_entity                       IN VARCHAR2
, p_event_class                  IN VARCHAR2
, p_event_type                   IN VARCHAR2
, p_acctd_flag                   IN VARCHAR2
, p_g_l_flag                     IN VARCHAR2
, p_application_id               IN NUMBER
, p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_amb_context_code             IN VARCHAR2
, p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
, p_rec_aad_objects              IN OUT NOCOPY xla_cmp_source_pkg.t_rec_aad_objects
, p_procedure                    IN VARCHAR2
, p_IsCompiled                   OUT NOCOPY BOOLEAN
)
RETURN DBMS_SQL.VARCHAR2S
IS
--
l_event                         CLOB;
l_array_event                   DBMS_SQL.VARCHAR2S;
--
l_IsExtractValid                BOOLEAN;
l_IsCompiled                    BOOLEAN;
--
l_array_evt_source_index        xla_cmp_source_pkg.t_array_ByInt;
l_array_evt_source_level        xla_cmp_source_pkg.t_array_VL1;
--
l_array_null_source_index       xla_cmp_source_pkg.t_array_ByInt;
--
l_array_hdr_acctg_source        xla_cmp_source_pkg.t_array_VL30;
l_array_hdr_acctg_source_type   xla_cmp_source_pkg.t_array_VL1;
l_array_hdr_acct_attr_source    xla_cmp_source_pkg.t_array_int;
l_array_line_acctg_source       xla_cmp_source_pkg.t_array_VL30;
l_array_line_acctg_source_type  xla_cmp_source_pkg.t_array_VL1;
l_array_line_acct_attr_source   xla_cmp_source_pkg.t_array_int;
--
l_array_table_name              xla_cmp_source_pkg.t_array_VL30;
l_array_parent_table_index            xla_cmp_source_pkg.t_array_ByInt;
l_array_table_type              xla_cmp_source_pkg.t_array_VL30;
l_array_table_hash              xla_cmp_source_pkg.t_array_VL30;
l_array_populated_flag          xla_cmp_source_pkg.t_array_VL1;
--
l_array_ref_obj_flag            xla_cmp_source_pkg.t_array_VL1;
l_array_join_condition          xla_cmp_source_pkg.t_array_VL2000;
--
l_array_h_source_index          xla_cmp_source_pkg.t_array_ByInt;
l_array_h_table_index           xla_cmp_source_pkg.t_array_ByInt;
--
l_array_h_mls_source_index      xla_cmp_source_pkg.t_array_ByInt;
l_array_h_mls_table_index       xla_cmp_source_pkg.t_array_ByInt;
--
l_array_l_source_index          xla_cmp_source_pkg.t_array_ByInt;
l_array_l_table_index           xla_cmp_source_pkg.t_array_ByInt;
--
l_array_l_mls_source_index      xla_cmp_source_pkg.t_array_ByInt;
l_array_l_mls_table_index       xla_cmp_source_pkg.t_array_ByInt;
--
l_hdr_description_index         BINARY_INTEGER;
l_array_alt_index               xla_cmp_source_pkg.t_array_ByInt;
--
l_ObjectIndex                   BINARY_INTEGER;
l_log_module                    VARCHAR2(240);
--
-- Transaction Objects Diagnostics variables
--
l_insert_sources                CLOB;
l_array_insert_sources          DBMS_SQL.VARCHAR2S;
--
BEGIN
IF g_log_enabled THEN
   l_log_module := C_DEFAULT_MODULE||'.GetEventTypeClassProc';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => 'p_procedure = '||p_procedure
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
   trace
      (p_msg      => 'BEGIN of GetEventTypeClassProc'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

g_entity_name            := GetEntityName(
                                    p_entity         => p_entity
                                  , p_application_id => p_application_id
                                   );

g_event_class_name       := GetEventClassName(
                                    p_application_id     => p_application_id
                                  , p_entity_code        => p_entity
                                  , p_event_class_code   => p_event_class
                                            );

g_event_type_name        := GetEventTypeName(
                                    p_application_id     => p_application_id
                                  , p_entity_code        => p_entity
                                  , p_event_class_code   => p_event_class
                                  , p_event_type_code    => p_event_type
                                   );


--
l_IsExtractValid                := TRUE;
l_IsCompiled                    := TRUE;
--
CollectHeaderAndLineSources (
    p_entity                       => p_entity
  , p_event_class                  => p_event_class
  , p_event_type                   => p_event_type
  , p_application_id               => p_application_id
  , p_product_rule_code            => p_product_rule_code
  , p_product_rule_type_code       => p_product_rule_type_code
  , p_amb_context_code             => p_amb_context_code
  , p_array_evt_source_index       => l_array_evt_source_index
  , p_array_hdr_acctg_source       => l_array_hdr_acctg_source
  , p_array_hdr_acctg_source_type  => l_array_hdr_acctg_source_type
  , p_array_hdr_acct_attr_source   => l_array_hdr_acct_attr_source
  , p_array_line_acctg_source      => l_array_line_acctg_source
  , p_array_line_acctg_source_type => l_array_line_acctg_source_type
  , p_array_line_acct_attr_source  => l_array_line_acct_attr_source
  , p_hdr_description_index        => l_hdr_description_index
  , p_array_alt_index              => l_array_alt_index
  , p_rec_aad_objects              => p_rec_aad_objects
  , p_rec_sources                  => p_rec_sources
);


-- Call the Extract Integrity Checker to validate sources with
-- event class Extract Objects

l_IsExtractValid := xla_cmp_extract_pkg.CallExtractIntegrityChecker (
  p_application_id               => p_application_id
, p_entity_code                  => p_entity
, p_event_class_code             => p_event_class
, p_amb_context_code             => p_amb_context_code
, p_product_rule_type_code       => p_product_rule_type_code
, p_product_rule_code            => p_product_rule_code
, p_array_evt_source_index       => l_array_evt_source_index
, p_array_application_id         => p_rec_sources.array_application_id
, p_array_source_code            => p_rec_sources.array_source_code
, p_array_source_type_code       => p_rec_sources.array_source_type_code
, p_array_datatype_code          => p_rec_sources.array_datatype_code
, p_array_translated_flag        => p_rec_sources.array_translated_flag
, p_array_evt_source_Level       => l_array_evt_source_level
, p_array_object_name            => l_array_table_name
, p_array_parent_object_index    => l_array_parent_table_index
, p_array_object_type            => l_array_table_type
, p_array_object_hash_id         => l_array_table_hash
, p_array_populated_flag         => l_array_populated_flag
, p_array_ref_obj_flag           => l_array_ref_obj_flag
, p_array_join_condition         => l_array_join_condition
, p_array_h_source_index         => l_array_h_source_index
, p_array_h_table_index          => l_array_h_table_index
, p_array_h_mls_source_index     => l_array_h_mls_source_index
, p_array_h_mls_table_index      => l_array_h_mls_table_index
, p_array_l_source_index         => l_array_l_source_index
, p_array_l_table_index          => l_array_l_table_index
, p_array_l_mls_source_index     => l_array_l_mls_source_index
, p_array_l_mls_table_index      => l_array_l_mls_table_index
)
;

IF (p_application_id = 200 AND XLA_CMP_PAD_PKG.g_bc_pkg_flag = 'Y') THEN
  PopulateBCObjectNames(l_array_table_name, l_array_join_condition);
END IF;

-- generate the event type/event class functions

l_event := GenerateProcedure(
  p_entity                       => p_entity
, p_event_class                  => p_event_class
, p_event_type                   => p_event_type
, p_application_id               => p_application_id
, p_product_rule_code            => p_product_rule_code
, p_product_rule_type_code       => p_product_rule_type_code
, p_amb_context_code             => p_amb_context_code
, p_acctd_flag                   => p_acctd_flag
, p_g_l_flag                     => p_g_l_flag
--
, p_hdr_description_index        => l_hdr_description_index
, p_array_alt_index              => l_array_alt_index
, p_array_evt_source_Level      => l_array_evt_source_level
--
, p_array_hdr_acctg_source       => l_array_hdr_acctg_source
, p_array_hdr_acctg_source_type  => l_array_hdr_acctg_source_type
, p_array_hdr_acct_attr_source   => l_array_hdr_acct_attr_source
, p_array_line_acctg_source      => l_array_line_acctg_source
, p_array_line_acctg_source_type => l_array_line_acctg_source_type
, p_array_line_acct_attr_source  => l_array_line_acct_attr_source
--
, p_array_table_name             => l_array_table_name
, p_array_parent_table_index           => l_array_parent_table_index
, p_array_table_type             => l_array_table_type
, p_array_table_hash             => l_array_table_hash
, p_array_populated_flag         => l_array_populated_flag
--
, p_array_ref_obj_flag           => l_array_ref_obj_flag
, p_array_join_condition         => l_array_join_condition
--
, p_array_h_source_index         => l_array_h_source_index
, p_array_h_table_index          => l_array_h_table_index
, p_array_h_mls_source_index     => l_array_h_mls_source_index
, p_array_h_mls_table_index      => l_array_h_mls_table_index
, p_array_l_source_index         => l_array_l_source_index
, p_array_l_table_index          => l_array_l_table_index
, p_array_l_mls_source_index     => l_array_l_mls_source_index
, p_array_l_mls_table_index      => l_array_l_mls_table_index
--
, p_rec_sources                  => p_rec_sources
, p_rec_aad_objects              => p_rec_aad_objects
, p_extract_status               => l_IsExtractValid
, p_procedure                    => p_procedure
);

  IF (C_LEVEL_STATEMENT>= g_log_level) THEN

          trace
             (p_msg      => 'length of l_event:'|| to_char(length(l_event))
             ,p_level    => C_LEVEL_STATEMENT
             ,p_module   => l_log_module);
  END IF;

  IF p_procedure = 'EVENT_TYPE' THEN

      l_ObjectIndex := xla_cmp_source_pkg.CacheAADObject (
               p_object                    => xla_cmp_source_pkg.C_EVT
             , p_object_code               => p_event_type
             , p_object_type_code          => 'S'
             , p_application_id            => p_application_id
             , p_array_source_Index        => l_array_evt_source_index
             , p_rec_aad_objects           => p_rec_aad_objects
             );

     l_event := xla_cmp_string_pkg.replace_token(l_event,'$EVENT_ID$'   ,'Type_'||TO_CHAR(l_ObjectIndex));  -- 4417664
     l_event := xla_cmp_string_pkg.replace_token(l_event,'$package_name$'          , g_package_name);  -- 4417664

  ELSIF  p_procedure = 'EVENT_CLASS' THEN

     l_ObjectIndex := xla_cmp_source_pkg.CacheAADObject (
                 p_object                    => xla_cmp_source_pkg.C_CLASS
               , p_object_code               => p_event_class
               , p_object_type_code          => 'S'
               , p_application_id            => p_application_id
               , p_array_source_Index        => l_array_evt_source_index
               , p_rec_aad_objects           => p_rec_aad_objects
               );

     l_event := xla_cmp_string_pkg.replace_token(l_event,'$EVENT_ID$'   ,'Class_'||TO_CHAR(l_ObjectIndex));  -- 4417664
     l_event := xla_cmp_string_pkg.replace_token(l_event,'$package_name$'          , g_package_name);  -- 4417664

  END IF;
--
l_IsCompiled:= l_IsCompiled AND (l_event IS NOT NULL) AND l_IsExtractValid;

IF (C_LEVEL_STATEMENT>= g_log_level) THEN
          trace
             (p_msg      => 'length of l_event:'|| to_char(length(l_event))
             ,p_level    => C_LEVEL_STATEMENT
             ,p_module   => l_log_module);
          trace
             (p_msg      => 'l_isCompiled = '||
              CASE l_IsCompiled WHEN TRUE THEN 'TRUE' ELSE 'FALSE' END
             ,p_level    => C_LEVEL_STATEMENT
             ,p_module   => l_log_module);
          trace
             (p_msg      => 'l_IsExtractValid= '||
              CASE l_IsExtractValid WHEN TRUE THEN 'TRUE' ELSE 'FALSE' END
             ,p_level    => C_LEVEL_STATEMENT
             ,p_module   => l_log_module);
END IF;

xla_cmp_string_pkg.CreateString(
                      p_package_text  => l_event
                     ,p_array_string  => l_array_event
                     );

--
--+==========================================================================+
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                      Transaction Objects Diagnostics                     |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--+==========================================================================+

IF (C_LEVEL_STATEMENT>= g_log_level) THEN
   trace
    (p_msg      => ' -> CALL Transaction Objects Diagnostics '
    ,p_level    => C_LEVEL_STATEMENT
    ,p_module   => l_log_module);
END IF;

l_insert_sources := C_INSERT_SOURCES_PROC;
l_insert_sources := xla_cmp_string_pkg.replace_token(l_insert_sources,'$event_class_code$', nvl(p_event_class,' '));  -- 4417664
l_insert_sources := xla_cmp_string_pkg.replace_token(l_insert_sources,'$event_type_code$',nvl(p_event_type,' '));  -- 4417664


l_insert_sources := xla_cmp_string_pkg.replace_token(l_insert_sources,'$insert_header_sources$',
                           nvl(xla_cmp_extract_pkg.GenerateInsertHdrSources  (
                           --
                             p_array_table_name             => l_array_table_name
                           , p_array_parent_table_index           => l_array_parent_table_index
                           , p_array_table_hash             => l_array_table_hash
                           , p_array_table_type             => l_array_table_type
                           , p_array_populated_flag         => l_array_populated_flag
                           --
                           , p_array_ref_obj_flag           => l_array_ref_obj_flag
                           , p_array_join_condition         => l_array_join_condition
                           --
                           , p_array_h_source_index         => l_array_h_source_index
                           , p_array_h_table_index          => l_array_h_table_index
                           --
                           , p_array_h_mls_source_index     => l_array_h_mls_source_index
                           , p_array_h_mls_table_index      => l_array_h_mls_table_index
                           --
                           , p_array_application_id         => p_rec_sources.array_application_id
                           , p_array_source_code            => p_rec_sources.array_source_code
                           , p_array_source_type_code       => p_rec_sources.array_source_type_code
                           , p_array_flex_value_set_id      => p_rec_sources.array_flex_value_set_id
                           , p_array_lookup_type            => p_rec_sources.array_lookup_type
                           , p_array_view_application_id    => p_rec_sources.array_view_application_id
                           --
                           , p_procedure                    => p_procedure
                           ),' ')
                         );

l_insert_sources := xla_cmp_string_pkg.replace_token(l_insert_sources, '$insert_line_sources$',
                           nvl(xla_cmp_extract_pkg.GenerateInsertLineSources (
                           --
                             p_array_table_name             => l_array_table_name
                           , p_array_parent_table_index           => l_array_parent_table_index
                           , p_array_table_hash             => l_array_table_hash
                           , p_array_table_type             => l_array_table_type
                           , p_array_populated_flag         => l_array_populated_flag
                           --
                           , p_array_ref_obj_flag           => l_array_ref_obj_flag
                           , p_array_join_condition         => l_array_join_condition
                           --
                           , p_array_l_source_index         => l_array_l_source_index
                           , p_array_l_table_index          => l_array_l_table_index
                           --
                           , p_array_l_mls_source_index     => l_array_l_mls_source_index
                           , p_array_l_mls_table_index      => l_array_l_mls_table_index
                           --
                           , p_array_application_id         => p_rec_sources.array_application_id
                           , p_array_source_code            => p_rec_sources.array_source_code
                           , p_array_source_type_code       => p_rec_sources.array_source_type_code
                           , p_array_flex_value_set_id      => p_rec_sources.array_flex_value_set_id
                           , p_array_lookup_type            => p_rec_sources.array_lookup_type
                           , p_array_view_application_id    => p_rec_sources.array_view_application_id
                           --
                           , p_procedure                    => p_procedure
                           )  ,' ')
                          );

--
l_insert_sources:= xla_cmp_string_pkg.replace_token(l_insert_sources,'$EVENT_INDEX$'   ,TO_CHAR(l_ObjectIndex));  -- 4417664

l_insert_sources:= xla_cmp_string_pkg.replace_token(l_insert_sources,'$package_name$'   ,g_package_name);   -- 4417664

xla_cmp_string_pkg.CreateString(
                      p_package_text  => l_insert_sources
                     ,p_array_string  => l_array_insert_sources
                     );


IF (C_LEVEL_STATEMENT>= g_log_level) THEN

          trace
             (p_msg      => 'End call to Transaction Objects Diagnostics  '
             ,p_level    => C_LEVEL_STATEMENT
             ,p_module   => l_log_module);


          trace
             (p_msg      => 'Concat to event type or event class function the code ='
                            ||l_array_insert_sources.COUNT
             ,p_level    => C_LEVEL_STATEMENT
             ,p_module   => l_log_module);

END IF;

l_array_event   := xla_cmp_string_pkg.ConcatTwoStrings (
                                 p_array_string_1    => l_array_insert_sources
                                ,p_array_string_2    => l_array_event
                          );

IF (C_LEVEL_STATEMENT>= g_log_level) THEN
        trace
             (p_msg      => 'Event class or Event Type function length ='
                            ||l_array_event.COUNT
             ,p_level    => C_LEVEL_STATEMENT
             ,p_module   => l_log_module);

END IF;
--
------------------------------------------------------------------------------
--
--   END the generation of Transaction Objects Diagnostics
--
------------------------------------------------------------------------------
--
l_array_evt_source_index   := l_array_null_source_index;
--
p_IsCompiled := l_IsCompiled;
--
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
       (p_msg      => 'p_IsCompiled = '||
              CASE p_IsCompiled WHEN TRUE THEN 'TRUE' ELSE 'FALSE' END
       ,p_level    => C_LEVEL_STATEMENT
       ,p_module   => l_log_module);
   trace
      (p_msg      => 'END of GetEventTypeClassProc'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

RETURN l_array_event;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN OTHERS    THEN
   xla_exceptions_pkg.raise_message
      (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetEventTypeClassProc ');
END GetEventTypeClassProc;


/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GetEventTypeOrClassProc                                      |
|                                                                |
| Drives the generation of EventType_xxx() or EventClass_xxx()   |
| functions                                                      |
|                                                                |
+---------------------------------------------------------------*/

FUNCTION GetEventTypeOrClassProc  (
  p_application_id               IN NUMBER
, p_amb_context_code             IN VARCHAR2
, p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_entity                       IN VARCHAR2
, p_event_class                  IN VARCHAR2
, p_event_type                   IN VARCHAR2
, p_acctd_flag                   IN VARCHAR2
, p_g_l_flag                     IN VARCHAR2
--
, p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
, p_rec_aad_objects              IN OUT NOCOPY xla_cmp_source_pkg.t_rec_aad_objects
--
, p_IsCompiled                   OUT NOCOPY BOOLEAN
)
RETURN DBMS_SQL.VARCHAR2S
IS

l_event                 DBMS_SQL.VARCHAR2S;
l_IsCompiled            BOOLEAN;
l_log_module            VARCHAR2(240);

BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetEventTypeOrClassProc';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN

      trace
         (p_msg      => 'BEGIN of GetEventTypeOrClassProc'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
      trace
         (p_msg      => 'p_entity = '||p_entity||
                        ' - p_event_class = '||p_event_class ||
                        ' - p_event_type = '||p_event_type
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;
--
l_IsCompiled := TRUE;
p_IsCompiled := TRUE;
--
l_event  := xla_cmp_string_pkg.g_null_varchar2s;
--
IF (p_event_type <> p_event_class ||'_ALL') THEN
--
-- generate event type procedure
--
  l_event:= GetEventTypeClassProc  (
  p_entity                      => p_entity
, p_event_class                 => p_event_class
, p_event_type                  => p_event_type
, p_acctd_flag                  => p_acctd_flag
, p_g_l_flag                    => p_g_l_flag
, p_application_id              => p_application_id
, p_product_rule_code           => p_product_rule_code
, p_product_rule_type_code      => p_product_rule_type_code
, p_amb_context_code            => p_amb_context_code
--
, p_rec_sources                 => p_rec_sources
, p_rec_aad_objects             => p_rec_aad_objects
--
, p_procedure                   => 'EVENT_TYPE'
, p_IsCompiled                  => l_IsCompiled
);
--
ELSE
--
-- generate event class procedure
--
  l_event:= GetEventTypeClassProc  (
  p_entity                      => p_entity
, p_event_class                 => p_event_class
, p_event_type                  => p_event_type
, p_acctd_flag                  => p_acctd_flag
, p_g_l_flag                    => p_g_l_flag
, p_application_id              => p_application_id
, p_product_rule_code           => p_product_rule_code
, p_product_rule_type_code      => p_product_rule_type_code
, p_amb_context_code            => p_amb_context_code
--
, p_rec_sources                 => p_rec_sources
, p_rec_aad_objects             => p_rec_aad_objects
--
, p_procedure                   => 'EVENT_CLASS'
, p_IsCompiled                  => l_IsCompiled
);
--
END IF;

--
p_IsCompiled :=  p_IsCompiled AND l_IsCompiled ;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
       (p_msg      => 'p_IsCompiled = '||
              CASE p_IsCompiled WHEN TRUE THEN 'TRUE' ELSE 'FALSE' END
       ,p_level    => C_LEVEL_STATEMENT
       ,p_module   => l_log_module);
   trace
      (p_msg      => 'END of GetEventTypeOrClassProc'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;
RETURN l_event;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetEventTypeOrClassProc ');
END GetEventTypeOrClassProc;

/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GetEventTypeOrClassProc                                      |
|                                                                |
| Generates all EventType_xxx() or EventClass_xxx() from event   |
| types and event classes assigned to AAD                        |
|                                                                |
+---------------------------------------------------------------*/

FUNCTION GetEventClassAndTypeProcs  (
  p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_application_id               IN NUMBER
, p_amb_context_code             IN VARCHAR2
--
, p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
, p_rec_aad_objects              IN OUT NOCOPY xla_cmp_source_pkg.t_rec_aad_objects
--
, p_IsCompiled                   OUT NOCOPY BOOLEAN
)
RETURN DBMS_SQL.VARCHAR2S
IS
--
l_events                      DBMS_SQL.VARCHAR2S;
l_array_events                DBMS_SQL.VARCHAR2S;
--
l_array_entity                xla_cmp_source_pkg.t_array_VL30;
l_array_event_class           xla_cmp_source_pkg.t_array_VL30;
l_array_event_type            xla_cmp_source_pkg.t_array_VL30;
l_array_event_class_acctd_flag   xla_cmp_source_pkg.t_array_VL1;
l_array_event_class_g_l_flag     xla_cmp_source_pkg.t_array_VL1;
--
l_array_null_entity           xla_cmp_source_pkg.t_array_VL30;
l_array_null_event_class      xla_cmp_source_pkg.t_array_VL30;
l_array_null_event_type       xla_cmp_source_pkg.t_array_VL30;
--
l_IsCompiled                  BOOLEAN;
l_log_module                  VARCHAR2(240);
--
BEGIN
IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GetEventClassAndTypeProcs';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GetEventClassAndTypeProcs'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

l_IsCompiled    := TRUE;
p_IsCompiled    := TRUE;

GetEventClassEventType(
                    p_application_id
                  , p_amb_context_code
                  , p_product_rule_code
                  , p_product_rule_type_code
                  , l_array_entity
                  , l_array_event_class
                  , l_array_event_type
                  , l_array_event_class_acctd_flag
                  , l_array_event_class_g_l_flag
                  );

l_events := xla_cmp_string_pkg.g_null_varchar2s;

IF l_array_event_type.COUNT > 0 THEN
  IF (C_LEVEL_PROCEDURE >= g_log_level) THEN

      trace
         (p_msg      => 'count is:'||to_char(l_array_event_type.COUNT)
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

  END IF;

 FOR Idx IN l_array_event_type.FIRST .. l_array_event_type.LAST LOOP
   IF l_array_event_type.EXISTS(Idx) THEN

   l_array_events :=  GetEventTypeOrClassProc  (
               p_application_id              => p_application_id
             , p_amb_context_code            => p_amb_context_code
             , p_product_rule_code           => p_product_rule_code
             , p_product_rule_type_code      => p_product_rule_type_code
             --
             , p_entity                      => l_array_entity(Idx)
             , p_event_class                 => l_array_event_class(Idx)
             , p_event_type                  => l_array_event_type(Idx)
             , p_acctd_flag                  => l_array_event_class_acctd_flag(Idx)
             , p_g_l_flag                    => l_array_event_class_g_l_flag(Idx)
             --
             , p_rec_sources                 => p_rec_sources
             , p_rec_aad_objects             => p_rec_aad_objects
             --
             , p_IsCompiled                  => l_IsCompiled
             );

     IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
            (p_msg      => 'l_event length is:'||to_char(l_events.COUNT)
            ,p_level    => C_LEVEL_PROCEDURE
            ,p_module   => l_log_module);
         trace
            (p_msg      => 'l__array_event length is:'||to_char(l_array_events.COUNT)
            ,p_level    => C_LEVEL_PROCEDURE
            ,p_module   => l_log_module);
     END IF;

     l_events :=  xla_cmp_string_pkg.ConcatTwoStrings (
                                 p_array_string_1    => l_events
                                ,p_array_string_2    => l_array_events
                          );
     IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
            (p_msg      => 'l_event length is:'||to_char(l_events.COUNT)
            ,p_level    => C_LEVEL_PROCEDURE
            ,p_module   => l_log_module);
     END IF;

     p_IsCompiled := p_IsCompiled AND l_IsCompiled;

     END IF;
 END LOOP;
END IF;

l_array_entity           := l_array_null_entity;
l_array_event_class      := l_array_null_event_class;
l_array_event_type       := l_array_null_event_type;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
       (p_msg      => 'p_IsCompiled = '||
              CASE p_IsCompiled WHEN TRUE THEN 'TRUE' ELSE 'FALSE' END
       ,p_level    => C_LEVEL_STATEMENT
       ,p_module   => l_log_module);
   trace
      (p_msg      => 'END of GetEventClassAndTypeProcs'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;
--
RETURN l_events;
EXCEPTION
 WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
 WHEN OTHERS    THEN
      xla_exceptions_pkg.raise_message
         (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GetEventClassAndTypeProcs ');
END GetEventClassAndTypeProcs;

/*-----------------------------------------------------------------------+
|                                                                        |
|  Public function                                                       |
|                                                                        |
|    GenerateEventClassAndType                                           |
|                                                                        |
|  Generates the EventType_xxx() and EventCass_xxx() functions from the  |
|  Event Type Code and Event Class Code assigned to the AAD.             |
|                                                                        |
+-----------------------------------------------------------------------*/

FUNCTION GenerateEventClassAndType   (
  p_application_id               IN NUMBER
, p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_product_rule_version         IN VARCHAR2
, p_amb_context_code             IN VARCHAR2
, p_product_rule_name            IN VARCHAR2
, p_package_name                 IN VARCHAR2
, p_rec_aad_objects              IN OUT NOCOPY xla_cmp_source_pkg.t_rec_aad_objects
, p_rec_sources                  IN OUT NOCOPY xla_cmp_source_pkg.t_rec_sources
, p_package_body                 OUT NOCOPY DBMS_SQL.VARCHAR2S
)
RETURN BOOLEAN
IS
--
l_IsCompiled                BOOLEAN:= TRUE;
l_events                    DBMS_SQL.VARCHAR2S;
l_log_module                VARCHAR2(240);
--
BEGIN

IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateEventClassAndType';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateEventClassAndType'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;
IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'p_package_name = '||p_package_name||
                        ' - p_product_rule_code='||p_product_rule_code||
                        ' - p_product_rule_type_code='||p_product_rule_type_code||
                        ' - p_product_rule_version='||p_product_rule_version||
                        ' - p_product_rule_name='||p_product_rule_name
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);

END IF;

g_package_name            := p_package_name ;
g_product_rule_code       := p_product_rule_code;
g_product_rule_type_code  := p_product_rule_type_code;
g_product_rule_version    := p_product_rule_version;
g_product_rule_name       := p_product_rule_name;
g_application_name        := XLA_CMP_PAD_PKG.GetApplicationName(p_application_id);

--
l_events :=  GetEventClassAndTypeProcs   (
  p_product_rule_code           => p_product_rule_code
, p_product_rule_type_code      => p_product_rule_type_code
, p_application_id              => p_application_id
, p_amb_context_code            => p_amb_context_code
, p_rec_sources                 => p_rec_sources
, p_rec_aad_objects             => p_rec_aad_objects
, p_IsCompiled                  => l_IsCompiled
 );


p_package_body            := l_events;

g_package_name            := NULL;
g_product_rule_code       := NULL;
g_product_rule_type_code  := NULL;
g_product_rule_version    := NULL;
g_product_rule_name       := NULL;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
       (p_msg      => 'l_IsCompiled = '||
              CASE l_IsCompiled WHEN TRUE THEN 'TRUE' ELSE 'FALSE' END
       ,p_level    => C_LEVEL_STATEMENT
       ,p_module   => l_log_module);
   trace
      (p_msg      => 'END of GenerateEventClassAndType'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

RETURN l_IsCompiled;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN OTHERS    THEN
   xla_exceptions_pkg.raise_message
      (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateEventClassAndType ');
END GenerateEventClassAndType;

--+==========================================================================+
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                  Generate main procedure                                 |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--|                                                                          |
--+==========================================================================+


/*---------------------------------------------------------------+
|                                                                |
|  Private function                                              |
|                                                                |
|   GenerateMainProcedure                                        |
|                                                                |
| Generates call to EventType_xxx() or EventClass_xxx() in AAD   |
| package.                                                       |
|                                                                |
+---------------------------------------------------------------*/

FUNCTION GenerateMainProcedure(
  p_application_id               IN NUMBER
, p_amb_context_code             IN VARCHAR2
, p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_product_rule_name            IN VARCHAR2
, p_rec_aad_objects              IN xla_cmp_source_pkg.t_rec_aad_objects
 )
RETURN CLOB
IS
------------------------------------------------------------
--
-- Call to EventClass_X() and EventType_X()
--
------------------------------------------------------------

C_CALL_EVENT_CLASS       CONSTANT VARCHAR2(10000) :='
l_created := EventClass_$Index$(
   p_application_id         => p_application_id
 , p_base_ledger_id         => p_base_ledger_id
 , p_target_ledger_id       => p_target_ledger_id
 , p_language               => l_language
 , p_currency_code          => l_currency_code
 , p_sla_ledger_id          => l_sla_ledger_id
 , p_pad_start_date         => p_pad_start_date
 , p_pad_end_date           => p_pad_end_date
 , p_primary_ledger_id      => p_primary_ledger_id
);

';

C_CALL_EVENT_TYPE       CONSTANT VARCHAR2(10000) := '
 l_created :=  EventType_$Index$(
   p_application_id         => p_application_id
 , p_base_ledger_id         => p_base_ledger_id
 , p_target_ledger_id       => p_target_ledger_id
 , p_language               => l_language
 , p_currency_code          => l_currency_code
 , p_sla_ledger_id          => l_sla_ledger_id
 , p_pad_start_date         => p_pad_start_date
 , p_pad_end_date           => p_pad_end_date
 , p_primary_ledger_id      => p_primary_ledger_id
);

';

------------------------------------------------------------
--
-- Call Transaction Objects Diagnostics
--
------------------------------------------------------------
--
C_CALL_INSERT_EXT_SOURCES   CONSTANT VARCHAR2(3000) := '

     IF ( g_diagnostics_mode =''Y'' ) THEN

         IF (C_LEVEL_STATEMENT >= g_log_level) THEN
          trace
              (p_msg      => ''CALL Transaction Objects Diagnostics''
              ,p_level    => C_LEVEL_STATEMENT
              ,p_module   => l_log_module);

         END IF;

         insert_sources_$Index$(
                          p_target_ledger_id => p_target_ledger_id
                        , p_language         => l_language
                        , p_sla_ledger_id    => l_sla_ledger_id
                        , p_pad_start_date   => p_pad_start_date
                        , p_pad_end_date     => p_pad_end_date
                          );

     END IF;
';

l_MainBodyProc                   CLOB;
l_name                           VARCHAR2(80);
l_ObjectIndex                    BINARY_INTEGER;
l_call_event                     VARCHAR2(32000);
l_array_entity                   xla_cmp_source_pkg.t_array_VL30;
l_array_event_type               xla_cmp_source_pkg.t_array_VL30;
l_array_NoAcctg_event_type       xla_cmp_source_pkg.t_array_VL30;
l_array_event_class              xla_cmp_source_pkg.t_array_VL30;
l_array_EventTypeInClass         xla_cmp_source_pkg.t_array_VL30;
l_array_event_class_acctd_flag   xla_cmp_source_pkg.t_array_VL1;
l_array_event_class_g_l_flag     xla_cmp_source_pkg.t_array_VL1;
l_log_module                     VARCHAR2(240);

BEGIN

IF g_log_enabled THEN
      l_log_module := C_DEFAULT_MODULE||'.GenerateMainProcedure';
END IF;
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'BEGIN of GenerateMainProcedure'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);
END IF;

l_MainBodyProc    := NULL;

GetEventClassEventType(
                    p_application_id               => p_application_id
                  , p_amb_context_code             => p_amb_context_code
                  , p_product_rule_code            => p_product_rule_code
                  , p_product_rule_type_code       => p_product_rule_type_code
                  , p_array_entity                 => l_array_entity
                  , p_array_event_class            => l_array_event_class
                  , p_array_event_type             => l_array_event_type
                  , p_array_event_class_acctd_flag => l_array_event_class_acctd_flag
                  , p_array_event_class_g_l_flag   => l_array_event_class_g_l_flag
                  );

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'l_array_event_type.COUNT = '||l_array_event_type.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

GetNoAccountEventTypes(
                    p_application_id            => p_application_id
                  , p_amb_context_code          => p_amb_context_code
                  , p_product_rule_code         => p_product_rule_code
                  , p_product_rule_type_code    => p_product_rule_type_code
                  , p_array_event_type          => l_array_NoAcctg_event_type
)
;
IF (C_LEVEL_STATEMENT >= g_log_level) THEN
      trace
         (p_msg      => 'l_array_NoAcctg_event_type.COUNT = '||l_array_NoAcctg_event_type.COUNT
         ,p_level    => C_LEVEL_STATEMENT
         ,p_module   => l_log_module);
END IF;

IF l_array_event_type.COUNT > 0 THEN
   FOR Idx IN l_array_event_type.FIRST .. l_array_event_type.LAST LOOP
      IF (l_array_event_type(Idx) <> l_array_event_class(Idx)||'_ALL') THEN

         l_ObjectIndex := xla_cmp_source_pkg.GetAADObjectPosition(
                      p_object                   => xla_cmp_source_pkg.C_EVT
                    , p_object_code              => l_array_event_type(Idx)
                    , p_object_type_code         => 'S'
                    , p_application_id           => p_application_id
                    , p_event_class_code         => NULL
                    , p_event_type_code          => NULL
                    , p_rec_aad_objects          => p_rec_aad_objects);



         IF l_ObjectIndex IS NOT NULL THEN
             --
             l_call_event   := C_CALL_EVENT_TYPE ;
             l_call_event   := l_call_event || C_CALL_INSERT_EXT_SOURCES;
             l_call_event   := REPLACE(l_call_event,'$Index$', TO_CHAR(l_ObjectIndex));
             l_MainBodyProc := l_MainBodyProc ||l_call_event ;
          END IF;
      ELSE

         GetEventType(
               p_application_id      => p_application_id
             , p_entity_code         => l_array_entity(Idx)
             , p_event_class_code    => l_array_event_class(Idx)
             , p_array_event_type    => l_array_EventTypeInClass);
         --
         IF l_array_EventTypeInClass.COUNT > 0 THEN

            l_ObjectIndex := xla_cmp_source_pkg.GetAADObjectPosition(
                              p_object                   => xla_cmp_source_pkg.C_CLASS
                            , p_object_code              => l_array_event_class(Idx)
                            , p_object_type_code         => 'S'
                            , p_application_id           => p_application_id
                            , p_event_class_code         => NULL
                            , p_event_type_code          => NULL
                            , p_rec_aad_objects          => p_rec_aad_objects);

            IF l_ObjectIndex IS NOT NULL THEN
               --
               l_call_event   := C_CALL_EVENT_CLASS;
               l_call_event   := l_call_event ||C_CALL_INSERT_EXT_SOURCES;
               l_call_event   := REPLACE(l_call_event,'$Index$', TO_CHAR(l_ObjectIndex));
               l_MainBodyProc := l_MainBodyProc ||l_call_event ;
            END IF;
         ELSE
            --
            BEGIN
               --
               l_name := GetEventClassName(
                 p_application_id            => p_application_id
               , p_entity_code               => l_array_entity(Idx)
               , p_event_class_code          => l_array_event_class(Idx)) ;
               --

               IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
                  trace
                     (p_msg      => 'ERROR: XLA_CMP_NO_EVENT_TYPE '
                     ,p_level    => C_LEVEL_EXCEPTION
                     ,p_module   => l_log_module);
               END IF;

               xla_exceptions_pkg.raise_message
                                      ('XLA'
                                      ,'XLA_CMP_NO_EVENT_TYPE'
                                      ,'PAD_NAME'
                                      , XLA_CMP_PAD_PKG.g_component_name
                                      ,'PAD_OWNER'
                                      , XLA_CMP_PAD_PKG.g_owner
                                      ,'EVENT_CLASS_NAME'
                                      , l_name);

            END;
         END IF;
      END IF;
   END LOOP;
ELSE

   l_MainBodyProc := NULL;

   IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
         trace
            (p_msg      => 'ERROR: XLA_CMP_NO_EVENT_CLASS  '
            ,p_level    => C_LEVEL_EXCEPTION
            ,p_module   => l_log_module);
   END IF;
   xla_exceptions_pkg.raise_message
                                   ('XLA'
                                   ,'XLA_CMP_NO_EVENT_CLASS'
                                   ,'PAD_NAME'
                                   , XLA_CMP_PAD_PKG.g_component_name
                                   ,'PAD_OWNER'
                                   , XLA_CMP_PAD_PKG.g_owner);
END IF;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
      trace
         (p_msg      => 'END of GenerateMainProcedure'
         ,p_level    => C_LEVEL_PROCEDURE
         ,p_module   => l_log_module);

END IF;
RETURN l_MainBodyProc;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
         RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN OTHERS    THEN
       xla_exceptions_pkg.raise_message
            (p_location => 'XLA_CMP_EVENT_TYPE_PKG.GenerateMainProcedure');
END GenerateMainProcedure;

/*-----------------------------------------------------------------+
|                                                                  |
|  Public function                                                 |
|                                                                  |
|    BuildMainProc                                                 |
|                                                                  |
|  Generates the main procedure CreateHeadersAndLines() in the AAD |
|  packages                                                        |
|                                                                  |
+-----------------------------------------------------------------*/

FUNCTION BuildMainProc(
  p_application_id               IN NUMBER
, p_product_rule_code            IN VARCHAR2
, p_product_rule_type_code       IN VARCHAR2
, p_product_rule_name            IN VARCHAR2
, p_product_rule_version         IN VARCHAR2
, p_amb_context_code             IN VARCHAR2
, p_package_name                 IN VARCHAR2
--
, p_rec_aad_objects              IN xla_cmp_source_pkg.t_rec_aad_objects
--
, p_package_body                 OUT NOCOPY DBMS_SQL.VARCHAR2S
)
RETURN BOOLEAN
IS
--
l_MainProcedure           CLOB;
l_MainBody                CLOB;
l_array_main              DBMS_SQL.VARCHAR2S;
l_IsCompiled              BOOLEAN;
l_log_module              VARCHAR2(240);
--
BEGIN
--
IF g_log_enabled THEN
   l_log_module := C_DEFAULT_MODULE||'.BuildMainProc';
END IF;
--
IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
      (p_msg      => 'BEGIN of BuildMainProc'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;

l_IsCompiled := TRUE;
l_array_main :=  xla_cmp_string_pkg.g_null_varchar2s;
l_MainBody   := NULL;

l_MainBody     :=  GenerateMainProcedure(
               p_application_id           => p_application_id
             , p_amb_context_code         => p_amb_context_code
             , p_product_rule_code        => p_product_rule_code
             , p_product_rule_type_code   => p_product_rule_type_code
             , p_product_rule_name        => p_product_rule_name
             , p_rec_aad_objects          => p_rec_aad_objects
             );

l_IsCompiled        := l_MainBody IS NOT NULL;

l_MainProcedure     := C_MAIN_PROCEDURE ;

l_MainProcedure     := xla_cmp_string_pkg.replace_token(l_MainProcedure ,  -- 4417664
                                   '$PACKAGE_NAME$',p_package_name);

l_MainProcedure     := xla_cmp_string_pkg.replace_token
                          (l_MainProcedure
                          ,'$BODY_MAIN_PROCEDURE$'
                          ,l_MainBody);

IF (C_LEVEL_STATEMENT >= g_log_level) THEN
   trace
      (p_msg      => '-> CALL xla_cmp_string_pkg.CreateString API'
      ,p_level    => C_LEVEL_STATEMENT
      ,p_module   => l_log_module);
END IF;

xla_cmp_string_pkg.CreateString
   (p_package_text  => l_MainProcedure
   ,p_array_string  => l_array_main);

p_package_body   := l_array_main ;

IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
   trace
       (p_msg      => 'l_IsCompiled = '||
              CASE l_IsCompiled WHEN TRUE THEN 'TRUE' ELSE 'FALSE' END
       ,p_level    => C_LEVEL_STATEMENT
       ,p_module   => l_log_module);
   trace
      (p_msg      => 'END of BuildMainProc'
      ,p_level    => C_LEVEL_PROCEDURE
      ,p_module   => l_log_module);
END IF;
--
RETURN l_IsCompiled;
EXCEPTION
WHEN VALUE_ERROR THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN xla_exceptions_pkg.application_exception   THEN
        IF (C_LEVEL_EXCEPTION >= g_log_level) THEN
            trace
               (p_msg      => 'ERROR: XLA_CMP_COMPILER_ERROR = '||sqlerrm
               ,p_level    => C_LEVEL_EXCEPTION
               ,p_module   => l_log_module);
        END IF;
        RAISE;
WHEN OTHERS    THEN
   xla_exceptions_pkg.raise_message
      (p_location => 'XLA_CMP_EVENT_TYPE_PKG.BuildMainProc');
END BuildMainProc;
--
--=============================================================================
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--=============================================================================
--=============================================================================
--          *********** Initialization routine **********
--=============================================================================

BEGIN

   g_log_level      := FND_LOG.G_CURRENT_RUNTIME_LEVEL;
   g_log_enabled    := fnd_log.test
                          (log_level  => g_log_level
                          ,module     => C_DEFAULT_MODULE);

   IF NOT g_log_enabled  THEN
      g_log_level := C_LEVEL_LOG_DISABLED;
   END IF;
--
END xla_cmp_event_type_pkg; --

/
