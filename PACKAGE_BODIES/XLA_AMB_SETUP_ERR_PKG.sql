--------------------------------------------------------
--  DDL for Package Body XLA_AMB_SETUP_ERR_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."XLA_AMB_SETUP_ERR_PKG" AS
-- $Header: xlaamerr.pkb 120.8 2005/06/28 20:10:30 dcshah ship $
/*===========================================================================+
|             Copyright (c) 2001-2002 Oracle Corporation                     |
|                       Redwood Shores, CA, USA                              |
|                         All rights reserved.                               |
+============================================================================+
| PACKAGE NAME                                                               |
|     xla_amb_setup_err_pkg                                                  |
|                                                                            |
| DESCRIPTION                                                                |
|     This is the body of the package that handles errors for accounting     |
|     methods builder setup generated by the Extract Integrity Checker and   |
|     Application Accounting Definition Compilation process                  |
|                                                                            |
| HISTORY                                                                    |
|     12/10/2003      Dimple Shah    Created                                 |
|                                                                            |
+===========================================================================*/

--=============================================================================
--           ****************  declaraions  ********************
--=============================================================================
-------------------------------------------------------------------------------
-- declaring private package variables
-------------------------------------------------------------------------------
g_error_index                  PLS_INTEGER := 0;
g_error_count                  PLS_INTEGER := 0;
g_amb_errors                   xla_amb_setup_err_pkg.t_array_error;
g_request_id                   NUMBER;
-------------------------------------------------------------------------------
-- forward declarion of private procedures and functions
-------------------------------------------------------------------------------
PROCEDURE reset;

--=============================================================================
--               *********** Local Trace Routine **********
--=============================================================================
C_LEVEL_STATEMENT     CONSTANT NUMBER := FND_LOG.LEVEL_STATEMENT;
C_LEVEL_PROCEDURE     CONSTANT NUMBER := FND_LOG.LEVEL_PROCEDURE;
C_LEVEL_EVENT         CONSTANT NUMBER := FND_LOG.LEVEL_EVENT;
C_LEVEL_EXCEPTION     CONSTANT NUMBER := FND_LOG.LEVEL_EXCEPTION;
C_LEVEL_ERROR         CONSTANT NUMBER := FND_LOG.LEVEL_ERROR;
C_LEVEL_UNEXPECTED    CONSTANT NUMBER := FND_LOG.LEVEL_UNEXPECTED;

C_DEFAULT_MODULE      CONSTANT VARCHAR2(240) := 'xla.plsql.xla_amb_setup_err_pkg';

g_trace_label   VARCHAR2(240);
g_log_level     NUMBER;
g_log_enabled   BOOLEAN;


PROCEDURE trace
       (p_msg                        IN VARCHAR2
       ,p_level                      IN NUMBER) IS

   l_module         VARCHAR2(240);
BEGIN
   ----------------------------------------------------------------------------
   -- Following is for FND log.
   ----------------------------------------------------------------------------
   l_module := C_DEFAULT_MODULE||'.'||g_trace_label;

   IF (p_msg IS NULL AND p_level >= g_log_level) THEN
      fnd_log.message(p_level, l_module);
   ELSIF p_level >= g_log_level THEN
      fnd_log.string(p_level, l_module, p_msg);
   END IF;
EXCEPTION
   WHEN xla_exceptions_pkg.application_exception THEN
      RAISE;
   WHEN OTHERS THEN
      xla_exceptions_pkg.raise_message
         (p_location   => 'xla_amb_setup_err_pkg.trace');
END trace;

--=============================================================================
--          *********** public procedures and functions **********
--=============================================================================
--=============================================================================
--
-- Following are the public routines:
--
--    1.    initialize
--    2.    stack_error
--    3.    insert_errors
--
--
--=============================================================================

/*======================================================================+
|                                                                       |
| Public Procedure                                                      |
|                                                                       |
| Initialize                                                            |
|                                                                       |
| This routine is called in the beginning of the program                |
| to initialize the array                                               |
|                                                                       |
+======================================================================*/

PROCEDURE initialize
       (p_request_id              IN  NUMBER   DEFAULT NULL)

IS

BEGIN
   g_trace_label :='Initialize';
   IF ((g_log_enabled = TRUE) AND (C_LEVEL_PROCEDURE >= g_log_level)) THEN
     trace
      (p_msg      => 'Begin'
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'p_request_id = ' ||p_request_id
      ,p_level    => C_LEVEL_PROCEDURE);
   END IF;

   -- Initializing Global Variables
   g_request_id      := NVL(p_request_id,NVL(g_request_id,xla_environment_pkg.g_req_id));
   g_error_count     := 0;

   -- Call Reset
   reset;

   IF ((g_log_enabled = TRUE) AND (C_LEVEL_PROCEDURE >= g_log_level)) THEN
      trace
       (p_msg      => 'End'
       ,p_level    => C_LEVEL_PROCEDURE);
   END IF;

EXCEPTION
WHEN xla_exceptions_pkg.application_exception THEN
   RAISE;
WHEN OTHERS THEN
   xla_exceptions_pkg.raise_message
       (p_location       => 'xla_amb_setup_err_pkg.initialize');
END initialize;

/*======================================================================+
|                                                                       |
| Public Procedure                                                      |
|                                                                       |
| Stack_Error                                                           |
|                                                                       |
| This routine is called to stack the error into a plsql array          |
|                                                                       |
+======================================================================*/

PROCEDURE stack_error
       (p_message_name               IN  VARCHAR2
       ,p_message_type               IN  VARCHAR2
       ,p_message_category           IN  VARCHAR2
       ,p_category_sequence          IN  NUMBER
       ,p_application_id             IN  NUMBER
       ,p_amb_context_code           IN  VARCHAR2 DEFAULT NULL
       ,p_product_rule_type_code     IN  VARCHAR2 DEFAULT NULL
       ,p_product_rule_code          IN  VARCHAR2 DEFAULT NULL
       ,p_entity_code                IN  VARCHAR2 DEFAULT NULL
       ,p_event_class_code           IN  VARCHAR2 DEFAULT NULL
       ,p_event_type_code            IN  VARCHAR2 DEFAULT NULL
       ,p_line_definition_owner_code IN  VARCHAR2 DEFAULT NULL
       ,p_line_definition_code       IN  VARCHAR2 DEFAULT NULL
       ,p_accounting_line_type_code  IN  VARCHAR2 DEFAULT NULL
       ,p_accounting_line_code       IN  VARCHAR2 DEFAULT NULL
       ,p_description_type_code      IN  VARCHAR2 DEFAULT NULL
       ,p_description_code           IN  VARCHAR2 DEFAULT NULL
       ,p_anal_criterion_type_code   IN  VARCHAR2 DEFAULT NULL
       ,p_anal_criterion_code        IN  VARCHAR2 DEFAULT NULL
       ,p_segment_rule_type_code     IN  VARCHAR2 DEFAULT NULL
       ,p_segment_rule_code          IN  VARCHAR2 DEFAULT NULL
       ,p_mapping_set_code           IN  VARCHAR2 DEFAULT NULL
       ,p_source_application_id      IN  NUMBER   DEFAULT NULL
       ,p_source_type_code           IN  VARCHAR2 DEFAULT NULL
       ,p_source_code                IN  VARCHAR2 DEFAULT NULL
       ,p_extract_object_name        IN  VARCHAR2 DEFAULT NULL
       ,p_extract_object_type        IN  VARCHAR2 DEFAULT NULL
       ,p_accounting_source_code     IN  VARCHAR2 DEFAULT NULL
       ,p_accounting_group_code      IN  VARCHAR2 DEFAULT NULL
       ,p_extract_column_name        IN  VARCHAR2 DEFAULT NULL
       ,p_language                   IN  VARCHAR2 DEFAULT NULL
       ,p_mpa_acct_line_type_code    IN  VARCHAR2 DEFAULT NULL
       ,p_mpa_acct_line_code         IN  VARCHAR2 DEFAULT NULL
       ) IS

    -- Local Variables
   l_amb_context_code        VARCHAR2(30);
   l_product_rule_type_code  VARCHAR2(1);
   l_product_rule_code       VARCHAR2(30);
   l_entity_code             VARCHAR2(30);
   l_event_class_code        VARCHAR2(30);

BEGIN
   g_trace_label :='Stack_error';
   IF ((g_log_enabled = TRUE) AND (C_LEVEL_PROCEDURE >= g_log_level)) THEN
     trace
      (p_msg      => 'Begin'
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'p_application_id = '  ||TO_CHAR(p_application_id)
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'p_amb_context_code = '||p_amb_context_code
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'p_product_rule_type_code = ' ||p_product_rule_type_code
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'p_product_rule_code = ' ||p_product_rule_code
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'p_entity_code = ' ||p_entity_code
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'p_event_class_code = ' ||p_event_class_code
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'p_message_name = ' ||p_message_name
      ,p_level    => C_LEVEL_PROCEDURE);
   END IF;

   l_amb_context_code        := p_amb_context_code;
   l_product_rule_type_code  := p_product_rule_type_code;
   l_product_rule_code       := p_product_rule_code;
   l_entity_code             := p_entity_code;
   l_event_class_code        := p_event_class_code;

   g_error_index    := g_error_index + 1;
   g_error_count    := g_error_count + 1;

   -- Stack Errors in the plsql array

   g_amb_errors(g_error_index).message_name                   := p_message_name;
   g_amb_errors(g_error_index).message_type_flag              := p_message_type;
   g_amb_errors(g_error_index).message_category_code          := p_message_category;
   g_amb_errors(g_error_index).category_sequence_num          := p_category_sequence;
   g_amb_errors(g_error_index).application_id                 := p_application_id;
   g_amb_errors(g_error_index).amb_context_code               := p_amb_context_code;
   g_amb_errors(g_error_index).product_rule_type_code         := p_product_rule_type_code;
   g_amb_errors(g_error_index).product_rule_code              := p_product_rule_code;
   g_amb_errors(g_error_index).line_definition_owner_code     := p_line_definition_owner_code;
   g_amb_errors(g_error_index).line_definition_code           := p_line_definition_code;
   g_amb_errors(g_error_index).accounting_line_type_code      := p_accounting_line_type_code;
   g_amb_errors(g_error_index).accounting_line_code           := p_accounting_line_code;
   g_amb_errors(g_error_index).description_type_code          := p_description_type_code;
   g_amb_errors(g_error_index).description_code               := p_description_code;
   g_amb_errors(g_error_index).analytical_criterion_type_code := p_anal_criterion_type_code;
   g_amb_errors(g_error_index).analytical_criterion_code      := p_anal_criterion_code;
   g_amb_errors(g_error_index).segment_rule_type_code         := p_segment_rule_type_code;
   g_amb_errors(g_error_index).segment_rule_code              := p_segment_rule_code;
   g_amb_errors(g_error_index).entity_code                    := p_entity_code;
   g_amb_errors(g_error_index).event_class_code               := p_event_class_code;
   g_amb_errors(g_error_index).event_type_code                := p_event_type_code;
   g_amb_errors(g_error_index).mapping_set_code               := p_mapping_set_code;
   g_amb_errors(g_error_index).source_application_id          := p_source_application_id;
   g_amb_errors(g_error_index).source_type_code               := p_source_type_code;
   g_amb_errors(g_error_index).source_code                    := p_source_code;
   g_amb_errors(g_error_index).extract_object_name            := p_extract_object_name;
   g_amb_errors(g_error_index).extract_object_type_code       := p_extract_object_type;
   g_amb_errors(g_error_index).accounting_source_code         := p_accounting_source_code;
   g_amb_errors(g_error_index).mapping_group_code             := p_accounting_group_code;
   g_amb_errors(g_error_index).request_id                     := g_request_id;
   g_amb_errors(g_error_index).extract_column_name            := p_extract_column_name;
   g_amb_errors(g_error_index).language                       := p_language;
   g_amb_errors(g_error_index).mpa_accounting_line_type_code  := p_mpa_acct_line_type_code;
   g_amb_errors(g_error_index).mpa_accounting_line_code       := p_mpa_acct_line_code;

   IF ((g_log_enabled = TRUE) AND (C_LEVEL_PROCEDURE >= g_log_level)) THEN
      trace
       (p_msg      => 'End'
       ,p_level    => C_LEVEL_PROCEDURE);
   END IF;

EXCEPTION
WHEN xla_exceptions_pkg.application_exception THEN
   RAISE;
WHEN OTHERS THEN
   xla_exceptions_pkg.raise_message
       (p_location       => 'xla_amb_setup_err_pkg.stack_error');
END stack_error;

/*======================================================================+
|                                                                       |
| Public Procedure                                                      |
|                                                                       |
| Insert_Errors                                                         |
|                                                                       |
| This routine is called at the end of the program to insert all        |
| errors from the plsql array into the error table  and reset the array |
|                                                                       |
+======================================================================*/

PROCEDURE insert_errors IS
BEGIN
   g_trace_label :='Insert_errors';
   IF ((g_log_enabled = TRUE) AND (C_LEVEL_PROCEDURE >= g_log_level)) THEN
     trace
      (p_msg      => 'Begin'
      ,p_level    => C_LEVEL_PROCEDURE);
     trace
      (p_msg      => 'Count of Error Messages in the stack =  '  ||TO_CHAR(g_error_index)
      ,p_level    => C_LEVEL_PROCEDURE);
   END IF;

   IF g_error_index > 0 THEN
      FOR i IN g_amb_errors.FIRST..g_amb_errors.LAST
      LOOP
         INSERT INTO xla_amb_setup_errors
                        (amb_error_id
                        ,message_name
                        ,message_type_flag
                        ,category_sequence_num
                        ,message_category_code
                        ,application_id
                        ,amb_context_code
                        ,product_rule_type_code
                        ,product_rule_code
                        ,entity_code
                        ,event_class_code
                        ,event_type_code
                        ,line_definition_owner_code
                        ,line_definition_code
                        ,accounting_line_type_code
                        ,accounting_line_code
                        ,description_type_code
                        ,description_code
                        ,analytical_criterion_type_code
                        ,analytical_criterion_code
                        ,segment_rule_type_code
                        ,segment_rule_code
                        ,mapping_set_code
                        ,source_application_id
                        ,source_type_code
                        ,source_code
                        ,extract_object_name
                        ,extract_object_type_code
                        ,accounting_source_code
                        ,mapping_group_code
                        ,created_by
                        ,creation_date
                        ,last_update_date
                        ,last_updated_by
                        ,last_update_login
                        ,program_update_date
                        ,program_application_id
                        ,program_id
                        ,request_id
                        ,extract_column_name
                        ,language
                        ,mpa_accounting_line_type_code
                        ,mpa_accounting_line_code)
                 VALUES (xla_amb_setup_errors_s.nextval
                        ,g_amb_errors(i).message_name
                        ,g_amb_errors(i).message_type_flag
                        ,g_amb_errors(i).category_sequence_num
                        ,g_amb_errors(i).message_category_code
                        ,g_amb_errors(i).application_id
                        ,g_amb_errors(i).amb_context_code
                        ,g_amb_errors(i).product_rule_type_code
                        ,g_amb_errors(i).product_rule_code
                        ,g_amb_errors(i).entity_code
                        ,g_amb_errors(i).event_class_code
                        ,g_amb_errors(i).event_type_code
                        ,g_amb_errors(i).line_definition_owner_code
                        ,g_amb_errors(i).line_definition_code
                        ,g_amb_errors(i).accounting_line_type_code
                        ,g_amb_errors(i).accounting_line_code
                        ,g_amb_errors(i).description_type_code
                        ,g_amb_errors(i).description_code
                        ,g_amb_errors(i).analytical_criterion_type_code
                        ,g_amb_errors(i).analytical_criterion_code
                        ,g_amb_errors(i).segment_rule_type_code
                        ,g_amb_errors(i).segment_rule_code
                        ,g_amb_errors(i).mapping_set_code
                        ,g_amb_errors(i).source_application_id
                        ,g_amb_errors(i).source_type_code
                        ,g_amb_errors(i).source_code
                        ,g_amb_errors(i).extract_object_name
                        ,g_amb_errors(i).extract_object_type_code
                        ,g_amb_errors(i).accounting_source_code
                        ,g_amb_errors(i).mapping_group_code
                        ,xla_environment_pkg.g_usr_id
                        ,sysdate
                        ,sysdate
                        ,xla_environment_pkg.g_usr_id
                        ,xla_environment_pkg.g_login_id
                        ,NULL
                        ,xla_environment_pkg.g_prog_appl_id
                        ,xla_environment_pkg.g_prog_id
                        ,g_amb_errors(i).request_id
                        ,g_amb_errors(i).extract_column_name
                        ,g_amb_errors(i).language
                        ,g_amb_errors(i).mpa_accounting_line_type_code
                        ,g_amb_errors(i).mpa_accounting_line_code);
      END LOOP;
   END IF;

   ----------------------------------------------------------------------------
   -- call to reset is made to clear the pl/sql array
   ----------------------------------------------------------------------------
   reset;

   IF ((g_log_enabled = TRUE) AND (C_LEVEL_PROCEDURE >= g_log_level)) THEN
      trace
       (p_msg      => 'End'
       ,p_level    => C_LEVEL_PROCEDURE);
   END IF;

EXCEPTION
WHEN xla_exceptions_pkg.application_exception THEN
   RAISE;
WHEN OTHERS THEN
   xla_exceptions_pkg.raise_message
       (p_location       => 'xla_amb_setup_err_pkg.insert_errors');
END insert_errors;


--=============================================================================
--          *********** private procedures and functions **********
--=============================================================================
--=============================================================================
--
-- Following are the private routines:
--
--    1.    reset
--
--
--=============================================================================

/*======================================================================+
|                                                                       |
| Private Procedure                                                     |
|                                                                       |
| Reset                                                                 |
|                                                                       |
| This routine initializes the plsql array in which errors are stacked  |
| in memory                                                             |
|                                                                       |
+======================================================================*/

PROCEDURE reset IS
BEGIN
   g_trace_label :='Reset';
   IF ((g_log_enabled = TRUE) AND (C_LEVEL_PROCEDURE >= g_log_level)) THEN
     trace
      (p_msg      => 'Begin'
      ,p_level    => C_LEVEL_PROCEDURE);
   END IF;

   g_error_index := 0;
   g_amb_errors.DELETE;

   IF ((g_log_enabled = TRUE) AND (C_LEVEL_PROCEDURE >= g_log_level)) THEN
      trace
       (p_msg      => 'End'
       ,p_level    => C_LEVEL_PROCEDURE);
   END IF;

EXCEPTION
WHEN xla_exceptions_pkg.application_exception THEN
   RAISE;
WHEN OTHERS THEN
   xla_exceptions_pkg.raise_message
       (p_location       => 'xla_amb_setup_err_pkg.reset');
END reset;

-- This is run only the first time when the package is called.
BEGIN

g_log_level     :=  FND_LOG.G_CURRENT_RUNTIME_LEVEL;
g_log_enabled   :=  fnd_log.test
                               (log_level  => g_log_level
                               ,module     => C_DEFAULT_MODULE);

END xla_amb_setup_err_pkg;

/
