--------------------------------------------------------
--  DDL for Package Body FF_WRAPPER_SUP_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."FF_WRAPPER_SUP_PKG" as
/*  $Header: ffwrpsup.pkb 120.0 2005/05/27 23:26:08 appldev noship $ */
----------------
-- Data types --
----------------
type t_range is record
(start_index binary_integer
,end_index   binary_integer
);
type t_range_tbl   is table of t_range index by binary_integer;
type t_ff_info is record
(start_date    date
,std_pkg_name  varchar2(256)
,wrap_pkg_name varchar2(256)
);
type t_ff_info_tbl is table of t_ff_info index by binary_integer;
---------------
-- Constants --
---------------
c_newline constant varchar2(1) := '
';
c_date_format     constant varchar2(10) := 'FXDDMMYYYY';
c_wrap_pkg_prefix constant varchar2(10) := 'FFW';
c_std_pkg_prefix  constant varchar2(10) := 'FFP';
c_package         constant varchar2(32) := 'PACKAGE';
c_package_body    constant varchar2(32) := 'PACKAGE BODY';
c_object_invalid  constant varchar2(32) := 'INVALID';
c_object_valid    constant varchar2(32) := 'VALID';
c_name_replace    constant varchar2(32) := '<NAME>';
c_wrapper_main    constant varchar2(32) := 'FF_WRAPPER_MAIN_PKG';
c_wrapper_name    constant varchar2(32) := 'FF_WRAPPER_PKG';

-- ******************************************************************** --
-- ** WARNING :  DO NOT PUT ANY GLOBAL DATA IN THE GENERATED PACKAGE ** --
-- **            HEADERS AND BODIES                                  ** --
-- ******************************************************************** --

------------------------------------------------------------------------
-- Package state causes problems with package invalidation if the     --
-- formula wrapper is regenerated.                                    --
------------------------------------------------------------------------

------------------------------------------------------------------------------
-- Common package and package body start and end text fragments.
-- 1. CREATE OR REPLACE PACKAGE <NAME> AS
-- 2. CREATE OR REPLACE PACKAGE BODY <NAME> AS
-- 3. -- Generated by Oracle FastFormula - do not delete.
--    -- $Header: ffwrpsup.pkb 120.0 2005/05/27 23:26 appldev noship $
-- 4. END <NAME>;
------------------------------------------------------------------------------
c_package_head_start varchar2(256) :=
'CREATE OR REPLACE PACKAGE <NAME> AS' || c_newline;
c_package_body_start varchar2(256) :=
'CREATE OR REPLACE PACKAGE BODY <NAME> AS' || c_newline;
c_package_comments   varchar2(256) :=
'-- Generated by Oracle FastFormula - do not delete.' || c_newline ||
'-- $Header: ffwrpsup.pkb 120.0 2005/05/27 23:26 appldev noship $' ||
c_newline;
c_package_end varchar2(256) := 'END <NAME>;';
------------------------------------------------------------------------------
-- Procedure begin and end for header and body.
-- 1. ;
-- 2. END FORMULA;
------------------------------------------------------------------------------
c_proc_head_end varchar2(256) := ';' || c_newline;
c_formula_body_end varchar2(256) := 'END FORMULA;' || c_newline;
------------------------------------------------------------------------------
-- FF_WRAPPER_PKG<X> header.
-- CREATE OR REPLACE PACKAGE <NAME> AS
-- -- Generated by Oracle FastFormula - do not delete.
-- -- $Header: ffwrpsup.pkb 120.0 2005/05/27 23:26 appldev noship $
-- PROCEDURE FORMULA
-- (P_FORMULA_NAME    IN            VARCHAR2
-- ,P_FF_PACKAGE_NAME IN            VARCHAR2
-- ,P_D               IN OUT NOCOPY FF_WRAPPER_PKG.T_DATE
-- ,P_N               IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER
-- ,P_T               IN OUT NOCOPY FF_WRAPPER_PKG.T_TEXT
-- ,P_I               IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER
-- ,P_FFERLN          IN OUT NOCOPY NUMBER
-- ,P_FFERCD          IN OUT NOCOPY NUMBER
-- ,P_FFERMT             OUT NOCOPY VARCHAR2
-- );
-- END <NAME>;
------------------------------------------------------------------------------
c_wrapper_formula1 varchar2(256) :=
'  PROCEDURE FORMULA'                                        || c_newline ||
'  (P_FORMULA_NAME    IN VARCHAR2'                           || c_newline ||
'  ,P_FF_PACKAGE_NAME IN VARCHAR2'                           || c_newline;
c_wrapper_formula2 varchar2(256) :=
'  ,P_D               IN OUT NOCOPY FF_WRAPPER_PKG.T_DATE'   || c_newline ||
'  ,P_N               IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER' || c_newline ||
'  ,P_T               IN OUT NOCOPY FF_WRAPPER_PKG.T_TEXT'   || c_newline;
c_wrapper_formula3 varchar2(256) :=
'  ,P_I               IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER' || c_newline ||
'  ,P_FFERLN             OUT NOCOPY NUMBER'                  || c_newline ||
'  ,P_FFERCD          IN OUT NOCOPY NUMBER'                  || c_newline;
c_wrapper_formula4 varchar2(256) :=
'  ,P_FFERMT             OUT NOCOPY VARCHAR2'                || c_newline ||
'  )';
------------------------------------------------------------------------------
-- Start code chunks.
-- CREATE OR REPLACE PACKAGE BODY <NAME> AS
-- -- Generated by Oracle FastFormula - do not delete.
-- -- $Header: ffwrpsup.pkb 120.0 2005/05/27 23:26 appldev noship $
-- BAD_PLSQL EXCEPTION;
-- PRAGMA EXCEPTION_INIT(BAD_PLSQL,-6550);
-- CANNOT_FIND_PROG_UNIT EXCEPTION;
-- PRAGMA EXCEPTION_INIT(CANNOT_FIND_PROG_UNIT, -6508);
--   PROCEDURE FORMULA
--   (P_FORMULA_NAME    IN            VARCHAR2
--   ,P_FF_PACKAGE_NAME IN            VARCHAR2
--   ,P_D               IN OUT NOCOPY FF_WRAPPER_PKG.T_DATE
--   ,P_N               IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER
--   ,P_T               IN OUT NOCOPY FF_WRAPPER_PKG.T_TEXT
--   ,P_I               IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER
--   ,P_FFERLN          IN OUT NOCOPY NUMBER
--   ,P_FFERCD          IN OUT NOCOPY NUMBER
--   ,P_FFERMT             OUT NOCOPY VARCHAR2
--   ) IS
--   L_DEBUG BOOLEAN:=HR_UTILITY.DEBUG_ENABLED;
--   BEGIN
------------------------------------------------------------------------------
c_wrapper_body1 varchar2(256) :=
'  BAD_PLSQL EXCEPTION;'                                 || c_newline ||
'  PRAGMA EXCEPTION_INIT(BAD_PLSQL,-6550);'              || c_newline ||
'  CANNOT_FIND_PROG_UNIT EXCEPTION;'                     || c_newline ||
'  PRAGMA EXCEPTION_INIT(CANNOT_FIND_PROG_UNIT, -6508);' || c_newline;
c_wrapper_body2 varchar2(256) :=
' IS'                                          || c_newline ||
'  L_DEBUG BOOLEAN:=HR_UTILITY.DEBUG_ENABLED;' || c_newline ||
'  BEGIN'                                      || c_newline
;
------------------------------------------------------------------------------
-- No call if-block.
-- Allows a valid wrapper package even when there were no specific formula
-- calls added.
-- IF 1 = 2 THEN
--   NULL;
------------------------------------------------------------------------------
c_nocall_if_block varchar2(256) :=
'    IF 1=2 THEN' || c_newline ||
'      NULL;'     || c_newline;
------------------------------------------------------------------------------
-- End code chunks.
-- This is the attempt to handle a formula that was not compiled
-- when the wrapper was last generated.
--
--      ELSE
--        GOTO FF_DYNAMIC_SQL;
--      END IF;
--      RETURN;
--      <<FF_DYNAMIC_SQL>>
--      FF_WRAPPER_PKG.G_D:=P_D;
--      FF_WRAPPER_PKG.G_N:=P_N;
--      FF_WRAPPER_PKG.G_T:=P_T;
--      FF_WRAPPER_PKG.G_I:=P_I;
--      IF L_DEBUG THEN
--        HR_UTILITY.TRACE
--        ('<NAME> DYNAMIC SQL FOR '||P_FF_PACKAGE_NAME);
--      END IF;
--      EXECUTE IMMEDIATE 'BEGIN ' || P_FF_PACKAGE_NAME || '.FORMULA;END;';
--      P_D:=FF_WRAPPER_PKG.G_D;
--      P_N:=FF_WRAPPER_PKG.G_N;
--      P_T:=FF_WRAPPER_PKG.G_T;
--      P_I:=FF_WRAPPER_PKG.G_I;
--      P_FFERCD:=FF_WRAPPER_PKG.G_FFERCD;
--      P_FFERLN:=FF_WRAPPER_PKG.G_FFERLN;
--      P_FFERMT:=FF_WRAPPER_PKG.G_FFERMT;
--    EXCEPTION
--      WHEN BAD_PLSQL THEN
--        HR_UTILITY.SET_MESSAGE(801,'FFX22J_FORMULA_NOT_FOUND');
--        HR_UTILITY.SET_MESSAGE_TOKEN('1',P_FORMULA_NAME);
--        HR_UTILITY.RAISE_ERROR;
--      WHEN CANNOT_FIND_PROG_UNIT THEN
--        HR_UTILITY.SET_MESSAGE(802, 'FF_33186_GENERATE_WRAPPER');
--        HR_UTILITY.SET_MESSAGE_TOKEN('1',P_FORMULA_NAME);
--        HR_UTILITY.RAISE_ERROR;
--    END FORMULA;
--  END <NAME>;
------------------------------------------------------------------------------
c_end1 varchar2(256) :=
'    ELSE'                                || c_newline ||
'      IF L_DEBUG THEN'                   || c_newline ||
'        HR_UTILITY.TRACE(''ELSE:END'');' || c_newline ||
'      END IF;'                           || c_newline ||
'      GOTO FF_DYNAMIC_SQL;'              || c_newline ||
'    END IF;'                             || c_newline ||
'    RETURN;'                             || c_newline ||
'    <<FF_DYNAMIC_SQL>>'                  || c_newline;
c_end2 varchar2(256) :=
'    FF_WRAPPER_PKG.G_D:=P_D;' || c_newline ||
'    FF_WRAPPER_PKG.G_N:=P_N;' || c_newline ||
'    FF_WRAPPER_PKG.G_T:=P_T;' || c_newline ||
'    FF_WRAPPER_PKG.G_I:=P_I;' || c_newline;
c_end3 varchar2(256) :=
'    IF L_DEBUG THEN' || c_newline ||
'      HR_UTILITY.TRACE' ||
'(''<NAME> DYNAMIC SQL FOR ''||P_FF_PACKAGE_NAME);' ||
c_newline || '    END IF;' || c_newline;
c_end4 varchar2(256) :=
'    EXECUTE IMMEDIATE ''BEGIN '' || P_FF_PACKAGE_NAME || ''.FORMULA;END;'';' ||
c_newline;
c_end5 varchar2(256) :=
'    P_D:=FF_WRAPPER_PKG.G_D;' || c_newline ||
'    P_N:=FF_WRAPPER_PKG.G_N;' || c_newline ||
'    P_T:=FF_WRAPPER_PKG.G_T;' || c_newline ||
'    P_I:=FF_WRAPPER_PKG.G_I;' || c_newline;
c_end6 varchar2(256) :=
'    P_FFERCD:=FF_WRAPPER_PKG.G_FFERCD;' || c_newline ||
'    P_FFERLN:=FF_WRAPPER_PKG.G_FFERLN;' || c_newline ||
'    P_FFERMT:=FF_WRAPPER_PKG.G_FFERMT;' || c_newline ||
'  EXCEPTION' || c_newline;
c_end7 varchar2(256) :=
'    WHEN BAD_PLSQL THEN' || c_newline ||
'      HR_UTILITY.SET_MESSAGE(801,''FFX22J_FORMULA_NOT_FOUND'');'||c_newline||
'      HR_UTILITY.SET_MESSAGE_TOKEN(''1'',P_FORMULA_NAME);'      ||c_newline;
c_end8 varchar2(256) :=
'      HR_UTILITY.RAISE_ERROR;'       || c_newline ||
'    WHEN CANNOT_FIND_PROG_UNIT THEN' || c_newline ||
'      HR_UTILITY.SET_MESSAGE(802,''FF_33186_GENERATE_WRAPPER'');'||c_newline;
c_end9 varchar2(256) :=
'      HR_UTILITY.SET_MESSAGE_TOKEN(''1'',P_FORMULA_NAME);' || c_newline ||
'      HR_UTILITY.RAISE_ERROR;'                             || c_newline ||
'  END FORMULA;'                                            || c_newline;
------------------------------------------------------------------------------
-- FFW package header.
-- CREATE OR REPLACE PACKAGE <PKGNAME> AS
--   -- Generated by Oracle FastFormula - do not delete.
--   -- $Header: ffwrpsup.pkb 120.0 2005/05/27 23:26 appldev noship $
--   PROCEDURE FORMULA
--   (P_D IN OUT NOCOPY FF_WRAPPER_PKG.T_DATE
--   ,P_N IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER
--   ,P_T IN OUT NOCOPY FF_WRAPPER_PKG.T_TEXT
--   ,P_I IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER
--   ,P_FFERLN IN OUT NOCOPY NUMBER
--   ,P_FFERCD IN OUT NOCOPY NUMBER
--   ,P_FFERMT    OUT NOCOPY VARCHAR2
--   );
-- END <PKGNAME>;
--
-- FFW package body.
-- CREATE OR REPLACE PACKAGE BODY <FFWNAME> AS
--   -- Generated by Oracle FastFormula - do not delete.
--   -- $Header: ffwrpsup.pkb 120.0 2005/05/27 23:26 appldev noship $
--   PROCEDURE FORMULA
--   (P_D IN OUT NOCOPY FF_WRAPPER_PKG.T_DATE
--   ,P_N IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER
--   ,P_T IN OUT NOCOPY FF_WRAPPER_PKG.T_TEXT
--   ,P_I IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER
--   ,P_FFERLN IN OUT NOCOPY NUMBER
--   ,P_FFERCD IN OUT NOCOPY NUMBER
--   ,P_FFERMT    OUT NOCOPY VARCHAR2
--   ) IS
--   BEGIN
--     <FFPNAME>.FORMULA
--     (P_D,P_N,P_T,P_I,P_FFERLN,P_FFERCD,P_FFERMT);
--   END FORMULA;
-- END <FFWNAME>;
------------------------------------------------------------------------------
c_ffw_formula constant varchar2(512) :=
'  PROCEDURE FORMULA'                                   || c_newline ||
'  (P_D IN OUT NOCOPY FF_WRAPPER_PKG.T_DATE'            || c_newline ||
'  ,P_N IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER'          || c_newline ||
'  ,P_T IN OUT NOCOPY FF_WRAPPER_PKG.T_TEXT'            || c_newline ||
'  ,P_I IN OUT NOCOPY FF_WRAPPER_PKG.T_NUMBER'          || c_newline ||
'  ,P_FFERLN IN OUT NOCOPY NUMBER'                      || c_newline ||
'  ,P_FFERCD IN OUT NOCOPY NUMBER'                      || c_newline ||
'  ,P_FFERMT    OUT NOCOPY VARCHAR2'                    || c_newline ||
'  )';
c_ffw_formula_body constant varchar2(256) :=
' IS' || c_newline || '  BEGIN' || c_newline || '    <NAME>.FORMULA' ||
c_newline || '    (P_D,P_N,P_T,P_I,P_FFERLN,P_FFERCD,P_FFERMT);' ||
c_newline;

-- ******************************************************************** --
-- ** WARNING :  DO NOT PUT ANY GLOBAL DATA IN THE GENERATED PACKAGE ** --
-- **            HEADERS AND BODIES                                  ** --
-- ******************************************************************** --

----------------------
-- Global Variables --
----------------------
--
-- Max number of formulas per wrapper (should be a square number).
--
g_formula_limit number := 576;
---------------------------- start_wrapper_body ------------------------------
--
-- Begin the wrapper body.
--
procedure start_wrapper_body
(p_pkg_name in            varchar2
,p_chunks   in out nocopy dbms_sql.varchar2s
) is
l_index binary_integer;
begin
  l_index := p_chunks.count + 1;
  p_chunks(l_index) :=
  replace(c_package_body_start, c_name_replace, p_pkg_name);
  l_index := l_index + 1;
  p_chunks(l_index) := c_package_comments;
  l_index := l_index + 1;
  p_chunks(l_index) := c_wrapper_body1;
  l_index := l_index + 1;
  p_chunks(l_index) := c_wrapper_formula1;
  l_index := l_index + 1;
  p_chunks(l_index) := c_wrapper_formula2;
  l_index := l_index + 1;
  p_chunks(l_index) := c_wrapper_formula3;
  l_index := l_index + 1;
  p_chunks(l_index) := c_wrapper_formula4;
  l_index := l_index + 1;
  p_chunks(l_index) := c_wrapper_body2;
end start_wrapper_body;
---------------------------- end_wrapper_body --------------------------------
--
-- End the wrapper body.
--
procedure end_wrapper_body
(p_package_name in           varchar2
,p_calls_added  in            boolean
,p_chunks       in out nocopy dbms_sql.varchar2s
) is
l_index binary_integer;
begin
  l_index := p_chunks.count + 1;
  --
  -- If no calls were added then it's necessary to add the no-call if-block.
  --
  if not p_calls_added then
    p_chunks(l_index) := c_nocall_if_block;
    l_index := l_index + 1;
  end if;
  p_chunks(l_index) := c_end1;
  l_index := l_index + 1;
  p_chunks(l_index) := c_end2;
  l_index := l_index + 1;
  p_chunks(l_index) :=
  replace(c_end3, c_name_replace, p_package_name);
  l_index := l_index + 1;
  p_chunks(l_index) := c_end4;
  l_index := l_index + 1;
  p_chunks(l_index) := c_end5;
  l_index := l_index + 1;
  p_chunks(l_index) := c_end6;
  l_index := l_index + 1;
  p_chunks(l_index) := c_end7;
  l_index := l_index + 1;
  p_chunks(l_index) := c_end8;
  l_index := l_index + 1;
  p_chunks(l_index) := c_end9;
  l_index := l_index + 1;
  p_chunks(l_index) :=
  replace(c_package_end, c_name_replace, p_package_name);
end end_wrapper_body;
----------------------------- drop_package -----------------------------------
--
-- Drop a formula package.
--
procedure drop_package
(p_package_name in varchar2
,p_body         in boolean  default false
) is
l_body varchar2(32) := ' ';
begin
  if p_body then
    l_body := ' BODY ';
  end if;
  execute immediate 'DROP PACKAGE' || l_body ||  p_package_name;
end drop_package;
-------------------------- core_create_ffw_body ------------------------------
procedure core_create_ffw_body
(p_wrapper_pkg_name  in varchar2
,p_standard_pkg_name in varchar2
) is
l_text varchar2(8192);
begin
  l_text :=
  replace(c_package_body_start, c_name_replace, p_wrapper_pkg_name) ||
  c_package_comments ||
  c_ffw_formula ||
  replace(c_ffw_formula_body, c_name_replace, p_standard_pkg_name) ||
  replace(c_formula_body_end, c_name_replace, p_wrapper_pkg_name) ||
  replace(c_package_end, c_name_replace, p_wrapper_pkg_name);
  execute immediate l_text;
end core_create_ffw_body;
-------------------------- create_specific_wrapper ---------------------------
--
-- Create the formula-specific FFW wrapper package.
--
procedure create_specific_wrapper
(p_wrapper_pkg_name  in varchar2
,p_standard_pkg_name in varchar2
) is
l_text   varchar2(8192);
l_header boolean := false;
l_status varchar2(32);
--
-- Cursor to check the status of the package body.
--
cursor csr_pkg_status(p_package_name in varchar2) is
select status
from   user_objects o
where  o.object_name = p_package_name
and    o.object_type = c_package_body
;
begin
  --
  -- 0. Check if the wrapper needs to be generated.
  --
  open csr_pkg_status(p_package_name => p_wrapper_pkg_name);
  fetch csr_pkg_status
  into  l_status
  ;
  if l_status = c_object_valid then
    --
    -- The package body is valid so there is no need to generate it again.
    --
    close csr_pkg_status;
    return;
  end if;
  close csr_pkg_status;
  --
  -- 1. Build and generate the header.
  --
  l_text :=
  replace(c_package_head_start, c_name_replace, p_wrapper_pkg_name) ||
  c_package_comments ||
  c_ffw_formula ||
  c_proc_head_end ||
  replace(c_package_end, c_name_replace, p_wrapper_pkg_name);
  execute immediate l_text;
  l_header := true;
  --
  -- 2. Build and generate the body.
  --
  core_create_ffw_body
  (p_wrapper_pkg_name  => p_wrapper_pkg_name
  ,p_standard_pkg_name => p_standard_pkg_name
  );
exception
  when others then
    if csr_pkg_status%isopen then
      close csr_pkg_status;
    end if;
    --
    if l_header then
      drop_package(p_package_name => p_wrapper_pkg_name);
    end if;
    hr_utility.set_message(800, 'FF_34999_WRAPPER_GEN_ERROR');
    hr_utility.set_message_token('PACKAGE', p_wrapper_pkg_name);
    hr_utility.raise_error;
end create_specific_wrapper;
--------------------------- create_ffw_body ----------------------------------
procedure create_ffw_body
(p_wrapper_pkg_name  in varchar2
,p_standard_pkg_name in varchar2
,p_keep_package      in varchar2 default 'N'
) is
l_header boolean := false;
l_body   boolean := false;
l_dummy  varchar2(1);
--
-- Cursor to check the status of the package.
--
cursor csr_pkg_status(p_package_name in varchar2) is
select o.status
,      o.object_type
from   user_objects o
where  o.object_name = p_package_name
;
--
-- Cursor to check if the package body exists.
--
cursor csr_body_exists(p_package_name in varchar2) is
select null
from   user_objects o
where  o.object_name = p_package_name
and    o.object_type = c_package_body
;
begin
  --
  -- See if the ffw package already exists.
  --
  for crec in csr_pkg_status(p_package_name => p_wrapper_pkg_name) loop
    --
    -- Looking for a valid header.
    --
    if crec.status = c_object_valid and crec.object_type = c_package then
      l_header := true;
    --
    -- Just acknowledge the presence of the package body. It is bound to be
    -- invalid in this session if the formula just has been recompiled. Unless
    -- there is a problem with the wrapper code itself there is no need to
    -- regenerate the package body or run ALTER PACKAGE ... COMPILE BODY
    -- on it. In such a case, it's best for the wrapper to get regenerated.
    --
    elsif crec.object_type = c_package_body then
      l_body := true;
    end if;
  end loop;
  --
  -- Create the body only if there is a valid header, but no valid body.
  -- This corresponds to the case where the packages were dropped due
  -- to an earlier compilation error.
  --
  if l_header and not l_body then
    begin
      core_create_ffw_body
      (p_wrapper_pkg_name  => p_wrapper_pkg_name
      ,p_standard_pkg_name => p_standard_pkg_name
      );
    exception
      when others then
        --
        -- Drop the package body if it was created with problems.
        --
        if upper(p_keep_package) = 'N' then
          open csr_body_exists(p_package_name => p_wrapper_pkg_name);
          fetch csr_body_exists into l_dummy;
          if csr_body_exists%found then
            drop_package(p_package_name => p_wrapper_pkg_name, p_body => true);
          end if;
          close csr_body_exists;
        end if;
        raise;
    end;
  end if;
exception
  when others then
    if csr_body_exists%isopen then
      close csr_body_exists;
    end if;
    raise;
end create_ffw_body;
------------------------------ genintercall ----------------------------------
--
-- Generate table-based interface FORMULA call for a given formula package.
--
procedure genintercall
(p_package_name in            varchar2
,p_chunk2          out nocopy varchar2
,p_chunk1          out nocopy varchar2
) is
l_prefix varchar2(32);
begin
  l_prefix := '      ';
  --
  p_chunk1 :=
  l_prefix || 'IF L_DEBUG THEN' || c_newline ||
  l_prefix || '  HR_UTILITY.TRACE(''CALL INTO ' || p_package_name || ''');'
  || c_newline ||
  l_prefix || 'END IF;' || c_newline;
  p_chunk2 :=
  l_prefix || p_package_name || '.FORMULA' || c_newline ||
  l_prefix || '(P_FORMULA_NAME,P_FF_PACKAGE_NAME,P_D,P_N,P_T,P_I,P_FFERLN' ||
  c_newline || l_prefix || ',P_FFERCD,P_FFERMT);' || c_newline;
end genintercall;
-------------------------------- gencall -------------------------------------
--
-- Generate table-based interface FORMULA call for a given formula package.
--
procedure gencall
(p_first    in            boolean
,p_indent   in            boolean  default false
,p_std_pkg  in            varchar2
,p_wrap_pkg in            varchar2
,p_chunk1      out nocopy varchar2
,p_chunk2      out nocopy varchar2
) is
l_prefix varchar2(32);
l_spaces varchar2(10);
begin
  if p_first then
    l_prefix := '    IF ';
  else
    l_prefix := '    ELSIF ';
  end if;
  --
  if p_indent then
    l_spaces := '  ';
  end if;
  --
  p_chunk1 := l_spaces ||
  l_prefix || 'P_FF_PACKAGE_NAME=''' || p_std_pkg || ''' THEN' || c_newline;
  p_chunk2 := l_spaces ||
  '      ' || p_wrap_pkg || '.FORMULA' || c_newline || l_spaces ||
  '      (P_D,P_N,P_T,P_I,P_FFERLN,P_FFERCD,P_FFERMT);' || c_newline;
end gencall;
------------------------------ gencallend ------------------------------------
--
-- Generate table-based the end of IF-statement for gencallend.
--
procedure gencallend
(p_where in            number
,p_chunk    out nocopy varchar2
) is
begin
  p_chunk :=
  '      ELSE'                                              || c_newline ||
  '        IF L_DEBUG THEN'                                 || c_newline ||
  '          HR_UTILITY.TRACE(''ELSE:' || p_where || ''');' || c_newline ||
  '        END IF;'                                         || c_newline ||
  '        GOTO FF_DYNAMIC_SQL;'                            || c_newline ||
  '      END IF;'                                           || c_newline;
end gencallend;
----------------------------- genrangeif ------------------------------------
--
-- Generate table-based interface FORMULA call for a given formula package.
--
procedure genrangeif
(p_first       in            boolean
,p_range_start in            varchar2
,p_range_end   in            varchar2
,p_chunk          out nocopy varchar2
) is
l_prefix varchar2(32);
begin
  if p_first then
    l_prefix := '    IF ';
  else
    l_prefix := '    ELSIF ';
  end if;
  --
  p_chunk :=
  l_prefix || 'P_FF_PACKAGE_NAME BETWEEN' || c_newline ||
  '      ''' || p_range_start || ''' AND ''' || p_range_end || ''' THEN' ||
  c_newline;
end genrangeif;
--------------------------- check_std_package --------------------------------
--
-- Check if the standard (FFP) formula package's body is valid. If not then
-- set P_ADD_TO_TABLE to FALSE. Otherwise, set P_ADD_TO_TABLE to TRUE.
--
procedure check_std_package
(p_package_name in            varchar2
,p_add_to_table in out nocopy boolean
) is
l_status varchar2(32);
--
cursor csr_pkg_status(p_package_name in varchar2) is
select status
from   user_objects o
where  o.object_name = p_package_name
and    o.object_type = c_package_body
;
begin
  open csr_pkg_status(p_package_name => p_package_name);
  fetch csr_pkg_status into l_status;
  --
  -- No longer dropping the package body.
  --
  close csr_pkg_status;
  p_add_to_table := (l_status = c_object_valid);
end check_std_package;
----------------------------- check_compile ----------------------------------
--
-- Check that the compiled package body is valid.
--
procedure check_compile
(p_package_name in varchar2
) is
cursor csr_check_compile
(p_package_name in varchar2
) is
select status
from   user_objects uo
where  uo.object_name = p_package_name
and    uo.object_type = c_package_body;
l_status varchar2(64);
begin
  open csr_check_compile(p_package_name);
  fetch csr_check_compile into l_status;
  close csr_check_compile;
  if upper(l_status) <> c_object_valid then
    hr_utility.set_message(800, 'FF_34999_WRAPPER_GEN_ERROR');
    hr_utility.set_message_token('PACKAGE', p_package_name);
    hr_utility.raise_error;
  end if;
exception
  when others then
    if csr_check_compile%isopen then
      close csr_check_compile;
    end if;
    raise;
end check_compile;
------------------------------ generate_body  --------------------------------
--
-- Generate the body for a wrapper package
-- FF_WRAPPER_MAIN_PKG, FF_WRAPPER_PKG<N>
--
procedure generate_body
(p_wrapper_name  in varchar2
,p_ff_info_tbl   in t_ff_info_tbl
,p_wrap_info     in t_range_tbl
,p_wrapper_num in varchar2
,p_intermediates in boolean
) is
l_debug        boolean := hr_utility.debug_enabled;
l_chunks       dbms_sql.varchar2s;
l_chunk_index  binary_integer := 1;
l_range_start  boolean;
l_range_size   number;
l_end_range    number;
l_branches     number;
l_start_index  binary_integer;
l_end_index    binary_integer;
l_saved_count  binary_integer;
l_indent       boolean;
l_csr_sql      integer;
l_rows         number;
l_generated    boolean := false;
begin
  if l_debug then
    hr_utility.trace('Enter:generate_body:'||p_wrapper_name);
  end if;

  --------------------------------
  -- A. Start the wrapper body. --
  --------------------------------
  start_wrapper_body
  (p_pkg_name => p_wrapper_name
  ,p_chunks   => l_chunks
  );
  l_saved_count  := l_chunks.count;

  -----------------------------------------
  -- B. Package body with intermediates. --
  -----------------------------------------
  l_chunk_index := l_chunks.count + 1;
  if p_intermediates then
    if l_debug then
      hr_utility.trace
      ('Generating calls to intermediate wrapper packages.');
    end if;

    for i in 1 .. p_wrap_info.count loop
      --
      -- 1. Generate the range IF-statement.
      --
      if l_debug then
        hr_utility.trace
        ('Range:'||p_wrap_info(i).start_index||'-'||p_wrap_info(i).end_index);
      end if;

      genrangeif
      (p_first       => i = 1
      ,p_range_start =>
       p_ff_info_tbl(p_wrap_info(i).start_index).std_pkg_name
      ,p_range_end   =>
       p_ff_info_tbl(p_wrap_info(i).end_index).std_pkg_name
      ,p_chunk       => l_chunks(l_chunk_index)
      );
      l_chunk_index := l_chunk_index + 1;

      --
      -- 2. Generate the intermediate package call.
      --
      if l_debug then
        hr_utility.trace('Call:'||c_wrapper_name||to_char(i));
      end if;

      genintercall
      (p_package_name => c_wrapper_name || to_char(i)
      ,p_chunk1       => l_chunks(l_chunk_index)
      ,p_chunk2       => l_chunks(l_chunk_index + 1)
      );
      l_chunk_index := l_chunk_index + 2;
    end loop;

  --------------------------------------------
  -- C. Package body without intermediates. --
  --------------------------------------------
  elsif p_ff_info_tbl.count <> 0 then
    -------------------------------------------------
    -- 1. Work out the range size for indirection. --
    -------------------------------------------------
    if l_debug then
      hr_utility.trace('Generating direct calls to formula packages.');
    end if;

    l_start_index := p_wrap_info(p_wrapper_num).start_index;
    l_end_index := p_wrap_info(p_wrapper_num).end_index;
    l_branches := 1 + l_end_index - l_start_index;
    --
    -- Too few formulas to bother with indirection.
    --
    if l_branches < 9 then
      l_range_size := 1;
    --
    -- Use a range size of SQRT(# of branches).
    --
    else
      l_range_size := trunc(sqrt(l_branches));
      if l_range_size * l_range_size <> l_branches then
        l_range_size := l_range_size + 1;
      end if;
    end if;

    if l_debug then
      hr_utility.trace
      ('Branches:'||l_branches||' Range Size:'||l_range_size);
      hr_utility.trace
      ('Generating for formulas:'||l_start_index||'-'||l_end_index);
    end if;

    -----------------------------------------------------------------
    -- 2. Loop through the formulas to generate the IF-statements. --
    -----------------------------------------------------------------
    for i in l_start_index .. l_end_index loop

      -----------------------------------------------------------
      -- Common case i.e. where the outer IF-statement will be --
      -- generated.                                            --
      -----------------------------------------------------------
      if l_range_size <> 1 then
        --
        -- Generate the outer IF-statement for the start of a range.
        --
        l_range_start := mod(i - l_start_index + 1, l_range_size) = 1;
        if l_range_start then
          --
          -- Where does the range end ?
          --
          l_end_range := i + l_range_size - 1;
          if l_end_range > l_end_index then
            l_end_range :=  l_end_index;
          end if;

          if l_debug then
            hr_utility.trace('Outer IF-range:'||i||'-'||l_end_range);
          end if;

          --
          -- Generate the IF-statement.
          --
          genrangeif
          (p_first       => i = l_start_index
          ,p_range_start => p_ff_info_tbl(i).std_pkg_name
          ,p_range_end   => p_ff_info_tbl(l_end_range).std_pkg_name
          ,p_chunk       => l_chunks(l_chunk_index)
          );
          l_chunk_index := l_chunk_index + 1;
        end if;

        --
        -- Indentation required for two-level IF-statement.
        --
        l_indent := true;

      ------------------------------------------------------
      -- With a range size of 1, just generating a single --
      -- IF-statement for all formulas.                   --
      ------------------------------------------------------
      else
        l_range_start := i = l_start_index;
        l_indent := false;
      end if;

      -----------------------------------------
      -- Generate the formula-specific call. --
      -----------------------------------------
      gencall
      (p_first    => l_range_start
      ,p_indent   => l_indent
      ,p_std_pkg  => p_ff_info_tbl(i).std_pkg_name
      ,p_wrap_pkg => p_ff_info_tbl(i).wrap_pkg_name
      ,p_chunk1   => l_chunks(l_chunk_index)
      ,p_chunk2   => l_chunks(l_chunk_index + 1)
      );
      l_chunk_index := l_chunk_index + 2;

      -----------------------------------------------------
      -- Terminate inner part of two-level IF-statement. --
      -----------------------------------------------------
      if l_range_size <> 1 then
        if i = l_end_range then
          gencallend
          (p_where => ceil(l_end_range / l_range_size)
          ,p_chunk => l_chunks(l_chunk_index)
          );
          l_chunk_index := l_chunk_index + 1;
        end if;
      end if;

    end loop;
  end if;

  -------------------------------------------------------
  -- D. Generate the rest of the main wrapper package. --
  -------------------------------------------------------
  end_wrapper_body
  (p_package_name => p_wrapper_name
  ,p_calls_added  => l_saved_count <> l_chunks.count
  ,p_chunks       => l_chunks
  );

  -----------------------------------------------------------
  -- E. Execute the generated SQL. Don't insert linefeeds. --
  -----------------------------------------------------------
  if l_debug then
    hr_utility.trace('Text complete, create package body...');
  end if;

  begin
    l_csr_sql := dbms_sql.open_cursor;
    dbms_sql.parse
    (l_csr_sql, l_chunks, 1, l_chunks.count, false, dbms_sql.native);
    l_rows := dbms_sql.execute(l_csr_sql);
    dbms_sql.close_cursor(l_csr_sql);
  exception
    when others then
      if dbms_sql.is_open(l_csr_sql) then
        dbms_sql.close_cursor(l_csr_sql);
      end if;
      raise;
  end;
  l_generated := true;

  ------------------------------------
  -- F. Check the compiled package. --
  ------------------------------------
  check_compile(p_package_name => p_wrapper_name);

  if l_debug then
    hr_utility.trace('Leaving:generate_body');
  end if;

exception
  when others then
    if l_debug then
      hr_utility.trace
      ('Leaving generate_body with error:' || sqlcode || ':' || sqlerrm);
    end if;

    if l_generated then
      drop_package(p_package_name => p_wrapper_name, p_body => true);
    end if;
    raise;
end generate_body;
---------------------------- process_compiled --------------------------------
--
-- Process the compiled formulas. For each compiled formula with a valid
-- standard (FFP) formula package the following are done:
-- * Entries created in the range and information tables.
-- * The specific (FFW) formula package is created.
-- * The text for the main (FF_WRAPPER_MAIN_PKG) wrapper package is generated.
-- * The intermediate (FF_WRAPPER_PKG<N>) wrapper package headers and bodies
--   are generated.
--
procedure process_compiled
(p_range_tbl   in out nocopy t_range_tbl
,p_ff_info_tbl in out nocopy t_ff_info_tbl
) is
l_debug       boolean := hr_utility.debug_enabled;
l_info_index  number := 1;
l_add_to_tbl  boolean;
l_wrap_info   t_range_tbl;
l_wrapper_num number := 0;
l_text        varchar2(8192);
l_wrap_name   varchar2(256);
l_header_done boolean;
l_wrap_delno  number;
l_dummy       varchar2(1);
--
-- FF information cursor for compiled formulas. The query is ordered by the
-- FFP package name. This ordering is necessary because the generated IF-block
-- will look BETWEEN a start and end package name.
--
cursor csr_get_ff_info is
select ff.formula_id
,      ff.effective_start_date start_date
,      c_std_pkg_prefix || to_char(ff.formula_id) || '_' ||
       to_char(ff.effective_start_date, c_date_format) std_pkg_name
,      c_wrap_pkg_prefix || to_char(ff.formula_id) || '_' ||
       to_char(ff.effective_start_date, c_date_format) wrap_pkg_name
from   ff_formulas_f ff
,      ff_compiled_info_f fci
where  fci.formula_id = ff.formula_id
and    fci.effective_start_date = ff.effective_start_date
order  by 3
;
--
-- Confirm that a package exists and is valid.
--
cursor csr_package_exists(p_package_name in varchar2) is
select null
from   user_objects uo
where  uo.object_name = p_package_name
and    uo.object_type = c_package
and    uo.status = c_object_valid
;
--
-- Cursor to get the name of the wrapper packages.
--
cursor csr_wrap_pkgs(p_wrapper_name in varchar2) is
select uo.object_name
from   user_objects uo
where  uo.object_name like p_wrapper_name
and    uo.object_type = c_package
;
begin
  if l_debug then
    hr_utility.trace('Entering:process_compiled');
  end if;
  --------------------------------------------------
  -- A. Read in the compiled formula information. --
  --------------------------------------------------
  if l_debug then
    hr_utility.trace('Set-up formula information tables...');
  end if;

  for crec in csr_get_ff_info loop
    l_add_to_tbl := true;
    --
    -- Has the formula got a valid standard (FFP) package ?
    --
    check_std_package
    (p_package_name => crec.std_pkg_name
    ,p_add_to_table => l_add_to_tbl
    );
    if l_add_to_tbl then
      --
      -- 1. Update range and information tables.
      --
      if not p_range_tbl.exists(crec.formula_id) then
        p_range_tbl(crec.formula_id).start_index := l_info_index;
      end if;
      --
      p_range_tbl(crec.formula_id).end_index := l_info_index;
      p_ff_info_tbl(l_info_index).start_date := crec.start_date;
      p_ff_info_tbl(l_info_index).std_pkg_name := crec.std_pkg_name;
      p_ff_info_tbl(l_info_index).wrap_pkg_name := crec.wrap_pkg_name;
      --
      -- 2. Create formula-specific wrapper package.
      --
      create_specific_wrapper
      (p_wrapper_pkg_name  => crec.wrap_pkg_name
      ,p_standard_pkg_name => crec.std_pkg_name
      );
      --
      -- 3. Update the wrapper package information.
      --
      if mod(l_info_index, g_formula_limit) = 1 then
        l_wrapper_num := l_wrapper_num + 1;
        l_wrap_info(l_wrapper_num).start_index := l_info_index;
      end if;
      l_wrap_info(l_wrapper_num).end_index := l_info_index;
      --
      -- 4. Increment index for the information table.
      --
      l_info_index := l_info_index + 1;
    end if;
  end loop;

  if l_debug then
    hr_utility.trace('Formula information tables set-up complete.');
  end if;

  ---------------------------------------------------------------
  -- B. Generate the main wrapper body, and, if necessary, the --
  --    intermediate wrapper packages.                         --
  ---------------------------------------------------------------
  --
  -- If only one wrapper is sufficient then just generate the
  -- main wrapper body.
  --
  if l_wrap_info.count > 1 then
    if l_debug then
      hr_utility.trace('Intermediate wrappers need to be generated.');
    end if;

    for i in 1 .. l_wrap_info.count loop
      l_header_done := false;
      l_wrap_name :=  c_wrapper_name || to_char(i);

      if l_debug then
        hr_utility.trace('Generating intermediate wrapper:' || l_wrap_name);
      end if;

      --
      -- Generate the package headers.
      --
      open csr_package_exists(p_package_name => l_wrap_name);
      fetch csr_package_exists into l_dummy;

      if csr_package_exists%notfound then
        if l_debug then
          hr_utility.trace('Generate header:' || l_wrap_name);
        end if;

        l_text :=
        replace(c_package_head_start, c_name_replace, l_wrap_name) ||
        c_package_comments ||
        c_wrapper_formula1 || c_wrapper_formula2 || c_wrapper_formula3 ||
        c_wrapper_formula4 ||
        c_proc_head_end ||
        replace(c_package_end, c_name_replace, l_wrap_name);
        execute immediate l_text;
        l_header_done := true;
      else
        if l_debug then
          hr_utility.trace('Did not generate header:' || l_wrap_name);
        end if;
      end if;

      close csr_package_exists;
      --
      -- Generate the package bodies.
      --
      generate_body
      (p_wrapper_name  => l_wrap_name
      ,p_ff_info_tbl   => p_ff_info_tbl
      ,p_wrap_info     => l_wrap_info
      ,p_wrapper_num   => i
      ,p_intermediates => false
      );
    end loop;

    l_header_done := false;
    l_wrap_delno := l_wrap_info.count + 1;

    --
    -- Generate the main package body with intermediates.
    --
    if l_debug then
      hr_utility.trace
      ('Generate main wrapper body with intermediate wrapper calls.');
    end if;

    generate_body
    (p_wrapper_name  => c_wrapper_main
    ,p_ff_info_tbl   => p_ff_info_tbl
    ,p_wrap_info     => l_wrap_info
    ,p_wrapper_num   => null
    ,p_intermediates => true
    );
  else
    --
    -- Generate the main package body without intermediates.
    --
    if l_debug then
      hr_utility.trace('Generate main wrapper body with direct formula calls.');
    end if;

    generate_body
    (p_wrapper_name  => c_wrapper_main
    ,p_ff_info_tbl   => p_ff_info_tbl
    ,p_wrap_info     => l_wrap_info
    ,p_wrapper_num   => 1
    ,p_intermediates => false
    );

    l_wrap_delno := 1;
  end if;

  --------------------------------------------
  -- C. Delete extraneous wrapper packages. --
  --------------------------------------------
  for crec in csr_wrap_pkgs(p_wrapper_name => c_wrapper_name || '%') loop
    begin
      l_wrapper_num :=
      to_number(replace(crec.object_name,c_wrapper_name,null));
      if l_wrapper_num >= l_wrap_delno then
        if l_debug then
          hr_utility.trace
          ('Dropping unused wrapper package:' || crec.object_name);
        end if;
        drop_package(p_package_name => crec.object_name);
      end if;
    exception
      --
      -- This package name could not have been in the correct format.
      --
      when others then
        null;
    end;
  end loop;

  if l_debug then
    hr_utility.trace('Leaving:process_compiled');
  end if;
exception
  when others then
    if l_debug then
      hr_utility.trace
      ('Leaving process_compiled with error:' || sqlcode || ':' || sqlerrm);
    end if;

    if l_header_done then
      drop_package(p_package_name => l_wrap_name);
    end if;

    if csr_package_exists%isopen then
      close csr_package_exists;
    end if;

    raise;
end process_compiled;
---------------------------- parse_pkg_name ----------------------------------
-- Parse a potential formula-generated package name to extract the formula_id
-- and start date. Format being parsed is:
-- FFP<formula_id>_<start_date in DDMMYYYY format>
--
procedure parse_pkg_name
(p_package_name in            varchar2
,p_is_ff_name      out nocopy boolean
,p_formula_id      out nocopy number
,p_start_date      out nocopy date
) is
l_underscore_pos number;
begin
  --
  -- 1. Look for the '_', the search starts after the initial FFP. Check
  --    that there is no possibility of a null formula_id or short date part.
  --
  l_underscore_pos := instr(p_package_name, '_', 1, 1);
  if l_underscore_pos <= 4 or l_underscore_pos > length(p_package_name) - 8 then
    p_is_ff_name := false;
    return;
  end if;
  --
  -- 2. Get the formula_id.
  --
  begin
    p_formula_id := to_number(substr(p_package_name, 4, l_underscore_pos - 4));
  exception
    when others then
      p_is_ff_name := false;
      return;
  end;
  --
  -- 3. Get the date part.
  --
  begin
    p_start_date :=
    to_date(substr(p_package_name, l_underscore_pos + 1), c_date_format);
  exception
    when others then
      p_is_ff_name := false;
      return;
  end;
  --
  -- It is an FF package name.
  --
  p_is_ff_name := true;
end parse_pkg_name;
---------------------------- has_compiled_info -------------------------------
--
-- Check whether or not a particular formula can be found in the compiled
-- information tables.
--
function has_compiled_info
(p_formula_id   in number
,p_start_date   in date
,p_range_tbl    in t_range_tbl
,p_ff_info_tbl  in t_ff_info_tbl
) return boolean is
--
l_has_compiled_info varchar2(10);
--
cursor csr_compiled_info
(p_formula_id in number
,p_start_date in date
) is
select 'Y'
from   ff_compiled_info_f fci
where  fci.formula_id = p_formula_id
and    fci.effective_start_date = p_start_date
;
begin
  if p_range_tbl.exists(p_formula_id) then
    for i in p_range_tbl(p_formula_id).start_index ..
             p_range_tbl(p_formula_id).end_index loop
      if p_start_date = p_ff_info_tbl(i).start_date then
        return true;
      end if;
    end loop;
  end if;
  --
  -- Now check to see if there was compiled information present but the
  -- formula was omitted from the range table because the package was
  -- invalid. Don't delete such formulas for the sake of consistency.
  --
  open csr_compiled_info
       (p_formula_id => p_formula_id
       ,p_start_date => p_start_date
       );
  fetch csr_compiled_info into l_has_compiled_info;
  if csr_compiled_info%notfound then
    l_has_compiled_info := 'N';
  end if;
  close csr_compiled_info;
  return l_has_compiled_info = 'Y';
end has_compiled_info;
---------------------------- process_orphans ---------------------------------
--
-- Go through the FF standard (FFP) and wrapper (FFW) packages looking for
-- orphans. Orphaned packages are those that cannot be in the compiled
-- information tables and are dropped.
--
procedure process_orphans
(p_range_tbl in t_range_tbl
,p_ff_info_tbl in t_ff_info_tbl
) is
c_wrap_package constant number := 1;
c_std_package  constant number := 2;
l_debug        boolean := hr_utility.debug_enabled;
l_prefix       varchar2(16);
l_formula_id   number;
l_is_ff_name   boolean;
l_start_date   date;
--
cursor csr_ff_package_names(p_prefix in varchar2) is
select uo.object_name
from   user_objects uo
where  uo.object_name like p_prefix
and    uo.object_type = c_package
order  by uo.object_name;
begin
  if l_debug then
    hr_utility.trace('Entering:process_orphans');
  end if;

  for package_type in c_wrap_package .. c_std_package loop
    --
    -- Iteration 1: FFW
    -- Iteration 2: FFP
    --
    if package_type = c_std_package then
      l_prefix := c_std_pkg_prefix || '%';
    else
      l_prefix := c_wrap_pkg_prefix || '%';
    end if;

    for crec in csr_ff_package_names(p_prefix => l_prefix) loop
      --
      -- 1. Is it a formula package ?
      --
      parse_pkg_name
      (p_package_name => crec.object_name
      ,p_is_ff_name   => l_is_ff_name
      ,p_formula_id   => l_formula_id
      ,p_start_date   => l_start_date
      );
      if l_is_ff_name then
        --
        -- 2. Is it an orphan ?
        --
        if not has_compiled_info
               (p_formula_id  => l_formula_id
               ,p_start_date  => l_start_date
               ,p_range_tbl   => p_range_tbl
               ,p_ff_info_tbl => p_ff_info_tbl
               )
        then
          --
          -- 3. Drop orphaned package.
          --
          if l_debug then
            hr_utility.trace
            ('Deleting orphaned FF package:' || crec.object_name);
          end if;

          drop_package(p_package_name => crec.object_name);
        end if;
      end if;
    end loop;
  end loop;

  if l_debug then
    hr_utility.trace('Leaving:process_orphans');
  end if;
end process_orphans;
----------------------------- create_wrapper ---------------------------------
procedure create_wrapper is
l_debug       boolean := hr_utility.debug_enabled;
l_range_tbl   t_range_tbl;
l_ff_info_tbl t_ff_info_tbl;
l_chunks      dbms_sql.varchar2s;
l_csr_sql     integer;
l_rows        number;
begin
  if l_debug then
    hr_utility.trace('Entering:create_wrapper');
  end if;

  --
  -- 1. Process the compiled formulas.
  --
  process_compiled
  (p_range_tbl   => l_range_tbl
  ,p_ff_info_tbl => l_ff_info_tbl
  );
  --
  -- 2. Look for orphaned FF packages.
  --
  process_orphans
  (p_range_tbl   => l_range_tbl
  ,p_ff_info_tbl => l_ff_info_tbl
  );

  if l_debug then
    hr_utility.trace('Leaving:create_wrapper');
  end if;
end create_wrapper;
----------------------------- create_wrapper ---------------------------------
procedure create_wrapper
(errbuf  out nocopy varchar2
,retcode out nocopy number
) is
begin
  retcode := 0;
  create_wrapper;
exception
  when others then
    retcode := 2;
    errbuf := substrb(sqlerrm, 1, 240);
end create_wrapper;
end ff_wrapper_sup_pkg;

/
