--------------------------------------------------------
--  DDL for Package Body BEN_DETERMINE_COMMUNICATIONS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."BEN_DETERMINE_COMMUNICATIONS" as
/*$Header: bentmpcm.pkb 120.7.12010000.2 2009/04/06 11:43:40 pvelvano ship $*/
--
/*
Name
  Determine Communications
Purpose
  This is a batch process that creates person communication for triggers
  that are not automatically generated by an OAB process.
History
  Version Date       Author     Comment
  -------+----------+----------+------------------------------------------------
  115.0   18-DEC-98  bbulusu    Created
  115.1   31-Dec-98  bbulusu    Added more functionality.
  115.2   04-Feb-98  bbulusu    Removed p_min_cmbn and p_max_cmbn. Added more
                                functionality.
  115.3   25-Feb-99  bbulusu    Changed dates in process and do_multithread to
                                varchar2.
  115.5   15 Apr 99  mhoyes     Un-datetrack of per_in_ler_f changes.
  115.6   29 Apr 99  maagrawa   - prtt_enrt_rslt now has a status code.
                                - Corrected cursors and calls to
                                  ben_generate_communications.
                                - Removed parameter comp_object_selection_rule.
                                - Added procedures for comm. reports.
                                - Removed bugs.
  115.7   09-May-99  maagrawa   Commit after submitting each request.
  115.8   10-May-99  maagrawa   Corrected the header position.
  115.9   10-May-99  jcarpent   Check ('VOIDD', 'BCKDT') for pil stat cd
  115.10  13-May-99  jcarpent   Fixed ben_prtt_enrt_actn query to handle arc.
  115.11  14-May-99  maagrawa   Changed chr() with fnd_global.local_chr()
  115.12  09-Jul-99  jcarpent   Added checks for backed out pil
  115.13  20-JUL-99  Gperry     genutils -> benutils package rename.
  115.14  27-JUL-1999 mhoyes  - Changed g_report_rec to ref ben_type.
  115.15  30-JUL-1999 mhoyes  - Changed g_batch_proc_rec to ref ben_type.
  115.16  10-SEP-1999 maagrawa  -For emerging event, trap the date the life
                                 event occurs.
                                -For emerging event, restrict the process to
                                 comp. objects where the derived factor in
                                 question is attached when the parameter
                                 use_fctr_to_sel_flag is ON.
                                -Added 3 parameters comp_selection_rule,
                                 los_det_to_use_cd, use_fctr_to_sel_flag.
  115.17  06-Oct-1999 tguy       added call to dt_fndate
  115.18  11-Oct-1999 maagrawa  los_dt_to_use_cd supported to get the start
                                date. Support available for DOH and ASD only.
  115.19  13-Oct-1999 stee      Change elig_enrol_cd to not be required for
                                mss mailing unless a comp object is specified.
  115.20  13-Oct-1999 maagrawa  Ordered the parameter list in procedure process
                                as in seeded concurrent procedure.
  115.21  19-Oct-1999 maagrawa  Moved function get_message_name to benutils.
  115.22  09-Feb-2000 maagrawa  Generate enrollment reminder letter when the
                                effective date is within the enrollment
                                window (1187184, 1183934).
                                Pass the ler_id of the active life event to
                                the communications process for enrollment
                                reminder letters (1187482).
  115.23  16-Feb-2000 maagrawa  Create emerging event comm. for dependents also
                                when they cross age boundaries.(1198557).
  115.24  23-Feb-2000 maagrawa  Forgot to close c_dpnt_enrt in previous version.
  115.25  02-Mar-2000 maagrawa  In standard_header procedure use application_id
                                (805) also to get conc.program name.(1167925)
  115.26  13-Mar-2000 maagrawa  Removed effective_start_date check from
                                procedure chk_per_cm.
  115.27  04-Apr-2000 mmogel    Added tokens to the message calls so that
                                they are more meaningful to the user
  115.28  11-Apr-2000 maagrawa  Use the global variable g_comm_generated to
                                identify communications generated in the
                                procedure chk_per_cm.(4507,4859,4883)
  115.29  08-May-2000 maagrawa  Added parameter p_status in procedure
                                standard_header.
  115.30  17-Jul-2000 gperry    Fixed WWBUG 1351039.
                                Dependent communications now created correctly.
                                Added in check for person_type_id parameter
                                and commented out verify_person_type check.
  115.31  05-Sep-2000 pbodla  - Bug 5422 : Allow different enrollment periods
                                for programs for scheduled  a enrollment.
  115.32  07-Dec-2000 rchase  - Bug 1518211. p_dob is in/out now for
                                determine_age calls.
  115.33  11-Jun-2002 pabodla - Added dbdrv command

  115.34  14-Jun-2002 pabodla   Do not select the contingent worker
                                assignment when assignment data is
                                fetched.
  115.35  18-Jun-2002 ikasire   Bug 2394141 NLS Fix
  115.36  27-Sep-2002 rpgupta   Fixed bug 2595834
  				Made changes to standard_header procedure
  				to take a substring of 80 characters
  115.38 11-dec-2002  hmani 		NoCopy changes
  115.39 30-dec-2003  mmudigon 	Bug 3232205. Modified cursors on
                                ben_person_actions to drive by
                                benefit_action_id
  115.40 17-Sep-2004  pabodla   iRec - c_pil_enrtrmdr : modified not to consider
                                GSP/irec/comp events.
  115.41 27-Dec-2004  tjesumic  person_type_id is validated for the communications
  115.42 30-Jun-2006  swjain    Passing ler_id in call to chk_person_selection
  115.43 01-Aug-2006  swjain	Bug 5435002 - Updated cursor c_per_actnrmdr, c_per_emrgevt
                                c_pil_enrtrmdr, c_per_mssmlg in procedure create_actnrmdr_ranges,
				create_emrgevt_ranges, create_enrtrmdr_ranges, create_mssmlg_ranges
				respectively.
  115.44 07-Aug-2006 rtagarra  Bug#5444208 Modified the cursor c_per_mssmlg to pick up the person when the assignment
  	                                             is active  on the effective date.
  115.45 07-Aug-2006 gsehgal   Bug 5446127 Changed the location description to location code
  115.46 20-apr-2007 nhunur    Bug 5942699 Perf fixes with logging and sql changes
  115.47 20-apr-2007 nhunur    Bug 6008383 Perf fixes with mass mailing cursors
  115.48 06-Apr-2009 velvanop	Bug8364821 - Communication is sent to the Employee and not to the Spouse when
                                Communication is triggered on the Spouse.Spouse is also an Employee.
  --------------------------------------------------------------------------------------------------
*/
--
-- GLOBAL VARIABLES
--
  g_package varchar2(80) := 'ben_determine_communications';
  --
  -- Process Information
  --
  type g_processes_table is table of number index by binary_integer;
  g_processes_rec g_processes_table;
  --
  -- Caching variables and their types.
  --
  type g_cache_pl_fctr_rec_type is record(pl_id number,
                                          belongs_to varchar2(1));
  type g_cache_plip_fctr_rec_type is record(plip_id number,
                                            belongs_to varchar2(1));
  type g_cache_pl_fctr_table is table of g_cache_pl_fctr_rec_type index
                      by binary_integer;
  type g_cache_plip_fctr_table is table of g_cache_plip_fctr_rec_type index
                      by binary_integer;
  g_cache_pl_fctr_rec         g_cache_pl_fctr_table;
  g_cache_plip_fctr_rec       g_cache_plip_fctr_table;
  g_cache_last_pl_fctr_rec    g_cache_pl_fctr_rec_type;
  g_cache_last_plip_fctr_rec  g_cache_plip_fctr_rec_type;
  --
  g_hash_key      number := ben_hash_utility.get_hash_key;
  g_hash_jump     number := ben_hash_utility.get_hash_jump;
  --
  g_num_processes number;
  g_threads number;
  g_chunk_size number;
  g_max_errors number;
  g_num_ranges number;
  --
  g_per_slctd number         := 0;
  g_person_actn_cnt number   := 0;
  g_person_cnt number        := 0;
  g_error_person_cnt number  := 0;
  g_current_thread number    := 0;
  --
  g_rec ben_type.g_report_rec;
  g_proc_rec ben_type.g_batch_proc_rec;
  g_action_rec ben_type.g_batch_action_rec;
  g_strt_tm_numeric number;
  g_end_tm_numeric number;
  --
  -- Global structure to hold the parameters that are passed into the master
  -- process
  --
  type g_parm_list is record
    (benefit_action_id      number(15)
    ,validate_flag          varchar2(30)
    ,effective_date         date
    ,business_group_id      number(15)
    ,mode_cd                varchar2(30)
    ,cm_trgr_typ_cd         varchar2(30)
    ,cm_typ_id              number(15)
    ,person_id              number(15)
    ,person_type_id         number(15)
    ,person_sel_rl          number(15)
    ,organization_id        number(15)
    ,location_id            number(15)
    ,ler_id                 number(15)
    ,pgm_id                 number(15)
    ,pl_nip_id              number(15)
    ,plan_in_pgm_flag       varchar2(30)
    ,comp_selection_rl      number(15)
    ,actn_typ_id            number(15)
    ,elig_enrol_cd          varchar2(30)
    ,use_fctr_to_sel_flag   varchar2(30)
    ,age_fctr_id            number(15)
    ,min_age                number(15)
    ,max_age                number(15)
    ,los_fctr_id            number(15)
    ,min_los                number(15)
    ,max_los                number(15)
    ,los_det_to_use_cd      varchar2(30)
    ,cmbn_age_los_fctr_id   number(15)
    ,date_from              date
    -- PB : 5422 :
    --
    ,lf_evt_ocrd_dt         date
    -- ,popl_enrt_typ_cycl_id  number(15)
    ,audit_log_flag         varchar2(30));
  --
  g_parm g_parm_list;
--
--
-- ----------------------------------------------------------------------------
-- --------------------------< seconds_to_hours >------------------------------
-- ----------------------------------------------------------------------------
--
function seconds_to_hours(p_seconds in number) return varchar2 is
  --
  l_hours varchar2(30);
  l_minutes varchar2(30);
  l_seconds varchar2(30);
  --
  l_proc varchar2(80) := g_package || '.seconds_to_hours';
  --
begin
  --
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  l_hours := to_char(floor(p_seconds/3600));
  l_minutes := to_char(floor(mod(p_seconds, 3600)/60));
  l_seconds := to_char(mod(p_seconds, 60));
  --
  if length(l_hours) = 1 then
    l_hours := '0' || l_hours;
  end if;
  --
  if length(l_minutes) = 1 then
    l_minutes := '0' || l_minutes;
  end if;
  --
  if length(l_seconds) = 1 then
    l_seconds := '0' || l_seconds;
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
  --
  return l_hours || 'h : ' || l_minutes || 'm : ' || l_seconds || 's';
  --
end seconds_to_hours;
--
-- ----------------------------------------------------------------------------
-- -----------------------< initialize_globals >-------------------------------
-- ----------------------------------------------------------------------------
--
procedure initialize_globals is
begin
  --
  g_processes_rec.delete;
  --
  benutils.g_report_table_object.delete;
  benutils.g_batch_action_table_object.delete;
  benutils.g_batch_proc_table_object.delete;
  benutils.g_batch_commu_table_object.delete;
  --
  g_num_processes := 0;
  g_threads := 0;
  g_chunk_size := 0;
  g_max_errors := 0;
  g_num_ranges := 0;
  --
  g_per_slctd := 0;
  g_person_actn_cnt := 0;
  g_person_cnt := 0;
  g_error_person_cnt := 0;
  g_current_thread := 0;
  --
end initialize_globals;
--
-- ----------------------------------------------------------------------------
-- -----------------------< submit_all_reports >-------------------------------
-- ----------------------------------------------------------------------------
--
procedure submit_all_reports is
  l_proc        varchar2(80) := g_package||'.submit_all_reports';
  l_actn        varchar2(80);
  l_request_id  number;
begin
  --
  hr_utility.set_location ('Entering '||l_proc,05);
  --
  -- Fire off the following Reports for BENTMPCM run.
  --  * Audit Log
  --  * Activity Summary
  --  * Error by Error Type
  --  * Error by Person
  --
  if (g_parm.audit_log_flag = 'Y') then
    --
    ben_batch_utils.batch_report
      (p_concurrent_request_id => fnd_global.conc_request_id
      ,p_program_name          => 'BENCMAUD'
      ,p_request_id            => l_request_id);
    --
  end if;
  --
  if fnd_global.conc_request_id <> - 1 then
  ben_batch_utils.batch_report
    (p_concurrent_request_id => fnd_global.conc_request_id
    ,p_program_name          => 'BENCMSUM'
    ,p_request_id            => l_request_id);
  --
  ben_batch_utils.batch_report
    (p_concurrent_request_id => fnd_global.conc_request_id
    ,p_program_name          => 'BENCMEPE'
    ,p_request_id            => l_request_id);
   --
   ben_batch_utils.batch_report
    (p_concurrent_request_id => fnd_global.conc_request_id
    ,p_program_name          => 'BENCMETY'
    ,p_request_id            => l_request_id);
  end if;
  --
exception
  when others then
    raise;
end submit_all_reports;
--
-- ----------------------------------------------------------------------------
-- -------------------< check_all_slaves_finished >----------------------------
-- ----------------------------------------------------------------------------
--
procedure check_all_slaves_finished is
  --
  l_proc varchar2(80) := g_package || '.check_all_slaves_finished';
  --
  l_no_slaves boolean := true;
  l_dummy     varchar2(1);
  l_master    varchar2(1) := 'N';
  --
  cursor c_slaves(v_request_id number) is
  select null
    from fnd_concurrent_requests fnd
   where fnd.phase_code <> 'C'
     and fnd.request_id = v_request_id;
  --
  cursor c_master is
  select 'Y'
    from ben_benefit_actions bft
   where bft.benefit_action_id = g_parm.benefit_action_id
     and bft.request_id = fnd_global.conc_request_id;
  --
  cursor c_person_actions(p_status_cd varchar2) is
  select count(*)
    from ben_person_actions pac
   where pac.benefit_action_id = g_parm.benefit_action_id
     and pac.action_status_cd = nvl(p_status_cd,pac.action_status_cd);
  --
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  -- Check if process is master
  --
  open c_master;
  fetch c_master into l_master;
  close c_master;
  --
  if g_num_processes <> 0 and l_master = 'Y' then
    --
    while l_no_slaves loop
      --
      l_no_slaves := false;
      --
      for l_count in 1..g_num_processes loop
        --
        open c_slaves(g_processes_rec(l_count));
          --
          fetch c_slaves into l_dummy;
          if c_slaves%found then
            --
            -- Slave is still running
            --
            l_no_slaves := true;
            close c_slaves;
            exit;
            --
          end if;
          --
        close c_slaves;
        --
      end loop;
      --
      -- To prevent over polling of fnd_concurrent_requests
      -- sleep for a while.
      --
      If (l_no_slaves) then
        dbms_lock.sleep(4);
      End if;
      --
    end loop;
    --
  end if;
  --
  -- Log process information
  -- This is master specific only
  --
  if l_master = 'Y' then
    --
    g_proc_rec.end_dt := sysdate;
    g_proc_rec.end_tm := to_char(sysdate,'HH24:MI:SS');
    g_end_tm_numeric := dbms_utility.get_time;
    g_proc_rec.elpsd_tm := seconds_to_hours
                             ((g_end_tm_numeric - g_strt_tm_numeric)/100);
    --
    open c_person_actions(null);
    fetch c_person_actions into g_proc_rec.per_slctd;
    close c_person_actions;
    --
    open c_person_actions('E');
    fetch c_person_actions into g_proc_rec.per_err;
    close c_person_actions;
    --
    open c_person_actions('P');
    fetch c_person_actions into g_proc_rec.per_proc_succ;
    close c_person_actions;
    --
    open c_person_actions('U');
    fetch c_person_actions into g_proc_rec.per_unproc;
    close c_person_actions;
    --
    g_proc_rec.per_proc := nvl(g_proc_rec.per_proc_succ,0)+
                           nvl(g_proc_rec.per_err,0);
    --
    benutils.write(p_rec => g_proc_rec);
    --
  end if;
  --
  benutils.write_table_and_file(p_table => true
                               ,p_file  => false);
  commit;
  --
  if l_master = 'Y' then
    --
    submit_all_reports;
    commit;
    --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
end check_all_slaves_finished;
--
-- ----------------------------------------------------------------------------
-- -------------------------< person_error_cnt >-----------------------------------
-- ----------------------------------------------------------------------------
--
procedure person_error_cnt is
--
  error_limit exception;
  --
  l_proc varchar2(80) := g_package || '.person_error_cnt';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  -- Increment the error count
  --
  g_error_person_cnt := g_error_person_cnt + 1;
  --
  -- Check if the error count excedes the maximum allowed errors
  --
  if g_error_person_cnt > g_max_errors then
    raise error_limit;
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
exception
--
  when error_limit then
    fnd_message.set_name('BEN', 'BEN_92163_BENTMPCM_ERR_LMT');
    fnd_message.set_token('PROC',l_proc);
    benutils.write(p_text => fnd_message.get);
    raise;
--
end person_error_cnt;
--
-- ----------------------------------------------------------------------------
-- -----------------------< write_logfile >------------------------------------
-- ----------------------------------------------------------------------------
--
procedure write_logfile is
--
  l_proc varchar2(80) := g_package || '.write_logfile';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  benutils.write(p_text => benutils.g_banner_minus);
  benutils.write(p_text => 'Batch Process Statistical Information');
  benutils.write(p_text => benutils.g_banner_minus);
  benutils.write(p_text => 'People processed : ' || g_person_cnt);
  benutils.write(p_text => 'People errored   : ' || g_error_person_cnt);
  benutils.write(p_text => benutils.g_banner_minus);
  --
  benutils.write_table_and_file(p_table => false
                               ,p_file  => true);
  commit;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
  --
exception
  --
  when others then
    --
    benutils.write(p_text => sqlerrm);
    fnd_message.set_name('BEN','BEN_91663_BENMNGLE_LOGGING');
    fnd_message.set_token('PROC',l_proc);
    benutils.write(p_text => fnd_message.get);
    fnd_message.raise_error;
    --
end write_logfile;
--
-- ----------------------------------------------------------------------------
-- -----------------------< print_parameters >---------------------------------
-- ----------------------------------------------------------------------------
--
procedure print_parameters is
--
  l_proc varchar2(80) := g_package || '.print_parameters';
--
  l_rec     benutils.g_batch_param_rec;
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  if fnd_global.conc_request_id = -1 then
    return;
  end if;
  --
  -- added to prevent logging
  --
  benutils.get_batch_parameters
    (p_benefit_action_id => g_parm.benefit_action_id,
     p_rec               => l_rec);
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Runtime Parameters');
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => '------------------');
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Benefit Action ID          : '||
                    benutils.iftrue
                      (p_expression => g_parm.benefit_action_id is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.benefit_action_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Validation Mode            : '||
                    hr_general.decode_lookup('YES_NO',g_parm.validate_flag));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Effective Date             : '||
                    to_char(g_parm.effective_date,'DD-MON-YYYY'));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Business Group ID          : '||
                    g_parm.business_group_id);
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Run Mode                   : ' ||
                    hr_general.decode_lookup('BEN_BENTMPCM_MD',g_parm.mode_cd));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Comm Trigger Type Code     : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.cm_trgr_typ_cd is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.cm_trgr_typ_cd));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Communication Type ID      : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.cm_typ_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.cm_typ_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Person ID                  : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.person_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.person_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Person Type ID             : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.person_type_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.person_type_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Person Selection Rule      : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.person_sel_rl is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.person_sel_rl));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Organization ID            : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.organization_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.organization_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Location ID                : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.location_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.location_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Life Event Reason ID       : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.ler_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.ler_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Program ID                 : '||
                    benutils.iftrue
                      (p_expression => g_parm.pgm_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.pgm_id));
  --
  fnd_file.put_line(which => fnd_file.log,
                    buff  => 'Plan ID                    : '||
                    benutils.iftrue
                      (p_expression => g_parm.pl_nip_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.pl_nip_id));
  --
  fnd_file.put_line(which => fnd_file.log,
                    buff  => 'Is plan in program?        : '||
                    g_parm.plan_in_pgm_flag);
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Action Type ID             : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.actn_typ_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.actn_typ_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Elig Enrol Code            : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.elig_enrol_cd is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.elig_enrol_cd));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Age Factor ID              : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.age_fctr_id is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.age_fctr_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Minimum Age                : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.min_age is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.min_age));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Maximum Age                : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.max_age is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.max_age));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Length of Srvce Factor Id  : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.los_fctr_id is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.los_fctr_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Minimum LOS                : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.min_los is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.min_los));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Maximum LOS                : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.max_los is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.max_los));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Cmbn Age and LOS Factor Id : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.cmbn_age_los_fctr_id is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.cmbn_age_los_fctr_id));
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Date From                  : ' ||
                    benutils.iftrue
                      (p_expression => g_parm.date_from is null
                      ,p_true       => 'NONE'
                      ,p_false      => g_parm.date_from));
  --
  /*
  fnd_file.put_line(which => fnd_file.log,
                    buff  => 'Enrollment Period          : '||
                    benutils.iftrue
                      (p_expression => g_parm.popl_enrt_typ_cycl_id is null
                      ,p_true       => 'All'
                      ,p_false      => g_parm.popl_enrt_typ_cycl_id));
  */
  --
  fnd_file.put_line(which => fnd_file.log
                   ,buff  => 'Audit Log Flag             : ' ||
                    hr_general.decode_lookup('YES_NO',g_parm.audit_log_flag));
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
end print_parameters;
--
procedure set_object(p_rec in g_cache_pl_fctr_rec_type) is
  --
  l_proc           varchar2(80) := g_package||'set_object pl_fctr';
  l_index          binary_integer;
  l_not_hash_found boolean;
  --
begin
  --
  hr_utility.set_location('Entering '||l_proc,10);
  --
  -- 1) get hash index
  -- 2) If hash index is not used use hash index
  -- 3) If hash index is used and correct then do nothing
  -- 4) If hash index is used and not correct then try next hash index
  --
  -- Get hashed index value
  --
  l_index := mod(p_rec.pl_id,g_hash_key);
  --
  if not g_cache_pl_fctr_rec.exists(l_index) then
    --
    -- Lets store the hash value in this index
    --
    g_cache_pl_fctr_rec(l_index) := p_rec;
    --
  else
    --
    -- If it does exist check if its the right one
    --
    if g_cache_pl_fctr_rec(l_index).pl_id <> p_rec.pl_id then
      --
      -- Loop through the hash using the jump routine to check further
      -- indexes
      --
      l_not_hash_found := false;
      --
      while not l_not_hash_found loop
        --
        l_index := l_index+g_hash_jump;
        --
        -- Check if the hash index exists, if not we can use it
        --
        if not g_cache_pl_fctr_rec.exists(l_index) then
          --
          -- Lets store the hash value in the index
          --
          g_cache_pl_fctr_rec(l_index) := p_rec;
          l_not_hash_found := true;
          --
        else
          --
          -- Make sure the index is the correct one
          --
          if g_cache_pl_fctr_rec(l_index).pl_id = p_rec.pl_id then
            --
            -- We have a match so the hashed value has been stored before
            --
            l_not_hash_found := true;
            --
          end if;
          --
        end if;
        --
      end loop;
      --
    end if;
    --
  end if;
  --
  hr_utility.set_location('Leaving '||l_proc,10);
  --
end set_object;


procedure set_object(p_rec in g_cache_plip_fctr_rec_type) is
  --
  l_proc           varchar2(80) := g_package||'set_object plip_fctr';
  l_index          binary_integer;
  l_not_hash_found boolean;
  --
begin
  --
  hr_utility.set_location('Entering '||l_proc,10);
  --
  -- 1) get hash index
  -- 2) If hash index is not used use hash index
  -- 3) If hash index is used and correct then do nothing
  -- 4) If hash index is used and not correct then try next hash index
  --
  -- Get hashed index value
  --
  l_index := mod(p_rec.plip_id,g_hash_key);
  --
  if not g_cache_plip_fctr_rec.exists(l_index) then
    --
    -- Lets store the hash value in this index
    --
    g_cache_plip_fctr_rec(l_index) := p_rec;
    --
  else
    --
    -- If it does exist check if its the right one
    --
    if g_cache_plip_fctr_rec(l_index).plip_id <> p_rec.plip_id then
      --
      -- Loop through the hash using the jump routine to check further
      -- indexes
      --
      l_not_hash_found := false;
      --
      while not l_not_hash_found loop
        --
        l_index := l_index+g_hash_jump;
        --
        -- Check if the hash index exists, if not we can use it
        --
        if not g_cache_plip_fctr_rec.exists(l_index) then
          --
          -- Lets store the hash value in the index
          --
          g_cache_plip_fctr_rec(l_index) := p_rec;
          l_not_hash_found := true;
          --
        else
          --
          -- Make sure the index is the correct one
          --
          if g_cache_plip_fctr_rec(l_index).plip_id = p_rec.plip_id then
            --
            -- We have a match so the hashed value has been stored before
            --
            l_not_hash_found := true;
            --
          end if;
          --
        end if;
        --
      end loop;
      --
    end if;
    --
  end if;
  --
  hr_utility.set_location('Leaving '||l_proc,10);
  --
end set_object;
--
--
procedure set_fctr_object(
               p_pl_id             in  number,
               p_pgm_id            in  number default null,
               p_plip_id           in  number default null,
               p_ptip_id           in  number default null,
               p_business_group_id in  number,
               p_effective_date    in  date,
               p_pl_fctr_rec       out nocopy g_cache_pl_fctr_rec_type,
               p_plip_fctr_rec     out nocopy g_cache_plip_fctr_rec_type
) is
  --
  l_proc           varchar2(80) := g_package||'set_fctr_object';
  --
   cursor c_los_fctr is
   select 'Y'
   from   ben_prtn_elig_f      epa,
          ben_prtn_elig_prfl_f cep,
          ben_eligy_prfl_f     elp,
          ben_elig_los_prte_f  els
   where  (epa.pl_id      = p_pl_id or
           epa.pgm_id     = p_pgm_id   or
           epa.plip_id    = p_plip_id  or
           epa.ptip_id    = p_ptip_id )
   and    epa.prtn_elig_id = cep.prtn_elig_id
   and    cep.eligy_prfl_id = elp.eligy_prfl_id
   and    elp.eligy_prfl_id = els.eligy_prfl_id
   and    els.los_fctr_id   = g_parm.los_fctr_id
   and    g_parm.effective_date between
          epa.effective_start_date and epa.effective_end_date
   and    g_parm.effective_date between
          cep.effective_start_date and cep.effective_end_date
   and    g_parm.effective_date between
          elp.effective_start_date and elp.effective_end_date
   and    g_parm.effective_date between
          els.effective_start_date and els.effective_end_date;
   --
   cursor c_age_fctr is
   select 'Y'
   from   ben_prtn_elig_f      epa,
          ben_prtn_elig_prfl_f cep,
          ben_eligy_prfl_f     elp,
          ben_elig_age_prte_f  eap
   where  (epa.pl_id      = p_pl_id or
           epa.pgm_id     = p_pgm_id   or
           epa.plip_id    = p_plip_id  or
           epa.ptip_id    = p_ptip_id )
   and    epa.prtn_elig_id = cep.prtn_elig_id
   and    cep.eligy_prfl_id = elp.eligy_prfl_id
   and    elp.eligy_prfl_id = eap.eligy_prfl_id
   and    eap.age_fctr_id   = g_parm.age_fctr_id
   and    g_parm.effective_date between
          epa.effective_start_date and epa.effective_end_date
   and    g_parm.effective_date between
          cep.effective_start_date and cep.effective_end_date
   and    g_parm.effective_date between
          elp.effective_start_date and elp.effective_end_date
   and    g_parm.effective_date between
          eap.effective_start_date and eap.effective_end_date;
   --
   cursor c_cmbn_age_los_fctr is
   select 'Y'
   from   ben_prtn_elig_f               epa,
          ben_prtn_elig_prfl_f          cep,
          ben_eligy_prfl_f              elp,
          ben_elig_cmbn_age_los_prte_f  ecp
   where  (epa.pl_id      = p_pl_id or
           epa.pgm_id     = p_pgm_id   or
           epa.plip_id    = p_plip_id  or
           epa.ptip_id    = p_ptip_id )
   and    epa.prtn_elig_id           = cep.prtn_elig_id
   and    cep.eligy_prfl_id          = elp.eligy_prfl_id
   and    elp.eligy_prfl_id          = ecp.eligy_prfl_id
   and    ecp.cmbn_age_los_fctr_id   = g_parm.cmbn_age_los_fctr_id
   and    g_parm.effective_date between
          epa.effective_start_date and epa.effective_end_date
   and    g_parm.effective_date between
          cep.effective_start_date and cep.effective_end_date
   and    g_parm.effective_date between
          elp.effective_start_date and elp.effective_end_date
   and    g_parm.effective_date between
          ecp.effective_start_date and ecp.effective_end_date;
  --
  l_belongs        varchar2(1);
  l_pl_fctr_rec    g_cache_pl_fctr_rec_type;
  l_plip_fctr_rec  g_cache_plip_fctr_rec_type;
  --
begin
  --
  hr_utility.set_location('Entering '||l_proc,10);
  --
  -- 1) Get record from database.
  -- 2) If record not found then raise error.
  -- 3) Pass record to set_object routine.
  --
  if g_parm.los_fctr_id is not null then
     --
     open c_los_fctr;
     --
     fetch c_los_fctr into l_belongs;
     if c_los_fctr%notfound then
        --
        l_pl_fctr_rec.belongs_to := 'N';
        l_plip_fctr_rec.belongs_to := 'N';
        --
     else
        --
        l_pl_fctr_rec.belongs_to := 'Y';
        l_plip_fctr_rec.belongs_to := 'Y';
        --
     end if;
     --
     close c_los_fctr;
     --
  elsif g_parm.age_fctr_id is not null then
     --
     open c_age_fctr;
     --
     fetch c_age_fctr into l_belongs;
     if c_age_fctr%notfound then
        --
        l_pl_fctr_rec.belongs_to := 'N';
        l_plip_fctr_rec.belongs_to := 'N';
        --
     else
        --
        l_pl_fctr_rec.belongs_to := 'Y';
        l_plip_fctr_rec.belongs_to := 'Y';
        --
     end if;
     --
     close c_age_fctr;
     --
  elsif g_parm.cmbn_age_los_fctr_id is not null then
     --
     open c_cmbn_age_los_fctr;
     --
     fetch c_cmbn_age_los_fctr into l_belongs;
     if c_cmbn_age_los_fctr%notfound then
        --
        l_pl_fctr_rec.belongs_to := 'N';
        l_plip_fctr_rec.belongs_to := 'N';
        --
     else
        --
        l_pl_fctr_rec.belongs_to := 'Y';
        l_plip_fctr_rec.belongs_to := 'Y';
        --
     end if;
     --
     close c_cmbn_age_los_fctr;
     --
  end if;
  --
  l_pl_fctr_rec.pl_id     := p_pl_id;
  l_plip_fctr_rec.plip_id := p_plip_id;
  --
  if p_plip_id is not null then
     set_object(p_rec => l_plip_fctr_rec);
  else
     set_object(p_rec => l_pl_fctr_rec);
  end if;
  --
  p_pl_fctr_rec   := l_pl_fctr_rec;
  p_plip_fctr_rec := l_plip_fctr_rec;
  --
  hr_utility.set_location('Leaving '||l_proc,10);
  --
end set_fctr_object;

--
procedure get_object(p_pl_id in  number,
                     p_rec   out nocopy g_cache_pl_fctr_rec_type) is
  --
  l_proc           varchar2(80) := g_package||'get_object pl_fctr';
  l_index          binary_integer;
  l_not_hash_found boolean;
  l_rec            g_cache_pl_fctr_rec_type;
  l_plip_fctr_rec  g_cache_plip_fctr_rec_type;
  --
begin
  --
  hr_utility.set_location('Entering '||l_proc,10);
  --
  if g_cache_last_pl_fctr_rec.pl_id = p_pl_id then
    --
    p_rec := g_cache_last_pl_fctr_rec;
    return;
    --
  end if;
  --
  -- 1) Get hashed index
  -- 2) If hashed index is correct person_id then return person_id
  -- 3) If hashed index is not correct person_id then check next index
  -- 4) Repeat 3 until correct person_id found, if not found raise error.
  --
  -- Get hashed index value
  --
  l_index := mod(p_pl_id,g_hash_key);
  --
  if g_cache_pl_fctr_rec.exists(l_index) then
    --
    -- Lets get the hashed record.
    --
    if g_cache_pl_fctr_rec(l_index).pl_id = p_pl_id then
      --
      g_cache_last_pl_fctr_rec := g_cache_pl_fctr_rec(l_index);
      p_rec := g_cache_pl_fctr_rec(l_index);
      --
    else
      --
      -- We need to loop through all the hashed indexes
      --
      l_not_hash_found := false;
      --
      while not l_not_hash_found loop
        --
        l_index := l_index+g_hash_jump;
        --
        -- Check if the hash index exists, if not error
        --
        if not g_cache_pl_fctr_rec.exists(l_index) then
          --
          -- Raise an error as we are trying to retrieve a non cached object
          --
          raise no_data_found;
          --
        else
          --
          -- Make sure the index is the correct one
          --
          if g_cache_pl_fctr_rec(l_index).pl_id = p_pl_id then
            --
            -- We have a match
            --
            g_cache_last_pl_fctr_rec := g_cache_pl_fctr_rec(l_index);
            p_rec := g_cache_pl_fctr_rec(l_index);
            l_not_hash_found := true;
            --
          end if;
          --
        end if;
        --
      end loop;
      --
    end if;
    --
  else
    --
    raise no_data_found;
    --
  end if;
  --
  hr_utility.set_location('Leaving '||l_proc,10);
  --
exception
  --
  when no_data_found then
    --
    set_fctr_object(p_pl_id             => p_pl_id,
                   p_business_group_id => g_parm.business_group_id,
                   p_effective_date    => g_parm.effective_date,
                   p_pl_fctr_rec       => l_rec,
                   p_plip_fctr_rec     => l_plip_fctr_rec);
    --
    g_cache_last_pl_fctr_rec := l_rec;
    p_rec := l_rec;
    --
end get_object;
--
--
procedure get_object(p_plip_id in  number,
                     p_pgm_id  in  number,
                     p_pl_id   in  number,
                     p_ptip_id in  number,
                     p_rec   out nocopy g_cache_plip_fctr_rec_type) is
  --
  l_proc           varchar2(80) := g_package||'get_object plip_fctr';
  l_index          binary_integer;
  l_not_hash_found boolean;
  l_rec            g_cache_plip_fctr_rec_type;
  l_pl_fctr_rec    g_cache_pl_fctr_rec_type;
  --
begin
  --
  hr_utility.set_location('Entering '||l_proc,10);
  --
  if g_cache_last_plip_fctr_rec.plip_id = p_plip_id then
    --
    p_rec := g_cache_last_plip_fctr_rec;
    return;
    --
  end if;
  --
  -- 1) Get hashed index
  -- 2) If hashed index is correct person_id then return person_id
  -- 3) If hashed index is not correct person_id then check next index
  -- 4) Repeat 3 until correct person_id found, if not found raise error.
  --
  -- Get hashed index value
  --
  l_index := mod(p_plip_id,g_hash_key);
  --
  if g_cache_plip_fctr_rec.exists(l_index) then
    --
    -- Lets get the hashed record.
    --
    if g_cache_plip_fctr_rec(l_index).plip_id = p_plip_id then
      --
      g_cache_last_plip_fctr_rec := g_cache_plip_fctr_rec(l_index);
      p_rec := g_cache_plip_fctr_rec(l_index);
      --
    else
      --
      -- We need to loop through all the hashed indexes
      --
      l_not_hash_found := false;
      --
      while not l_not_hash_found loop
        --
        l_index := l_index+g_hash_jump;
        --
        -- Check if the hash index exists, if not error
        --
        if not g_cache_plip_fctr_rec.exists(l_index) then
          --
          -- Raise an error as we are trying to retrieve a non cached object
          --
          raise no_data_found;
          --
        else
          --
          -- Make sure the index is the correct one
          --
          if g_cache_plip_fctr_rec(l_index).plip_id = p_plip_id then
            --
            -- We have a match
            --
            g_cache_last_plip_fctr_rec := g_cache_plip_fctr_rec(l_index);
            p_rec := g_cache_plip_fctr_rec(l_index);
            l_not_hash_found := true;
            --
          end if;
          --
        end if;
        --
      end loop;
      --
    end if;
    --
  else
    --
    raise no_data_found;
    --
  end if;
  --
  hr_utility.set_location('Leaving '||l_proc,10);
  --
exception
  --
  when no_data_found then
    --
    set_fctr_object(p_plip_id           => p_plip_id,
                    p_pl_id             => p_pl_id,
                    p_pgm_id            => p_pgm_id,
                    p_ptip_id           => p_ptip_id,
                   p_business_group_id => g_parm.business_group_id,
                   p_effective_date    => g_parm.effective_date,
                   p_plip_fctr_rec     => l_rec,
                   p_pl_fctr_rec       => l_pl_fctr_rec);
    --
    g_cache_last_plip_fctr_rec := l_rec;
    p_rec := l_rec;
    --
end get_object;
--
--
function fctr_belongs_to_comp_object(
            p_pgm_id       in number default null,
            p_pl_id        in number default null)
return boolean is
   --
   cursor c_get_pl_details is
   select ptip.ptip_id,
          plip.plip_id
   from   ben_pl_f     pl,
          ben_ptip_f   ptip,
          ben_plip_f   plip
   where  pl.pl_id     = p_pl_id
   and    pl.pl_typ_id = ptip.pl_typ_id
   and    ptip.pgm_id  = p_pgm_id
   and    plip.pl_id   = pl.pl_id
   and    plip.pgm_id  = ptip.pgm_id
   and    g_parm.effective_date between
          pl.effective_start_date and pl.effective_end_date
   and    g_parm.effective_date between
          plip.effective_start_date and plip.effective_end_date
   and    g_parm.effective_date between
          ptip.effective_start_date and ptip.effective_end_date;
   --
   l_plip_id       ben_plip_f.plip_id%type := null;
   l_ptip_id       ben_ptip_f.ptip_id%type := null;
   l_pl_fctr_rec   g_cache_pl_fctr_rec_type;
   l_plip_fctr_rec g_cache_plip_fctr_rec_type;
   l_return        boolean := false;
   l_proc          varchar2(80) := g_package || '.fctr_belongs_to_comp_object';
   --
begin
  --
  hr_utility.set_location('Entering '||l_proc,10);
   --
   if p_pgm_id is not null then
      --
      open  c_get_pl_details;
      fetch c_get_pl_details into l_ptip_id, l_plip_id;
      if c_get_pl_details%found then
         get_object(p_pl_id   => p_pl_id,
                    p_pgm_id  => p_pgm_id,
                    p_plip_id => l_plip_id,
                    p_ptip_id => l_ptip_id,
                    p_rec     => l_plip_fctr_rec);
         if l_plip_fctr_rec.belongs_to = 'Y' then
            l_return := true;
         end if;
      end if;
      close c_get_pl_details;
      --
   elsif p_pl_id is not null then
      --
      get_object(p_pl_id   => p_pl_id,
                 p_rec     => l_pl_fctr_rec);
      if l_pl_fctr_rec.belongs_to = 'Y' then
         l_return := true;
      end if;
      --
   end if;
  --
  hr_utility.set_location('Leaving '||l_proc,10);
   --
   return l_return;
   --
end fctr_belongs_to_comp_object;
--
-- ----------------------------------------------------------------------------
-- ----------------------------< chk_per_cm >----------------------------------
-- ----------------------------------------------------------------------------
--
procedure chk_per_cm(p_person_id in number) is
  --
  l_proc varchar2(80) := g_package || '.chk_per_cm';
  --
begin
  --
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  g_rec.person_id := p_person_id;
  --
  if ben_generate_communications.g_comm_generated then
     --
     g_rec.rep_typ_cd := 'COMMU';
     fnd_message.set_name('BEN','BEN_92182_COMM_GNRTD');
     fnd_message.set_token('PERSON_ID',to_char(p_person_id));
     g_rec.text       := fnd_message.get;
     --
  else
     --
     g_rec.rep_typ_cd := 'NOCOMMU';
     fnd_message.set_name('BEN','BEN_92183_NO_COMM_GNRTD');
     fnd_message.set_token('PERSON_ID',to_char(p_person_id));
     g_rec.text       := fnd_message.get;
     --
  end if;
  --
  benutils.write(p_rec => g_rec);
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
  --
end chk_per_cm;
--
-- ----------------------------------------------------------------------------
-- ----------------------< get_main_person_id >--------------------------------
-- ----------------------------------------------------------------------------
--
function get_main_person_id(p_dpnt_person_id in number)
return number is
--
  cursor c_per is
  select ppf.person_id
    from per_all_people_f ppf,
         per_contact_relationships pcr
   where pcr.contact_person_id = p_dpnt_person_id
     and pcr.business_group_id = g_parm.business_group_id
     and ppf.person_id = pcr.person_id
     and ppf.business_group_id = g_parm.business_group_id
     and g_parm.effective_date between ppf.effective_start_date
                                   and ppf.effective_end_date;
  --
  l_person_id number;
  --
  l_proc varchar2(80) := g_package || '.get_main_person_id';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  open c_per;
  fetch c_per into l_person_id;
  close c_per;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
  --
  return l_person_id;
  --
end get_main_person_id;
--
-- ----------------------------------------------------------------------------
-- -------------------------< get_person_type >--------------------------------
-- ----------------------------------------------------------------------------
--
function get_person_type(p_person_type_id in number)
return varchar2 is
--
  cursor c_person_type is
  select ppt.system_person_type
    from per_person_types ppt
   where ppt.person_type_id = p_person_type_id
     and ppt.business_group_id = g_parm.business_group_id;
  --
  l_type varchar2(30) := null;
  l_proc varchar2(80) := g_package || '.get_person_type';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  open c_person_type;
  fetch c_person_type into l_type;
  close c_person_type;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
  --
  return(l_type);
  --
exception
  when others then
    raise;
--
end get_person_type;
--
--
--
function verify_person_type_id(p_person_id in number,
                               p_person_type_id in number)
return boolean is
  --
  cursor c1 is
  select 'Y'
    from per_all_people_f ppf, per_person_types ppt
   where ppf.person_id = p_person_id
     and ppf.person_type_id = p_person_type_id
     and ppf.business_group_id = g_parm.business_group_id
     and g_parm.effective_date between ppf.effective_start_date
                                   and ppf.effective_end_date
     and ppf.person_type_id = ppt.person_type_id
     and ppt.business_group_id = g_parm.business_group_id
     and ppt.active_flag = 'Y';
  --
  l_success    varchar2(30) := null;
  --
begin
  --
  if p_person_type_id is null then
     --
     return(true);
     --
  end if;
  --
  open  c1;
  fetch c1 into l_success;
  close c1;
  --
  if l_success = 'Y' then
     --
     return(true);
     --
  else
     --
     return(false);
     --
  end if;
  --
end verify_person_type_id;
--
function is_dependent(p_person_id in number)
return boolean is
--
  cursor c_dpnt is
  select 'Y'
    from per_person_type_usages_f ptu,
         per_person_types         ppt
   where ptu.person_id      = p_person_id
     and ptu.person_type_id = ppt.person_type_id
     and ppt.system_person_type = 'DPNT'
     and g_parm.effective_date between
         ptu.effective_start_date and ptu.effective_end_date
     and ppt.active_flag = 'Y'
     and ppt.business_group_id = g_parm.business_group_id;
  --
  l_exists varchar2(30) := null;
  l_return boolean      := false;
  l_proc varchar2(80)   := g_package || '.is_dependent';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  open  c_dpnt;
  fetch c_dpnt into l_exists;
  close c_dpnt;
  --
  if l_exists = 'Y' then
     --
     l_return := true;
     --
     hr_utility.set_location('Person id DPNT',10);
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
  --
  return(l_return);
  --
exception
  when others then
    raise;
--
end is_dependent;
--

/* Bug 8364821: Added function to determine whether Dependent is also an Employee */

function is_dependent_emp(p_person_id in number)
return boolean is
--
  cursor c_dpnt is
  select 'Y'
    from per_person_type_usages_f ptu,
         per_person_types         ppt
   where ptu.person_id      = p_person_id
     and ptu.person_type_id = ppt.person_type_id
     and ppt.system_person_type = 'EMP'
     and g_parm.effective_date between
         ptu.effective_start_date and ptu.effective_end_date
     and ppt.active_flag = 'Y'
     and ppt.business_group_id = g_parm.business_group_id;
  --
  l_exists varchar2(30) := null;
  l_return boolean      := false;
  l_proc varchar2(80)   := g_package || '.is_dependent_emp';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  open  c_dpnt;
  fetch c_dpnt into l_exists;
  close c_dpnt;
  --
  if l_exists = 'Y' then
     --
     l_return := true;
     --
     hr_utility.set_location('Person id EMP',10);
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
  --
  return(l_return);
  --
exception
  when others then
    raise;
--
end is_dependent_emp;

/* End Bug 8364821*/


-- ----------------------------------------------------------------------------
-- -------------------------< check_business_rules >---------------------------
-- ----------------------------------------------------------------------------
--
procedure check_business_rules is
--
  cursor c1 is
  select null
    from per_all_people_f ppf, per_person_types ppt
   where ppf.person_id = g_parm.person_id
     and ppf.person_type_id = g_parm.person_type_id
     and ppf.business_group_id = g_parm.business_group_id
     and g_parm.effective_date between ppf.effective_start_date
                                   and ppf.effective_end_date
     and ppf.person_type_id = ppt.person_type_id
     and ppt.business_group_id = g_parm.business_group_id
     and ppt.active_flag = 'Y';
  --
  l_person_type varchar2(30);
  l_dummy varchar2(30);
  --
  l_proc varchar2(80) := g_package || '.check_business_rules';
--
begin
--
  hr_utility.set_location ('Entering '||l_proc,10);
  --
  -- This procedure checks validity of parameters that have been passed to the
  -- BENTMPCM process.
  --
  -- Check if mandatory arguments have been stipulated
  --
  hr_api.mandatory_arg_error(p_api_name       => l_proc,
                             p_argument       => 'p_business_group_id',
                             p_argument_value => g_parm.business_group_id);
  --
  hr_api.mandatory_arg_error(p_api_name       => l_proc,
                             p_argument       => 'p_effective_date',
                             p_argument_value => g_parm.effective_date);
  --
  hr_api.mandatory_arg_error(p_api_name       => l_proc,
                             p_argument       => 'p_validate',
                             p_argument_value => g_parm.validate_flag);
  --
  hr_api.mandatory_arg_error(p_api_name       => l_proc,
                             p_argument       => 'p_cm_trgr_typ_cd',
                             p_argument_value => g_parm.cm_trgr_typ_cd);
  --
  -- Business Rule Checks
  --
  -- p_person_selection_rule_id and p_person_id are mutually exclusive
  --
  if g_parm.person_id is not null and
     g_parm.person_sel_rl is not null then
    fnd_message.set_name('BEN','BEN_91745_RULE_AND_PERSON');
    fnd_message.set_token('PROC',l_proc);
    fnd_message.set_token('PERSON_ID',to_char(g_parm.person_id));
    fnd_message.set_token('PER_SELECT_RL',
                 'person_selection_rule :'||g_parm.person_sel_rl);
    fnd_message.raise_error;
  end if;
  --
  -- p_person_id must be of p_person_type_id specified
  --
  if g_parm.person_id is not null and
     g_parm.person_type_id is not null then
    --
    -- Make sure person is of the person type specified
    --
    if not(verify_person_type_id(p_person_id      => g_parm.person_id,
                                 p_person_type_id => g_parm.person_type_id)) then
      --
      fnd_message.set_name('BEN','BEN_91748_PERSON_TYPE');
      fnd_message.set_token('PROC',l_proc);
      fnd_message.set_token('PERSON_ID',to_char(g_parm.person_id));
      fnd_message.set_token('PER_TYPE_ID',to_char(g_parm.person_type_id));
      fnd_message.raise_error;
      --
    end if;
    --
  end if;
  --
  -- If a plan is specified as not in a program then the pgm_id should be null
  --
  if g_parm.plan_in_pgm_flag = 'N' and
     g_parm.pgm_id is not null then
    --
    fnd_message.set_name('BEN', 'BEN_92164_PLN_NIP_PGM_NULL');
    -- If you specify a plan as not in a program then the program should be blank.
    fnd_message.set_token('PROC',l_proc);
    fnd_message.raise_error;
    --
  end if;
  --
  -- Business rule for the emerging event trigger type:
  --
  if g_parm.cm_trgr_typ_cd = 'EMRGEVT' then
    --
    -- Atleast one of the derivable factors column must be specified.
    --
    if g_parm.age_fctr_id is null and
       g_parm.min_age is null and
       g_parm.max_age is null and
       g_parm.los_fctr_id is null and
       g_parm.min_los is null and
       g_parm.max_los is null and
       g_parm.cmbn_age_los_fctr_id is null then
      fnd_message.set_name('BEN','BEN_92165_ATLEAST_ONE_FCTR');
      fnd_message.set_token('PROC',l_proc);
      fnd_message.raise_error;
    end if;
    --
    -- If evaluating LOS then check if the person type is compatible.
    --
    if (g_parm.los_fctr_id is not null or
        g_parm.min_los is not null or
        g_parm.max_los is not null or
        g_parm.cmbn_age_los_fctr_id is not null) then
      --
      l_person_type := get_person_type
                         (p_person_type_id => g_parm.person_type_id);
      --
      if    l_person_type = 'DPNT'  -- Dependent
         or l_person_type = 'BNF'   -- Beneficiary
         or l_person_type = 'OTHER' -- External, Contact
         or l_person_type = 'APL'   -- Applicant
      then
        --
        fnd_message.set_name('BEN','BEN_92166_INVLD_PER_TYPE');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('PER_TYP',l_person_type);
        fnd_message.raise_error;
        --
      end if;
      --
    end if;
    --
    -- Only ONE derivable factor id should be specified. All other parameters
    -- related to derivable factors should be null.
    --
    if g_parm.age_fctr_id is not null then
      --
      -- If the factor is specified, then the min and max values should be null
      --
      if g_parm.min_age is not null or
         g_parm.max_age is not null then
        --
        fnd_message.set_name('BEN', 'BEN_92167_NO_MINMAX_WHEN_FCTR');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('MIN','Min Age : '||g_parm.min_age);
        fnd_message.set_token('MAX','Max Age : '||g_parm.max_age);
        --
        -- Do not specify the min and max values when selecting a predefined
        -- FCTR factor.
        --
        fnd_message.raise_error;
        --
      end if;
      --
      if g_parm.los_fctr_id is not null or
         g_parm.min_los is not null or
         g_parm.max_los is not null or
         g_parm.cmbn_age_los_fctr_id is not null then
        fnd_message.set_name('BEN', 'BEN_92168_ONLY_ONE_FCTR');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('LOS_FCTR_ID',to_char(g_parm.los_fctr_id));
        fnd_message.set_token('AGE_FCTR_ID',to_char(g_parm.age_fctr_id));
        fnd_message.set_token('MIN_LOS',to_char(g_parm.min_los));
        fnd_message.set_token('MAX_LOS',to_char(g_parm.max_los));
        fnd_message.set_token('MIN_AGE',to_char(g_parm.min_age));
        fnd_message.set_token('MAX_AGE',to_char(g_parm.max_age));
        fnd_message.set_token('CMBN_AGE_LOS_FCTR_ID',
                             to_char(g_parm.cmbn_age_los_fctr_id));
        fnd_message.raise_error;
      end if;
      --
    end if;
    --
    if g_parm.los_fctr_id is not null then
      --
      -- If the factor is specified, then the min and max values should be null
      --
      if g_parm.min_los is not null or
         g_parm.max_los is not null then
        --
        fnd_message.set_name('BEN', 'BEN_92167_NO_MINMAX_WHEN_FCTR');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('MIN','Min Length of Service : '||g_parm.min_los);
        fnd_message.set_token('MAX','Max Length of Service : '||g_parm.max_los);
        --
        -- Do not specify the min and max values when selecting a predefined
        -- FCTR factor.
        --
        fnd_message.raise_error;
        --
      end if;
      --
      if g_parm.age_fctr_id is not null or
         g_parm.min_age is not null or
         g_parm.max_age is not null or
         g_parm.cmbn_age_los_fctr_id is not null then
        fnd_message.set_name('BEN', 'BEN_92168_ONLY_ONE_FCTR');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('LOS_FCTR_ID',to_char(g_parm.los_fctr_id));
        fnd_message.set_token('AGE_FCTR_ID',to_char(g_parm.age_fctr_id));
        fnd_message.set_token('MIN_LOS',to_char(g_parm.min_los));
        fnd_message.set_token('MAX_LOS',to_char(g_parm.max_los));
        fnd_message.set_token('MIN_AGE',to_char(g_parm.min_age));
        fnd_message.set_token('MAX_AGE',to_char(g_parm.max_age));
        fnd_message.set_token('CMBN_AGE_LOS_FCTR_ID',
                             to_char(g_parm.cmbn_age_los_fctr_id));
        fnd_message.raise_error;
      end if;
      --
    end if;
    --
    if g_parm.cmbn_age_los_fctr_id is not null then
      --
      if g_parm.age_fctr_id is not null or
         g_parm.los_fctr_id is not null then
        fnd_message.set_name('BEN', 'BEN_92168_ONLY_ONE_FCTR');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('LOS_FCTR_ID',to_char(g_parm.los_fctr_id));
        fnd_message.set_token('AGE_FCTR_ID',to_char(g_parm.age_fctr_id));
        fnd_message.set_token('MIN_LOS',to_char(g_parm.min_los));
        fnd_message.set_token('MAX_LOS',to_char(g_parm.max_los));
        fnd_message.set_token('MIN_AGE',to_char(g_parm.min_age));
        fnd_message.set_token('MAX_AGE',to_char(g_parm.max_age));
        fnd_message.set_token('CMBN_AGE_LOS_FCTR_ID',
                             to_char(g_parm.cmbn_age_los_fctr_id));
        fnd_message.raise_error;
      end if;
      --
    end if;
    --
    -- When a min or a max value is being supplied for a derivable factor:
    --
    if g_parm.min_age is not null or
       g_parm.max_age is not null then
      --
      -- Check if the min is greater than then max
      --
      if g_parm.min_age > g_parm.max_age then
        fnd_message.set_name('BEN', 'BEN_92534_MIN_MAX');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('MIN','Minimum Age : '||g_parm.min_age);
        fnd_message.set_token('MAX','Maximum Age : '||g_parm.max_age);
        fnd_message.raise_error;
      end if;
      --
      -- If only a max value is being provided, error out because if the user
      -- wants to evaluate a threshold, the min can be used for that purpose
      --
      if g_parm.min_age is null and
         g_parm.max_age is not null then
        fnd_message.set_name('BEN', 'BEN_92169_ONLY_MIN_OR_BOTH');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('MIN','Minimum Age : '||g_parm.min_age);
        fnd_message.set_token('MAX','Maximum Age : '||g_parm.max_age);
        -- Only max value specified. Provide only the min value or both min and
        -- max values.
        fnd_message.raise_error;
      end if;
      --
      -- When evaluating this derived factor, all other parameters relating to
      -- other derived factors should be null.
      --
      if g_parm.los_fctr_id is not null or
         g_parm.min_los is not null or
         g_parm.max_los is not null or
         g_parm.cmbn_age_los_fctr_id is not null then
        fnd_message.set_name('BEN', 'BEN_92168_ONLY_ONE_FCTR');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('LOS_FCTR_ID',to_char(g_parm.los_fctr_id));
        fnd_message.set_token('AGE_FCTR_ID',to_char(g_parm.age_fctr_id));
        fnd_message.set_token('MIN_LOS',to_char(g_parm.min_los));
        fnd_message.set_token('MAX_LOS',to_char(g_parm.max_los));
        fnd_message.set_token('MIN_AGE',to_char(g_parm.min_age));
        fnd_message.set_token('MAX_AGE',to_char(g_parm.max_age));
        fnd_message.set_token('CMBN_AGE_LOS_FCTR_ID',
                             to_char(g_parm.cmbn_age_los_fctr_id));
        --
        fnd_message.raise_error;
      end if;
      --
    elsif g_parm.min_los is not null or
          g_parm.max_los is not null then
      --
      -- Check if the min is greater than then max
      --
      if g_parm.min_los > g_parm.max_los then
        fnd_message.set_name('BEN', 'BEN_92534_MIN_MAX');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('MIN',
                   'Minimum Length of Service : '||g_parm.min_los);
        fnd_message.set_token('MAX',
                   'Maximum Length of Service : '||g_parm.max_los);
        fnd_message.raise_error;
      end if;
      --
      -- If only a max value is being provided, error out because if the user
      -- wants to evaluate a threshold, the min can be used for that purpose
      --
      if g_parm.min_los is null and
         g_parm.max_los is not null then
        fnd_message.set_name('BEN', 'BEN_92169_ONLY_MIN_OR_BOTH');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('MIN',
                   'Minimum Length of Service : '||g_parm.min_los);
        fnd_message.set_token('MAX',
                   'Maximum Length of Service : '||g_parm.max_los);
        fnd_message.raise_error;
      end if;
      --
      -- When evaluating this derived factor, all other parameters relating to
      -- other derived factors should be null.
      --
      if g_parm.age_fctr_id is not null or
         g_parm.min_age is not null or
         g_parm.max_age is not null or
         g_parm.cmbn_age_los_fctr_id is not null then
        fnd_message.set_name('BEN', 'BEN_92168_ONLY_ONE_FCTR');
        fnd_message.set_token('PROC',l_proc);
        fnd_message.set_token('LOS_FCTR_ID',to_char(g_parm.los_fctr_id));
        fnd_message.set_token('AGE_FCTR_ID',to_char(g_parm.age_fctr_id));
        fnd_message.set_token('MIN_LOS',to_char(g_parm.min_los));
        fnd_message.set_token('MAX_LOS',to_char(g_parm.max_los));
        fnd_message.set_token('MIN_AGE',to_char(g_parm.min_age));
        fnd_message.set_token('MAX_AGE',to_char(g_parm.max_age));
        fnd_message.set_token('CMBN_AGE_LOS_FCTR_ID',
                             to_char(g_parm.cmbn_age_los_fctr_id));
        fnd_message.raise_error;
      end if;
      --
    end if;
    --
  end if; -- cm_trgr_typ_cd = EMRGEVT
  --
  -- Business Rules for the Targeted Mass Mailing Trigger
  --
  if g_parm.cm_trgr_typ_cd = 'MSSMLG' then
    --
    if g_parm.elig_enrol_cd is not null
       and g_parm.pgm_id is null and
          g_parm.pl_nip_id is null then
      --
      -- If the elig_enrol_cd is being specified, then a comp object must be
      -- specified.
      --
      fnd_message.set_name('BEN', 'BEN_92171_PLAN_OR_PGM');
      fnd_message.set_token('PROC',l_proc);
      -- A program or a plan must be provided for the mass mailing trigger.
      fnd_message.raise_error;
      --
    end if;
    --
  end if; -- g_parm.cm_trgr_typ_cd = MSSMLG
  --
  hr_utility.set_location ('Leaving '||l_proc,10);
--
end check_business_rules;
--
-- ----------------------------------------------------------------------------
-- ---------------------------< process_age >----------------------------------
-- ----------------------------------------------------------------------------
--
procedure process_age
  (p_person_id        in  number
  ,p_lf_evt_ocrd_dt   out nocopy date
  ,p_breach           out nocopy boolean) is
--
-- This procedure processes a person's age. This calculation is different from
-- age calculations in other modules because of a date range. The user can
-- specify a range of dates in which to evaluate if the person(s) will cross an
-- age boundary.
--
  cursor c_person is
  select ppf.date_of_birth
    from per_all_people_f ppf
   where ppf.person_id = p_person_id
     and ppf.business_group_id = g_parm.business_group_id
     and g_parm.effective_date between ppf.effective_start_date
                                   and ppf.effective_end_date;
  --
  l_dob date;
  --
  cursor c_agf is
  select *
    from ben_age_fctr agf
   where agf.age_fctr_id = g_parm.age_fctr_id
     and agf.business_group_id = g_parm.business_group_id;
  --
  l_agf c_agf%rowtype;
  --
  dob_null exception;
  agf_pgm_or_pl exception;
  --
  l_age_before number;
  l_age_after number;
  l_adj_date_from date;
  l_adj_date_to date;
  l_effective_date date;
  l_uom              varchar2(30) := null;
  l_min_value        number;
  l_max_value        number;
  l_break            varchar2(30);
  --RCHASE
  l_dob_null date:=NULL;
  --
  l_proc varchar2(80) := g_package || '.process_age';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  hr_utility.set_location('Processing age for person ID : ' || p_person_id, 10);
  --
  -- Get the person's date of birth
  --
  open c_person;
  fetch c_person into l_dob;
  close c_person;
  --
  if l_dob is null then
    raise dob_null;
  end if;
  --
  if g_parm.date_from is not null then
     --
     l_effective_date := g_parm.date_from;
     --
  else
     --
     l_effective_date := g_parm.effective_date;
     --
  end if;
  --
  if g_parm.age_fctr_id is not null then
    --
    -- An age factor is specified. Get the details from the table.
    --
    open c_agf;
    fetch c_agf into l_agf;
    close c_agf;
    --
    l_uom       := l_agf.age_uom;
    l_min_value := l_agf.mn_age_num;
    l_max_value := l_agf.mx_age_num;
    --
    if l_agf.age_det_cd in ('AFDCPPY', 'ALDCPPY', 'AFDFPPY') and
       g_parm.pgm_id is null and
       g_parm.pl_nip_id is null then
      raise agf_pgm_or_pl;
    end if;
    --
    ben_derive_factors.determine_age
      (p_person_id            => p_person_id
      --RCHASE
      ,p_per_dob              => l_dob_null
      ,p_age_fctr_id          => l_agf.age_fctr_id
      ,p_per_in_ler_id        => null
      ,p_pgm_id               => g_parm.pgm_id
      ,p_pl_id                => g_parm.pl_nip_id
      ,p_effective_date       => l_effective_date - 1
      ,p_business_group_id    => g_parm.business_group_id
      ,p_value                => l_age_before
      ,p_change_date          => l_adj_date_from);
    --
    ben_derive_factors.determine_age
     (p_person_id            => p_person_id
      --RCHASE
      ,p_per_dob              => l_dob_null
     ,p_age_fctr_id          => l_agf.age_fctr_id
     ,p_per_in_ler_id        => null
     ,p_pgm_id               => g_parm.pgm_id
     ,p_pl_id                => g_parm.pl_nip_id
     ,p_effective_date       => g_parm.effective_date
     ,p_business_group_id    => g_parm.business_group_id
     ,p_value                => l_age_after
     ,p_change_date          => l_adj_date_to);
    --
  elsif g_parm.age_fctr_id is null and
        (g_parm.min_age is not null or
         g_parm.max_age is not null) then
    --
    -- An age factor not specified. But a min age or a max age was specified.
    -- Evaluate if the person's age will cross either the min or max boundary
    -- in the date range (date_from to effective_date) specified.
    --
    hr_utility.set_location('Calculating user specified age ' || l_proc, 10);
    --
    l_age_before := months_between(l_effective_date - 1, l_dob )/12;
    l_age_after  := months_between(g_parm.effective_date, l_dob)/12;
    l_uom        := 'YR';
    l_min_value  := g_parm.min_age;
    l_max_value  := g_parm.max_age;
    --
    hr_utility.set_location('Age Before'||l_age_before,10);
    hr_utility.set_location('Age After'||l_age_after,10);
    hr_utility.set_location('Min Value'||l_min_value,10);
    hr_utility.set_location('Max Value'||l_max_value,10);
    --
  end if; -- g_parm.age_fctr_id
  --
  -- Check if a breach occures.
  --
  --
  if benutils.min_max_breach(
           p_min_value => l_min_value,
           p_max_value => l_max_value,
           p_old_value => l_age_before,
           p_new_value => l_age_after,
           p_break     => l_break)  then
     --
     p_lf_evt_ocrd_dt := benutils.derive_date(
                             p_date    => l_dob,
                             p_uom     => l_uom,
                             p_min     => l_min_value,
                             p_max     => l_max_value,
                             p_value   => l_break);
     p_breach := true;
     --
  else
     --
     p_lf_evt_ocrd_dt := null;
     p_breach         := false;
     --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
exception
--
  when dob_null then
    hr_utility.set_location('Exception raised in ' || l_proc, 10);
    fnd_message.set_name('BEN', 'BEN_91337_DOB');
    fnd_message.set_token('PROC',l_proc);
    fnd_message.set_token('PERSON_ID',to_char(p_person_id));
    -- The person being processed does not have a date of birth.
    raise ben_manage_life_events.g_record_error;
  --
  when agf_pgm_or_pl then
    hr_utility.set_location('Exception raised in ' || l_proc, 10);
    fnd_message.set_name('BEN','BEN_92181_FCTR_RQR_PGM_OR_PL');
    fnd_message.set_token('PROC',l_proc);
    fnd_message.set_token('PERSON_ID',to_char(p_person_id));
    --
    -- The derived factor chosen uses a program or a plan year for calculation.
    -- Please select a program or plan.
    --
    raise ben_manage_life_events.g_record_error;
  --
  when others then
    hr_utility.set_location('Exception raised in ' || l_proc, 10);
    	-- For nocopy changes
    	p_lf_evt_ocrd_dt := null;
    	p_breach         := false;
    	--
    raise;
    --
end process_age;
--
-- ----------------------------------------------------------------------------
-- ---------------------------< process_los >----------------------------------
-- ----------------------------------------------------------------------------
--
procedure process_los
  (p_person_id in     number
  ,p_lf_evt_ocrd_dt out nocopy date
  ,p_breach       out nocopy boolean) is
--
-- This procedure processes the person's length of service.
--
  cursor c_lsf is
  select *
    from ben_los_fctr los
   where los.los_fctr_id = g_parm.los_fctr_id
     and los.business_group_id = g_parm.business_group_id;
  --
  l_lsf c_lsf%rowtype;
  --
  cursor c_person is
  select pps.date_start,
         pps.adjusted_svc_date
    from per_periods_of_service pps
   where pps.person_id = p_person_id
     and pps.business_group_id = g_parm.business_group_id;
  --
  l_start_date     date;
  l_adj_svc_date   date;
  l_los_before     number;
  l_los_after      number;
  l_min_value      number;
  l_max_value      number;
  l_effective_date date;
  l_break          varchar2(30);
  l_uom            varchar2(30);
  --
  lsf_pgm_or_pl exception;
  --
  l_proc varchar2(80) := g_package || '.calculate_los';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  hr_utility.set_location('Person ID : ' || p_person_id, 10);
  --
  open c_person;
  fetch c_person into l_start_date,
                      l_adj_svc_date;
  close c_person;
  --
  -- If the LOS Date to use Code is to use Adjusted Service date,
  -- override the start date by adjusted service date, if it is not null.
  --
  if g_parm.los_det_to_use_cd = 'ASD' then
     --
     l_start_date := nvl(l_adj_svc_date, l_start_date);
     --
  end if;
  --
  if g_parm.date_from is not null then
     --
     l_effective_date := g_parm.date_from;
     --
  else
     --
     l_effective_date := g_parm.effective_date;
     --
  end if;
  --
  if g_parm.los_fctr_id is not null then
    --
    -- An LOS factor is specified. Get the details from the table.
    --
    open c_lsf;
    fetch c_lsf into l_lsf;
    close c_lsf;
    --
    if l_lsf.los_det_cd in ('AFDCPPY', 'ALDCPPY', 'AFDFPPY') and
       g_parm.pgm_id is null and
       g_parm.pl_nip_id is null then
      raise lsf_pgm_or_pl;
    end if;
    --
    l_uom       := l_lsf.los_uom;
    l_min_value := l_lsf.mn_los_num;
    l_max_value := l_lsf.mx_los_num;
    --
    ben_derive_factors.determine_los
      (p_person_id            => p_person_id
      ,p_los_fctr_id          => l_lsf.los_fctr_id
      ,p_per_in_ler_id        => null
      ,p_pgm_id               => g_parm.pgm_id
      ,p_pl_id                => g_parm.pl_nip_id
      ,p_effective_date       => l_effective_date - 1
      ,p_lf_evt_ocrd_dt       => null
      ,p_business_group_id    => g_parm.business_group_id
      ,p_perform_rounding_flg => TRUE
      ,p_value                => l_los_before
      ,p_start_date           => l_start_date);
    --
    ben_derive_factors.determine_los
      (p_person_id            => p_person_id
      ,p_los_fctr_id          => l_lsf.los_fctr_id
      ,p_per_in_ler_id        => null
      ,p_pgm_id               => g_parm.pgm_id
      ,p_pl_id                => g_parm.pl_nip_id
      ,p_effective_date       => g_parm.effective_date
      ,p_lf_evt_ocrd_dt       => null
      ,p_business_group_id    => g_parm.business_group_id
      ,p_perform_rounding_flg => TRUE
      ,p_value                => l_los_after
      ,p_start_date           => l_start_date);
    --
  elsif g_parm.los_fctr_id is null and
        (g_parm.min_los is not null or
         g_parm.max_los is not null) then
    --
    -- An LOS factor not specified. But a min LOS or a max LOS was specified.
    -- Evaluate if the person's LOS will cross either the min or max boundary
    -- in the date range (date_from to effective_date) specified.
    --
    hr_utility.set_location('Calculating user specified LOS ' || l_proc, 10);
    --
    l_los_before := months_between(l_effective_date - 1, l_start_date )/12;
    l_los_after  := months_between(g_parm.effective_date, l_start_date)/12;
    l_uom        := 'YR';
    l_min_value  := g_parm.min_los;
    l_max_value  := g_parm.max_los;
    --
  end if; -- g_parm.los_fctr_id
  --
  -- Check if a breach occures.
  --
  if benutils.min_max_breach(
           p_min_value => l_min_value,
           p_max_value => l_max_value,
           p_old_value => l_los_before,
           p_new_value => l_los_after,
           p_break     => l_break)  then
     --
     p_lf_evt_ocrd_dt := benutils.derive_date(
                             p_date    => l_start_date,
                             p_uom     => l_uom,
                             p_min     => l_min_value,
                             p_max     => l_max_value,
                             p_value   => l_break);
     p_breach := true;
     --
  else
     --
     p_lf_evt_ocrd_dt := null;
     p_breach         := false;
     --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
exception
--
  when lsf_pgm_or_pl then
    --
    hr_utility.set_location('Leaving : ' || l_proc, 10);
    fnd_message.set_name('BEN','BEN_92181_FCTR_RQR_PGM_OR_PL');
    fnd_message.set_token('PROC',l_proc);
    fnd_message.set_token('PERSON_ID',to_char(p_person_id));
    --
    -- The derived factor chosen uses a program or a plan year for calculation.
    -- Please select a program or plan.
    --
    raise ben_manage_life_events.g_record_error;
    --
  when others then
    hr_utility.set_location('Exception raised in ' || l_proc, 10);
    -- For nocopy changes
    p_lf_evt_ocrd_dt := null;
    p_breach         := false;
    --
    raise;
--
end process_los;
--
-- ----------------------------------------------------------------------------
-- ------------------------< process_cmbn_age_los >----------------------------
-- ----------------------------------------------------------------------------
--
procedure process_cmbn_age_los
  (p_person_id       in  number
  ,p_lf_evt_ocrd_dt  out nocopy date
  ,p_breach          out nocopy boolean) is
--
  cursor c_cmbn is
  select cal.cmbn_age_los_fctr_id,
         cal.age_fctr_id,
         cal.los_fctr_id,
         cal.cmbnd_min_val,
         cal.cmbnd_max_val,
         agf.mn_age_num,
         agf.mx_age_num,
         agf.age_det_cd,
         lsf.mn_los_num,
         lsf.mx_los_num,
         lsf.los_det_cd
    from ben_cmbn_age_los_fctr cal,
         ben_age_fctr agf,
         ben_los_fctr lsf
   where cal.cmbn_age_los_fctr_id = g_parm.cmbn_age_los_fctr_id
     and cal.business_group_id = g_parm.business_group_id
     and cal.age_fctr_id = agf.age_fctr_id
     and agf.business_group_id = g_parm.business_group_id
     and cal.los_fctr_id = lsf.los_fctr_id
     and lsf.business_group_id = g_parm.business_group_id;
  --
  l_cmbn c_cmbn%rowtype;
  --
  l_age_before       number;
  l_age_after        number;
  l_los_before       number;
  l_los_after        number;
  l_cmbn_before      number;
  l_cmbn_after       number;
  l_min_value        number;
  l_max_value        number;
  l_adj_date         date;
  l_effective_date   date;
  l_start_date       date;
  l_break            varchar2(30);
  l_dob_null date:=NULL;
  --
  cmbn_pgm_or_pl exception;
  --
  l_proc varchar2(80) := g_package || '.process_cmbn_age_los';
--
begin
  --
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  if g_parm.date_from is not null then
     --
     l_effective_date := g_parm.date_from;
     --
  else
     --
     l_effective_date := g_parm.effective_date;
     --
  end if;
  --
  open c_cmbn;
  fetch c_cmbn into l_cmbn;
  close c_cmbn;
  --
  if (l_cmbn.age_det_cd in ('AFDCPPY','ALDCPPY','AFDCPPY') or
      l_cmbn.los_det_cd in ('AFDCPPY','ALDCPPY','AFDCPPY')) and
      g_parm.pgm_id is null and
      g_parm.pl_nip_id is null then
     raise cmbn_pgm_or_pl;
  end if;
  --
  ben_derive_factors.determine_age
    (p_person_id            => p_person_id
      --RCHASE
    ,p_per_dob              => l_dob_null
    ,p_age_fctr_id          => l_cmbn.age_fctr_id
    ,p_per_in_ler_id        => null
    ,p_pgm_id               => g_parm.pgm_id
    ,p_pl_id                => g_parm.pl_nip_id
    ,p_effective_date       => l_effective_date - 1
    ,p_business_group_id    => g_parm.business_group_id
    ,p_value                => l_age_before
    ,p_change_date          => l_adj_date);
  --
  ben_derive_factors.determine_age
   (p_person_id            => p_person_id
      --RCHASE
   ,p_per_dob              => l_dob_null
   ,p_age_fctr_id          => l_cmbn.age_fctr_id
   ,p_per_in_ler_id        => null
   ,p_pgm_id               => g_parm.pgm_id
   ,p_pl_id                => g_parm.pl_nip_id
   ,p_effective_date       => g_parm.effective_date
   ,p_business_group_id    => g_parm.business_group_id
   ,p_value                => l_age_after
   ,p_change_date          => l_adj_date);
    --
  ben_derive_factors.determine_los
    (p_person_id            => p_person_id
    ,p_los_fctr_id          => l_cmbn.los_fctr_id
    ,p_per_in_ler_id        => null
    ,p_pgm_id               => g_parm.pgm_id
    ,p_pl_id                => g_parm.pl_nip_id
    ,p_effective_date       => l_effective_date - 1
    ,p_lf_evt_ocrd_dt       => null
    ,p_business_group_id    => g_parm.business_group_id
    ,p_perform_rounding_flg => TRUE
    ,p_value                => l_los_before
    ,p_start_date           => l_start_date);
  --
  ben_derive_factors.determine_los
    (p_person_id            => p_person_id
    ,p_los_fctr_id          => l_cmbn.los_fctr_id
    ,p_per_in_ler_id        => null
    ,p_pgm_id               => g_parm.pgm_id
    ,p_pl_id                => g_parm.pl_nip_id
    ,p_effective_date       => g_parm.effective_date
    ,p_lf_evt_ocrd_dt       => null
    ,p_business_group_id    => g_parm.business_group_id
    ,p_perform_rounding_flg => TRUE
    ,p_value                => l_los_after
    ,p_start_date           => l_start_date);
  --
  l_cmbn_before := l_age_before + l_los_before;
  l_cmbn_after  := l_age_after + l_los_after;
  l_min_value   := nvl(l_cmbn.cmbnd_min_val,
                       l_cmbn.mn_age_num+l_cmbn.mn_los_num);
  l_max_value   := nvl(l_cmbn.cmbnd_max_val,
                       l_cmbn.mx_age_num+l_cmbn.mx_los_num);
  --
  if benutils.min_max_breach(
           p_min_value => l_min_value,
           p_max_value => l_max_value,
           p_old_value => l_cmbn_before,
           p_new_value => l_cmbn_after,
           p_break     => l_break)  then
     --
     p_lf_evt_ocrd_dt := g_parm.effective_date;
     p_breach := true;
     --
  else
     --
     p_lf_evt_ocrd_dt := null;
     p_breach         := false;
     --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
exception
--
  when cmbn_pgm_or_pl then
    hr_utility.set_location('Exception raised in ' || l_proc, 10);
    fnd_message.set_name('BEN','BEN_92181_FCTR_RQR_PGM_OR_PL');
    fnd_message.set_token('PROC',l_proc);
    fnd_message.set_token('PERSON_ID',to_char(p_person_id));
    --
    -- The derived factor chosen uses a program or plan year for calculation.
    -- Please select a program or plan.
    --
    raise ben_manage_life_events.g_record_error;
  --
  when others then
    hr_utility.set_location('Exception raised in ' || l_proc, 10);
    -- For nocopy changes
    p_lf_evt_ocrd_dt := null;
    p_breach         := false;
    --
    raise;
end;
--
-- ----------------------------------------------------------------------------
-- ------------------------< process_emrg_events >-----------------------------
-- ----------------------------------------------------------------------------
--
procedure process_emrg_events
  (p_start_person_action_id in number
  ,p_end_person_action_id   in number) is
  --
  cursor c_per_actn is
  select *
    from ben_person_actions bpa
   where bpa.benefit_action_id = g_parm.benefit_action_id
     and bpa.person_action_id between p_start_person_action_id
                              and p_end_person_action_id
     and bpa.action_status_cd <> 'P'
   order by bpa.person_action_id;
  --
  l_breach boolean;
  l_lf_evt_ocrd_dt date;
  l_person_id number;
  l_dpnt_person_id number := null;
  l_cm_sent boolean := TRUE;
  --
  l_proc varchar2(80) := g_package || '.process_emrg_events';
--
begin
--
  hr_utility.set_location('Entering ' || l_proc, 10);
  --
  for l_per_rec in c_per_actn loop
    --
    g_person_cnt := g_person_cnt + 1;
    l_breach := false;
    l_lf_evt_ocrd_dt := null;
    l_person_id := l_per_rec.person_id;
    --
    begin
      --
      -- Set a savepoint to rollback errors
      --
      savepoint before_communications;
      --
      if g_parm.age_fctr_id is not null or
         g_parm.min_age is not null or
         g_parm.max_age is not null then
        --
        hr_utility.set_location('Processing age ' || l_proc, 15);
        --
        -- If we are processing emerging events for dependents, then get the
        -- main person id since the communication will be sent to participants.
        --
        /* Bug 8364821: Added If else condition. If Dependent is an Employee, do not create communication on the
	  Employee. Communication should be sent to the Dependent. If not send the Communication to the Employee */
          if is_dependent_emp(p_person_id => l_per_rec.person_id) then
	          hr_utility.set_location('Dependent is Employee ', 15);
                  l_person_id := l_per_rec.person_id;
	  else
	          hr_utility.set_location('Dependent is Dependent ', 15);
		  l_person_id := get_main_person_id
				   (p_dpnt_person_id => l_per_rec.person_id);
		  --
		  l_dpnt_person_id := l_per_rec.person_id;
          end if;
        --
        -- Process the person's age to check if there is a breach.
        --
        process_age(p_person_id      => l_per_rec.person_id
                   ,p_lf_evt_ocrd_dt => l_lf_evt_ocrd_dt
                   ,p_breach         => l_breach);
        --
      elsif g_parm.los_fctr_id is not null or
            g_parm.min_los is not null or
            g_parm.max_los is not null then
        --
        hr_utility.set_location('Processing LOS ' || l_proc, 15);
        --
        l_person_id := l_per_rec.person_id;
        --
        -- Process the person's length of service to check if there is a breach.
        --
        process_los
          (p_person_id      => l_per_rec.person_id
          ,p_lf_evt_ocrd_dt => l_lf_evt_ocrd_dt
          ,p_breach         => l_breach);
        --
      elsif g_parm.cmbn_age_los_fctr_id is not null then
        --
        hr_utility.set_location('Processing cmbn_age_los ' || l_proc, 15);
        --
        l_person_id := l_per_rec.person_id;
        --
        -- Process the person's combination of age and length of service.
        --
        process_cmbn_age_los
          (p_person_id      => l_per_rec.person_id
          ,p_lf_evt_ocrd_dt => l_lf_evt_ocrd_dt
          ,p_breach         => l_breach);
        --
      else
        hr_utility.set_location('Not calculating factors ' || l_proc, 15);
      end if;
      --
      hr_utility.set_location('After processing...', 15);
      --
      ben_generate_communications.g_comm_generated := false;
      --
      if l_breach then
        --
        hr_utility.set_location(l_person_id,10);
        hr_utility.set_location(g_parm.cm_trgr_typ_cd,10);
        hr_utility.set_location(g_parm.cm_typ_id,10);
        hr_utility.set_location(g_parm.pgm_id,10);
        hr_utility.set_location(g_parm.pl_nip_id,10);
        hr_utility.set_location(l_dpnt_person_id,10);
        hr_utility.set_location(g_parm.business_group_id,10);
        hr_utility.set_location(g_parm.effective_date,10);
        hr_utility.set_location(l_lf_evt_ocrd_dt,10);
        hr_utility.set_location(g_parm.mode_cd,10);
        ben_generate_communications.main
          (p_person_id             => l_person_id
          ,p_cm_trgr_typ_cd        => g_parm.cm_trgr_typ_cd
          ,p_cm_typ_id             => g_parm.cm_typ_id
          ,p_pgm_id                => g_parm.pgm_id
          ,p_pl_id                 => g_parm.pl_nip_id
          ,p_dpnt_person_id        => l_dpnt_person_id
          ,p_business_group_id     => g_parm.business_group_id
          ,p_proc_cd1              => 'MSSMLGEE'
          ,p_effective_date        => g_parm.effective_date
          ,p_lf_evt_ocrd_dt        => l_lf_evt_ocrd_dt
          ,p_mode                  => g_parm.mode_cd);
        --
      end if;
      --
      hr_utility.set_location('Here',10);
      if (g_parm.audit_log_flag = 'Y') then
         chk_per_cm(p_person_id => l_person_id);
      end if;
      --
      g_action_rec.person_action_id := l_per_rec.person_action_id;
      g_action_rec.action_status_cd := 'P';
      g_action_rec.object_version_number := l_per_rec.object_version_number;
      g_action_rec.effective_date := g_parm.effective_date;
      --
      hr_utility.set_location('Nearly Leaving Now',10);
      benutils.write(p_rec => g_action_rec);
      --
      hr_utility.set_location('Leaving Now',10);
    exception
      --
      when ben_manage_life_events.g_record_error then
        --
        hr_utility.set_location ('PERSON ERROR '|| l_proc,10);
        --
        rollback to before_communications;
        --
        g_rec.person_id  := l_per_rec.person_id;
        g_rec.rep_typ_cd := 'ERRCM';
        g_rec.error_message_code := benutils.get_message_name;
        g_rec.text := fnd_message.get;
        --
        benutils.write(p_rec => g_rec);
        --
        -- Update person action to errored as record has an error
        --
        g_action_rec.person_action_id := l_per_rec.person_action_id;
        g_action_rec.action_status_cd := 'E';
        g_action_rec.object_version_number := l_per_rec.object_version_number;
        g_action_rec.effective_date := g_parm.effective_date;
        --
        benutils.write(p_rec => g_action_rec);
        --
        -- Increment the person error count.
        --
        person_error_cnt;
        --
      when others then
        --
        hr_utility.set_location ('PERSON ERROR '|| l_proc,10);
        --
        rollback to before_communications;
        --
        g_rec.person_id := l_per_rec.person_id;
        g_rec.rep_typ_cd := 'FATAL';
        g_rec.error_message_code := sqlcode;
        g_rec.text := sqlerrm;
        --
        benutils.write(p_rec => g_rec);
        --
        -- Update person action to errored as record has an error
        --
        g_action_rec.person_action_id := l_per_rec.person_action_id;
        g_action_rec.action_status_cd := 'E';
        g_action_rec.object_version_number := l_per_rec.object_version_number;
        g_action_rec.effective_date := g_parm.effective_date;
        --
        benutils.write(p_rec => g_action_rec);
        --
        -- Increment the person error count.
        --
        person_error_cnt;
      --
    end;
    --
  end loop;
  --
  if g_parm.validate_flag = 'Y' then
    rollback;
  end if;
  --
  benutils.write_table_and_file(p_table => true
                               ,p_file  => true);
  --
  commit;
  --
  hr_utility.set_location('Leaving ' || l_proc, 10);
--
end process_emrg_events;
--
-- ----------------------------------------------------------------------------
-- ----------------------< process_trgt_mass_mail >----------------------------
-- ----------------------------------------------------------------------------
--
procedure process_trgt_mass_mail
  (p_start_person_action_id in number
  ,p_end_person_action_id   in number) is
--
  cursor c_per_actn is
  select *
    from ben_person_actions bpa
   where bpa.benefit_action_id = g_parm.benefit_action_id
     and bpa.person_action_id between p_start_person_action_id
                              and p_end_person_action_id
     and bpa.action_status_cd <> 'P'
   order by bpa.person_action_id;
  --
  l_object_version_number number;
  l_cm_sent boolean := TRUE;
  --
  l_proc varchar2(80) := g_package || '.process_trgt_mass_mail';
--
begin
  --
  hr_utility.set_location('Entering ' || l_proc, 10);
  --
  for l_per_rec in c_per_actn loop
    --
    g_person_cnt := g_person_cnt + 1;
    --
    begin
      -- Issue a savepoint to rollback when errors occur.
      --
      savepoint before_communications;
      --
      -- generate communications the selected people
      --
      ben_generate_communications.g_comm_generated := false;
      --
      ben_generate_communications.main
        (p_person_id             => l_per_rec.person_id
        ,p_cm_trgr_typ_cd        => g_parm.cm_trgr_typ_cd
        ,p_cm_typ_id             => g_parm.cm_typ_id
        ,p_pgm_id                => g_parm.pgm_id
        ,p_pl_id                 => g_parm.pl_nip_id
        ,p_business_group_id     => g_parm.business_group_id
        ,p_proc_cd1              => 'MSSMLG'
        ,p_effective_date        => g_parm.effective_date
        ,p_mode                  => g_parm.mode_cd);
      --
      if (g_parm.audit_log_flag = 'Y') then
        chk_per_cm(p_person_id => l_per_rec.person_id);
      end if;
      --
      g_action_rec.person_action_id := l_per_rec.person_action_id;
      g_action_rec.action_status_cd := 'P';
      g_action_rec.object_version_number := l_per_rec.object_version_number;
      g_action_rec.effective_date := g_parm.effective_date;
      --
      benutils.write(p_rec => g_action_rec);
      --
    exception
      --
      when ben_manage_life_events.g_record_error then
        --
        hr_utility.set_location ('PERSON ERROR '|| l_proc,10);
        --
        rollback to before_communications;
        --
        g_rec.rep_typ_cd := 'ERRCM';
        g_rec.error_message_code := benutils.get_message_name;
        g_rec.text := fnd_message.get;
        g_rec.person_id := l_per_rec.person_id;
        --
        benutils.write(p_rec => g_rec);
        --
        -- Update person action to errored as record has an error
        --
        g_action_rec.person_action_id := l_per_rec.person_action_id;
        g_action_rec.action_status_cd := 'E';
        g_action_rec.object_version_number := l_per_rec.object_version_number;
        g_action_rec.effective_date := g_parm.effective_date;
        --
        benutils.write(p_rec => g_action_rec);
        --
        -- Increment the person error count.
        --
        person_error_cnt;
      --
      when others then
        --
        hr_utility.set_location ('PERSON ERROR '|| l_proc,10);
        --
        rollback to before_communications;
        --
        g_rec.rep_typ_cd := 'FATAL';
        g_rec.error_message_code := sqlcode;
        g_rec.text := sqlerrm;
        g_rec.person_id := l_per_rec.person_id;
        --
        benutils.write(p_rec => g_rec);
        --
        -- Update person action to errored as record has an error
        --
        g_action_rec.person_action_id := l_per_rec.person_action_id;
        g_action_rec.action_status_cd := 'E';
        g_action_rec.object_version_number := l_per_rec.object_version_number;
        g_action_rec.effective_date := g_parm.effective_date;
        --
        benutils.write(p_rec => g_action_rec);
        --
        -- Increment the person error count.
        --
        person_error_cnt;
      --
    end;
    --
  end loop;
  --
  if g_parm.validate_flag = 'Y' then
    rollback;
  end if;
  --
  benutils.write_table_and_file(p_table => true
                               ,p_file  => true);
  --
  commit;
  --
  hr_utility.set_location('Leaving ' || l_proc, 10);
--
end process_trgt_mass_mail;
--
-- ----------------------------------------------------------------------------
-- --------------------< process_actn_item_reminders >-------------------------
-- ----------------------------------------------------------------------------
--
procedure process_actn_item_reminders
  (p_start_person_action_id in number
  ,p_end_person_action_id   in number) is
--
  cursor c_per_actn is
  select *
    from ben_person_actions bpa
   where bpa.benefit_action_id = g_parm.benefit_action_id
     and bpa.person_action_id between p_start_person_action_id
                              and p_end_person_action_id
     and bpa.benefit_action_id = g_parm.benefit_action_id
   order by bpa.person_action_id;
  --
  l_cm_sent boolean := TRUE;
  --
  l_proc varchar2(80) := g_package || '.process_actn_item_reminders';
--
begin
  --
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  for l_per_rec in c_per_actn loop
    --
    hr_utility.set_location('Processing person ID : ' ||l_per_rec.person_id,10);
    --
    begin
      --
      -- Set a savepoint to rollback errors
      --
      savepoint before_communications;
      --
      g_person_cnt := g_person_cnt + 1;
      --
      -- generate communications for the selected people
      --
      ben_generate_communications.g_comm_generated := false;
      --
      ben_generate_communications.main
        (p_person_id             => l_per_rec.person_id
        ,p_cm_trgr_typ_cd        => g_parm.cm_trgr_typ_cd
        ,p_cm_typ_id             => g_parm.cm_typ_id
        ,p_ler_id                => l_per_rec.ler_id
        ,p_actn_typ_id           => g_parm.actn_typ_id
        ,p_pgm_id                => g_parm.pgm_id
        ,p_pl_id                 => g_parm.pl_nip_id
        ,p_business_group_id     => g_parm.business_group_id
        ,p_proc_cd1              => 'MSSMLGAR'
        ,p_effective_date        => g_parm.effective_date
        ,p_mode                  => g_parm.mode_cd);
      --
      if (g_parm.audit_log_flag = 'Y') then
         chk_per_cm(p_person_id => l_per_rec.person_id);
      end if;
      --
      g_action_rec.person_action_id := l_per_rec.person_action_id;
      g_action_rec.action_status_cd := 'P';
      g_action_rec.object_version_number := l_per_rec.object_version_number;
      g_action_rec.effective_date := g_parm.effective_date;
      --
      benutils.write(p_rec => g_action_rec);
      --
    exception
      --
      when ben_manage_life_events.g_record_error then
        --
        hr_utility.set_location ('PERSON ERROR '|| l_proc,10);
        --
        rollback to before_communications;
        --
        g_rec.rep_typ_cd := 'ERRCM';
        g_rec.error_message_code := benutils.get_message_name;
        g_rec.text := fnd_message.get;
        g_rec.person_id := l_per_rec.person_id;
        --
        benutils.write(p_rec => g_rec);
        --
        -- Update the g_action_rec to record an error
        --
        g_action_rec.person_action_id := l_per_rec.person_action_id;
        g_action_rec.action_status_cd := 'E';
        g_action_rec.object_version_number := l_per_rec.object_version_number;
        g_action_rec.effective_date := g_parm.effective_date;
        --
        benutils.write(p_rec => g_action_rec);
        --
        -- Increment the person error count.
        --
        person_error_cnt;
      --
      when others then
        --
        hr_utility.set_location ('PERSON ERROR '|| l_proc,10);
        --
        rollback to before_communications;
        --
        g_rec.rep_typ_cd := 'FATAL';
        g_rec.error_message_code := sqlcode;
        g_rec.text := sqlerrm;
        g_rec.person_id := l_per_rec.person_id;
        --
        benutils.write(p_rec => g_rec);
        --
        -- Update person action to errored as record has an error
        --
        g_action_rec.person_action_id := l_per_rec.person_action_id;
        g_action_rec.action_status_cd := 'E';
        g_action_rec.object_version_number := l_per_rec.object_version_number;
        g_action_rec.effective_date := g_parm.effective_date;
        --
        benutils.write(p_rec => g_action_rec);
        --
        -- Increment the person error count.
        --
        person_error_cnt;
      --
    end;
    --
  end loop;
  --
  if g_parm.validate_flag = 'Y' then
    rollback;
  end if;
  --
  benutils.write_table_and_file(p_table => true
                               ,p_file  => true);
  --
  commit;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
end process_actn_item_reminders;
--
-- ----------------------------------------------------------------------------
-- ------------------------< process_enrt_reminders >--------------------------
-- ----------------------------------------------------------------------------
--
procedure process_enrt_reminders
  (p_start_person_action_id in number
  ,p_end_person_action_id   in number) is
--
  cursor c_per_actn is
  select *
    from ben_person_actions bpa
   where bpa.benefit_action_id = g_parm.benefit_action_id
     and bpa.person_action_id between p_start_person_action_id
                              and p_end_person_action_id
     and bpa.action_status_cd <> 'P'
      and bpa.benefit_action_id = g_parm.benefit_action_id
   order by bpa.person_action_id;
  --
  l_cm_sent boolean := TRUE;
  --
  l_proc varchar2(80) := g_package || '.process_enrt_reminders';
  l_asnd_lf_evt_dt date;
--
begin
  --
  hr_utility.set_location('Entering ' || l_proc, 10);
  --
  for l_per_rec in c_per_actn loop
    --
    g_person_cnt := g_person_cnt + 1;
    --
    begin
      --
      -- Set a savepoint to rollback errors.
      --
      savepoint before_communications;
      --
      -- generate communications for the selected people
      --
      ben_generate_communications.g_comm_generated := false;
      --
      l_asnd_lf_evt_dt   := fnd_date.canonical_to_date(g_parm.lf_evt_ocrd_dt);
      ben_generate_communications.main
        (p_person_id             => l_per_rec.person_id
        ,p_cm_trgr_typ_cd        => g_parm.cm_trgr_typ_cd
        ,p_cm_typ_id             => g_parm.cm_typ_id
        ,p_ler_id                => l_per_rec.ler_id
        ,p_pgm_id                => g_parm.pgm_id
        ,p_pl_id                 => g_parm.pl_nip_id
        -- PB : 5422 :
        -- ,p_enrt_perd_id          => g_parm.popl_enrt_typ_cycl_id
        ,p_asnd_lf_evt_dt        => l_asnd_lf_evt_dt -- fnd_date.canonical_to_date(g_parm.lf_evt_ocrd_dt)
        ,p_business_group_id     => g_parm.business_group_id
        ,p_proc_cd1              => 'MSSMLGER'
        ,p_effective_date        => g_parm.effective_date
        ,p_mode                  => g_parm.mode_cd);
      --
      if (g_parm.audit_log_flag = 'Y') then
        chk_per_cm(p_person_id => l_per_rec.person_id);
      end if;
      --
      g_action_rec.person_action_id := l_per_rec.person_action_id;
      g_action_rec.action_status_cd := 'P';
      g_action_rec.object_version_number := l_per_rec.object_version_number;
      g_action_rec.effective_date := g_parm.effective_date;
      --
      benutils.write(p_rec => g_action_rec);
      --
    exception
      --
      when ben_manage_life_events.g_record_error then
        --
        hr_utility.set_location ('PERSON ERROR '|| l_proc,10);
        --
        rollback to before_communications;
        --
        benutils.write(p_text => fnd_message.get);
        --
        g_rec.rep_typ_cd := 'ERRCM';
        g_rec.error_message_code := benutils.get_message_name;
        g_rec.text := fnd_message.get;
        g_rec.person_id := l_per_rec.person_id;
        --
        benutils.write(p_rec => g_rec);
        --
        -- Update person action to errored as record has an error
        --
        g_action_rec.person_action_id := l_per_rec.person_action_id;
        g_action_rec.action_status_cd := 'E';
        g_action_rec.object_version_number := l_per_rec.object_version_number;
        g_action_rec.effective_date := g_parm.effective_date;
        --
        benutils.write(p_rec => g_action_rec);
        --
        -- Increment the person error count.
        --
        person_error_cnt;
      --
      when others then
        --
        hr_utility.set_location ('PERSON ERROR '|| l_proc,10);
        --
        rollback to before_communications;
        --
        g_rec.rep_typ_cd := 'FATAL';
        g_rec.error_message_code := sqlcode;
        g_rec.text := sqlerrm;
        g_rec.person_id := l_per_rec.person_id;
        --
        benutils.write(p_rec => g_rec);
        --
        -- Update person action to errored as record has an error
        --
        g_action_rec.person_action_id := l_per_rec.person_action_id;
        g_action_rec.action_status_cd := 'E';
        g_action_rec.object_version_number := l_per_rec.object_version_number;
        g_action_rec.effective_date := g_parm.effective_date;
        --
        benutils.write(p_rec => g_action_rec);
        --
        -- Increment the person error count.
        --
        person_error_cnt;
      --
    end;
    --
  end loop;
  --
  if g_parm.validate_flag = 'Y' then
    rollback;
  end if;
  --
  benutils.write_table_and_file(p_table => true
                               ,p_file  => true);
  --
  commit;
  --
  hr_utility.set_location('Leaving ' || l_proc, 10);
--
end process_enrt_reminders;
--
-- ----------------------------------------------------------------------------
-- ---------------------------------< restart >--------------------------------
-- ----------------------------------------------------------------------------
--
procedure restart
  (errbuf              out nocopy varchar2
  ,retcode             out nocopy number
  ,p_benefit_action_id in  number) is
  --
  -- Cursor Declaration
  --
  cursor c_parm is
  select *
    from ben_benefit_actions ben
   where ben.benefit_action_id = p_benefit_action_id;
  --
  l_parm c_parm%rowtype;
  --
  l_errbuf varchar2(80);
  l_retcode number;
  l_proc varchar2(80) := g_package || '.restart';
--
begin
--
  --
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  -- get the parameters for a previous run and do a restart
  --
  open c_parm;
  fetch c_parm into l_parm;
  --
  if c_parm%notfound then
    close c_parm;
    fnd_message.set_name('BEN', 'BEN_91753_BENEFIT_ACTION_ERR');
    fnd_message.set_token('PROC',l_proc);
    fnd_message.raise_error;
  end if;
  --
  close c_parm;
  --
  process
    (errbuf                     => l_errbuf
    ,retcode                    => l_retcode
    ,p_benefit_action_id        => p_benefit_action_id
    ,p_validate                 => l_parm.validate_flag
    ,p_effective_date           => l_parm.process_date
    ,p_business_group_id        => l_parm.business_group_id
    ,p_mode                     => l_parm.mode_cd
    ,p_cm_trgr_typ_cd           => l_parm.cm_trgr_typ_cd
    ,p_cm_typ_id                => l_parm.cm_typ_id
    ,p_person_id                => l_parm.person_id
    ,p_person_type_id           => l_parm.person_type_id
    ,p_person_sel_rl            => l_parm.person_selection_rl
    ,p_organization_id          => l_parm.organization_id
    ,p_location_id              => l_parm.location_id
    ,p_ler_id                   => l_parm.ler_id
    ,p_pgm_id                   => l_parm.pgm_id
    ,p_pl_nip_id                => l_parm.pl_id
    ,p_plan_in_pgm_flag         => l_parm.no_programs_flag
    ,p_comp_selection_rl        => l_parm.comp_selection_rl
    ,p_actn_typ_id              => l_parm.actn_typ_id
    ,p_elig_enrol_cd            => l_parm.elig_enrol_cd
    ,p_use_fctr_to_sel_flag     => l_parm.use_fctr_to_sel_flag
    ,p_age_fctr_id              => l_parm.age_fctr_id
    ,p_min_age                  => l_parm.min_age
    ,p_max_age                  => l_parm.max_age
    ,p_los_fctr_id              => l_parm.los_fctr_id
    ,p_min_los                  => l_parm.min_los
    ,p_max_los                  => l_parm.max_los
    ,p_los_det_to_use_cd        => l_parm.los_det_to_use_cd
    ,p_cmbn_age_los_fctr_id     => l_parm.cmbn_age_los_fctr_id
    ,p_date_from                => l_parm.date_from
    --
    -- PB : 5422 :
    -- ,p_popl_enrt_typ_cycl_id    => l_parm.popl_enrt_typ_cycl_id
    ,p_lf_evt_ocrd_dt           => fnd_date.date_to_canonical(l_parm.lf_evt_ocrd_dt)
    ,p_audit_log_flag           => l_parm.audit_log_flag);
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
  --
end restart;
--
-- ----------------------------------------------------------------------------
-- ----------------------------< do_multithread >------------------------------
-- ----------------------------------------------------------------------------
--
procedure do_multithread
  (errbuf                     out nocopy varchar2
  ,retcode                    out nocopy number
  ,p_validate              in     varchar2 default 'N'
  ,p_benefit_action_id     in     number
  ,p_thread_id             in     number
  ,p_effective_date        in     varchar2
  ,p_business_group_id     in     number) is
  --
  cursor c_range_thread is
  select ran.rowid,
         ran.starting_person_action_id,
         ran.ending_person_action_id
    from ben_batch_ranges ran
   where ran.range_status_cd = 'U'
     and ran.benefit_action_id = p_benefit_action_id
     and rownum < 2
     for update of ran.range_status_cd;
  --
  l_range_rec c_range_thread%rowtype;
  --
  cursor c_parm is
  select ben.benefit_action_id
        ,ben.validate_flag
        ,ben.process_date
        ,ben.business_group_id
        ,ben.mode_cd
        ,ben.cm_trgr_typ_cd
        ,ben.cm_typ_id
        ,ben.person_id
        ,ben.person_type_id
        ,ben.person_selection_rl
        ,ben.organization_id
        ,ben.location_id
        ,ben.ler_id
        ,ben.pgm_id
        ,ben.pl_id
        ,ben.no_programs_flag
        ,ben.comp_selection_rl
        ,ben.actn_typ_id
        ,ben.elig_enrol_cd
        ,ben.use_fctr_to_sel_flag
        ,ben.age_fctr_id
        ,ben.min_age
        ,ben.max_age
        ,ben.los_fctr_id
        ,ben.min_los
        ,ben.max_los
        ,ben.los_det_to_use_cd
        ,ben.cmbn_age_los_fctr_id
        ,ben.date_from
        -- PB : 5422 :
        -- ,ben.popl_enrt_typ_cycl_id
        ,ben.lf_evt_ocrd_dt
        ,ben.audit_log_flag
    from ben_benefit_actions ben
   where ben.benefit_action_id = p_benefit_action_id;
  --
  l_effective_date date;
  l_proc varchar2(80) := g_package || '.do_multithread';
  l_commit      number;
--
begin
  --
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  -- Convert varchar2 dates to real dates
  -- 1) First remove time component
  -- 2) Next convert format
  l_effective_date := to_date(p_effective_date,'YYYY/MM/DD HH24:MI:SS');
  l_effective_date := to_date(to_char(trunc(l_effective_date),'DD-MON-RRRR')
                             ,'DD-MON-RRRR');
  --
  -- Put row in fnd_sessions
  --
  dt_fndate.change_ses_date
      (p_ses_date => l_effective_date,
       p_commit   => l_commit);
  --
  -- This process could be either a continuation of the master process or could
  -- be a spawned request from the master process in which case the globals will
  -- be empty. Get all the parameters just in case
  --
  -- Get the chunk size and threads for the batch process.
  --
  benutils.get_parameter
    (p_business_group_id => p_business_group_id
    ,p_batch_exe_cd      => 'BENTMPCM'
    ,p_threads           => g_threads
    ,p_chunk_size        => g_chunk_size
    ,p_max_errors        => g_max_errors);
  --
  -- Load the global parameter list.
  --
  open  c_parm;
  fetch c_parm into g_parm;
  close c_parm;
  --
  hr_utility.set_location(g_parm.business_group_id,100000);
  -- Set up benefits environment
  --
  ben_env_object.init(p_business_group_id => p_business_group_id,
                      p_effective_date    => l_effective_date,
                      p_thread_id         => p_thread_id,
                      p_chunk_size        => g_chunk_size,
                      p_threads           => g_threads,
                      p_max_errors        => g_max_errors,
                      p_benefit_action_id => p_benefit_action_id);
  --
  -- Set the global for the current thread being processed.
  --
  g_current_thread := p_thread_id;
  benutils.g_benefit_action_id := p_benefit_action_id;
  benutils.g_thread_id := p_thread_id;
  --
  -- Print parameters
  --
  print_parameters;
  --
  -- The processing for this thread is as follows:
  --   1) Lock the rows in ben_batch_ranges that are not processed.
  --   2) Fetch the start and ending person action id for the range.
  --   3) Process the rows in ben_person_action that fall in the range based on
  --      the trigger type.
  --   4) Go to number 1 again and repeat until all ranges are processed.
  --
  loop
    --
    open c_range_thread;
    fetch c_range_thread into l_range_rec;
    --
    if c_range_thread%notfound then
      close c_range_thread;
      exit;
    end if;
    --
    close c_range_thread;
    --
    update ben_batch_ranges
       set range_status_cd = 'P'
     where rowid = l_range_rec.rowid;
    --
    commit;
    --
    if g_parm.cm_trgr_typ_cd = 'ENRTRMDR' then
      --
      process_enrt_reminders
        (p_start_person_action_id => l_range_rec.starting_person_action_id
        ,p_end_person_action_id   => l_range_rec.ending_person_action_id);
      --
    elsif g_parm.cm_trgr_typ_cd = 'ACTNRMDR' then
      --
      process_actn_item_reminders
        (p_start_person_action_id => l_range_rec.starting_person_action_id
        ,p_end_person_action_id   => l_range_rec.ending_person_action_id);
      --
    elsif g_parm.cm_trgr_typ_cd = 'EMRGEVT' then
      --
      process_emrg_events
        (p_start_person_action_id => l_range_rec.starting_person_action_id
        ,p_end_person_action_id   => l_range_rec.ending_person_action_id);
      --
    elsif g_parm.cm_trgr_typ_cd = 'MSSMLG' then
      --
      process_trgt_mass_mail
        (p_start_person_action_id => l_range_rec.starting_person_action_id
        ,p_end_person_action_id   => l_range_rec.ending_person_action_id);
      --
    end if;
    --
  end loop;
  --
  check_all_slaves_finished;
  --
  -- Write statistics of the process to a log file
  --
  write_logfile;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
exception
  --
  when others then
    --
    rollback;
    benutils.write(p_text => sqlerrm);
    hr_utility.set_location ('BENTMPCM Error '|| l_proc,10);
    g_rec.rep_typ_cd := 'FATAL';
    g_rec.error_message_code := sqlcode;
    g_rec.text := fnd_message.get;
    benutils.write(p_rec => g_rec);
    --
    -- Output log information to log file
    --
    write_logfile;
    --
    check_all_slaves_finished;
    --
    fnd_message.set_name('BEN','BEN_92172_BENTMPCM_ERRORED');
    fnd_message.set_token('PROC',l_proc);
    benutils.write(p_text => fnd_message.get);
    benutils.write_table_and_file(p_table => true,
                                  p_file  => true);
    commit;
    --
    fnd_message.raise_error;
    --
end do_multithread;
--
-- ----------------------------------------------------------------------------
-- ---------------------------< create_actions_ranges >------------------------
-- ----------------------------------------------------------------------------
--
-- This procedure creates person actions and batch ranges based on the chunk
-- size. The in-out parameters keep track of the person action ids created.
--
procedure create_actions_ranges
  (p_person_id                in     number  default null
  ,p_ler_id                   in     number  default null
  ,p_start_person_action_id   in out nocopy number
  ,p_ending_person_action_id  in out nocopy number) is
--
  l_person_ok varchar2(1) := 'Y';
  l_person_action_id number;
  l_object_version_number number;
  l_range_id number;

 -- For Nocopy changes
   l_start_person_action_id number := p_start_person_action_id;
   l_ending_person_action_id number := p_ending_person_action_id;
  --
  l_proc varchar2(80) := g_package || '.create_actions_ranges';
--
begin
  --
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  if g_parm.person_sel_rl is not null then
    --
    hr_utility.set_location('Verifying rul',10);
    if not ben_rules.chk_person_selection
              (p_person_id               => p_person_id
              ,p_business_group_id       => g_parm.business_group_id
              ,p_person_selection_rule_id=> g_parm.person_sel_rl
              ,p_effective_date          => g_parm.effective_date
	      ,p_ler_id                  => p_ler_id) then
      --
      l_person_ok := 'N';
      --
    end if;
    --
  end if;
  --
  --if not(verify_person_type_id(p_person_id      => p_person_id,
  --                             p_person_type_id => g_parm.person_type_id)) then
  --  --
  --  hr_utility.set_location('Verifying person type',10);
  --  l_person_ok := 'N';
  --  --
  --end if;
  --
  -- Create a person action only if the person passes the person selection rule
  -- above. The default (if no person selecion rule was passed in) is 'Y'.
  --
  if l_person_ok = 'Y' then
    --
    ben_person_actions_api.create_person_actions
      (p_validate              => FALSE
      ,p_person_action_id      => l_person_action_id
      ,p_person_id             => p_person_id
      ,p_ler_id                => p_ler_id
      ,p_benefit_action_id     => g_parm.benefit_action_id
      ,p_action_status_cd      => 'U'
      ,p_chunk_number          => null
      ,p_object_version_number => l_object_version_number
      ,p_effective_date        => g_parm.effective_date);
    --
    g_person_actn_cnt := g_person_actn_cnt + 1;
    --
    -- We have to create batch ranges based on the number of person actions
    -- inserted and the chunk size. Keep track of the starting person action id
    -- by setting the out parameter.
    --
    if mod(g_person_actn_cnt, g_chunk_size) = 1 or g_chunk_size = 1 then
      p_start_person_action_id := l_person_action_id;
    end if;
    --
    p_ending_person_action_id := l_person_action_id;
    --
    if mod(g_person_actn_cnt, g_chunk_size) = 0 or g_chunk_size = 1 then
      --
      ben_batch_ranges_api.create_batch_ranges
        (p_validate                  => FALSE
        ,p_effective_date            => g_parm.effective_date
        ,p_benefit_action_id         => g_parm.benefit_action_id
        ,p_range_id                  => l_range_id
        ,p_range_status_cd           => 'U'
        ,p_starting_person_action_id => p_start_person_action_id
        ,p_ending_person_action_id   => p_ending_person_action_id
        ,p_object_version_number     => l_object_version_number);
      --
      g_num_ranges := g_num_ranges + 1;
      --
    end if;
    --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
exception
  when others then
  -- For nocopy changes
  p_start_person_action_id := l_start_person_action_id;
  p_ending_person_action_id := l_ending_person_action_id;

    raise;
--
end create_actions_ranges;
--
-- ----------------------------------------------------------------------------
-- ------------------------< create_enrtrmdr_ranges >--------------------------
-- ----------------------------------------------------------------------------
--
procedure create_enrtrmdr_ranges is
  --
  -- Cursor to select rows from ben_per_in_ler for people that haven't enrolled
  -- in a plan or a program as of the effective date
  --
  cursor c_pil_enrtrmdr is
  select distinct pil.person_id, pil.ler_id
    from ben_per_in_ler pil,
         ben_pil_elctbl_chc_popl pel,
         ben_ler_f ler
   where (g_parm.person_id is null or
          pil.person_id = g_parm.person_id)
     and pil.per_in_ler_stat_cd = 'STRTD'
     and pil.business_group_id = g_parm.business_group_id
     and pil.per_in_ler_id = pel.per_in_ler_id
     and pil.ler_id        = ler.ler_id
     and g_parm.effective_date between
         ler.effective_start_date and ler.effective_end_date
     and ler.typ_cd not in ('COMP', 'GSP', 'ABS')
     and pel.elcns_made_dt is null
     and g_parm.effective_date between
         nvl(pel.enrt_perd_strt_dt, g_parm.effective_date) and
         nvl(pel.enrt_perd_end_dt, g_parm.effective_date)
     --
     and (g_parm.person_type_id is null
          or
          exists (select null
                  from   per_person_type_usages_f ppu
                  where  pil.person_id = ppu.person_id
                  and    ppu.person_type_id = g_parm.person_type_id
                  and    g_parm.effective_date
                         between ppu.effective_start_date
                         and     ppu.effective_end_date))
     --
     and (g_parm.pgm_id is null or
          pel.pgm_id = g_parm.pgm_id)
     and ((g_parm.pl_nip_id is null
          and g_parm.plan_in_pgm_flag = 'Y'
          and pel.pgm_id is not null)
          or
          (g_parm.pl_nip_id is null
           and g_parm.plan_in_pgm_flag = 'N'
           and pel.pgm_id is null)
          or
          (g_parm.pl_nip_id = pel.pl_id
           and g_parm.plan_in_pgm_flag = 'N'))
     and (g_parm.ler_id is null or
          pil.ler_id = g_parm.ler_id)
     and ((g_parm.organization_id is null and
           g_parm.location_id is null)
           or
           /* check if the person belongs to the org or location specified */
	   /* Bug 5435002 */
           exists (select 's'
	 	    FROM per_all_assignments_f asg, per_assignment_status_types ast
                     WHERE asg.person_id = pil.person_id
                     AND asg.primary_flag = 'Y'
                     and (g_parm.organization_id is null or
                          asg.organization_id = g_parm.organization_id)
                     and (g_parm.location_id is null or
                          asg.location_id = g_parm.location_id)
                      AND g_parm.effective_date
                          BETWEEN asg.effective_start_date AND asg.effective_end_date
                      AND asg.assignment_status_type_id = ast.assignment_status_type_id
                      and asg.business_group_id = g_parm.business_group_id
                      AND (   (    assignment_type = 'E'
                                   AND (   ast.per_system_status = 'ACTIVE_ASSIGN'
                                    OR (    ast.per_system_status = 'TERM_ASSIGN'
                                            AND NOT EXISTS (
                                             SELECT assignment_id
                                              FROM per_all_assignments_f asg1, per_assignment_status_types ast1
                                               WHERE asg1.assignment_type = 'B'
                                                AND asg1.primary_flag = 'Y'
                                                AND asg1.person_id = pil.person_id
                                                AND asg1.assignment_status_type_id = ast1.assignment_status_type_id
                                                AND ast1.per_system_status = 'ACTIVE_ASSIGN'
                                                AND g_parm.effective_date
                                                    BETWEEN asg1.effective_start_date AND asg1.effective_end_date
                                            )
                                       )
                                       )
                              )
                       OR (    assignment_type = 'B'
                                   AND NOT EXISTS (
                                       SELECT assignment_id
                                        FROM per_all_assignments_f asg2, per_assignment_status_types ast2
                                         WHERE asg2.assignment_type = 'E'
                                           AND asg2.primary_flag = 'Y'
                                           AND asg2.person_id = pil.person_id
                                           AND asg2.assignment_status_type_id = ast2.assignment_status_type_id
                                           AND ast2.per_system_status = 'ACTIVE_ASSIGN'
                                           AND g_parm.effective_date
                                               BETWEEN asg2.effective_start_date AND asg2.effective_end_date
                                       )
                          )
                          )
		  )
	);
  --
  l_start_person_action_id number;
  l_ending_person_action_id number;
  l_range_id number;
  l_object_version_number number;
  --
  l_proc varchar2(80) := g_package || '.create_enrtrmdr_ranges';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  hr_utility.set_location('Creating actions and ranges ' || l_proc, 15);
  --
  for l_per_rec in c_pil_enrtrmdr loop
    --
    create_actions_ranges
      (p_person_id                => l_per_rec.person_id
      ,p_ler_id                   => l_per_rec.ler_id
      ,p_start_person_action_id   => l_start_person_action_id
      ,p_ending_person_action_id  => l_ending_person_action_id);
    --
  end loop;
  --
  -- There could be a few person actions left over from the call in the for
  -- loop above. Create a batch range for them.
  --
  If g_person_actn_cnt > 0 and
     mod(g_person_actn_cnt, g_chunk_size) <> 0 then
    --
    hr_utility.set_location('Ranges for remaining people ' || l_proc, 25);
    --
    ben_batch_ranges_api.create_batch_ranges
      (p_validate                  => FALSE
      ,p_effective_date            => g_parm.effective_date
      ,p_benefit_action_id         => g_parm.benefit_action_id
      ,p_range_id                  => l_range_id
      ,p_range_status_cd           => 'U'
      ,p_starting_person_action_id => l_start_person_action_id
      ,p_ending_person_action_id   => l_ending_person_action_id
      ,p_object_version_number     => l_object_version_number);
    --
    g_num_ranges := g_num_ranges + 1;
    --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
end create_enrtrmdr_ranges;
--
-- ----------------------------------------------------------------------------
-- ------------------------< create_actnrmdr_ranges >--------------------------
-- ----------------------------------------------------------------------------
--
procedure create_actnrmdr_ranges is
  --
  cursor c_per_actnrmdr is
  select distinct ppf.person_id
    from per_all_people_f ppf,
         ben_prtt_enrt_rslt_f pen,
         ben_per_in_ler pil,
         ben_prtt_enrt_actn_f pea
   where (g_parm.person_id is null or
          ppf.person_id = g_parm.person_id)
     and g_parm.effective_date between ppf.effective_start_date
                                   and ppf.effective_end_date
     and ppf.business_group_id = g_parm.business_group_id
     and pen.person_id = ppf.person_id
     and pen.ler_id = nvl(g_parm.ler_id, pen.ler_id)
     and pen.business_group_id = g_parm.business_group_id
     and g_parm.effective_date  between pen.effective_start_date
                                    and pen.effective_end_date
     and nvl(pen.enrt_cvg_thru_dt, hr_api.g_eot) = hr_api.g_eot
     and pen.prtt_enrt_rslt_stat_cd is null
     and pen.prtt_enrt_rslt_id = pea.prtt_enrt_rslt_id
     and (g_parm.actn_typ_id is null or
          pea.actn_typ_id = g_parm.actn_typ_id)
     and g_parm.effective_date between pea.effective_start_date
                                   and pea.effective_end_date
     and pea.business_group_id = g_parm.business_group_id
     --
     and (g_parm.person_type_id is null
          or
          exists (select null
                  from   per_person_type_usages_f ppu
                  where  ppf.person_id = ppu.person_id
                  and    ppu.person_type_id = g_parm.person_type_id
                  and    g_parm.effective_date
                         between ppu.effective_start_date
                         and     ppu.effective_end_date))
     --
     and pea.cmpltd_dt is null
     and (g_parm.pgm_id is null or
          pen.pgm_id = g_parm.pgm_id)
     and ((g_parm.pl_nip_id is null
          and g_parm.plan_in_pgm_flag = 'Y'
          and pen.pgm_id is not null)
          or
          (g_parm.pl_nip_id is null
           and g_parm.plan_in_pgm_flag = 'N'
           and pen.pgm_id is null)
          or
          (g_parm.pl_nip_id = pen.pl_id))
     and ((g_parm.organization_id is null and
           g_parm.location_id is null)
           or
           /* check if the person belongs to the org or location specified */
	   /* Bug 5435002 */
           exists (select 's'
	 	    FROM per_all_assignments_f asg, per_assignment_status_types ast
                     WHERE asg.person_id = ppf.person_id
                     AND asg.primary_flag = 'Y'
                     and (g_parm.organization_id is null or
                          asg.organization_id = g_parm.organization_id)
                     and (g_parm.location_id is null or
                          asg.location_id = g_parm.location_id)
                      AND g_parm.effective_date
                          BETWEEN asg.effective_start_date AND asg.effective_end_date
                      AND asg.assignment_status_type_id = ast.assignment_status_type_id
                      and asg.business_group_id = g_parm.business_group_id
                      AND (   (    assignment_type = 'E'
                                   AND (   ast.per_system_status = 'ACTIVE_ASSIGN'
                                    OR (    ast.per_system_status = 'TERM_ASSIGN'
                                            AND NOT EXISTS (
                                             SELECT assignment_id
                                              FROM per_all_assignments_f asg1, per_assignment_status_types ast1
                                               WHERE asg1.assignment_type = 'B'
                                                AND asg1.primary_flag = 'Y'
                                                AND asg1.person_id = ppf.person_id
                                                AND asg1.assignment_status_type_id = ast1.assignment_status_type_id
                                                AND ast1.per_system_status = 'ACTIVE_ASSIGN'
                                                AND g_parm.effective_date
                                                    BETWEEN asg1.effective_start_date AND asg1.effective_end_date
                                            )
                                       )
                                       )
                              )
                       OR (    assignment_type = 'B'
                                   AND NOT EXISTS (
                                       SELECT assignment_id
                                        FROM per_all_assignments_f asg2, per_assignment_status_types ast2
                                         WHERE asg2.assignment_type = 'E'
                                           AND asg2.primary_flag = 'Y'
                                           AND asg2.person_id = ppf.person_id
                                           AND asg2.assignment_status_type_id = ast2.assignment_status_type_id
                                           AND ast2.per_system_status = 'ACTIVE_ASSIGN'
                                           AND g_parm.effective_date
                                               BETWEEN asg2.effective_start_date AND asg2.effective_end_date
                                       )
                          )
                          )
		  )
	)
     and pil.per_in_ler_id(+)=pea.per_in_ler_id
     and pil.business_group_id(+)=pea.business_group_id
     and (   pil.per_in_ler_stat_cd not in ('VOIDD','BCKDT')
             -- found row condition
          or pil.per_in_ler_stat_cd is null
             -- outer join condition
         )
    ;
  --
  l_start_person_action_id number;
  l_ending_person_action_id number;
  l_range_id number;
  l_object_version_number number;
  --
  l_proc varchar2(80) := g_package || '.create_actnrmdr_ranges';
  --
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  for l_per_rec in c_per_actnrmdr loop
    --
    -- Create person actions and batch ranges.
    --
    create_actions_ranges
      (p_person_id                => l_per_rec.person_id
      ,p_start_person_action_id   => l_start_person_action_id
      ,p_ending_person_action_id  => l_ending_person_action_id);
    --
  end loop;
  --
  -- There could be a few person actions left over from the call in the for
  -- loop above. Create a batch range for them.
  --
  If g_person_actn_cnt > 0 and
     mod(g_person_actn_cnt, g_chunk_size) <> 0 then
    --
    hr_utility.set_location('Ranges for remaining people ' || l_proc, 25);
    --
    ben_batch_ranges_api.create_batch_ranges
      (p_validate                  => FALSE
      ,p_effective_date            => g_parm.effective_date
      ,p_benefit_action_id         => g_parm.benefit_action_id
      ,p_range_id                  => l_range_id
      ,p_range_status_cd           => 'U'
      ,p_starting_person_action_id => l_start_person_action_id
      ,p_ending_person_action_id   => l_ending_person_action_id
      ,p_object_version_number     => l_object_version_number);
    --
    g_num_ranges := g_num_ranges + 1;
    --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
end create_actnrmdr_ranges;
--
-- ----------------------------------------------------------------------------
-- ------------------------< create_emrgevt_ranges >---------------------------
-- ----------------------------------------------------------------------------
--
procedure create_emrgevt_ranges is
  --
  -- Cursor to select people from per_people_f for the emerging event literature
  --
  cursor c_per_emrgevt is
  select distinct ppf.person_id
    from per_people_f ppf
   where (g_parm.person_id is null or
          ppf.person_id = g_parm.person_id)
     and ppf.business_group_id = g_parm.business_group_id
     and (g_parm.date_from is null or
          g_parm.date_from between ppf.effective_start_date
                               and ppf.effective_end_date)
     and g_parm.effective_date between ppf.effective_start_date
                                   and ppf.effective_end_date
     and (g_parm.person_type_id is null
          or
          exists (select null
                  from   per_person_type_usages_f ppu
                  where  ppf.person_id = ppu.person_id
                  and    ppu.person_type_id = g_parm.person_type_id
                  and    g_parm.effective_date
                         between ppu.effective_start_date
                         and     ppu.effective_end_date))
     and ((g_parm.organization_id is null and
           g_parm.location_id is null)
           or
           /* check if the person belongs to the org or location specified */
	   /* Bug 5435002 */
           exists (select 's'
	 	    FROM per_all_assignments_f asg, per_assignment_status_types ast
                     WHERE asg.person_id = ppf.person_id
                     AND asg.primary_flag = 'Y'
                     and (g_parm.organization_id is null or
                          asg.organization_id = g_parm.organization_id)
                     and (g_parm.location_id is null or
                          asg.location_id = g_parm.location_id)
                      AND g_parm.effective_date
                          BETWEEN asg.effective_start_date AND asg.effective_end_date
                      AND asg.assignment_status_type_id = ast.assignment_status_type_id
                      and asg.business_group_id = g_parm.business_group_id
                      AND (   (    assignment_type = 'E'
                                   AND (   ast.per_system_status = 'ACTIVE_ASSIGN'
                                    OR (    ast.per_system_status = 'TERM_ASSIGN'
                                            AND NOT EXISTS (
                                             SELECT assignment_id
                                              FROM per_all_assignments_f asg1, per_assignment_status_types ast1
                                               WHERE asg1.assignment_type = 'B'
                                                AND asg1.primary_flag = 'Y'
                                                AND asg1.person_id = ppf.person_id
                                                AND asg1.assignment_status_type_id = ast1.assignment_status_type_id
                                                AND ast1.per_system_status = 'ACTIVE_ASSIGN'
                                                AND g_parm.effective_date
                                                    BETWEEN asg1.effective_start_date AND asg1.effective_end_date
                                            )
                                       )
                                       )
                              )
                       OR (    assignment_type = 'B'
                                   AND NOT EXISTS (
                                       SELECT assignment_id
                                        FROM per_all_assignments_f asg2, per_assignment_status_types ast2
                                         WHERE asg2.assignment_type = 'E'
                                           AND asg2.primary_flag = 'Y'
                                           AND asg2.person_id = ppf.person_id
                                           AND asg2.assignment_status_type_id = ast2.assignment_status_type_id
                                           AND ast2.per_system_status = 'ACTIVE_ASSIGN'
                                           AND g_parm.effective_date
                                               BETWEEN asg2.effective_start_date AND asg2.effective_end_date
                                       )
                          )
                          )
		  )
	);
  --
  cursor c_elig(v_person_id number) is
  select elig.pgm_id,
         elig.pl_id
    from ben_elig_per_f elig,
         ben_per_in_ler pil
   where elig.person_id = v_person_id
    and (g_parm.pgm_id is null or
         elig.pgm_id = g_parm.pgm_id)
    and ((g_parm.pl_nip_id is null
          and g_parm.plan_in_pgm_flag = 'Y'
          and elig.pgm_id is not null)
          or
         (g_parm.pl_nip_id is null
          and g_parm.plan_in_pgm_flag = 'N'
          and elig.pgm_id is null)
          or
         (g_parm.pl_nip_id = elig.pl_id))
          and elig.elig_flag = 'Y'
    and g_parm.effective_date between elig.effective_start_date
                                  and elig.effective_end_date
    and pil.per_in_ler_id(+)=elig.per_in_ler_id
    and pil.business_group_id(+)=elig.business_group_id
    and (   pil.per_in_ler_stat_cd not in ('VOIDD','BCKDT')
                -- found row condition
           or pil.per_in_ler_stat_cd is null
            -- outer join condition
           );
  --
  cursor c_enrt(v_person_id number) is
  select pen.pgm_id,
         pen.pl_id
    from ben_prtt_enrt_rslt_f pen
   where pen.person_id = v_person_id
     and (g_parm.pgm_id is null or
          pen.pgm_id = g_parm.pgm_id)
     and ((g_parm.pl_nip_id is null
           and g_parm.plan_in_pgm_flag = 'Y'
           and pen.pgm_id is not null)
           or
          (g_parm.pl_nip_id is null
           and g_parm.plan_in_pgm_flag = 'N'
           and pen.pgm_id is null)
           or
          (g_parm.pl_nip_id = pen.pl_id))
     and pen.sspndd_flag = 'N'
     and pen.prtt_enrt_rslt_stat_cd is null
     and pen.business_group_id = g_parm.business_group_id
     and nvl(pen.enrt_cvg_thru_dt, hr_api.g_eot) = hr_api.g_eot
     and g_parm.effective_date between pen.effective_start_date
                                   and pen.effective_end_date
     and pen.effective_end_date = hr_api.g_eot;
  --
  cursor c_dpnt_enrt(v_person_id number) is
  select pen.pgm_id,
         pen.pl_id
    from ben_prtt_enrt_rslt_f pen,
         ben_elig_cvrd_dpnt_f pdp
   where pdp.dpnt_person_id = v_person_id
     and pdp.cvg_thru_dt    = hr_api.g_eot
     and g_parm.effective_date between
         pdp.effective_start_date and pdp.effective_end_date
     and pdp.effective_end_date = hr_api.g_eot
     and pdp.prtt_enrt_rslt_id = pen.prtt_enrt_rslt_id
     and (g_parm.pgm_id is null or
          pen.pgm_id = g_parm.pgm_id)
     and ((g_parm.pl_nip_id is null
           and g_parm.plan_in_pgm_flag = 'Y'
           and pen.pgm_id is not null)
           or
          (g_parm.pl_nip_id is null
           and g_parm.plan_in_pgm_flag = 'N'
           and pen.pgm_id is null)
           or
          (g_parm.pl_nip_id = pen.pl_id))
     and pen.sspndd_flag = 'N'
     and pen.prtt_enrt_rslt_stat_cd is null
     and pen.business_group_id = g_parm.business_group_id
     and nvl(pen.enrt_cvg_thru_dt, hr_api.g_eot) = hr_api.g_eot
     and g_parm.effective_date between
         pen.effective_start_date and pen.effective_end_date
     and pen.effective_end_date = hr_api.g_eot;
  --
  l_start_person_action_id number;
  l_ending_person_action_id number;
  l_range_id number;
  l_object_version_number number;
  l_create_action  boolean := false;
  l_pgm_id         number;
  l_pl_id          number;
  --
  l_proc varchar2(80) := g_package || '.create_emrtevt_ranges';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  --
  for l_per_rec in c_per_emrgevt loop
    --
    l_create_action := false;
    --
    if is_dependent(p_person_id => l_per_rec.person_id) then
       --
       -- For Dependents.
       --
       if g_parm.elig_enrol_cd = 'ENROL' then
          --
hr_utility.set_location('Person is dependent',10);
hr_utility.set_location('Person ID '||l_per_rec.person_id,10);
hr_utility.set_location('BG ID '||g_parm.business_group_id,10);
hr_utility.set_location('EFF DATE '||g_parm.effective_date,10);
hr_utility.set_location('PGM ID '||g_parm.pgm_id,10);
hr_utility.set_location('PL_NIP ID '||g_parm.pl_nip_id,10);
hr_utility.set_location('PL_IN PROG FLAG '||g_parm.plan_in_pgm_flag,10);
          open  c_dpnt_enrt(l_per_rec.person_id);
          fetch c_dpnt_enrt into l_pgm_id, l_pl_id;
          --
          if c_dpnt_enrt%found then
             --
                hr_utility.set_location('Definately Found record',10);
             l_create_action := true;
             --
             if g_parm.use_fctr_to_sel_flag = 'Y'  then
                --
                hr_utility.set_location('Found record',10);
                l_create_action := fctr_belongs_to_comp_object(
                                       p_pgm_id => l_pgm_id,
                                       p_pl_id  => l_pl_id);
                --
             end if;
             --
          end if;
          --
          close c_dpnt_enrt;
          --
       end if;
       --
    else
       --
       -- Participants.
       --
       if g_parm.elig_enrol_cd = 'ELIG' then
          --
          open  c_elig(l_per_rec.person_id);
          fetch c_elig into l_pgm_id, l_pl_id;
          --
          if c_elig%found then
             --
             l_create_action := true;
             --
             if g_parm.use_fctr_to_sel_flag = 'Y'  then
                --
                l_create_action := fctr_belongs_to_comp_object(
                                       p_pgm_id => l_pgm_id,
                                       p_pl_id  => l_pl_id);
                --
             end if;
             --
          end if;
          --
          close c_elig;
          --
       elsif g_parm.elig_enrol_cd = 'ENROL' then
          --
hr_utility.set_location('Person is participant',10);
          open  c_enrt(l_per_rec.person_id);
          fetch c_enrt into l_pgm_id, l_pl_id;
          --
          if c_enrt%found then
             --
             l_create_action := true;
             --
             if g_parm.use_fctr_to_sel_flag = 'Y'  then
                --
                l_create_action := fctr_belongs_to_comp_object(
                                       p_pgm_id => l_pgm_id,
                                       p_pl_id  => l_pl_id);
                --
             end if;
             --
          end if;
          --
          close c_enrt;
          --
       end if;
       --
    end if;
    --
    if l_create_action  AND
       ben_rules.chk_comp_object_selection(
             p_oipl_id                => null,
             p_pl_id                  => l_pl_id,
             p_pgm_id                 => l_pgm_id,
             p_pl_typ_id              => null,
             p_opt_id                 => null,
             p_business_group_id      => g_parm.business_group_id,
             p_comp_selection_rule_id => g_parm.comp_selection_rl,
             p_effective_date         => g_parm.effective_date) then
       --
       -- Create person actions and batch ranges
       --
       g_per_slctd := g_per_slctd + 1;
       --
       hr_utility.set_location('Range created',10);
       --
       create_actions_ranges
         (p_person_id                => l_per_rec.person_id
         ,p_start_person_action_id   => l_start_person_action_id
         ,p_ending_person_action_id  => l_ending_person_action_id);
       --
    end if;
    --
  end loop;
  --
  hr_utility.set_location('People selected from database : ' || g_per_slctd,10);
  --
  -- There could be a few person actions left over from the call in the for
  -- loop above. Create a batch range for them.
  --
  If g_person_actn_cnt > 0 and
     mod(g_person_actn_cnt, g_chunk_size) <> 0 then
    --
    hr_utility.set_location('Ranges for remaining people ' || l_proc, 25);
    --
    ben_batch_ranges_api.create_batch_ranges
      (p_validate                  => FALSE
      ,p_effective_date            => g_parm.effective_date
      ,p_benefit_action_id         => g_parm.benefit_action_id
      ,p_range_id                  => l_range_id
      ,p_range_status_cd           => 'U'
      ,p_starting_person_action_id => l_start_person_action_id
      ,p_ending_person_action_id   => l_ending_person_action_id
      ,p_object_version_number     => l_object_version_number);
    --
    g_num_ranges := g_num_ranges + 1;
    --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
end create_emrgevt_ranges;
--
-- ----------------------------------------------------------------------------
-- -------------------------< create_mssmlg_ranges >---------------------------
-- ----------------------------------------------------------------------------
--
procedure create_mssmlg_ranges is
  --
  --  if g_parm.elig_enrol_cd is not null  and g_parm.pgm_id is null and g_parm.pl_nip_id is null
  -- this is error condition

  cursor c_per_mssmlg_elig_pgm is
  select person_id
    from per_all_people_f ppf
   where (g_parm.person_id is null or
          ppf.person_id = g_parm.person_id)
     and g_parm.effective_date between ppf.effective_start_date
                                   and ppf.effective_end_date
     and ppf.business_group_id  = g_parm.business_group_id
     and (g_parm.person_type_id is null
          or
          exists (select null
                  from   per_person_type_usages_f ppu
                  where  ppf.person_id = ppu.person_id
                  and    ppu.person_type_id = g_parm.person_type_id
                  and    g_parm.effective_date between ppu.effective_start_date and ppu.effective_end_date))
     --
     and ((g_parm.elig_enrol_cd = 'ELIG' -- begin ELIG block
           and
           -- check if the person is eligible for the comp object
           exists (select 's'
                     from ben_elig_per_f elig,
                          ben_per_in_ler pil
                    where elig.person_id = ppf.person_id
                      and elig.pgm_id = g_parm.pgm_id
                      and (g_parm.pl_nip_id is null and g_parm.plan_in_pgm_flag = 'Y' and elig.pgm_id is not null)
                      and elig.elig_flag = 'Y'
                      and g_parm.effective_date between elig.effective_start_date and elig.effective_end_date
                      and pil.per_in_ler_id(+)=elig.per_in_ler_id
                      and pil.business_group_id(+)=elig.business_group_id
                      and ( pil.per_in_ler_stat_cd not in ('VOIDD','BCKDT')
                                 -- found row condition
                              or pil.per_in_ler_stat_cd is null
                                 -- outer join condition
                              )
          ))
           )
     and ((g_parm.organization_id is null and
           g_parm.location_id is null)
           or
           exists (select 's'
	 	    FROM per_all_assignments_f asg, per_assignment_status_types ast
                     WHERE asg.person_id = ppf.person_id
                     AND asg.primary_flag = 'Y'
                     and (g_parm.organization_id is null or asg.organization_id = g_parm.organization_id)
                     and (g_parm.location_id is null or asg.location_id = g_parm.location_id)
                      AND g_parm.effective_date BETWEEN asg.effective_start_date AND asg.effective_end_date
                      AND asg.assignment_status_type_id = ast.assignment_status_type_id
                      and asg.business_group_id = g_parm.business_group_id
                      AND (   (    assignment_type = 'E'
                                   AND (   ast.per_system_status = 'ACTIVE_ASSIGN'
                                    OR (    ast.per_system_status = 'TERM_ASSIGN'
                                            AND NOT EXISTS (
                                             SELECT assignment_id
                                              FROM per_all_assignments_f asg1, per_assignment_status_types ast1
                                               WHERE asg1.assignment_type = 'B'
                                                AND asg1.primary_flag = 'Y'
                                                AND asg1.person_id = ppf.person_id
                                                AND asg1.assignment_status_type_id = ast1.assignment_status_type_id
                                                AND ast1.per_system_status = 'ACTIVE_ASSIGN'
                                                AND g_parm.effective_date
                                                    BETWEEN asg1.effective_start_date AND asg1.effective_end_date
                                            )
                                       )
                                       )
                              )
                       OR (    assignment_type = 'B'
                                   AND NOT EXISTS (
                                       SELECT assignment_id
                                        FROM per_all_assignments_f asg2, per_assignment_status_types ast2
                                         WHERE asg2.assignment_type = 'E'
                                           AND asg2.primary_flag = 'Y'
                                           AND asg2.person_id = ppf.person_id
                                           AND asg2.assignment_status_type_id = ast2.assignment_status_type_id
                                           AND ast2.per_system_status = 'ACTIVE_ASSIGN'
                                           AND g_parm.effective_date
                                               BETWEEN asg2.effective_start_date AND asg2.effective_end_date
                                       )
                          )
                          )
		  )
	);
  --
 cursor c_per_mssmlg_elig_plnip is
  select person_id
    from per_all_people_f ppf
   where (g_parm.person_id is null or
          ppf.person_id = g_parm.person_id)
     and g_parm.effective_date between ppf.effective_start_date
                                   and ppf.effective_end_date
     and ppf.business_group_id  = g_parm.business_group_id
     and (g_parm.person_type_id is null
          or
          exists (select null
                  from   per_person_type_usages_f ppu
                  where  ppf.person_id = ppu.person_id
                  and    ppu.person_type_id = g_parm.person_type_id
                  and    g_parm.effective_date between ppu.effective_start_date and ppu.effective_end_date))
     --
     and ((g_parm.elig_enrol_cd = 'ELIG' -- begin ELIG block
           and
           -- check if the person is eligible for the comp object
           exists (select 's'
                     from ben_elig_per_f elig,
                          ben_per_in_ler pil
                    where elig.person_id = ppf.person_id
                      and g_parm.pgm_id is null
                      and (g_parm.pl_nip_id is not null and g_parm.plan_in_pgm_flag = 'N' and elig.pgm_id is null)
                      and g_parm.pl_nip_id = elig.pl_id
                      and elig.elig_flag = 'Y'
                      and g_parm.effective_date between elig.effective_start_date and elig.effective_end_date
                      and pil.per_in_ler_id(+)=elig.per_in_ler_id
                      and pil.business_group_id(+)=elig.business_group_id
                      and (   pil.per_in_ler_stat_cd not in ('VOIDD','BCKDT')
                                 -- found row condition
                              or pil.per_in_ler_stat_cd is null
                                 -- outer join condition
                              )
          ))
           )
     and ((g_parm.organization_id is null and
           g_parm.location_id is null)
           or
           exists (select 's'
	 	    FROM per_all_assignments_f asg, per_assignment_status_types ast
                     WHERE asg.person_id = ppf.person_id
                     AND asg.primary_flag = 'Y'
                     and (g_parm.organization_id is null or asg.organization_id = g_parm.organization_id)
                     and (g_parm.location_id is null or asg.location_id = g_parm.location_id)
                      AND g_parm.effective_date BETWEEN asg.effective_start_date AND asg.effective_end_date
                      AND asg.assignment_status_type_id = ast.assignment_status_type_id
                      and asg.business_group_id = g_parm.business_group_id
                      AND (   (    assignment_type = 'E'
                                   AND (   ast.per_system_status = 'ACTIVE_ASSIGN'
                                    OR (    ast.per_system_status = 'TERM_ASSIGN'
                                            AND NOT EXISTS (
                                             SELECT assignment_id
                                              FROM per_all_assignments_f asg1, per_assignment_status_types ast1
                                               WHERE asg1.assignment_type = 'B'
                                                AND asg1.primary_flag = 'Y'
                                                AND asg1.person_id = ppf.person_id
                                                AND asg1.assignment_status_type_id = ast1.assignment_status_type_id
                                                AND ast1.per_system_status = 'ACTIVE_ASSIGN'
                                                AND g_parm.effective_date
                                                    BETWEEN asg1.effective_start_date AND asg1.effective_end_date
                                            )
                                       )
                                       )
                              )
                       OR (    assignment_type = 'B'
                                   AND NOT EXISTS (
                                       SELECT assignment_id
                                        FROM per_all_assignments_f asg2, per_assignment_status_types ast2
                                         WHERE asg2.assignment_type = 'E'
                                           AND asg2.primary_flag = 'Y'
                                           AND asg2.person_id = ppf.person_id
                                           AND asg2.assignment_status_type_id = ast2.assignment_status_type_id
                                           AND ast2.per_system_status = 'ACTIVE_ASSIGN'
                                           AND g_parm.effective_date
                                               BETWEEN asg2.effective_start_date AND asg2.effective_end_date
                                       )
                          )
                          )
		  )
	);
  --
  cursor c_per_mssmlg_enrol_pgm is
  select person_id
    from per_all_people_f ppf
   where (g_parm.person_id is null or ppf.person_id = g_parm.person_id)
     and g_parm.effective_date between ppf.effective_start_date and ppf.effective_end_date
     and ppf.business_group_id  = g_parm.business_group_id
     and (g_parm.person_type_id is null
          or
          exists (select null
                  from   per_person_type_usages_f ppu
                  where  ppf.person_id = ppu.person_id
                  and    ppu.person_type_id = g_parm.person_type_id
                  and    g_parm.effective_date between ppu.effective_start_date and ppu.effective_end_date))
     --
     and ( (g_parm.elig_enrol_cd = 'ENROL'  -- begin ENROL block
         and exists (select 's'
                     from ben_prtt_enrt_rslt_f pen
                    where pen.person_id = ppf.person_id
                      and (pen.pgm_id = g_parm.pgm_id)
                      and (g_parm.pl_nip_id is null and g_parm.plan_in_pgm_flag = 'Y' and pen.pgm_id is not null)
                      and pen.sspndd_flag = 'N'
                      and pen.prtt_enrt_rslt_stat_cd is null
                      and pen.business_group_id = g_parm.business_group_id
                      and nvl(pen.enrt_cvg_thru_dt, hr_api.g_eot) = hr_api.g_eot
                      and g_parm.effective_date between pen.effective_start_date and pen.effective_end_date
		     ))
                   )
     and ((g_parm.organization_id is null and
           g_parm.location_id is null)
           or
           exists (select 's'
	 	    FROM per_all_assignments_f asg, per_assignment_status_types ast
                     WHERE asg.person_id = ppf.person_id
                     AND asg.primary_flag = 'Y'
                     and (g_parm.organization_id is null or asg.organization_id = g_parm.organization_id)
                     and (g_parm.location_id is null or asg.location_id = g_parm.location_id)
                      AND g_parm.effective_date BETWEEN asg.effective_start_date AND asg.effective_end_date
                      AND asg.assignment_status_type_id = ast.assignment_status_type_id
                      and asg.business_group_id = g_parm.business_group_id
                      AND (   (    assignment_type = 'E'
                                   AND (   ast.per_system_status = 'ACTIVE_ASSIGN'
                                    OR (    ast.per_system_status = 'TERM_ASSIGN'
                                            AND NOT EXISTS (
                                             SELECT assignment_id
                                              FROM per_all_assignments_f asg1, per_assignment_status_types ast1
                                               WHERE asg1.assignment_type = 'B'
                                                AND asg1.primary_flag = 'Y'
                                                AND asg1.person_id = ppf.person_id
                                                AND asg1.assignment_status_type_id = ast1.assignment_status_type_id
                                                AND ast1.per_system_status = 'ACTIVE_ASSIGN'
                                                AND g_parm.effective_date
                                                    BETWEEN asg1.effective_start_date AND asg1.effective_end_date
                                            ))
                                       ))
                       OR (    assignment_type = 'B'
                                   AND NOT EXISTS (
                                       SELECT assignment_id
                                        FROM per_all_assignments_f asg2, per_assignment_status_types ast2
                                         WHERE asg2.assignment_type = 'E'
                                           AND asg2.primary_flag = 'Y'
                                           AND asg2.person_id = ppf.person_id
                                           AND asg2.assignment_status_type_id = ast2.assignment_status_type_id
                                           AND ast2.per_system_status = 'ACTIVE_ASSIGN'
                                           AND g_parm.effective_date
                                               BETWEEN asg2.effective_start_date AND asg2.effective_end_date
                                       ))
                          ))
	);
 --
  cursor c_per_mssmlg_enrol_plnip is
  select person_id
    from per_all_people_f ppf
   where (g_parm.person_id is null or ppf.person_id = g_parm.person_id)
     and g_parm.effective_date between ppf.effective_start_date and ppf.effective_end_date
     and ppf.business_group_id  = g_parm.business_group_id
     and (g_parm.person_type_id is null
          or
          exists (select null
                  from   per_person_type_usages_f ppu
                  where  ppf.person_id = ppu.person_id
                  and    ppu.person_type_id = g_parm.person_type_id
                  and    g_parm.effective_date between ppu.effective_start_date and ppu.effective_end_date))
     --
     and ( (g_parm.elig_enrol_cd = 'ENROL'  -- begin ENROL block
         and exists (select 's'
                     from ben_prtt_enrt_rslt_f pen
                    where pen.person_id = ppf.person_id
                      and (g_parm.pgm_id is null)
                      and (g_parm.pl_nip_id is not null and g_parm.plan_in_pgm_flag = 'N' and pen.pgm_id is null)
                      and (g_parm.pl_nip_id = pen.pl_id)
                      and pen.sspndd_flag = 'N'
                      and pen.prtt_enrt_rslt_stat_cd is null
                      and pen.business_group_id = g_parm.business_group_id
                      and nvl(pen.enrt_cvg_thru_dt, hr_api.g_eot) = hr_api.g_eot
                      and g_parm.effective_date between pen.effective_start_date and pen.effective_end_date
		     ))
                     )
     and ((g_parm.organization_id is null and
           g_parm.location_id is null)
           or
           exists (select 's'
	 	    FROM per_all_assignments_f asg, per_assignment_status_types ast
                     WHERE asg.person_id = ppf.person_id
                     AND asg.primary_flag = 'Y'
                     and (g_parm.organization_id is null or asg.organization_id = g_parm.organization_id)
                     and (g_parm.location_id is null or asg.location_id = g_parm.location_id)
                      AND g_parm.effective_date BETWEEN asg.effective_start_date AND asg.effective_end_date
                      AND asg.assignment_status_type_id = ast.assignment_status_type_id
                      and asg.business_group_id = g_parm.business_group_id
                      AND ( ( assignment_type = 'E'
                                   AND ( ast.per_system_status = 'ACTIVE_ASSIGN'
                                    OR ( ast.per_system_status = 'TERM_ASSIGN'
                                            AND NOT EXISTS (
                                             SELECT assignment_id
                                              FROM per_all_assignments_f asg1, per_assignment_status_types ast1
                                               WHERE asg1.assignment_type = 'B'
                                                AND asg1.primary_flag = 'Y'
                                                AND asg1.person_id = ppf.person_id
                                                AND asg1.assignment_status_type_id = ast1.assignment_status_type_id
                                                AND ast1.per_system_status = 'ACTIVE_ASSIGN'
                                                AND g_parm.effective_date
                                                    BETWEEN asg1.effective_start_date AND asg1.effective_end_date
                                            ))
                                       ))
                       OR ( assignment_type = 'B'
                                   AND NOT EXISTS (
                                       SELECT assignment_id
                                        FROM per_all_assignments_f asg2, per_assignment_status_types ast2
                                         WHERE asg2.assignment_type = 'E'
                                           AND asg2.primary_flag = 'Y'
                                           AND asg2.person_id = ppf.person_id
                                           AND asg2.assignment_status_type_id = ast2.assignment_status_type_id
                                           AND ast2.per_system_status = 'ACTIVE_ASSIGN'
                                           AND g_parm.effective_date
                                               BETWEEN asg2.effective_start_date AND asg2.effective_end_date
                                       ))
                          ))
	);
--
  cursor c_per_mssmlg is
  select person_id
    from per_all_people_f ppf
   where (g_parm.person_id is null or ppf.person_id = g_parm.person_id)
     and g_parm.effective_date between ppf.effective_start_date and ppf.effective_end_date
     and ppf.business_group_id  = g_parm.business_group_id
     and (g_parm.person_type_id is null
          or
          exists (select null
                  from   per_person_type_usages_f ppu
                  where  ppf.person_id = ppu.person_id
                  and    ppu.person_type_id = g_parm.person_type_id
                  and    g_parm.effective_date between ppu.effective_start_date and ppu.effective_end_date))
     --
     and (g_parm.elig_enrol_cd is null )
     and ((g_parm.organization_id is null and
           g_parm.location_id is null)
           or
           exists (select 's'
	 	    FROM per_all_assignments_f asg, per_assignment_status_types ast
                     WHERE asg.person_id = ppf.person_id
                     AND asg.primary_flag = 'Y'
                     and (g_parm.organization_id is null or asg.organization_id = g_parm.organization_id)
                     and (g_parm.location_id is null or asg.location_id = g_parm.location_id)
                      AND g_parm.effective_date BETWEEN asg.effective_start_date AND asg.effective_end_date
                      AND asg.assignment_status_type_id = ast.assignment_status_type_id
                      and asg.business_group_id = g_parm.business_group_id
                      AND ( ( assignment_type = 'E'
                                   AND ( ast.per_system_status = 'ACTIVE_ASSIGN'
                                    OR ( ast.per_system_status = 'TERM_ASSIGN'
                                            AND NOT EXISTS (
                                             SELECT assignment_id
                                              FROM per_all_assignments_f asg1, per_assignment_status_types ast1
                                               WHERE asg1.assignment_type = 'B'
                                                AND asg1.primary_flag = 'Y'
                                                AND asg1.person_id = ppf.person_id
                                                AND asg1.assignment_status_type_id = ast1.assignment_status_type_id
                                                AND ast1.per_system_status = 'ACTIVE_ASSIGN'
                                                AND g_parm.effective_date
                                                    BETWEEN asg1.effective_start_date AND asg1.effective_end_date
                                            ))
                                       ))
                       OR ( assignment_type = 'B'
                                   AND NOT EXISTS (
                                       SELECT assignment_id
                                        FROM per_all_assignments_f asg2, per_assignment_status_types ast2
                                         WHERE asg2.assignment_type = 'E'
                                           AND asg2.primary_flag = 'Y'
                                           AND asg2.person_id = ppf.person_id
                                           AND asg2.assignment_status_type_id = ast2.assignment_status_type_id
                                           AND ast2.per_system_status = 'ACTIVE_ASSIGN'
                                           AND g_parm.effective_date
                                               BETWEEN asg2.effective_start_date AND asg2.effective_end_date
                                       ))
                          ))
	);
--
  l_start_person_action_id number;
  l_ending_person_action_id number;
  l_range_id number;
  l_object_version_number number;
  --
  l_proc varchar2(80) := g_package || '.create_mssmlg_ranges';
--
begin
--
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  if (g_parm.elig_enrol_cd = 'ELIG' and g_parm.pgm_id is not null and g_parm.pl_nip_id is null)
  then
      for l_per_rec in c_per_mssmlg_elig_pgm loop
        --
        g_per_slctd := g_per_slctd + 1;
        --
        create_actions_ranges
          (p_person_id                => l_per_rec.person_id
          ,p_start_person_action_id   => l_start_person_action_id
          ,p_ending_person_action_id  => l_ending_person_action_id);
        --
      end loop;
  elsif (g_parm.elig_enrol_cd = 'ELIG' and g_parm.pgm_id is null and g_parm.pl_nip_id is not null)
  then
      for l_per_rec in c_per_mssmlg_elig_plnip loop
        --
        g_per_slctd := g_per_slctd + 1;
        --
        create_actions_ranges
          (p_person_id                => l_per_rec.person_id
          ,p_start_person_action_id   => l_start_person_action_id
          ,p_ending_person_action_id  => l_ending_person_action_id);
        --
      end loop;
  elsif (g_parm.elig_enrol_cd = 'ENROL' and g_parm.pgm_id is not null and g_parm.pl_nip_id is null)
  then
      for l_per_rec in c_per_mssmlg_enrol_pgm loop
        --
        g_per_slctd := g_per_slctd + 1;
        --
        create_actions_ranges
          (p_person_id                => l_per_rec.person_id
          ,p_start_person_action_id   => l_start_person_action_id
          ,p_ending_person_action_id  => l_ending_person_action_id);
        --
      end loop;
  elsif (g_parm.elig_enrol_cd = 'ENROL' and g_parm.pgm_id is null and g_parm.pl_nip_id is not null)
  then
      for l_per_rec in c_per_mssmlg_enrol_plnip loop
        --
        g_per_slctd := g_per_slctd + 1;
        --
        create_actions_ranges
          (p_person_id                => l_per_rec.person_id
          ,p_start_person_action_id   => l_start_person_action_id
          ,p_ending_person_action_id  => l_ending_person_action_id);
        --
      end loop;
  else
       for l_per_rec in c_per_mssmlg loop
        --
        g_per_slctd := g_per_slctd + 1;
        --
        create_actions_ranges
          (p_person_id                => l_per_rec.person_id
          ,p_start_person_action_id   => l_start_person_action_id
          ,p_ending_person_action_id  => l_ending_person_action_id);
        --
      end loop;
  end if;
  --
  hr_utility.set_location('People selected from database : ' || g_per_slctd,10);
  --
  -- There could be a few person actions left over from the call in the for
  -- loop above. Create a batch range for them.
  --
  If g_person_actn_cnt > 0 and
     mod(g_person_actn_cnt, g_chunk_size) <> 0 then
    --
    hr_utility.set_location('Ranges for remaining people ' || l_proc, 25);
    --
    ben_batch_ranges_api.create_batch_ranges
      (p_validate                  => FALSE
      ,p_effective_date            => g_parm.effective_date
      ,p_benefit_action_id         => g_parm.benefit_action_id
      ,p_range_id                  => l_range_id
      ,p_range_status_cd           => 'U'
      ,p_starting_person_action_id => l_start_person_action_id
      ,p_ending_person_action_id   => l_ending_person_action_id
      ,p_object_version_number     => l_object_version_number);
    --
    g_num_ranges := g_num_ranges + 1;
    --
  end if;
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
end create_mssmlg_ranges;
--
-- ----------------------------------------------------------------------------
-- -------------------------------< process >----------------------------------
-- ----------------------------------------------------------------------------
--
procedure process
  (errbuf                      out nocopy varchar2
  ,retcode                     out nocopy number
  ,p_benefit_action_id      in     number   default null
  ,p_validate               in     varchar2 default 'N'
  ,p_effective_date         in     varchar2
  ,p_business_group_id      in     number
  ,p_mode                   in     varchar2 default 'I'
  ,p_cm_trgr_typ_cd         in     varchar2
  ,p_cm_typ_id              in     number   default null
  ,p_person_id              in     number   default null
  ,p_person_type_id         in     number   default null
  ,p_person_sel_rl          in     number   default null
  ,p_organization_id        in     number   default null
  ,p_location_id            in     number   default null
  ,p_ler_id                 in     number   default null
  ,p_pgm_id                 in     number   default null
  ,p_pl_nip_id              in     number   default null
  ,p_plan_in_pgm_flag       in     varchar2 default 'Y'
  ,p_actn_typ_id            in     number   default null
  ,p_elig_enrol_cd          in     varchar2 default null
  ,p_age_fctr_id            in     number   default null
  ,p_min_age                in     number   default null
  ,p_max_age                in     number   default null
  ,p_los_fctr_id            in     number   default null
  ,p_min_los                in     number   default null
  ,p_max_los                in     number   default null
  ,p_cmbn_age_los_fctr_id   in     number   default null
  ,p_date_from              in     varchar2 default null
  -- PB : 5422 :
  -- ,p_popl_enrt_typ_cycl_id  in     number   default null
  ,p_lf_evt_ocrd_dt         in     varchar2 default null
  ,p_audit_log_flag         in     varchar2 default 'N'
  ,p_comp_selection_rl      in     number   default null
  ,p_use_fctr_to_sel_flag   in     varchar2 default 'N'
  ,p_los_det_to_use_cd      in     varchar2 default null
  ) is
--
  l_effective_date date;
  l_date_from date;
  l_request_id number;
  l_errbuf varchar2(1000);
  l_retcode number;
  l_object_version_number number;
  l_commit number;
  --
  l_proc varchar2(80) := g_package || '.process';
  l_lf_evt_ocrd_dt  date;
--
begin
  --
  hr_utility.set_location('Entering : ' || l_proc, 10);
  --
  -- Convert varchar2 dates to real dates
  -- 1) First remove time component
  -- 2) Next convert format
  l_effective_date := to_date(p_effective_date,'YYYY/MM/DD HH24:MI:SS');
  l_effective_date := to_date(to_char(trunc(l_effective_date),'DD-MON-RRRR')
                             ,'DD-MON-RRRR');
  l_date_from := to_date(p_date_from,'YYYY/MM/DD HH24:MI:SS');
  l_date_from := to_date(to_char(trunc(l_date_from),'DD-MON-RRRR')
                        ,'DD-MON-RRRR');
  l_lf_evt_ocrd_dt := to_date(p_lf_evt_ocrd_dt,'YYYY/MM/DD HH24:MI:SS');
  l_lf_evt_ocrd_dt := to_date(to_char(trunc(l_lf_evt_ocrd_dt),'DD/MM/RRRR'),'DD/MM/RRRR');
  --
  -- Put row in fnd_sessions
  --
  dt_fndate.change_ses_date
      (p_ses_date => l_effective_date,
       p_commit   => l_commit);
  --
  -- Initialize all the global record structures
  --
  initialize_globals;
  --
  -- Log start time of process
  --
  g_proc_rec.business_group_id := p_business_group_id;
  g_proc_rec.strt_dt := sysdate;
  g_proc_rec.strt_tm := to_char(sysdate,'HH24:MI:SS');
  g_strt_tm_numeric := dbms_utility.get_time;
  --
  -- Flush the global-parameter-list and load all the passed parameters into it.
  -- All the sub procedures in the main process will be able to access this list
  -- and this will keep the procedure calls simple.
  --
  g_parm.benefit_action_id := p_benefit_action_id;
  g_parm.validate_flag := p_validate;
  g_parm.effective_date := l_effective_date;
  g_parm.business_group_id := p_business_group_id;
  g_parm.mode_cd := p_mode;
  g_parm.cm_trgr_typ_cd := p_cm_trgr_typ_cd;
  g_parm.cm_typ_id := p_cm_typ_id;
  g_parm.person_id := p_person_id;
  g_parm.person_type_id := p_person_type_id;
  g_parm.person_sel_rl := p_person_sel_rl;
  g_parm.organization_id := p_organization_id;
  g_parm.location_id := p_location_id;
  g_parm.ler_id := p_ler_id;
  g_parm.pgm_id := p_pgm_id;
  g_parm.pl_nip_id := p_pl_nip_id;
  g_parm.plan_in_pgm_flag := p_plan_in_pgm_flag;
  g_parm.comp_selection_rl := p_comp_selection_rl;
  g_parm.actn_typ_id := p_actn_typ_id;
  g_parm.elig_enrol_cd := p_elig_enrol_cd;
  g_parm.use_fctr_to_sel_flag := p_use_fctr_to_sel_flag;
  g_parm.age_fctr_id := p_age_fctr_id;
  g_parm.min_age := p_min_age;
  g_parm.max_age := p_max_age;
  g_parm.los_fctr_id := p_los_fctr_id;
  g_parm.min_los := p_min_los;
  g_parm.max_los := p_max_los;
  g_parm.los_det_to_use_cd := p_los_det_to_use_cd;
  g_parm.cmbn_age_los_fctr_id := p_cmbn_age_los_fctr_id;
  g_parm.date_from := l_date_from;
  -- PB : 5422 :
  -- g_parm.popl_enrt_typ_cycl_id := p_popl_enrt_typ_cycl_id;
  g_parm.lf_evt_ocrd_dt := l_lf_evt_ocrd_dt;
  g_parm.audit_log_flag := p_audit_log_flag;
  --
  -- Check the parameters for validity and incompatibilities.
  --
  check_business_rules;
  --
  -- Get the parameters for the batch process so we know how many slaves to
  -- start and what size the chunk size is. Store them in globals.
  --
  benutils.get_parameter
    (p_business_group_id => p_business_group_id
    ,p_batch_exe_cd      => 'BENTMPCM'
    ,p_threads           => g_threads
    ,p_chunk_size        => g_chunk_size
    ,p_max_errors        => g_max_errors);
  --
  hr_utility.set_location('Num Threads = ' || g_threads, 10);
  hr_utility.set_location('Chunk Size = ' || g_chunk_size, 10);
  hr_utility.set_location('Max Errors = ' || g_max_errors, 10);
  --
  -- Create benefit actions parameters in the benefit action table.
  -- If a benefit action already exists, do not create - in other words
  -- we are doing a restart.
  --
  if p_benefit_action_id is null then
    --
    -- A new request was submitted. Create a new benefit action.
    --
    ben_benefit_actions_api.create_benefit_actions
      (p_validate               => FALSE
      ,p_benefit_action_id      => g_parm.benefit_action_id
      ,p_process_date           => l_effective_date
      ,p_mode_cd                => p_mode
      ,p_derivable_factors_flag => 'N'
      ,p_validate_flag          => p_validate
      ,p_person_id              => p_person_id
      ,p_person_type_id         => p_person_type_id
      ,p_pgm_id                 => p_pgm_id
      ,p_business_group_id      => p_business_group_id
      ,p_pl_id                  => p_pl_nip_id
      -- PB : 5422 :
      -- ,p_popl_enrt_typ_cycl_id  => p_popl_enrt_typ_cycl_id
      ,p_lf_evt_ocrd_dt         => l_lf_evt_ocrd_dt
      ,p_no_programs_flag       => p_plan_in_pgm_flag
      ,p_no_plans_flag          => 'N'
      ,p_comp_selection_rl      => p_comp_selection_rl
      ,p_person_selection_rl    => p_person_sel_rl
      ,p_ler_id                 => p_ler_id
      ,p_organization_id        => p_organization_id
      ,p_location_id            => p_location_id
      ,p_debug_messages_flag    => 'Y'
      ,p_cm_trgr_typ_cd         => p_cm_trgr_typ_cd
      ,p_cm_typ_id              => p_cm_typ_id
      ,p_use_fctr_to_sel_flag   => p_use_fctr_to_sel_flag
      ,p_age_fctr_id            => p_age_fctr_id
      ,p_min_age                => p_min_age
      ,p_max_age                => p_max_age
      ,p_los_fctr_id            => p_los_fctr_id
      ,p_min_los                => p_min_los
      ,p_max_los                => p_max_los
      ,p_los_det_to_use_cd      => p_los_det_to_use_cd
      ,p_cmbn_age_los_fctr_id   => p_cmbn_age_los_fctr_id
      ,p_date_from              => l_date_from
      ,p_elig_enrol_cd          => p_elig_enrol_cd
      ,p_actn_typ_id            => p_actn_typ_id
      ,p_audit_log_flag         => p_audit_log_flag
      ,p_request_id             => fnd_global.conc_request_id
      ,p_program_application_id => fnd_global.prog_appl_id
      ,p_program_id             => fnd_global.conc_program_id
      ,p_program_update_date    => sysdate
      ,p_object_version_number  => l_object_version_number
      ,p_effective_date         => l_effective_date);
    --
    commit;
    --
    -- Delete batch ranges for the benefit action id
    --
    delete from ben_batch_ranges
    where benefit_action_id = g_parm.benefit_action_id;
    --
    commit;
    --
    -- Create person-actions and batch-ranges for the process. The following
    -- if-statement calls the appropriate procedure based on the trigger-type.
    --
    if p_cm_trgr_typ_cd = 'ENRTRMDR' then
      --
      create_enrtrmdr_ranges;
      --
    elsif p_cm_trgr_typ_cd = 'ACTNRMDR' then
      --
      create_actnrmdr_ranges;
      --
    elsif p_cm_trgr_typ_cd = 'EMRGEVT' then
      --
      create_emrgevt_ranges;
      --
    elsif p_cm_trgr_typ_cd = 'MSSMLG' then
      --
      create_mssmlg_ranges;
      --
    end if;
    --
    g_proc_rec.benefit_action_id := g_parm.benefit_action_id;
    --
    hr_utility.set_location('Number of person actions : ' ||
                            to_char(g_person_actn_cnt), 10);
    --
  else -- p_benefit_action_id
    --
    -- Benefit action id is not null i.e. the batch process is being restarted
    -- for a certain benefit action id. Create batch ranges and person actions
    -- for restarting.
    --
    hr_utility.set_location('restart batch process ' || l_proc, 20);
    --
    ben_batch_utils.create_restart_person_actions
      (p_benefit_action_id => p_benefit_action_id
      ,p_effective_date    => l_effective_date
      ,p_chunk_size        => g_chunk_size
      ,p_threads           => g_threads
      ,p_num_ranges        => g_num_ranges
      ,p_num_persons       => g_person_cnt
      ,p_commit_data       => 'Y');
    --
    g_parm.benefit_action_id := p_benefit_action_id;
    g_proc_rec.benefit_action_id := g_parm.benefit_action_id;
    --
  end if;
  --
  -- If there were no people selected with the criteria provided, the number of
  -- ranges created would have been zero. Raise an error if so.
  --
  if g_num_ranges = 0 then
    --
    fnd_message.set_name('BEN', 'BEN_91769_NOONE_TO_PROCESS');
    fnd_message.set_token('PROC',l_proc);
    fnd_message.raise_error;
    --
  end if;
  --
  -- Set the number of threads to the lesser of the defined number of threads
  -- and the number of ranges created above.
  --
  g_threads := least(g_threads, g_num_ranges);
  --
  hr_utility.set_location('Number of Threads : ' || g_threads, 20);
  --
  -- Submit requests
  --
  for l_count in 1..(g_threads -1) loop
    --
    -- We are subtracting one from the number of threads because the main
    -- process will act as the last thread and will be able to keep track of
    -- the child processes. If only one range got created this loop will never
    -- be executed and no additional concurrent requests will be submitted.
    --
    hr_utility.set_location('Sumitting thread : ' || l_count, 25);
    --
    l_request_id := fnd_request.submit_request
                      (application => 'BEN'
                      ,program     => 'BENTMPCMT'
                      ,description => NULL
                      ,sub_request => FALSE
                      ,argument1   => p_validate
                      ,argument2   => g_parm.benefit_action_id
                      ,argument3   => l_count
                      ,argument4   => p_effective_date
                      ,argument5   => p_business_group_id);
    --
    commit;
    --
    g_num_processes := ben_batch_utils.g_num_processes + 1;
    g_processes_rec(g_num_processes) := l_request_id;
    --
  end loop;
  --
  -- Carry on with the master. This will ensure that the master finishes last.
  --
  do_multithread
    (errbuf              => l_errbuf
    ,retcode             => l_retcode
    ,p_validate          => p_validate
    ,p_benefit_action_id => g_parm.benefit_action_id
    ,p_thread_id         => g_threads
    ,p_effective_date    => p_effective_date
    ,p_business_group_id => p_business_group_id);
  --
  hr_utility.set_location('Leaving : ' || l_proc, 10);
--
end process;
--
procedure summary_by_action(p_concurrent_request_id in number,
                            p_rcv_comm_count        out nocopy number,
                            p_rcv_1_comm_count      out nocopy number,
                            p_rcv_mlt_comm_count    out nocopy number)
is
   --
   cursor c_tot_person_cm is
      select count(distinct bmi.person_id)
      from   ben_batch_commu_info bmi,
             ben_benefit_actions  bft
      where  bft.request_id = p_concurrent_request_id
      and    bft.benefit_action_id = bmi.benefit_action_id;
   --
   cursor c_tot_person_1_cm is
      select  count(*)
      from    ben_batch_commu_info bmi1,
              ben_benefit_actions  bft
      where   bft.request_id = p_concurrent_request_id
      and     bft.benefit_action_id = bmi1.benefit_action_id
      and   not exists ( select 1
                         from   ben_batch_commu_info bmi2
                         where  bmi2.benefit_action_id = bft.benefit_action_id
                         and    bmi2.person_id = bmi1.person_id
                         and    bmi2.batch_commu_id <> bmi1.batch_commu_id);
   --
begin
   --
   open  c_tot_person_cm;
   fetch c_tot_person_cm into p_rcv_comm_count;
   close c_tot_person_cm;
   --
   open  c_tot_person_1_cm;
   fetch c_tot_person_1_cm into p_rcv_1_comm_count;
   close c_tot_person_1_cm;
   --
   if p_rcv_comm_count is null then
      --
      p_rcv_comm_count := 0;
      --
   end if;
   --
   if p_rcv_1_comm_count is null then
      --
      p_rcv_1_comm_count := 0;
      --
   end if;
   --
   p_rcv_mlt_comm_count := p_rcv_comm_count - p_rcv_1_comm_count;
   --
end summary_by_action;
--
--
procedure standard_header(p_concurrent_request_id in number,
                          p_concurrent_program_name out nocopy varchar2,
                          p_process_date            out nocopy date,
                          p_validate                out nocopy varchar2,
                          p_business_group          out nocopy varchar2,
                          p_mode                    out nocopy varchar2,
                          p_cm_trgr_typ             out nocopy varchar2,
                          p_cm_typ                  out nocopy varchar2,
                          p_person                  out nocopy varchar2,
                          p_person_type             out nocopy varchar2,
                          p_person_selection_rule   out nocopy varchar2,
                          p_organization            out nocopy varchar2,
                          p_location                out nocopy varchar2,
                          p_ler                     out nocopy varchar2,
                          p_program                 out nocopy varchar2,
                          p_plan                    out nocopy varchar2,
                          p_plan_in_program         out nocopy varchar2,
                          p_actn_typ                out nocopy varchar2,
                          p_elig_enrol              out nocopy varchar2,
                          p_age_fctr                out nocopy varchar2,
                          p_min_age                 out nocopy number,
                          p_max_age                 out nocopy number,
                          p_los_fctr                out nocopy varchar2,
                          p_min_los                 out nocopy number,
                          p_max_los                 out nocopy number,
                          p_cmbn_age_los_fctr       out nocopy varchar2,
                          p_date_from               out nocopy date,
                          p_enrollment_period       out nocopy varchar2,
                          p_audit_log               out nocopy varchar2,
                          p_status                  out nocopy varchar2) is
  --
  l_all            varchar2(80);
  l_none           varchar2(80);
  l_proc           varchar2(80) := g_package||'.standard_header';
  --
  cursor c_benefit_actions is
    select bft.process_date  process_date,
           hr1.meaning       mode_meaning,
           hr2.meaning       validate_meaning,
           nvl(ppf.full_name,l_all) person_name,
           nvl(ppt.user_person_type,l_all) person_type,
           nvl(pgm1.name,l_all) pgm_name,
           pbg.name business_group_name,
           nvl(pln1.name,l_all) pln_name,
           decode(hr4.meaning,
                  null,
                  l_all,
                  hr4.meaning||
                  ' '||
                  pln2.name||
                  ' '||
                  pgm2.name||
                  ' '||
                  epo.strt_dt||
                  ' '||
                  epo.end_dt)  enrt_perd,
           hr3.meaning plan_in_program,
           hr5.meaning elig_enrol,
           hr6.meaning audit_log,
           hr7.meaning cm_trgr_typ,
           nvl(cct.name, l_all) cm_typ_name,
           decode(loc.location_code,
                        null, l_all,
                        -- changed bug: 5446127
			-- loc.description) location_desc,
			loc.location_code) location_desc,
			-- change end
           nvl(ff.formula_name,l_none) person_selection_rl,
           nvl(ler.name,l_all) ler_name,
           nvl(org.name,l_all) org_name,
           actn.name            actn_typ_name,
           agf.name             agf_fctr,
           bft.min_age          min_age,
           bft.max_age          max_age,
           los.name             los_fctr,
           bft.min_los          min_los,
           bft.max_los          max_los,
           cla.name             cmbn_age_los_fctr,
           bft.date_from        date_from,
           conc.user_concurrent_program_name conc_prog_name,
	   fnd1.meaning
    from   ben_benefit_actions bft,
           hr_lookups hr1,
           hr_lookups hr2,
           hr_lookups hr3,
           hr_lookups hr4,
           hr_lookups hr5,
           hr_lookups hr6,
           hr_lookups hr7,
	   fnd_lookups fnd1,
           ben_age_fctr agf,
           ben_los_fctr los,
           ben_cmbn_age_los_fctr cla,
           ben_cm_typ_f cct,
           ben_actn_typ actn,
           per_people_f ppf,
           per_person_types ppt,
           ben_pgm_f pgm1,
           per_business_groups pbg,
           ben_pl_f pln1,
           ff_formulas_f ff,
           ben_ler_f ler,
           hr_all_organization_units org,
           ben_popl_enrt_typ_cycl_f pop,
           ben_enrt_perd epo,
           ben_pl_f pln2,
           ben_pgm_f pgm2,
           hr_locations_all loc,
           fnd_concurrent_requests fnd,
           fnd_concurrent_programs_tl conc
    where  fnd.request_id = p_concurrent_request_id
    and    conc.concurrent_program_id = fnd.concurrent_program_id
    and    conc.application_id = 805
    and    conc.language = userenv('LANG')  --NLS Fix
    and    bft.request_id = fnd.request_id
    and    hr1.lookup_code = bft.mode_cd
    and    hr1.lookup_type = 'BEN_BENTMPCM_MD'
    and    hr2.lookup_code = bft.validate_flag
    and    hr2.lookup_type = 'YES_NO'
    and    hr3.lookup_code = bft.no_programs_flag
    and    hr3.lookup_type = 'YES_NO'
    and    hr4.lookup_code(+) = pop.enrt_typ_cycl_cd
    and    hr4.lookup_type(+) = 'BEN_ENRT_TYP_CYCL'
    and    hr5.lookup_code(+) = bft.elig_enrol_cd
    and    hr5.lookup_type(+) = 'BEN_ELIG_ENROL'
    and    hr6.lookup_code(+) = bft.audit_log_flag
    and    hr6.lookup_type(+) = 'YES_NO'
    and    hr7.lookup_code = bft.cm_trgr_typ_cd
    and    hr7.lookup_type = 'BEN_CM_TRGR_TYP'
    and    fnd.status_code = fnd1.lookup_code
    and    fnd1.lookup_type= 'CP_STATUS_CODE'
    and    cct.cm_typ_id(+) = bft.cm_typ_id
    and    bft.process_date
           between nvl(cct.effective_start_date,bft.process_date)
           and     nvl(cct.effective_end_date,bft.process_date)
    and    loc.location_id(+) = bft.location_id
    and    actn.actn_typ_id(+) = bft.actn_typ_id
    and    agf.age_fctr_id(+) = bft.age_fctr_id
    and    los.los_fctr_id(+) = bft.los_fctr_id
    and    cla.cmbn_age_los_fctr_id(+) = bft.cmbn_age_los_fctr_id
    and    pop.popl_enrt_typ_cycl_id(+) = epo.popl_enrt_typ_cycl_id
    and    bft.process_date
           between nvl(pop.effective_start_date,bft.process_date)
           and     nvl(pop.effective_end_date,bft.process_date)
    -- PB : 5422 :
    -- and    epo.enrt_perd_id(+) = bft.popl_enrt_typ_cycl_id
    -- and    epo.asnd_lf_evt_dt(+) = bft.lf_evt_ocrd_dt
    and    pln2.pl_id(+) = pop.pl_id
    and    bft.process_date
           between nvl(pln2.effective_start_date,bft.process_date)
           and     nvl(pln2.effective_end_date,bft.process_date)
    and    pgm2.pgm_id(+) = pop.pgm_id
    and    bft.process_date
           between nvl(pgm2.effective_start_date,bft.process_date)
           and     nvl(pgm2.effective_end_date,bft.process_date)
    and    ppf.person_id(+) = bft.person_id
    and    bft.process_date
           between nvl(ppf.effective_start_date,bft.process_date)
           and     nvl(ppf.effective_end_date,bft.process_date)
    and    ppt.person_type_id(+) = bft.person_type_id
    and    pgm1.pgm_id(+) = bft.pgm_id
    and    bft.process_date
           between nvl(pgm1.effective_start_date,bft.process_date)
           and     nvl(pgm1.effective_end_date,bft.process_date)
    and    pbg.business_group_id = bft.business_group_id
    and    pln1.pl_id(+) = bft.pl_id
    and    bft.process_date
           between nvl(pln1.effective_start_date,bft.process_date)
           and     nvl(pln1.effective_end_date,bft.process_date)
    and    ler.ler_id(+) = bft.ler_id
    and    bft.process_date
           between nvl(ler.effective_start_date,bft.process_date)
           and     nvl(ler.effective_end_date,bft.process_date)
    and    ff.formula_id(+) = bft.person_selection_rl
    and    bft.process_date
           between nvl(ff.effective_start_date,bft.process_date)
           and     nvl(ff.effective_end_date,bft.process_date)
    and    org.organization_id(+) = bft.organization_id
    and    bft.process_date
           between nvl(org.date_from,bft.process_date)
           and     nvl(org.date_to,bft.process_date);
  --
begin
  --
  hr_utility.set_location('Entering :'||l_proc,10);
  --
  -- Default return values for nulls
  --
  fnd_message.set_name('BEN','BEN_91792_ALL_PROMPT');
  --l_all := fnd_message.get;
  l_all  := substrb(fnd_message.get,1,80); -- bug 2595834
  fnd_message.set_name('BEN','BEN_91793_NONE_PROMPT');
  l_none := substrb(fnd_message.get,1,80); -- bug 2595834
  --l_none := fnd_message.get;
  --
  open c_benefit_actions;
  fetch c_benefit_actions into p_process_date,
                               p_mode,
                               p_validate,
                               p_person,
                               p_person_type,
                               p_program,
                               p_business_group,
                               p_plan,
                               p_enrollment_period,
                               p_plan_in_program,
                               p_elig_enrol,
                               p_audit_log,
                               p_cm_trgr_typ,
                               p_cm_typ,
                               p_location,
                               p_person_selection_rule,
                               p_ler,
                               p_organization,
                               p_actn_typ,
                               p_age_fctr,
                               p_min_age,
                               p_max_age,
                               p_los_fctr,
                               p_min_los,
                               p_max_los,
                               p_cmbn_age_los_fctr,
                               p_date_from,
                               p_concurrent_program_name,
			       p_status;
  close c_benefit_actions;
  --
  hr_utility.set_location('Leaving :'||l_proc,10);
  --
end;
--
--
end ben_determine_communications;

/
