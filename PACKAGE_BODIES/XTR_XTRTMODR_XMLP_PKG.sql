--------------------------------------------------------
--  DDL for Package Body XTR_XTRTMODR_XMLP_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."XTR_XTRTMODR_XMLP_PKG" AS
/* $Header: XTRTMODRB.pls 120.1 2007/12/31 12:26:20 vjaganat noship $ */
  FUNCTION INT_COMPONENT1FORMULA RETURN VARCHAR2 IS
  BEGIN
    EXECUTE IMMEDIATE
      'SELECT DECODE(SIGN(:INT_OD_RUNNING - :INT_OVERDUE2 - :INT_OVERDUE),-1,DECODE(SIGN(:INT_OD_RUNNING - :INT_OVERDUE),1,0,round(:INT_OVERDUE2,2)),0) INTO :INT_COMPONENT FROM DUAL';
    COMMIT;
    RETURN ('');
  END INT_COMPONENT1FORMULA;

  FUNCTION BAL_COMPONENT1FORMULA RETURN VARCHAR2 IS
  BEGIN
    EXECUTE IMMEDIATE
      'SELECT DECODE(SIGN(:BAL_RUNNING - :BAL_OVERDUE2 - :BAL_OVERDUE),-1,DECODE(SIGN(:BAL_RUNNING - :BAL_OVERDUE),1,round(:BAL_OVERDUE - :BAL_RUNNING + :BAL_OVERDUE2,2),0,0,round(:BAL_OVERDUE2,2)),0) INTO :BAL_COMPONENT FROM DUAL';
    COMMIT;
    RETURN ('');
  END BAL_COMPONENT1FORMULA;

  FUNCTION TOT_OVERDUE1FORMULA RETURN VARCHAR2 IS
  BEGIN
    EXECUTE IMMEDIATE
      'SELECT NVL(round(:INT_COMPONENT,2),0) + nvl(round(:BAL_COMPONENT,2),0) INTO :TOT_OVERDUE from DUAL';
    COMMIT;
    RETURN ('');
  END TOT_OVERDUE1FORMULA;

  FUNCTION CURR1FORMULA RETURN VARCHAR2 IS
  BEGIN
    EXECUTE IMMEDIATE
      'SELECT DECODE(:DAY30P + :DAY60P + :DAY90P,0,:TOT_OVERDUE,0) INTO :CURR FROM DUAL';
    COMMIT;
    RETURN ('');
  END CURR1FORMULA;

  FUNCTION DAY30P1FORMULA RETURN VARCHAR2 IS
  BEGIN
    EXECUTE IMMEDIATE
      'SELECT DECODE(:DAY60P + :DAY90P,0,DECODE(SIGN(:NUMDAY - 1),1,:TOT_OVERDUE,0),0) INTO :DAY30P FROM DUAL';
    COMMIT;
    RETURN ('');
  END DAY30P1FORMULA;

  FUNCTION DAY60P1FORMULA RETURN VARCHAR2 IS
  BEGIN
    EXECUTE IMMEDIATE
      'SELECT DECODE(:DAY90P,0,DECODE(SIGN(:NUMDAY - 2),1,:TOT_OVERDUE,0),0) INTO :DAY60P FROM DUAL';
    COMMIT;
    RETURN ('');
  END DAY60P1FORMULA;

  FUNCTION DAY90P1FORMULA RETURN VARCHAR2 IS
  BEGIN
    EXECUTE IMMEDIATE
      'SELECT DECODE(SIGN(:NUMDAY - 3),1,:TOT_OVERDUE,0) INTO :DAY90P FROM DUAL';
    COMMIT;
    RETURN ('');
  END DAY90P1FORMULA;

  FUNCTION BEFOREPFORM RETURN BOOLEAN IS
    L_ERROR NUMBER;
  BEGIN
    AS_AT_DATE2 := TRUNC(SYSDATE);
    RETURN (TRUE);
  END BEFOREPFORM;

  FUNCTION CF_SET_PARAFORMULA RETURN VARCHAR2 IS
  BEGIN
    SELECT
      SUBSTR(USER
            ,1
            ,10)
    INTO
      CP_PARA
    FROM
      DUAL;
    RETURN (CP_PARA);
  END CF_SET_PARAFORMULA;

  FUNCTION BEFOREREPORT RETURN BOOLEAN IS
    L_DMMY_NUM NUMBER;
    L_MESSAGE FND_NEW_MESSAGES.MESSAGE_TEXT%TYPE;
    apf boolean;
    CURSOR GET_LANGUAGE_DESC(P_MODULE IN VARCHAR2) IS
      SELECT
        ITEM_NAME,
        SUBSTR(TEXT
              ,1
              ,100) LANG_NAME
      FROM
        XTR_SYS_LANGUAGES_VL
      WHERE MODULE_NAME = P_MODULE;
  BEGIN
    P_CONC_REQUEST_ID := FND_GLOBAL.CONC_REQUEST_ID;
    apf := AFTERPFORM;

    BEGIN
      COMPANY_NAME_HEADER := CEP_STANDARD.GET_WINDOW_SESSION_TITLE;
    EXCEPTION
      WHEN OTHERS THEN
        FND_MESSAGE.SET_NAME('XTR'
                            ,'XTR_LOOKUP_ERR');
        L_MESSAGE := FND_MESSAGE.GET;
        RAISE_APPLICATION_ERROR(-20101
                               ,NULL);
    END;
    IF (P_DISPLAY_DEBUG = 'Y') THEN
      NULL;
    END IF;
    FOR c IN GET_LANGUAGE_DESC('XTRTMODR') LOOP
      IF C.ITEM_NAME = 'Z1AS_AT_DATE' THEN
        Z1AS_AT_DATE := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z1DEAL_NUMBER' THEN
        Z1DEAL_NUMBER := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z1ORDER_BY_COLUMN' THEN
        Z1ORDER_BY_COLUMN := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z1PARAMETERS' THEN
        Z1PARAMETERS := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z1PARTY_CODE' THEN
        Z1PARTY_CODE := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z1PARTY_NAME' THEN
        Z1PARTY_NAME := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z1PRODUCT' THEN
        IF P_SORT_BY in ('PRODUCT','AMOUNT') THEN
          Z1PRODUCT := C.LANG_NAME;
        ELSE
          Z2CLIENT := C.LANG_NAME;
        END IF;
      ELSIF C.ITEM_NAME = 'Z2CLIENT' THEN
        IF P_SORT_BY in ('PRODUCT','AMOUNT') THEN
          Z2CLIENT := C.LANG_NAME;
        ELSE
          Z1PRODUCT := C.LANG_NAME;
        END IF;
      ELSIF C.ITEM_NAME = 'Z2END_OF_REPORT' THEN
        Z2END_OF_REPORT := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2INTEREST' THEN
        Z2INTEREST := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2NAME' THEN
        Z2NAME := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2NINTY_PLUS_DAYS' THEN
        Z2NINTY_PLUS_DAYS := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2NUMBER' THEN
        Z2NUMBER := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2OVERDUE' THEN
        Z2OVERDUE := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2OVERDUE_AMOUNTS' THEN
        Z2OVERDUE_AMOUNTS := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2PRINCIPAL' THEN
        Z2PRINCIPAL := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2PRODUCT_TOTALS' THEN
        Z2PRODUCT_TOTALS := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2REF' THEN
        Z2REF := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2REPORT_TOTALS' THEN
        Z2REPORT_TOTALS := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2SIXTY_DAYS' THEN
        Z2SIXTY_DAYS := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2THIRTY_DAYS' THEN
        Z2THIRTY_DAYS := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2TOTAL_DUE' THEN
        Z2TOTAL_DUE := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2UNDER' THEN
        Z2UNDER := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z2PAGE' THEN
        Z2PAGE := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'REPORT_DATE' THEN
        REPORT_DATE := C.LANG_NAME;
      ELSIF C.ITEM_NAME = 'Z1P_FACTOR' THEN
        Z1P_FACTOR := C.LANG_NAME;
      END IF;
    END LOOP;
    RETURN (TRUE);
  END BEFOREREPORT;

  FUNCTION AFTERPFORM RETURN BOOLEAN IS
    TEMP NUMBER(15) := 1000;
  BEGIN
    IF P_FACTOR IS NOT NULL THEN
      SELECT
        SUBSTR(DESCRIPTION
              ,1
              ,20),
        DECODE(SUBSTR(P_FACTOR
                     ,1
                     ,1)
              ,'U'
              ,1
              ,'T'
              ,1000
              ,'M'
              ,1000000
              ,'B'
              ,100000000)
      INTO
        LP_FACTOR_DESC
        ,TEMP
      FROM
        FND_LOOKUPS
      WHERE LOOKUP_TYPE = 'XTR_FACTOR'
        AND LOOKUP_CODE = SUBSTR(P_FACTOR
            ,1
            ,1);
    ELSE
      SELECT
        SUBSTR(DESCRIPTION
              ,1
              ,20)
      INTO
        LP_FACTOR_DESC
      FROM
        FND_LOOKUPS
      WHERE LOOKUP_TYPE = 'XTR_FACTOR'
        AND LOOKUP_CODE = 'T';
      TEMP := 1000;
    END IF;
    AMT_UNIT2 := TEMP;
    LP_AS_OF_DATE := TO_CHAR(TO_DATE(P_AS_OF_DATE
                                   ,'YYYY/MM/DD HH24:MI:SS')
                           ,'DD-MON-YYYY');
    AS_AT_DATE2 := to_date(LP_AS_OF_DATE,'DD-MM-YYYY');
    CPARTY_NAME2 := P_CPARTY_NAME;
    PRODUCT_TYPE2 := P_PRODUCT_TYPE;
    DEAL_NO2 := P_DEAL_NUMBER;
    CPARTY_CODE2 := P_CPARTY;
    ORDER_BY_COLUMN2 := P_SORT_BY;
    IF P_SORT_BY = 'AMOUNT' THEN
      ORDER_BY_CLAUSE := ' order by group_1,group_3 desc ';
    ELSIF P_SORT_BY = 'PRODUCT' THEN
      ORDER_BY_CLAUSE := ' order by group_1,group_2 ';
    ELSIF P_SORT_BY = 'CLIENT' THEN
      ORDER_BY_CLAUSE := ' order by group_1, group_2';
    ELSE
      ORDER_BY_CLAUSE := ' order by group_1, group_2';
    END IF;
    SELECT
      CP.USER_CONCURRENT_PROGRAM_NAME
    INTO
      REPORT_SHORT_NAME
    FROM
      FND_CONCURRENT_PROGRAMS_VL CP,
      FND_CONCURRENT_REQUESTS CR
    WHERE CR.REQUEST_ID = P_CONC_REQUEST_ID
      AND CP.APPLICATION_ID = CR.PROGRAM_APPLICATION_ID
      AND CP.CONCURRENT_PROGRAM_ID = CR.CONCURRENT_PROGRAM_ID;

      REPORT_SHORT_NAME:= substr(REPORT_SHORT_NAME,1,instr(REPORT_SHORT_NAME,' (XML)'));

    RETURN (TRUE);
  END AFTERPFORM;

  FUNCTION AFTERREPORT RETURN BOOLEAN IS
  BEGIN
    RETURN (TRUE);
  END AFTERREPORT;

  FUNCTION INT_COMPONENT_P RETURN NUMBER IS
  BEGIN
    RETURN INT_COMPONENT;
  END INT_COMPONENT_P;

  FUNCTION BAL_COMPONENT_P RETURN NUMBER IS
  BEGIN
    RETURN BAL_COMPONENT;
  END BAL_COMPONENT_P;

  FUNCTION TOT_OVERDUE_P RETURN NUMBER IS
  BEGIN
    RETURN TOT_OVERDUE;
  END TOT_OVERDUE_P;

  FUNCTION CURR_P RETURN NUMBER IS
  BEGIN
    RETURN CURR;
  END CURR_P;

  FUNCTION DAY30P_P RETURN NUMBER IS
  BEGIN
    RETURN DAY30P;
  END DAY30P_P;

  FUNCTION DAY60P_P RETURN NUMBER IS
  BEGIN
    RETURN DAY60P;
  END DAY60P_P;

  FUNCTION DAY90P_P RETURN NUMBER IS
  BEGIN
    RETURN DAY90P;
  END DAY90P_P;

  FUNCTION CP_PARA_P RETURN VARCHAR2 IS
  BEGIN
    RETURN CP_PARA;
  END CP_PARA_P;

END XTR_XTRTMODR_XMLP_PKG;



/
