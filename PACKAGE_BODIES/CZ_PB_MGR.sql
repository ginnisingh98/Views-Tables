--------------------------------------------------------
--  DDL for Package Body CZ_PB_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."CZ_PB_MGR" AS
/*  $Header: czpbmgrb.pls 120.229.12010000.16 2010/05/10 11:29:10 vsingava ship $  */

   TYPE varchar_type_32000_tbl IS TABLE OF VARCHAR2(32000) INDEX BY VARCHAR2(15);

   --Bug #5186307 - deferred.
   --TYPE t_item_origsysref_tbl IS TABLE OF cz_item_masters.orig_sys_ref%TYPE INDEX BY VARCHAR2(4000);
   --TYPE t_itemtype_origsysref_tbl IS TABLE OF cz_item_types.orig_sys_ref%TYPE INDEX BY VARCHAR2(4000);

   v_application_id_tbl             cz_pb_mgr.t_ref;
   v_language_id_tbl                cz_pb_mgr.t_lang_code;
   v_usage_id_tbl                   cz_pb_mgr.t_ref;
   v_remote_names_not_exported      varchar_type_32000_tbl;
   v_remote_names_exported          varchar_type_32000_tbl;

   g_ui_style_dhtml                 CONSTANT VARCHAR2(1) := '0';
   g_ui_style_applet                CONSTANT VARCHAR2(1) := '3';
   g_ui_style_jrad                  CONSTANT VARCHAR2(1) := '7';
   g_ui_style_custom                CONSTANT VARCHAR2(1) := '8';
   v_default_eff_usg_mask           CONSTANT VARCHAR2(16) := '0000000000000000';

   PS_NODE_TYPE_REFERENCE         CONSTANT PLS_INTEGER  := 263;
   PS_NODE_TYPE_BOM_MODEL         CONSTANT PLS_INTEGER  := 436;
   PS_NODE_TYPE_BOM_OPTIONCLASS   CONSTANT PLS_INTEGER  := 437;
   PS_NODE_TYPE_BOM_STANDARD      CONSTANT PLS_INTEGER  := 438;
   SRC_APPL_ID_BOM                CONSTANT PLS_INTEGER  := 702;

   ENGINE_TYPE_FCE                  CONSTANT VARCHAR2(1) := 'F';

   ENTITY_TYPE_UCT         CONSTANT VARCHAR2(3) := 'UCT';
   ENTITY_TYPE_UMT         CONSTANT VARCHAR2(3) := 'UMT';
   ENTITY_TYPE_SIGNATURE   CONSTANT VARCHAR2(3) := 'SIG';
   ENTITY_TYPE_RULE        CONSTANT VARCHAR2(3) := 'RUL';
   ENTITY_TYPE_PROPERTY    CONSTANT VARCHAR2(3) := 'PRP';

   -- special fields in id resolution
   -- cz_des_chart_cells.primary_opt_id, secondary_opt_id, secondary_feature_id
   -- cz_des_chart_feature.feature_id, cz_rules.rule_folder_id,
   -- cz_ps_nodes.reference_id, cz_ui_nodes.ui_node_ref_id
   FLD_PSN_REFERENCE_ID    CONSTANT VARCHAR2(9) := 'PSNREFID';
   FLD_RULE_COMPONENT_ID   CONSTANT VARCHAR2(9) := 'RULCOMID';
   FLD_UI_NODE_REF_ID      CONSTANT VARCHAR2(9) := 'UINREFID';
   FLD_IGNORE_NOW          CONSTANT VARCHAR2(9) := 'IGNOREID';

   NONSEED_UCT_MIN_ID      CONSTANT INTEGER := 2000;
   NONSEED_UMT_MIN_ID      CONSTANT INTEGER := 1000;
   NONSEED_SIGN_MIN_ID     CONSTANT INTEGER := 10000;
   NONSEED_RULE_MIN_ID     CONSTANT INTEGER := 1000;
   NONSEED_PROP_MIN_ID     CONSTANT INTEGER := 1000;

   RULE_TYPE_DISPLAY_CONDITION  CONSTANT INTEGER := 33;
   RULE_TYPE_ENABLED_CONDITION  CONSTANT INTEGER := 34;
   RULE_TYPE_CONFIG_EXTENSION   CONSTANT INTEGER := 300;
   RULE_TYPE_POPULATOR          CONSTANT INTEGER := 502;
   RULE_TYPE_CAPTION            CONSTANT INTEGER := 700;

   g_engine_type                    cz_devl_projects.config_engine_type%TYPE;

   --Bug #5186307 - deferred.
   --v_item_synched_osr             t_item_origsysref_tbl;
   --v_itemtype_synched_osr         t_itemtype_origsysref_tbl;

   v_prop_vals_def_num_value_ref    cz_pb_mgr.t_ref;

-- These two procedures are created for debugging purpose. They will be called only
-- when Publication Logging is turned ON.

   PROCEDURE mm_dump_array (array_to_dump IN cz_pb_mgr.t_ref,
                            array_name IN VARCHAR2)
   IS
        x NUMBER := 0;
   BEGIN
      IF (array_to_dump.COUNT > 0) THEN
        FOR j IN array_to_dump.first .. array_to_dump.last LOOP
           INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
             (Sysdate, 'MM_DUMP_ARRAY', 'Array ' || array_name || ', index ' || j || ': ' || array_to_dump(j));
        END LOOP;
      END IF;
   END mm_dump_array;

   PROCEDURE mm_dump_osr_array (array_to_dump IN cz_pb_mgr.orig_sys_ref_type,
                                array_name IN VARCHAR2)
   IS
        x NUMBER := 0;
   BEGIN
      IF (array_to_dump.COUNT > 0) THEN
        FOR j IN array_to_dump.first .. array_to_dump.last LOOP
           INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
             (Sysdate, 'MM_DUMP_OSR_ARRAY', 'Array ' || array_name || ', index ' || j || ': ' || array_to_dump(j));
        END LOOP;
      END IF;
   END mm_dump_osr_array;

------------------------------------------------------------------------------------------------


------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure that resolves remote reference nodes - forward declaration
   PROCEDURE resolve_ref_ids_not_found(
      p_master_keys_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_resolving_key_old_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_resolving_key_new_idx_array IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2
     ,p_resolved_key_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_column_name IN VARCHAR2
     ,x_status IN OUT NOCOPY VARCHAR2
   );

   PROCEDURE rollback_data(p_db_link IN VARCHAR2);
   PROCEDURE get_seq_incrementor(x_oraclesequenceincr IN OUT NOCOPY cz_db_settings.VALUE%TYPE);
------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----------delete session variables
   PROCEDURE delete_session_parameters
   AS
   BEGIN
      cz_pb_mgr.g_ui_actns_ui_uidef_old_ref.delete;
      cz_pb_mgr.g_ui_actns_ui_act_id_old_ref.delete;
      cz_pb_mgr.v_models_to_be_exported.DELETE;
      cz_pb_mgr.v_models_not_to_be_exported.DELETE;
      cz_pb_mgr.v_models_to_be_exported_new.DELETE;
      v_remote_names_not_exported.DELETE;
      v_remote_names_exported.DELETE;
      cz_pb_mgr.v_templates_tobe_exported.DELETE;
      cz_pb_mgr.v_templates_not_exported.DELETE;
      cz_pb_mgr.v_global_templs_ref.DELETE;
      cz_pb_mgr.v_server_id := 0;
      cz_pb_mgr.v_ui_def_id := 0;
      cz_pb_mgr.v_export_id := 0;
      cz_pb_mgr.v_publication_id := 0;
      cz_pb_mgr.v_root_model_id := 0;
      cz_pb_mgr.target_root_model_id := 0;
      cz_pb_mgr.v_root_ui_def_id := 0;
      cz_pb_mgr.v_status_code := NULL;
      cz_pb_mgr.loguser := NULL;
      cz_pb_mgr.v_err_message := NULL;
      cz_pb_mgr.sequence_no := 0;
      cz_pb_mgr.v_oraclesequenceincr := 0;
      cz_pb_mgr.v_db_link := NULL;
      cz_pb_mgr.v_insert_string := NULL;
      cz_pb_mgr.v_new_devl_id := 0;
      cz_pb_mgr.v_msg_tbl.DELETE;
      cz_pb_mgr.v_pb_run_id := 0;
      cz_pb_mgr.v_new_object_id := 0;
      cz_pb_mgr.v_server_local_name := NULL;
      cz_pb_mgr.copy_rules := 'YES';
      cz_pb_mgr.copy_uis := 'YES';
      cz_pb_mgr.copy_root_only := 'YES';
      v_application_id_tbl.DELETE;
      v_usage_id_tbl.DELETE;
      v_language_id_tbl.DELETE;
      cz_pb_mgr.g_item_type_id := 0;
      cz_pb_mgr.g_item_id := 0;
      g_object_type := ' ';
      g_cz_ui_pages_ui_def_ref.DELETE;
      g_cz_ui_pages_jrad_doc_ref.DELETE;
      g_cz_ui_pages_capt_id_ref.DELETE;
      cz_pb_mgr.g_cz_uipg_tmplid_tbl.DELETE;
      cz_pb_mgr.g_cz_uipg_tmplui_tbl.DELETE;
      g_cz_ui_pages_ui_def_tbl.DELETE;
      g_cz_ui_pages_jrad_doc_tbl.DELETE;
      g_cz_ui_pages_capt_id_tbl.DELETE;
      g_page_sets_ui_old_ref.DELETE;
      g_page_sets_ui_ref.DELETE;
      g_page_sets_pg_tbl.DELETE;
      cz_pb_mgr.v_ui_images_ui_ref.DELETE;
      cz_pb_mgr.v_ui_images_ui_tbl.DELETE;
      cz_pb_mgr.v_ui_images_usg_tbl.DELETE;
      cz_pb_mgr.v_ui_images_enty_tbl.DELETE;
      g_page_refs_ui_def_old_ref.DELETE;
      g_page_refs_ui_def_new_ref.DELETE;
      g_page_refs_cond_id_ref.DELETE;
      g_page_refs_capt_id_ref.DELETE;
      g_page_refs_tgt_ui_ref.DELETE;
      g_page_refs_tgt_expl_tbl.DELETE;
      g_ui_refs_old_ui_def_ref.DELETE;
      g_ui_refs_new_ui_def_ref.DELETE;
      g_ui_refs_ref_ui_def_ref.DELETE;
      g_ui_refs_expl_id_ref.DELETE;
      g_ui_ps_maps_old_ui_def_ref.DELETE;
      g_ui_ps_maps_new_ui_def_ref.DELETE;
      g_ui_ps_maps_ctrl_tmp_ref.DELETE;
      cz_pb_mgr.g_ui_ps_maps_page_id_tbl.DELETE;
      cz_pb_mgr.g_ui_ps_maps_element_tbl.DELETE;
      g_ui_templates_old_temp_id_ref.DELETE;
      g_ui_templates_new_temp_id_ref.DELETE;
      g_ui_templates_idx_temp_ref.DELETE;
      g_ui_templates_ui_def_old_ref.DELETE;
      g_ui_templates_ui_def_new_ref.DELETE;
      g_ui_templates_jrad_new_ref.DELETE;
      g_ui_templates_jrad_old_ref.DELETE;
      g_tmpl_jrad_old_tbl.DELETE;
      g_tmpl_jrad_new_tbl.DELETE;
      g_cnt_typ_tmpls_old_uidef_ref.DELETE;
      g_cnt_typ_tmpls_new_uidef_ref.DELETE;
      g_cnt_typ_tmpls_tmpid_ref.DELETE;
      g_cnt_typ_tmpls_tgtuidef_ref.DELETE;
      g_cnt_typ_tmpls_cont_ref.DELETE;
      g_ui_actns_ui_act_id_ref.DELETE;
      g_ui_actns_ui_uidef_ref.DELETE;
      g_ui_actns_ui_tgtui_ref.DELETE;
      g_pages_ui_def_old_ref.DELETE;
      cz_pb_mgr.v_sig_new_ref.DELETE;
      cz_pb_mgr.v_sig_old_ref.DELETE;
      cz_pb_mgr.v_sig_idx_ref.DELETE;
      cz_pb_mgr.v_arg_sig_old_tbl.DELETE;
      cz_pb_mgr.v_arg_sig_tbl.DELETE;
      cz_pb_mgr.v_data_sig_tbl.DELETE;
      cz_pb_mgr.g_page_sets_jrad_doc_ref.DELETE;
      cz_pb_mgr.v_cz_ui_nodes_idx_ref.DELETE;
      cz_pb_mgr.l_cnt_typ_tmpls_cont_ref.DELETE;
      cz_pb_mgr.l_cnt_typ_tmpls_new_uidef_ref.DELETE;
      cz_pb_mgr.l_ui_images_ui_ref.DELETE;
      cz_pb_mgr.l_ui_images_enty_tbl.DELETE;
      cz_pb_mgr.l_ui_images_usg_tbl.DELETE;
      cz_pb_mgr.h_devl_prj_by_intl_text.DELETE;
      cz_pb_mgr.v_propval_node_id := NULL;
      cz_pb_mgr.v_propval_prop_id := NULL;
      cz_pb_mgr.v_propval_data_value := NULL;

      cz_pb_mgr.g_ps_reverse_connector_tbl.DELETE;
      cz_pb_mgr.g_ui_actions_id_idx_ref.DELETE;
      cz_pb_mgr.g_ui_actns_ui_act_id_ref.DELETE;
      cz_pb_mgr.g_ui_actns_tgtexpl_ref.DELETE;
      cz_pb_mgr.g_ui_actns_ctx_comp_tbl.DELETE;
      cz_pb_mgr.g_ui_actns_ren_cond_tbl.DELETE;
      cz_pb_mgr.g_uiact_prcpg_templ_tbl.DELETE;
      cz_pb_mgr.g_uiact_prcpg_tmpui_tbl.DELETE;
      cz_pb_mgr.g_uiact_prc_caption_tbl.DELETE;
      cz_pb_mgr.g_uiact_pg_title_tbl.DELETE;
      cz_pb_mgr.g_uiact_main_msg_tbl.DELETE;
      cz_pb_mgr.g_fcefile_old_id_tbl.DELETE;
      cz_pb_mgr.g_fcefile_new_id_tbl.DELETE;
      cz_pb_mgr.g_fcefile_compid_tbl.DELETE;
      g_migration_group_id := NULL;

      --Bug #5186307 - deferred.
      --v_item_synched_osr.DELETE;
      --v_itemtype_synched_osr.DELETE;

      --The sequence incrementor cannot be 0, therefore we need to re-read it.

      get_seq_incrementor(cz_pb_mgr.v_oraclesequenceincr);
   EXCEPTION
      WHEN OTHERS
      THEN
         NULL;
   END delete_session_parameters;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that clears pl/sql tables for a table
-----@p_table_name : name of the table
-----@p_table_type : type of array
-----@x_status     : publication status parameter
   PROCEDURE clear_tables(p_table_name IN VARCHAR2, p_table_type IN VARCHAR2, x_status IN OUT NOCOPY VARCHAR2)
   AS
   BEGIN
      IF (p_table_name = 'cz_ps_nodes')
      THEN
         IF (p_table_type = 'tbl')
         THEN
            cz_pb_mgr.v_cz_ps_nodes_new_tbl.DELETE;
            cz_pb_mgr.v_cz_ps_nodes_old_tbl.DELETE;
            cz_pb_mgr.v_cz_ps_nodes_idx_tbl.DELETE;
            cz_pb_mgr.v_ps_parent_id_tbl.DELETE;
            cz_pb_mgr.v_ps_refid_old_tbl.DELETE;
            cz_pb_mgr.v_devl_project_tbl.DELETE;
            cz_pb_mgr.v_ps_eff_set_id_tbl.DELETE;
            cz_pb_mgr.v_ps_intl_old_tbl.DELETE;
            cz_pb_mgr.v_ps_viol_old_tbl.DELETE;
            cz_pb_mgr.v_ps_orig_sys_tbl.DELETE;
            cz_pb_mgr.v_ps_comp_seq_path_tbl.DELETE;
            cz_pb_mgr.v_ps_comp_seq_id_tbl.DELETE;
            cz_pb_mgr.v_intl_text_model_tbl.DELETE;
            cz_pb_mgr.v_intl_text_ui_tbl.DELETE;
            cz_pb_mgr.v_ps_capt_rule_tbl.DELETE;
            cz_pb_mgr.v_cz_ps_nodes_comp_tbl.DELETE;
            cz_pb_mgr.v_ps_item_id_tbl.DELETE;
            cz_pb_mgr.v_ps_type_old_tbl.DELETE;
            cz_pb_mgr.v_ps_src_appl_id_old_tbl.DELETE;
            cz_pb_mgr.g_ps_uits_add_tbl.DELETE;
		cz_pb_mgr.g_usg_name_processed.DELETE;
         ELSIF(p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_ps_nodes_new_ref.DELETE;
            cz_pb_mgr.v_cz_ps_nodes_old_ref.DELETE;
            cz_pb_mgr.v_ps_parent_id_ref.DELETE;
            cz_pb_mgr.v_ps_ref_id_ref.DELETE;
            cz_pb_mgr.v_ps_eff_set_id_ref.DELETE;
            cz_pb_mgr.v_ps_intl_old_ref.DELETE;
            cz_pb_mgr.v_ps_viol_old_ref.DELETE;
            cz_pb_mgr.v_ps_orig_sys_ref.DELETE;
            cz_pb_mgr.v_ps_comp_seq_path_ref.DELETE;
            cz_pb_mgr.v_ps_comp_seq_id_ref.DELETE;
            cz_pb_mgr.v_ps_capt_rule_ref.DELETE;
            cz_pb_mgr.v_cz_ps_nodes_comp_ref.DELETE;
            cz_pb_mgr.v_ps_item_id_ref.DELETE;
            cz_pb_mgr.v_ps_type_old_ref.DELETE;
            cz_pb_mgr.v_ps_src_appl_id_old_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_model_ref_expls')
      THEN
         IF (p_table_type = 'tbl')
         THEN
            cz_pb_mgr.v_component_id_old_tbl.DELETE;
            cz_pb_mgr.v_parent_expl_id_tbl.DELETE;
            cz_pb_mgr.v_child_expl_id_tbl.DELETE;
            cz_pb_mgr.v_referring_node_id_tbl.DELETE;
         ELSIF(p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_model_ref_expls_idx_ref.DELETE;
            cz_pb_mgr.v_cz_model_ref_expls_old_ref.DELETE;
            cz_pb_mgr.v_cz_model_ref_expls_new_ref.DELETE;
            cz_pb_mgr.v_component_id_old_ref.DELETE;
            cz_pb_mgr.v_parent_expl_id_ref.DELETE;
            cz_pb_mgr.v_child_expl_id_ref.DELETE;
            cz_pb_mgr.v_referring_node_id_ref.DELETE;
            cz_pb_mgr.v_ref_model_id_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_func_comp_specs')
      THEN
         IF (p_table_type = 'tbl')
         THEN
            cz_pb_mgr.v_cz_func_comp_old_tbl.DELETE;
            cz_pb_mgr.v_cz_func_comp_new_tbl.DELETE;
         ELSIF(p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_func_comp_new_ref.DELETE;
            cz_pb_mgr.v_cz_func_comp_old_ref.DELETE;
            cz_pb_mgr.v_cz_func_comp_idx_ref.DELETE;
            cz_pb_mgr.v_cz_func_devl_old_ref.DELETE;
            cz_pb_mgr.v_cz_func_cid_old_ref.DELETE;
            cz_pb_mgr.v_cz_func_expl_old_ref.DELETE;
            cz_pb_mgr.v_cz_func_fld_old_ref.DELETE;
            cz_pb_mgr.v_cz_func_obj_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_ui_defs')
      THEN
         IF (p_table_type = 'tbl')
         THEN
            cz_pb_mgr.v_ui_devl_id_tbl.DELETE;
            cz_pb_mgr.v_ui_comp_id_tbl.DELETE;
         ELSIF(p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_ui_defs_old_oa_ref.DELETE;
            cz_pb_mgr.v_cz_ui_defs_new_ref.DELETE;
            cz_pb_mgr.v_cz_ui_defs_old_ref.DELETE;
            cz_pb_mgr.v_cz_ui_defs_idx_ref.DELETE;
            cz_pb_mgr.v_ui_devl_id_ref.DELETE;
            cz_pb_mgr.v_ui_comp_id_ref.DELETE;
            cz_pb_mgr.v_ui_defs_mcpt_rule_ref.DELETE;
            cz_pb_mgr.v_ui_defs_pcpt_rule_ref.DELETE;
            cz_pb_mgr.v_master_template_id_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_ui_nodes')
      THEN
         IF (p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_ui_nodes_new_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_old_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_ui_def_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_parent_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_ui_ref_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_ps_node_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_component_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_ui_dref_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_expl_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_fcomp_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_capt_id_ref.DELETE;
            cz_pb_mgr.v_cz_ui_nodes_tool_id_ref.DELETE;
            cz_pb_mgr.v_intl_text_model_tbl.DELETE;
            cz_pb_mgr.v_intl_text_ui_tbl.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_ps_prop_vals')
      THEN
         IF (p_table_type = 'tbl')
         THEN
            cz_pb_mgr.v_prop_vals_node_tbl.DELETE;
            cz_pb_mgr.v_prop_vals_prop_tbl.DELETE;
            cz_pb_mgr.v_prop_vals_data_tbl.DELETE;
            cz_pb_mgr.v_prop_vals_num_tbl.DELETE;
            cz_pb_mgr.v_prop_vals_origsys_tbl.DELETE;
            cz_pb_mgr.v_prop_vals_datanum_tbl.DELETE;
         ELSIF(p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_prop_vals_node_ref.DELETE;
            cz_pb_mgr.v_prop_vals_prop_ref.DELETE;
            cz_pb_mgr.v_prop_vals_data_ref.DELETE;
            cz_pb_mgr.v_prop_vals_num_ref.DELETE;
            cz_pb_mgr.v_prop_vals_origsys_ref.DELETE;
            cz_pb_mgr.v_prop_vals_datanum_ref.DELETE;
            cz_pb_mgr.v_prop_vals_data_typ_ref.DELETE;
            cz_pb_mgr.v_prop_vals_data_num_ref.DELETE;
            cz_pb_mgr.v_prop_vals_intl_text_ref.DELETE;
            v_prop_vals_def_num_value_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_item_masters')
      THEN
         IF (p_table_type = 'tbl')
         THEN
            cz_pb_mgr.v_item_prop_num_val_tbl.DELETE;
            cz_pb_mgr.v_item_prop_data_typ_tbl.DELETE;
            cz_pb_mgr.v_item_masters_tbl.DELETE;
            cz_pb_mgr.v_item_types_tbl.DELETE;
            cz_pb_mgr.v_item_prop_id_tbl.DELETE;
            cz_pb_mgr.v_item_prop_type_tbl.DELETE;
            cz_pb_mgr.v_it_prop_vals_id_tbl.DELETE;
            cz_pb_mgr.v_it_prop_vals_item_tbl.DELETE;
            cz_pb_mgr.v_it_prop_value_tbl.DELETE;
         ELSIF(p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_item_prop_num_val_ref.DELETE;
            cz_pb_mgr.v_item_prop_data_typ_ref.DELETE;
            cz_pb_mgr.v_item_masters_ref.DELETE;
            cz_pb_mgr.v_item_types_ref.DELETE;
            cz_pb_mgr.v_item_prop_id_ref.DELETE;
            cz_pb_mgr.v_item_prop_type_ref.DELETE;
            cz_pb_mgr.v_it_prop_vals_id_ref.DELETE;
            cz_pb_mgr.v_it_prop_vals_item_ref.DELETE;
            cz_pb_mgr.v_it_prop_value_ref.DELETE;
            cz_pb_mgr.v_remote_prop_ref.DELETE;
            cz_pb_mgr.v_property_record_ref.DELETE;
            cz_pb_mgr.v_type_property_record_ref.DELETE;
            cz_pb_mgr.v_type_record_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_rule_folders')
      THEN
         IF (p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_folders_id_old_ref.DELETE;
            cz_pb_mgr.v_cz_folders_id_new_ref.DELETE;
            cz_pb_mgr.v_cz_folders_id_idx_ref.DELETE;
            cz_pb_mgr.v_cz_folders_pf_id_ref.DELETE;
            cz_pb_mgr.v_cz_folders_pj_id_ref.DELETE;
            cz_pb_mgr.v_cz_folders_eff_ref.DELETE;
            cz_pb_mgr.v_cz_folders_orig_ref.DELETE;
            cz_pb_mgr.v_cz_folders_obj_ref.DELETE;
         ELSIF(p_table_type = 'tbl')
         THEN
            cz_pb_mgr.v_cz_folders_id_old_tbl.DELETE;
            cz_pb_mgr.v_cz_folders_id_new_tbl.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_expression_nodes')
      THEN
         IF (p_table_type = 'tbl')
         THEN
            cz_pb_mgr.v_cz_enodes_enode_id_new_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_enode_id_old_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_expr_id_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_psnode_id_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_gcol_id_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_pexpr_id_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_mrefl_id_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_rule_id_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_par_sig_id_tbl.DELETE;
            cz_pb_mgr.v_cz_enodes_prop_id_tbl.delete;
         ELSIF(p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_enodes_enode_id_old_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_enode_id_idx_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_enode_id_new_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_psnode_id_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_gcol_id_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_pexpr_id_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_mrefl_id_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_rule_id_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_arg_sig_id_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_par_sig_id_ref.DELETE;
            cz_pb_mgr.v_cz_expr_sig_ref.DELETE;
            cz_pb_mgr.v_cz_enodes_prop_id_ref.delete;
         END IF;
      ELSIF(p_table_name = 'cz_rules') THEN
         IF (p_table_type = 'ref') THEN
            cz_pb_mgr.v_cz_rules_rule_id_old_ref.DELETE;
            cz_pb_mgr.v_cz_rules_rule_id_new_ref.DELETE;
            cz_pb_mgr.v_cz_rules_persistent_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_rule_id_idx_ref.DELETE;
            cz_pb_mgr.v_cz_rules_rf_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_proj_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_comp_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_ant_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_con_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_rea_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_eff_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_unmsg_id_ref.DELETE;
            cz_pb_mgr.v_cz_rules_expl_ref.DELETE;
            cz_pb_mgr.v_cz_rules_sig_ref.DELETE;
            cz_pb_mgr.v_intl_text_model_tbl.DELETE;
            cz_pb_mgr.v_intl_text_ui_tbl.DELETE;
            cz_pb_mgr.v_cz_rules_obj_ref.DELETE;
            cz_pb_mgr.v_cz_rules_sig_idx_ref.DELETE;
            cz_pb_mgr.v_cz_rules_ui_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_des_chart_features')
      THEN
         IF (p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_des_feature_id_old_ref.DELETE;
            cz_pb_mgr.v_cz_des_feature_id_new_ref.DELETE;
            cz_pb_mgr.v_cz_des_feature_rid_new_ref.DELETE;
            cz_pb_mgr.v_cz_des_feature_rule_id_ref.DELETE;
            cz_pb_mgr.v_cz_des_feature_mrefl_id_ref.DELETE;
            cz_pb_mgr.v_cz_des_feature_ft_typ_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_des_chart_cells')
      THEN
         IF (p_table_type = 'ref')
         THEN
            cz_pb_mgr.v_cz_des_cells_rule_id_new_ref.DELETE;
            cz_pb_mgr.v_cz_des_cells_rule_id_old_ref.DELETE;
            cz_pb_mgr.v_cz_des_cells_sf_id_ref.DELETE;
            cz_pb_mgr.v_cz_des_cells_sopt_id_ref.DELETE;
            cz_pb_mgr.v_cz_des_cells_popt_id_ref.DELETE;
            cz_pb_mgr.v_cz_des_cells_sexpl_id_ref.DELETE;
         END IF;
      ELSIF(p_table_name = 'cz_lce_headers')
      THEN
         cz_pb_mgr.v_cz_lce_headers_new_tbl.DELETE;
         cz_pb_mgr.v_cz_lce_headers_old_tbl.DELETE;
         cz_pb_mgr.v_cz_intl_text_idx_ref.DELETE;
         cz_pb_mgr.v_cz_intl_unmsg_idx_ref.DELETE;
         cz_pb_mgr.v_cz_lce_headers_new_ref.DELETE;
         cz_pb_mgr.v_cz_lce_headers_old_ref.DELETE;
         cz_pb_mgr.v_cz_lce_comp_id_ref.DELETE;
         cz_pb_mgr.v_cz_lce_expl_id_ref.DELETE;
      ELSIF(p_table_name = 'cz_lce_load_specs')
      THEN
         cz_pb_mgr.v_specs_net_type_ref.DELETE;
         cz_pb_mgr.v_specs_attach_expl_id_ref.DELETE;
         cz_pb_mgr.v_specs_lce_header_id_ref.DELETE;
         cz_pb_mgr.v_specs_required_expl_id_ref.DELETE;
         cz_pb_mgr.v_specs_attach_comp_id_ref.DELETE;
         cz_pb_mgr.v_specs_model_id_ref.DELETE;
         cz_pb_mgr.v_specs_alias_name_ref.DELETE;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_status := PUBLICATION_ERROR;
         RAISE;
   END;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------error and log messages are trapped
   PROCEDURE error_msg_populate(p_msg VARCHAR2, p_caller VARCHAR2, p_code NUMBER)
   AS
      record_count PLS_INTEGER := 0;
   BEGIN
      record_count := cz_pb_mgr.v_msg_tbl.COUNT + 1;
      cz_pb_mgr.v_msg_tbl(record_count).msg_text := LTRIM(RTRIM(SUBSTR(p_msg, 1, 2000)));
      cz_pb_mgr.v_msg_tbl(record_count).called_proc := p_caller;
      cz_pb_mgr.v_msg_tbl(record_count).sql_code := pbdebug;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in populating messages: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SESSN', SQLCODE);
   END error_msg_populate;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------------sequence no generator function
   FUNCTION sequence_generate(seq_const PLS_INTEGER, seq_name VARCHAR2, p_oraclesequenceincr NUMBER)
      RETURN NUMBER
   AS
      seq_cv ref_cursor;
      l_sequence_gen NUMBER;

      cz_pb_no_incrementor  EXCEPTION;
   BEGIN

      IF(p_oraclesequenceincr = 0)THEN
          cz_pb_mgr.v_err_message := 'The sequence incrementor cannot be 0.';
          cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SESSN', 70001);
          RAISE cz_pb_no_incrementor;
      END IF;

      IF (cz_pb_mgr.v_sequence_count.EXISTS(seq_const))
      THEN
         l_sequence_gen := cz_pb_mgr.v_sequence_count(seq_const) + 1;
      ELSE
         l_sequence_gen := 0;                                                                 -- Will fall into this statement only for a New session
      END IF;

      -- We will grab a new sequence from the sequencer only in case of
      -- 1. New session OR
      -- 2. If the running sequence count has reached the last sequence in the block
      IF (l_sequence_gen = 0 OR(l_sequence_gen = cz_pb_mgr.v_next_sequence_gen(seq_const)))
      THEN
         BEGIN
            OPEN seq_cv FOR 'SELECT ' || seq_name || ' FROM  dual';

            LOOP
               FETCH seq_cv
                INTO l_sequence_gen;

               EXIT WHEN seq_cv%NOTFOUND;
            END LOOP;

            CLOSE seq_cv;
         EXCEPTION
            WHEN OTHERS
            THEN
               cz_pb_mgr.v_err_message := 'Error in getting the next sequence value : ' || SQLERRM;
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SESSN', SQLCODE);
               RAISE;
         END;

         cz_pb_mgr.v_next_sequence_gen(seq_const) := l_sequence_gen + p_oraclesequenceincr;
      END IF;

      cz_pb_mgr.v_sequence_count(seq_const) := l_sequence_gen;
      RETURN l_sequence_gen;
   EXCEPTION
     WHEN OTHERS THEN
       cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
       RAISE;
   END sequence_generate;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----update orig_sys_ref of cz_localized_texts to NULL
   PROCEDURE update_localized_texts
   AS
   BEGIN
      IF (cz_pb_mgr.v_cz_intl_text_new_ref.COUNT > 0)
      THEN
         EXECUTE IMMEDIATE    'BEGIN'
                           || ' '
                           || 'FOR I IN cz_pb_mgr.v_cz_intl_text_new_ref.FIRST..cz_pb_mgr.v_cz_intl_text_new_ref.LAST'
                           || ' '
                           || 'LOOP'
                           || ' '
                           || 'UPDATE cz_localized_texts'
                           || cz_pb_mgr.v_db_link
                           || '  t'
                           || ' '
                           || 'SET   t.orig_sys_ref = NULL'
                           || ' '
                           || 'WHERE  t.intl_text_id = cz_pb_mgr.v_cz_intl_text_new_ref(i)'
                           || ' '
                           || 'AND   t.orig_sys_ref IS NOT NULL;'
                           || ' '
                           || 'END LOOP;'
                           || ' '
                           || 'EXCEPTION'
                           || ' '
                           || 'WHEN OTHERS THEN'
                           || ' '
                           || 'ROLLBACK;'
                           || ' '
                           || 'END;';

         COMMIT;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_UPDATE_ERR', 'TABLENAME', 'cz_localized_texts', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UPDLOCALTEXT', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----update orig_sys_ref of cz_localized_texts to target values during model migration.
   PROCEDURE update_mm_localized_texts
   AS
   BEGIN
      IF (cz_pb_mgr.v_cz_intl_text_new_ref.COUNT > 0)
      THEN
         EXECUTE IMMEDIATE    'DECLARE'
                           || ' '
                           || 'orig_sys_ref_tgt VARCHAR2(100);'
                           || ' '
                           || 'base_lang VARCHAR2(10);'
                           || ' '
                           || 'BEGIN'
                           || ' '
                           || ' SELECT language_code into base_lang FROM fnd_languages WHERE installed_flag = ''B'';'
                           || ' '
                           || 'FOR I IN cz_pb_mgr.v_cz_intl_text_new_ref.FIRST..cz_pb_mgr.v_cz_intl_text_new_ref.LAST'
                           || ' '
                           || 'LOOP'
                           || ' '
                           || 'orig_sys_ref_tgt := NULL;'
                           || ' '
                           || 'BEGIN'
                           || ' '
                           || 'SELECT DECODE(cz_pb_mgr.bomsynch_flag,''Y'', cz_bom_synch.locText_origSysRef(t.orig_sys_ref),t.orig_sys_ref)'
                           || ' '
                           || 'INTO orig_sys_ref_tgt'
                           || ' '
                           || 'FROM cz_localized_texts'
                           || cz_pb_mgr.v_db_link
                           || '  t'
                           || ' '
                           || 'WHERE  t.intl_text_id = cz_pb_mgr.v_cz_intl_text_new_ref(i) AND t.orig_sys_ref IS NOT NULL AND t.language = base_lang;'
                           || ' '
                           || 'UPDATE cz_localized_texts'
                           || cz_pb_mgr.v_db_link
                           || '  t'
                           || ' '
                           || 'SET   t.orig_sys_ref = orig_sys_ref_tgt'
                           || ' '
                           || 'WHERE  t.intl_text_id = cz_pb_mgr.v_cz_intl_text_new_ref(i)'
                           || ' '
                           || 'AND   t.orig_sys_ref IS NOT NULL;'
                           || ' '
                           || 'EXCEPTION'
                           || ' '
                           || 'WHEN NO_DATA_FOUND THEN'
                           || ' '
                           || 'NULL;'
                           || ' '
                           || 'END;'
                           || ' '
                           || 'END LOOP;'
                           || ' '
                           || 'EXCEPTION'
                           || ' '
                           || 'WHEN OTHERS THEN'
                           || ' '
                           || 'ROLLBACK;'
                           || ' '
                           || 'END;';
         COMMIT;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_UPDATE_ERR', 'TABLENAME', 'cz_localized_texts', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UPDLOCALTEXT', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-- id_type: null means all input ids not seeded nor from special fields, so have
-- to be resolved; not null implies an id in the array may or may not be resolved,
-- depending on the id value and its type (e.g., seeded, special type/value).
-- ignore id mapping failure here for a. 'seeded' ids b. ui rules' rule_folder_id
-- because it is useless (and because it may have a non-zero value) c. explicit
-- compatability rule's primary opt id (not real fks) d. reference id and component_id
-- because there are updates on them after new record insertion e. expression nodes'
-- ps_node_id because node could be deleted f. ui node's ui_node_ref_id because they
-- are specially handled after insertion (or obsolete anyway)
PROCEDURE resolve_ids(array_to_resolve     IN OUT NOCOPY cz_pb_mgr.t_ref,
                      resolved_array       IN OUT NOCOPY cz_pb_mgr.t_ref,
                      array_of_new_keys    IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2,
                      resolving_id         IN VARCHAR2,
                      id_type              IN VARCHAR2 DEFAULT NULL
                     )
IS
  l_use_old_id  BOOLEAN;
BEGIN
  IF cz_pb_mgr.v_status_code=PUBLICATION_ERROR OR array_to_resolve.COUNT=0 THEN RETURN; END IF;

  FOR J IN array_to_resolve.FIRST..array_to_resolve.LAST
  LOOP
    BEGIN
      IF array_to_resolve(j) IS NOT NULL THEN
        resolved_array(j) := array_of_new_keys(array_to_resolve(j));
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        IF array_to_resolve(j) = 0 THEN
          IF cz_pb_mgr.v_session_parameter = pub_model THEN
            resolved_array(j) := 1;
          ELSE
            resolved_array(j) := 0;
          END IF;
        ELSE
          IF id_type IS NULL THEN
            l_use_old_id := FALSE;
          ELSE
            l_use_old_id := (id_type=FLD_IGNORE_NOW                                       OR
              id_type=ENTITY_TYPE_UCT        AND array_to_resolve(j)<NONSEED_UCT_MIN_ID   OR
              id_type=ENTITY_TYPE_UMT        AND array_to_resolve(j)<NONSEED_UMT_MIN_ID   OR
	      id_type=ENTITY_TYPE_SIGNATURE  AND array_to_resolve(j)<NONSEED_SIGN_MIN_ID  OR
	      id_type=ENTITY_TYPE_RULE       AND array_to_resolve(j)<NONSEED_RULE_MIN_ID  OR
	      id_type=ENTITY_TYPE_PROPERTY   AND array_to_resolve(j)<NONSEED_PROP_MIN_ID  OR
	      id_type=FLD_PSN_REFERENCE_ID   AND
	         (cz_pb_mgr.v_models_not_to_be_exported.FIRST IS NOT NULL OR
	          cz_pb_mgr.v_session_parameter=model_copy AND cz_pb_mgr.copy_root_only='YES') OR
	      id_type=FLD_RULE_COMPONENT_ID AND cz_pb_mgr.v_session_parameter=model_copy AND cz_pb_mgr.copy_root_only='YES');
          END IF;
          IF l_use_old_id THEN
            resolved_array(j) := array_to_resolve(j);
          ELSE
            cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            cz_pb_mgr.v_err_message := 'Unable to resolve '||id_type||' id ('||resolving_id||'): '||to_char(array_to_resolve(j));
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_pb_mgr.RESOLVEIDS',SQLCODE);
            RAISE;
          END IF;
        END IF;
    END;
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN
    cz_pb_mgr.v_err_message  := CZ_UTILS.GET_TEXT('CZ_PB_KEY_RES_ERR', 'ResolvingId', resolving_id, 'SQLERRM',SQLERRM);
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_pb_mgr.RESOLVEIDS',SQLCODE);
    cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
    cz_pb_mgr.v_sql_err_msg := substr(SQLERRM,1,2000);
    RAISE;
END resolve_ids;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PROCEDURE resolve_ids(array_to_resolve IN OUT NOCOPY cz_pb_mgr.t_ref,
                      array_of_new_keys IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2,
                      resolving_id IN VARCHAR2,
                      id_type  IN VARCHAR2 DEFAULT NULL)
IS
BEGIN
  resolve_ids(array_to_resolve,array_to_resolve,array_of_new_keys,resolving_id,id_type);
END resolve_ids;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure that resolves ids via single index keys and one additional array
PROCEDURE resolve_tmpl_ui_defs(array_to_resolve               IN OUT NOCOPY cz_pb_mgr.t_ref,
                               resolved_array                 IN OUT NOCOPY cz_pb_mgr.t_ref,
                               ui_templ_id_tbl                IN OUT NOCOPY cz_pb_mgr.t_ref,
                               array_of_new_keys              IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2,
                                     resolving_id                     IN VARCHAR2
                            )
IS

  l_seeded_flag VARCHAR2(1);

BEGIN

  IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) THEN
    IF (array_to_resolve.COUNT > 0) THEN
      FOR J IN array_to_resolve.FIRST..array_to_resolve.LAST
        LOOP
          BEGIN
            IF (array_to_resolve(j) IS NOT NULL) THEN
              resolved_array(j) := array_of_new_keys(array_to_resolve(j));
            END IF;
          EXCEPTION
            WHEN NO_DATA_FOUND THEN
              IF (array_to_resolve(j) = 0 AND(cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model)) THEN

               IF NOT(ui_templ_id_tbl(j)=0 OR ui_templ_id_tbl(j) IS NULL) THEN

                 SELECT seeded_flag INTO l_seeded_flag FROM CZ_UI_TEMPLATES
                  WHERE template_id=ui_templ_id_tbl(j) AND ui_def_id=0;

                 IF l_seeded_flag='1' THEN
                     resolved_array(j) := 0;
                 ELSE
                   resolved_array(j) := 1;
                 END IF;

               END IF;

            ELSE
               resolved_array(j) := array_to_resolve(j);
            END IF;
        END;
      END LOOP;
    END IF;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    cz_pb_mgr.v_err_message  := CZ_UTILS.GET_TEXT('CZ_PB_KEY_RES_ERR', 'ResolvingId', resolving_id, 'SQLERRM',SQLERRM);
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_pb_mgr.RESOLVEIDS',SQLCODE);
    cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
    cz_pb_mgr.v_sql_err_msg := substr(SQLERRM,1,2000);
END resolve_tmpl_ui_defs;
-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE resolve_tmpl_ui_defs(
      p_array_to_resolve IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_templ_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_table_name IN VARCHAR2
   )
   IS
   BEGIN
      IF (p_array_to_resolve.COUNT > 0)
      THEN
         FOR i IN p_array_to_resolve.FIRST .. p_array_to_resolve.LAST
         LOOP
            BEGIN
               IF ((p_array_to_resolve(i) IS NOT NULL) AND(p_templ_array(i) IS NOT NULL))
               THEN
                  IF ((p_array_to_resolve(i) = 0))
                  THEN
                     IF (   (NOT cz_pb_mgr.g_ui_templates_idx_temp_ref.EXISTS(p_templ_array(i)))
                         OR (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
                        )
                     THEN
                        p_array_to_resolve(i) := 0;
                     ELSE
                        p_array_to_resolve(i) := 1;
                     END IF;
                  END IF;
               ELSE
                  BEGIN
                     p_array_to_resolve(i) := cz_pb_mgr.v_cz_ui_defs_idx_ref(p_array_to_resolve(i));
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        NULL;
                  END;
               END IF;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  p_array_to_resolve(i) := 0;
            END;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in resolving template ui def id of: ' || p_table_name || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'RESOLVETEMPLUIDEFS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END resolve_tmpl_ui_defs;
----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE resolve_intl_texts(
      array_to_resolve IN OUT NOCOPY cz_pb_mgr.t_ref
     ,array_of_new_keys IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2
     ,resolving_id IN VARCHAR2
   )
   IS
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF (array_to_resolve.COUNT > 0)
         THEN
            FOR j IN array_to_resolve.FIRST .. array_to_resolve.LAST
            LOOP
               BEGIN
                  IF (array_to_resolve(j) IS NOT NULL)
                  THEN
                     array_to_resolve(j) := array_of_new_keys(array_to_resolve(j));
                  END IF;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     IF (array_to_resolve(j) > 1000)
                     THEN
                        cz_pb_mgr.v_err_message :=
                                                 'Resolution error for: ' || resolving_id || ' : ' || TO_CHAR(array_to_resolve(j)) || ' : '
                                                 || SQLERRM;
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEIDS', SQLCODE);
                        cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                        RAISE;
                     END IF;
               END;
            END LOOP;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_KEY_RES_ERR', 'ResolvingId', resolving_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEIDS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
   END resolve_intl_texts;

------------------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_into_item_tables(
      table_name IN VARCHAR2
     ,primary_key IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name IN VARCHAR2
     ,primary_key_plsql_table IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;
      l_len NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> cz_pb_mgr.PUBLICATION_ERROR) AND(primary_key_plsql_table.COUNT > 0))
      THEN
         v_db_link := db_link;
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table.FIRST || '..' || primary_key_plsql_table.LAST || '  LOOP ';
            v_insertstring := v_insertstring || ' BEGIN  insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring :=
                      v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key || ' = ' || plsql_table_name || '(m) ';
            v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;   ';
            v_insertstring := v_insertstring || '  EXCEPTION WHEN DUP_VAL_ON_INDEX THEN  ';
            v_insertstring := v_insertstring || '  IF (UPPER(cz_pb_mgr.v_insert_table_name) = ''CZ_ITEM_MASTERS'') THEN ';
            v_insertstring := v_insertstring || '  UPDATE cz_item_masters' || cz_pb_mgr.v_db_link || ' t  ';
            v_insertstring := v_insertstring || '  SET ( ITEM_TYPE_ID,DESC_TEXT,ORIG_SYS_REF,REF_PART_NBR,QUOTEABLE_FLAG,LEAD_TIME ';
            v_insertstring := v_insertstring || ' ,ITEM_STATUS,PRIMARY_UOM_CODE,DELETED_FLAG,DECIMAL_QTY_FLAG) ';
            v_insertstring := v_insertstring || '  = ( SELECT   ITEM_TYPE_ID,DESC_TEXT,orig_sys_ref,REF_PART_NBR, ';
            v_insertstring := v_insertstring || '  QUOTEABLE_FLAG ,LEAD_TIME,ITEM_STATUS,PRIMARY_UOM_CODE, DELETED_FLAG,DECIMAL_QTY_FLAG  ';
            v_insertstring := v_insertstring || '  FROM   cz_item_masters WHERE   cz_item_masters.item_id = ' || plsql_table_name || '(m) ';
            v_insertstring := v_insertstring || '   AND   deleted_flag = ''0'') WHERE t.item_id = ' || plsql_table_name || '(m); ';
            v_insertstring := v_insertstring || '  ELSIF (UPPER(cz_pb_mgr.v_insert_table_name) = ''CZ_ITEM_TYPES'') THEN  ';
            v_insertstring := v_insertstring || '  UPDATE cz_item_types' || cz_pb_mgr.v_db_link || ' t  ';
            v_insertstring := v_insertstring || '  SET (DESC_TEXT,NAME,USER_NUM01,USER_NUM02,USER_NUM03,USER_NUM04 ';
            v_insertstring := v_insertstring || '  ,USER_STR01,USER_STR02,USER_STR03,USER_STR04,DELETED_FLAG,ORIG_SYS_REF) ';
            v_insertstring := v_insertstring || '   = (SELECT DESC_TEXT,NAME,USER_NUM01,USER_NUM02,USER_NUM03,USER_NUM04 ';
            v_insertstring := v_insertstring || '	,USER_STR01,USER_STR02,USER_STR03,USER_STR04,DELETED_FLAG,ORIG_SYS_REF ';
            v_insertstring := v_insertstring || '   FROM   cz_item_types WHERE   cz_item_types.item_type_id = ' || plsql_table_name || '(m) ';
            v_insertstring := v_insertstring || '   AND   deleted_flag = ''0'') WHERE t.item_type_id = ' || plsql_table_name || '(m); ';
            v_insertstring := v_insertstring || '  ELSIF (UPPER(cz_pb_mgr.v_insert_table_name) = ''CZ_PROPERTIES'') THEN  ';
            v_insertstring := v_insertstring || '  UPDATE cz_properties' || cz_pb_mgr.v_db_link || ' t ';
            v_insertstring := v_insertstring || '   SET ( PROPERTY_UNIT,DESC_TEXT,NAME,DATA_TYPE,DEF_VALUE,USER_NUM01 ';
            v_insertstring := v_insertstring || '  ,USER_NUM02,USER_NUM03,USER_NUM04,USER_STR01,USER_STR02,USER_STR03,USER_STR04 ';
            v_insertstring := v_insertstring || '  ,DELETED_FLAG,EFF_FROM,EFF_TO,ORIG_SYS_REF) = (SELECT PROPERTY_UNIT,DESC_TEXT,';
            v_insertstring := v_insertstring || '  NAME,DATA_TYPE,DEF_VALUE,USER_NUM01,USER_NUM02,USER_NUM03,USER_NUM04,';
            v_insertstring := v_insertstring || '  USER_STR01,USER_STR02,USER_STR03,USER_STR04,DELETED_FLAG,EFF_FROM,';
            v_insertstring := v_insertstring || '  EFF_TO,ORIG_SYS_REF   FROM   cz_properties  ';
            v_insertstring := v_insertstring || '  WHERE   cz_properties.property_id = ' || plsql_table_name || '(m) ';
            v_insertstring := v_insertstring || '  AND   deleted_flag = ''0'') WHERE t.property_id = ' || plsql_table_name || '(m); ';
            v_insertstring := v_insertstring || '  END IF; END; END LOOP; COMMIT; END; ';

            EXECUTE IMMEDIATE v_insertstring;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               ROLLBACK;
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTINTO', SQLCODE);
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERTION_ERR', 'TABLENAME', table_name, 'SQLERRM', SQLERRM);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTINTO', SQLCODE);
               cz_pb_mgr.v_status_code := cz_pb_mgr.PUBLICATION_ERROR;
               RAISE;
         END;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END insert_into_item_tables;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----generates new publication id for the target publication
   PROCEDURE get_new_publication_id(
      p_old_pub_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_old_pb_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_new_pub_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_old_rem_pb_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (cz_pb_mgr.v_server_id <> 0)
         THEN
            SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_model_publications_seq
                                              , 'cz_model_publications_s.nextval' || cz_pb_mgr.v_db_link
                                              ,cz_pb_mgr.v_oraclesequenceincr
                                              )
                  ,publication_id, remote_publication_id
              INTO x_new_pub_id
                  ,x_old_pb_id, x_old_rem_pb_id
              FROM cz_model_publications
             WHERE cz_model_publications.publication_id = cz_pb_mgr.v_publication_id AND cz_model_publications.deleted_flag = record_not_deleted;
         ELSE
            SELECT cz_model_publications_s.NEXTVAL, publication_id, remote_publication_id
              INTO x_new_pub_id, x_old_pb_id, x_old_rem_pb_id
              FROM cz_model_publications
             WHERE cz_model_publications.publication_id = cz_pb_mgr.v_publication_id AND cz_model_publications.deleted_flag = record_not_deleted;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_model_publications', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUB', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_new_publication_id;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_item_tables(
      table_name IN VARCHAR2
     ,primary_key1 IN VARCHAR2
     ,primary_key2 IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name1 IN VARCHAR2
     ,plsql_table_name2 IN VARCHAR2
     ,primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table2 IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> cz_pb_mgr.PUBLICATION_ERROR) AND(primary_key_plsql_table1.COUNT > 0))
      THEN
         v_db_link := UPPER(LTRIM(RTRIM(db_link)));
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table1.FIRST || '..' || primary_key_plsql_table1.LAST || '  LOOP ';
            v_insertstring := v_insertstring || 'BEGIN  insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring :=
                    v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key1 || ' = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key2 || '=' || plsql_table_name2 || '(m) ';
            v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF; ';
            v_insertstring := v_insertstring || '  EXCEPTION WHEN DUP_VAL_ON_INDEX THEN  ';
            v_insertstring := v_insertstring || '  IF (UPPER(cz_pb_mgr.v_insert_table_name) = ''CZ_ITEM_TYPE_PROPERTIES'') THEN ';
            v_insertstring := v_insertstring || '  UPDATE cz_item_type_properties' || cz_pb_mgr.v_db_link || ' SET  DELETED_FLAG = ''0'' ';
            v_insertstring := v_insertstring || '  WHERE PROPERTY_ID = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || '  AND  ITEM_TYPE_ID  = ' || plsql_table_name2 || '(m);  ';
            v_insertstring := v_insertstring || '  ELSIF (UPPER(cz_pb_mgr.v_insert_table_name) = ''CZ_ITEM_PROPERTY_VALUES'') THEN ';
            v_insertstring := v_insertstring || '  UPDATE cz_item_property_values' || cz_pb_mgr.v_db_link || ' t SET   ( PROPERTY_VALUE )= (SELECT PROPERTY_VALUE ';
            v_insertstring := v_insertstring || '  FROM  cz_item_property_values WHERE  PROPERTY_ID = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || '  AND ITEM_ID = ' || plsql_table_name2 || '(m) ) WHERE  t.PROPERTY_ID =  ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || '  AND t.ITEM_ID  = ' || plsql_table_name2 || '(m); ';
            v_insertstring := v_insertstring || '  END IF; END; END LOOP; COMMIT; END; ';

            EXECUTE IMMEDIATE v_insertstring;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               ROLLBACK;
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTINTO', SQLCODE);
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERTION_ERR', 'TABLENAME', table_name, 'SQLERRM', SQLERRM);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTINTO', SQLCODE);
               cz_pb_mgr.v_status_code := cz_pb_mgr.PUBLICATION_ERROR;
               RAISE;
         END;
      END IF;

      COMMIT;
   END insert_item_tables;

/* Procedure to insert dev num val for translateable properties of CZ_PROPERTIES into localized texts*/

PROCEDURE mm_ins_def_num_val_in_intl AS
 l_sql_str varchar2(4000);
 lang_count number;
 BEGIN

  select count(1) into lang_count from fnd_languages where installed_flag in('I','B');

      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(cz_pb_mgr.mm_v_tbl_prop_vals_trans_new.COUNT > 0))
      THEN

      --The mm_intl_text_model_id_ref table contains model_id of intl texts.
      -- mm_intl_text_model_id_ref already resolved in mm_sync_properties (put step) using h_devl_prj_by_intl_text map

      l_sql_str:='BEGIN'
                   || ' '
                   || 'cz_pb_mgr.v_expr_count := 0;'
                   || ' '
                   || 'FOR I IN cz_pb_mgr.mm_v_tbl_prop_vals_trans_new.FIRST .. cz_pb_mgr.mm_v_tbl_prop_vals_trans_new.LAST'
                   || ' '
                   || 'LOOP'
                   || ' INSERT INTO cz_localized_texts'
                   || cz_pb_mgr.v_db_link
                   || '('
                   || ' '
                   || 'intl_text_id,localized_str,ui_def_id,ORIG_SYS_REF,model_id,source_lang,language)'
                   || ' '
                   || 'select cz_pb_mgr.mm_v_tbl_prop_vals_trans_new(i),localized_str,ui_def_id,ORIG_SYS_REF,cz_pb_mgr.mm_intl_text_model_id_ref(i),source_lang,language'
                   || ' '
                   || ' from cz_localized_texts where intl_text_id=cz_pb_mgr.mm_v_tbl_prop_vals_trans_old(i);'
                   || ' '
                   || 'IF ( cz_pb_mgr.v_expr_count > cz_pb_mgr.RECORD_COMMIT_SIZE) THEN'
                   || ' '
                   || 'COMMIT; cz_pb_mgr.v_expr_count := 0;'
                   || ' '
                   || 'END IF;'
                   || ' '
                   || 'cz_pb_mgr.v_expr_count := cz_pb_mgr.v_expr_count +'||lang_count||';'
                   || ' '
                   || 'END LOOP;'
                   || ' '
                   || 'END;';

         EXECUTE IMMEDIATE    l_sql_str;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_TABLE_POPULATION_ERR', 'TABLENAME', 'CZ_LOCALIZED_TEXTS', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:cz_localized_texts', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
 END;


----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_item_schema
   IS
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      rec_count NUMBER;
      tmp_array_count NUMBER;
   BEGIN
--All reading has been moved to load_data->read_item_schema.

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         mm_v_tbl_sync_prop_vals_num.DELETE;
         mm_v_tbl_prop_vals_trans_old.DELETE;
         mm_v_tbl_prop_vals_trans_new.DELETE;
         mm_v_ht_sync_all_prop_val_num.DELETE;
         mm_v_ht_sync_all_prop.DELETE;
         mm_v_tbl_sync_prop_type.DELETE;
         mm_v_tbl_sync_prop_folder.DELETE;
         mm_v_tbl_sync_prop.DELETE;
         mm_v_ht_sync_item_type.DELETE;
         mm_v_ht_sync_item_type_items.DELETE;
         mm_v_ht_sync_items.DELETE;
         mm_v_ht_sync_item_prop.DELETE;
         mm_v_ht_sync_item_type_prop.DELETE;
         mm_v_ht_sync_itmtype_for_prop.DELETE;
         mm_v_ht_sync_it_propval_itm.DELETE;
         mm_v_ht_sync_ps_propval.DELETE;
         mm_v_ht_sync_it_propval.DELETE;
         mm_v_ht_eff_set_tbl_t.DELETE;
         mm_v_ht_eff_set_tbl_s.DELETE;
         mm_v_ht_sync_exist_items.DELETE;
         mm_v_ht_sync_exist_item_types.DELETE; --Bug9180063
         mm_insert_array1.DELETE;
         mm_insert_array2.DELETE;
         mm_source_array1.DELETE;
         mm_source_array2.DELETE;
         mm_objtype_array.DELETE;
         mm_tgtfldr_array.DELETE;

         mm_intl_text_model_id_ref.DELETE;

         mm_sync_properties;
         mm_sync_itemschema;
         mm_migrate_into_ps_prop_vals;
      END IF;

      -- ITEM TYPES
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'item_type_id';

      -- sure if we need to maintain a table for orig_sys_ref, if needed, we need to maintain a sync table
      -- for model migration and then resolve them before updating
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         cz_pb_mgr.mm_insert_array1.DELETE;
         cz_pb_mgr.mm_insert_array2.DELETE;
         cz_pb_mgr.mm_insert_array3.DELETE;
         cz_pb_mgr.mm_source_array1.DELETE;
         cz_pb_mgr.mm_source_array2.DELETE;
         cz_pb_mgr.mm_source_array3.DELETE;
         --get only those that need to be migrated
         mm_resolve_ids(cz_pb_mgr.v_item_types_new_ref
                       ,cz_pb_mgr.mm_v_ht_sync_item_type
                       ,'ITEM TYPES'
                       ,cz_pb_mgr.mm_insert_array1
                       ,cz_pb_mgr.mm_source_array1
                       );
--Bug9619157 . Only the item types not exists in target, needs to be moved to target instance and will
-- have to resolve orig_sys_ref, not ALL the item types for the migrated model.
-- So, we changed to mm_source_array1 from v_item_types_new_ref

         mm_resolve_orig_refs(cz_pb_mgr.mm_source_array1
                             ,cz_pb_mgr.mm_v_ht_item_types_orig_ref
                             ,'ITEM TYPES - ORIG SYS REF'
                             ,cz_pb_mgr.mm_insert_array3
                             ,cz_pb_mgr.mm_source_array3
                             );

      IF ((cz_pb_mgr.v_pb_log_flag = 'YES') OR (cz_pb_mgr.v_status_code = PUBLICATION_ERROR)) THEN

         tmp_array_count := cz_pb_mgr.mm_source_array1.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of item type source array: ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array1.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array1 (item type id): ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array3.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array3 (orig_sys_ref item type ): ' || tmp_array_count);

         mm_dump_array(cz_pb_mgr.mm_source_array1, 'ITEM TYPE SOURCE');
         mm_dump_array(cz_pb_mgr.mm_insert_array1, 'ITEM TYPE INSERT');
         mm_dump_osr_array(cz_pb_mgr.mm_insert_array3, 'ITEM TYPE ORIG_SYS_REF INSERT');

      END IF;

         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array1';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'orig_sys_ref';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array3';
         insert_into_item_tables('cz_item_types'
                                ,'item_type_id'
                                ,cz_pb_mgr.v_db_link
                                ,plsql_table_list
                                ,'cz_pb_mgr.mm_source_array1'
                                ,cz_pb_mgr.mm_source_array1
                                );
 --todo Bug9180063 Update the Non BOM item types, that have orig_sys_ref = 'NULL'
        BEGIN
           IF (cz_pb_mgr.mm_insert_array1.COUNT > 0)
           THEN
             EXECUTE IMMEDIATE    'BEGIN'
                       || ' '
                       || 'FOR I IN cz_pb_mgr.mm_insert_array1.FIRST..cz_pb_mgr.mm_insert_array1.LAST'
                       || ' '
                       || 'LOOP'
                       || ' '
                       || 'UPDATE cz_item_types'
                       || cz_pb_mgr.v_db_link
                       || '  t'
                       || ' '
                       || 'SET   t.orig_sys_ref = NULL'
                       || ' '
                       || 'WHERE  t.item_type_id = cz_pb_mgr.mm_insert_array1(i)'
                       || ' '
                       || 'AND   t.orig_sys_ref = ''NULL'';'
                       || ' '
                       || 'END LOOP;'
                       || ' '
                       || 'END;';
             COMMIT;
           END IF;
        END;
      ELSE
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_item_types_new_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'orig_sys_ref';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_item_types_orig_ref';
         insert_into_item_tables('cz_item_types'
                                ,'item_type_id'
                                ,cz_pb_mgr.v_db_link
                                ,plsql_table_list
                                ,'cz_pb_mgr.v_item_types_new_ref'
                                ,cz_pb_mgr.v_item_types_new_ref
                                );
      END IF;

      --ITEMS
      plsql_table_list.DELETE;
      rec_count := 1;

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         cz_pb_mgr.mm_insert_array1.DELETE;
         cz_pb_mgr.mm_insert_array2.DELETE;
         cz_pb_mgr.mm_insert_array3.DELETE;
         cz_pb_mgr.mm_source_array1.DELETE;
         cz_pb_mgr.mm_source_array2.DELETE;
         cz_pb_mgr.mm_source_array3.DELETE;

         mm_resolve_ids(cz_pb_mgr.v_item_masters_tbl
                       ,cz_pb_mgr.mm_v_ht_sync_items
                       ,'ITEMS - ITEM ARRAY'
                       ,cz_pb_mgr.mm_insert_array1
                       ,cz_pb_mgr.mm_source_array1
                       );

--Bug9619157 : Changed the array for the same reason as stated for item types.
-- Source array (mm_source_array1) can be shorter than v_item_masters_tbl because ht_sync_items only contains NEW items
-- means items to create on target

         mm_resolve_ids(cz_pb_mgr.mm_source_array1
                       ,cz_pb_mgr.mm_v_ht_sync_item_type_items
                       ,'ITEMS - ITEM TYPE ARRAY'
                       ,cz_pb_mgr.mm_insert_array2
                       ,cz_pb_mgr.mm_source_array2
                       );

--Bug9619157 : Changed the array for the same reason as stated for item types.
         mm_resolve_orig_refs(cz_pb_mgr.mm_source_array1
                             ,cz_pb_mgr.mm_v_ht_items_orig_ref
                             ,'ITEMS - ORIG SYS REF'
                             ,cz_pb_mgr.mm_insert_array3
                             ,cz_pb_mgr.mm_source_array3
                             );
         plsql_table_list(rec_count).col_name := 'item_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array1';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'item_type_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array2';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'orig_sys_ref';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array3';


      IF ((cz_pb_mgr.v_pb_log_flag = 'YES') OR (cz_pb_mgr.v_status_code = PUBLICATION_ERROR)) THEN

         tmp_array_count := cz_pb_mgr.mm_source_array1.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of source array: ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array1.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array1 (item_id): ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array2.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array2 (item_type): ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array3.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array3 (orig_sys_ref): ' || tmp_array_count);

         mm_dump_array(cz_pb_mgr.mm_source_array1, 'ITEM SOURCE');
         mm_dump_array(cz_pb_mgr.mm_insert_array1, 'ITEM INSERT');
         mm_dump_array(cz_pb_mgr.mm_insert_array2, 'ITEM TYPE INSERT');
         mm_dump_osr_array(cz_pb_mgr.mm_insert_array3, 'ITEM ORIG_SYS_REF INSERT');

      END IF;

         insert_into_item_tables('cz_item_masters'
                                ,'item_id'
                                ,cz_pb_mgr.v_db_link
                                ,plsql_table_list
                                ,'cz_pb_mgr.mm_source_array1'
                                ,cz_pb_mgr.mm_source_array1
                                );
      ELSE
         plsql_table_list(rec_count).col_name := 'item_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_item_masters_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'item_type_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_item_types_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'orig_sys_ref';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_items_orig_ref';
         insert_into_item_tables('cz_item_masters'
                                ,'item_id'
                                ,cz_pb_mgr.v_db_link
                                ,plsql_table_list
                                ,'cz_pb_mgr.v_item_masters_tbl'
                                ,cz_pb_mgr.v_item_masters_tbl
                                );
      END IF;

      --PROPERTIES (with RP_ENTRIES if model migration)
      plsql_table_list.DELETE;
      rec_count := 1;

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         cz_pb_mgr.mm_insert_array1.DELETE;
         cz_pb_mgr.mm_insert_array2.DELETE;
         cz_pb_mgr.mm_objtype_array.DELETE;
         cz_pb_mgr.mm_tgtfldr_array.DELETE;
         cz_pb_mgr.mm_source_array1.DELETE;
         cz_pb_mgr.mm_source_array2.DELETE;

--insert into localized texts:ids which belong to  translateable props
         mm_ins_def_num_val_in_intl;

         mm_resolve_ids_w_rp_entries(cz_pb_mgr.v_remote_prop_ref
                                    ,cz_pb_mgr.mm_v_tbl_sync_prop
                                    ,'PRP'
                                    ,g_migration_tgt_folder_id
                                    ,'PROPERTIES - PROPERTIES AND RP ENTRIES'
                                    ,mm_insert_array1
                                    ,mm_objtype_array
                                    ,mm_tgtfldr_array
                                    ,mm_source_array1
                                    );

         --The array cz_pb_mgr.mm_v_tbl_sync_prop_vals_num is a hash table, containing numeric default values,
         --hashed by target property_id, so we cannot use it directly in the following block. We need to construct a
         --new array that will be in synch with mm_insert_array1. Also, it should be global to be used inside the
         --insert_into_item_tables procedure.

         FOR i IN 1..cz_pb_mgr.mm_insert_array1.COUNT LOOP

            cz_pb_mgr.mm_insert_array2(i) := cz_pb_mgr.mm_v_tbl_sync_prop_vals_num(cz_pb_mgr.mm_insert_array1(i));
         END LOOP;

         plsql_table_list(rec_count).col_name := 'property_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array1';
         rec_count:=rec_count+1;

         plsql_table_list(rec_count).col_name := 'def_num_value';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array2';

         insert_into_item_tables('cz_properties'
                                ,'property_id'
                                ,cz_pb_mgr.v_db_link
                                ,plsql_table_list
                                ,'cz_pb_mgr.mm_source_array1'
                                ,cz_pb_mgr.mm_source_array1
                                );

         --insert rp entries as well
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'object_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array1';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'object_type';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_objtype_array';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'enclosing_folder';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_tgtfldr_array';
         insert_into_rp_entries('cz_rp_entries'
                               ,'object_id'
                               ,'object_type'
                               ,cz_pb_mgr.v_db_link
                               ,plsql_table_list
                               ,'cz_pb_mgr.mm_source_array1'
                               ,'cz_pb_mgr.mm_objtype_array'
                               ,cz_pb_mgr.mm_source_array1
                               ,cz_pb_mgr.mm_objtype_array
                               );
      ELSE
         plsql_table_list(rec_count).col_name := 'property_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_remote_prop_ref';
         insert_into_item_tables('cz_properties'
                                ,'property_id'
                                ,cz_pb_mgr.v_db_link
                                ,plsql_table_list
                                ,'cz_pb_mgr.v_remote_prop_ref'
                                ,cz_pb_mgr.v_remote_prop_ref
                                );
      END IF;

      --ITEM TYPE PROPERTIES
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         cz_pb_mgr.mm_insert_array1.DELETE;
         cz_pb_mgr.mm_insert_array2.DELETE;
         cz_pb_mgr.mm_insert_array3.DELETE;
         cz_pb_mgr.mm_objtype_array.DELETE;
         cz_pb_mgr.mm_tgtfldr_array.DELETE;
         cz_pb_mgr.mm_source_array1.DELETE;
         cz_pb_mgr.mm_source_array2.DELETE;
         cz_pb_mgr.mm_source_array3.DELETE;
         mm_resolve_ids(cz_pb_mgr.v_item_prop_id_tbl
                       ,cz_pb_mgr.mm_v_ht_sync_item_type_prop
                       ,'ITEM TYPE PROPERTIES - PROP'
                       ,cz_pb_mgr.mm_insert_array1
                       ,cz_pb_mgr.mm_source_array1
                       );
         mm_resolve_ids(cz_pb_mgr.v_item_prop_type_tbl
                       ,cz_pb_mgr.mm_v_ht_sync_itmtype_for_prop
                       ,'ITEM TYPE PROPERTIES - ITEM TYPE'
                       ,cz_pb_mgr.mm_insert_array2
                       ,cz_pb_mgr.mm_source_array2
                       );
         mm_resolve_orig_refs(cz_pb_mgr.v_src_type_prop_orig_tbl
                             ,cz_pb_mgr.mm_v_ht_item_typ_prop_orig_ref
                             ,'ITEM TYPE PROPERTIES - ORIG SYS REF'
                             ,cz_pb_mgr.mm_insert_array3
                             ,cz_pb_mgr.mm_source_array3
                             );

      IF ((cz_pb_mgr.v_pb_log_flag = 'YES') OR (cz_pb_mgr.v_status_code = PUBLICATION_ERROR)) THEN

         tmp_array_count := cz_pb_mgr.mm_source_array1.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of item type prop source array: ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array1.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array1 (item type prop id): ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array2.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array2(item type): ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array3.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array3 (item type prop orig_sys_ref): ' || tmp_array_count);

         mm_dump_array(cz_pb_mgr.mm_source_array1, 'ITEM TYPE PROP SOURCE');
         mm_dump_array(cz_pb_mgr.mm_insert_array1, 'ITEM TYPE PROP INSERT');
         mm_dump_array(cz_pb_mgr.mm_insert_array2, 'ITEM TYPE PROP ITEM TYPE INSERT');
         mm_dump_osr_array(cz_pb_mgr.mm_insert_array3, 'ITEM TYPE PROP ORIG_SYS_REF INSERT');

      END IF;

         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'property_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array1';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'item_type_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array2';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'orig_sys_ref';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array3';
         insert_item_tables('cz_item_type_properties'
                           ,'property_id'
                           ,'item_type_id'
                           ,cz_pb_mgr.v_db_link
                           ,plsql_table_list
                           ,'cz_pb_mgr.mm_source_array1'
                           ,'cz_pb_mgr.mm_source_array2'
                           ,cz_pb_mgr.mm_source_array1
                           ,cz_pb_mgr.mm_source_array2
                           );
 --todo Bug9180063 Update the Non BOM item type properties, that have orig_sys_ref = 'NULL'
 -- there is no need to have any exception block as the calling procedure will take care of this.
         BEGIN
           IF (cz_pb_mgr.mm_insert_array2.COUNT > 0)
           THEN
             EXECUTE IMMEDIATE    'BEGIN'
                       || ' '
                       || 'FOR I IN cz_pb_mgr.mm_insert_array2.FIRST..cz_pb_mgr.mm_insert_array2.LAST'
                       || ' '
                       || 'LOOP'
                       || ' '
                       || 'UPDATE cz_item_type_properties'
                       || cz_pb_mgr.v_db_link
                       || '  t'
                       || ' '
                       || 'SET   t.orig_sys_ref = NULL'
                       || ' '
                       || 'WHERE  t.item_type_id = cz_pb_mgr.mm_insert_array2(i)'
                       || ' '
                       || 'AND   t.orig_sys_ref = ''NULL'';'
                       || ' '
                       || 'END LOOP;'
                       || ' '
                       || 'END;';
             COMMIT;
           END IF;
        END;
      END IF;

      --ITEM  PROPERTY VALUES
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         cz_pb_mgr.mm_insert_array1.DELETE;
         cz_pb_mgr.mm_insert_array2.DELETE;
         cz_pb_mgr.mm_insert_array3.DELETE;
         cz_pb_mgr.mm_objtype_array.DELETE;
         cz_pb_mgr.mm_tgtfldr_array.DELETE;
         cz_pb_mgr.mm_source_array1.DELETE;
         cz_pb_mgr.mm_source_array2.DELETE;
         cz_pb_mgr.mm_source_array3.DELETE;
         mm_resolve_ids(cz_pb_mgr.v_it_prop_vals_id_tbl
                       ,cz_pb_mgr.mm_v_ht_sync_it_propval
                       ,'IT PROP VAL- PROPERTIES'
                       ,cz_pb_mgr.mm_insert_array1
                       ,cz_pb_mgr.mm_source_array1
                       );
         mm_resolve_ids(cz_pb_mgr.v_it_prop_vals_item_tbl
                       ,cz_pb_mgr.mm_v_ht_sync_it_propval_itm
                       ,'IT PROP VALS - ITEMS'
                       ,cz_pb_mgr.mm_insert_array2
                       ,cz_pb_mgr.mm_source_array2
                       );
         mm_resolve_orig_refs(cz_pb_mgr.v_src_prop_val_orig_tbl
                             ,cz_pb_mgr.mm_v_ht_item_prop_val_orig_ref
                             ,'IT PROP VAL - ORIG SYS REF'
                             ,cz_pb_mgr.mm_insert_array3
                             ,cz_pb_mgr.mm_source_array3
                             );

      IF ((cz_pb_mgr.v_pb_log_flag = 'YES') OR (cz_pb_mgr.v_status_code = PUBLICATION_ERROR)) THEN

         tmp_array_count := cz_pb_mgr.mm_source_array1.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of item prop val source array: ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array1.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array1 (item prop val prop id): ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array2.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array2(item prop val item id): ' || tmp_array_count);

         tmp_array_count := cz_pb_mgr.mm_insert_array3.COUNT;

         INSERT INTO cz_db_logs (logtime, loguser, message) VALUES
           (Sysdate, 'CZ_PB_MGR.INSERT_ITEM_SCHEMA', 'Length of insert array3 (item prop val orig_sys_ref): ' || tmp_array_count);

         mm_dump_array(cz_pb_mgr.mm_source_array1, 'ITEM PROP VAL SOURCE');
         mm_dump_array(cz_pb_mgr.mm_insert_array1, 'ITEM PROP VAL INSERT');
         mm_dump_array(cz_pb_mgr.mm_insert_array2, 'ITEM PROP VAL ITEM ID INSERT');
         mm_dump_osr_array(cz_pb_mgr.mm_insert_array3, 'ITEM PROP VAL ORIG_SYS_REF INSERT');

      END IF;

         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'property_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array1';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'item_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array2';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'orig_sys_ref';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_insert_array3';
         insert_item_tables('cz_item_property_values'
                           ,'property_id'
                           ,'item_id'
                           ,cz_pb_mgr.v_db_link
                           ,plsql_table_list
                           ,'cz_pb_mgr.mm_source_array1'
                           ,'cz_pb_mgr.mm_source_array2'
                           ,cz_pb_mgr.mm_source_array1
                           ,cz_pb_mgr.mm_source_array2
                           );
 --todo Bug9180063 Update the Non BOM item  property values, that have orig_sys_ref = 'NULL'
        BEGIN
           IF (cz_pb_mgr.mm_insert_array2.COUNT > 0)
           THEN
             EXECUTE IMMEDIATE    'BEGIN'
                       || ' '
                       || 'FOR I IN cz_pb_mgr.mm_insert_array2.FIRST..cz_pb_mgr.mm_insert_array2.LAST'
                       || ' '
                       || 'LOOP'
                       || ' '
                       || 'UPDATE cz_item_property_values'
                       || cz_pb_mgr.v_db_link
                       || '  t'
                       || ' '
                       || 'SET   t.orig_sys_ref = NULL'
                       || ' '
                       || 'WHERE  t.item_id = cz_pb_mgr.mm_insert_array2(i)'
                       || ' '
                       || 'AND   t.orig_sys_ref = ''NULL'';'
                       || ' '
                       || 'END LOOP;'
                       || ' '
                       || 'END;';
             COMMIT;
           END IF;
        END;
      END IF;
   END insert_item_schema;
----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_into_rp_entries(
      table_name IN VARCHAR2
     ,primary_key1 IN VARCHAR2
     ,primary_key2 IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name1 IN VARCHAR2
     ,plsql_table_name2 IN VARCHAR2
     ,primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table2 IN OUT NOCOPY cz_pb_mgr.varchar_tbl_type_3
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(primary_key_plsql_table1.COUNT > 0))
      THEN
         v_db_link := UPPER(LTRIM(RTRIM(db_link)));
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table1.FIRST || '..' || primary_key_plsql_table1.LAST || '  LOOP ';
            v_insertstring := v_insertstring || ' insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring :=
                    v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key1 || ' = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key2 || '=' || plsql_table_name2 || '(m) ';
            v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;  END LOOP; COMMIT; ';
            v_insertstring :=
                  v_insertstring
               || '  EXCEPTION WHEN OTHERS THEN '
               || ' '
               || 'cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT(''CZ_PB_INSERTION_ERR'', ''TABLENAME'', cz_pb_mgr.v_insert_table_name,''SQLERRM'',SQLERRM);'
               || ' '
               || 'ROLLBACK; insert into cz_db_logs (message, message_id,run_id,caller) values(cz_pb_mgr.v_err_message, cz_pb_mgr.v_publication_id, cz_pb_mgr.v_pb_run_id, ''INSERTINTOTABLE'');'
               || ' '
               || 'COMMIT; cz_pb_mgr.v_status_code := ''ERR''; RAISE; END; ';

            EXECUTE IMMEDIATE v_insertstring;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               ROLLBACK;
               RAISE;
         END;
      END IF;

      COMMIT;
   END;

----------------------------------------------------

   ------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_into_table(
      table_name IN VARCHAR2
     ,primary_key1 IN VARCHAR2
     ,primary_key2 IN VARCHAR2
     ,primary_key3 IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name1 IN VARCHAR2
     ,plsql_table_name2 IN VARCHAR2
     ,plsql_table_name3 IN VARCHAR2
     ,primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table2 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table3 IN OUT NOCOPY cz_pb_mgr.varchar_type_tbl
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(primary_key_plsql_table1.COUNT > 0))
      THEN
         v_db_link := UPPER(LTRIM(RTRIM(db_link)));
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table1.FIRST || '..' || primary_key_plsql_table1.LAST || '  LOOP BEGIN ';
            v_insertstring := v_insertstring || ' insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring :=
                    v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key1 || ' = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key2 || '=' || plsql_table_name2 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key3 || '=' || plsql_table_name3 || '(m) ';
            v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;  EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; END; END LOOP; COMMIT; ';
            v_insertstring :=
                  v_insertstring
               || '  EXCEPTION WHEN OTHERS THEN'
               || ' '
               || 'cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT(''CZ_PB_INSERTION_ERR'', ''TABLENAME'', cz_pb_mgr.v_insert_table_name,''SQLERRM'',SQLERRM);'
               || ' '
               || 'ROLLBACK; insert into cz_db_logs (message, message_id,run_id,caller) values(cz_pb_mgr.v_err_message, cz_pb_mgr.v_publication_id, cz_pb_mgr.v_pb_run_id, ''INSERTINTOTABLE'');'
               || ' '
               || 'COMMIT; cz_pb_mgr.v_status_code := ''ERR''; RAISE; END; ';

            EXECUTE IMMEDIATE v_insertstring;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               ROLLBACK;
               RAISE;
         END;
      END IF;

      COMMIT;
   END;

-------------------------------------------------------------------------
   PROCEDURE insert_into_table(
      table_name IN VARCHAR2
     ,primary_key1 IN VARCHAR2
     ,primary_key2 IN VARCHAR2
     ,primary_key3 IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name1 IN VARCHAR2
     ,plsql_table_name2 IN VARCHAR2
     ,plsql_table_name3 IN VARCHAR2
     ,primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table2 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table3 IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(primary_key_plsql_table1.COUNT > 0))
      THEN
         v_db_link := UPPER(LTRIM(RTRIM(db_link)));
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table1.FIRST || '..' || primary_key_plsql_table1.LAST || '  LOOP BEGIN ';
            v_insertstring := v_insertstring || ' insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring :=
                    v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key1 || ' = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key2 || '=' || plsql_table_name2 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key3 || '=' || plsql_table_name3 || '(m) ';
            v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF; EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; END;   END LOOP; COMMIT; ';
            v_insertstring :=
                  v_insertstring
               || '  EXCEPTION WHEN OTHERS THEN'
               || ' '
               || 'cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT(''CZ_PB_INSERTION_ERR'', ''TABLENAME'', cz_pb_mgr.v_insert_table_name,''SQLERRM'',SQLERRM);'
               || ' '
               || 'ROLLBACK; insert into cz_db_logs (message, message_id,run_id,caller) values(cz_pb_mgr.v_err_message, cz_pb_mgr.v_publication_id, cz_pb_mgr.v_pb_run_id, ''INSERTINTOTABLE'');'
               || ' '
               || 'COMMIT; cz_pb_mgr.v_status_code := ''ERR''; RAISE; END; ';

            EXECUTE IMMEDIATE v_insertstring;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               cz_pb_mgr.v_err_message := 'Insert into cz ui page refs: ' || SQLERRM;
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZUIPAGEREFS', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               RAISE;
         END;
      END IF;

      COMMIT;
   END;

------------------------------------------------------------
   PROCEDURE insert_into_table(
      table_name IN VARCHAR2
     ,primary_key1 IN VARCHAR2
     ,primary_key2 IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name1 IN VARCHAR2
     ,plsql_table_name2 IN VARCHAR2
     ,primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table2 IN OUT NOCOPY cz_pb_mgr.objtype
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(primary_key_plsql_table1.COUNT > 0))
      THEN
         v_db_link := UPPER(LTRIM(RTRIM(db_link)));
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table1.FIRST || '..' || primary_key_plsql_table1.LAST || '  LOOP BEGIN ';
            v_insertstring := v_insertstring || ' insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring :=
                    v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key1 || ' = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key2 || '=' || plsql_table_name2 || '(m) ';
            v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;  EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; END; END LOOP; COMMIT; ';
            v_insertstring :=
                  v_insertstring
               || '  EXCEPTION WHEN OTHERS THEN '
               || ' '
               || 'cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT(''CZ_PB_INSERTION_ERR'', ''TABLENAME'', cz_pb_mgr.v_insert_table_name,''SQLERRM'',SQLERRM);'
               || ' '
               || 'ROLLBACK; insert into cz_db_logs (message, message_id,run_id,caller) values(cz_pb_mgr.v_err_message, cz_pb_mgr.v_publication_id, cz_pb_mgr.v_pb_run_id, ''INSERTINTOTABLE'');'
               || ' '
               || 'COMMIT; cz_pb_mgr.v_status_code := ''ERR''; RAISE; END; ';

            EXECUTE IMMEDIATE v_insertstring;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               ROLLBACK;
               RAISE;
         END;
      END IF;

      COMMIT;
   END;

---------------------------------------------------------------------------------
   PROCEDURE insert_into_table(
      table_name IN VARCHAR2
     ,primary_key1 IN VARCHAR2
     ,primary_key2 IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name1 IN VARCHAR2
     ,plsql_table_name2 IN VARCHAR2
     ,primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table2 IN OUT NOCOPY cz_pb_mgr.varchar_tbl_type
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(primary_key_plsql_table1.COUNT > 0))
      THEN
         v_db_link := UPPER(LTRIM(RTRIM(db_link)));
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table1.FIRST || '..' || primary_key_plsql_table1.LAST || '  LOOP BEGIN ';
            v_insertstring := v_insertstring || ' insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring :=
                    v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key1 || ' = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key2 || '=' || plsql_table_name2 || '(m) ';
            v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF; EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; END;  END LOOP; COMMIT; ';
            v_insertstring :=
                  v_insertstring
               || '  EXCEPTION WHEN OTHERS THEN '
               || ' '
               || 'cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT(''CZ_PB_INSERTION_ERR'', ''TABLENAME'', cz_pb_mgr.v_insert_table_name,''SQLERRM'',SQLERRM);'
               || ' '
               || 'ROLLBACK; insert into cz_db_logs (message, message_id,run_id,caller) values(cz_pb_mgr.v_err_message, cz_pb_mgr.v_publication_id, cz_pb_mgr.v_pb_run_id, ''INSERTINTOTABLE'');'
               || ' '
               || 'COMMIT; cz_pb_mgr.v_status_code := ''ERR''; RAISE; END; ';

            EXECUTE IMMEDIATE v_insertstring;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               ROLLBACK;
               RAISE;
         END;
      END IF;

      COMMIT;
   END;

----------------------------------------------------
   PROCEDURE insert_into_table(
      table_name IN VARCHAR2
     ,primary_key1 IN VARCHAR2
     ,primary_key2 IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name1 IN VARCHAR2
     ,plsql_table_name2 IN VARCHAR2
     ,primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref
     ,primary_key_plsql_table2 IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(primary_key_plsql_table1.COUNT > 0))
      THEN
         v_db_link := UPPER(LTRIM(RTRIM(db_link)));
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table1.FIRST || '..' || primary_key_plsql_table1.LAST || ' LOOP BEGIN ';
            v_insertstring := v_insertstring || ' insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring :=
                    v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key1 || ' = ' || plsql_table_name1 || '(m) ';
            v_insertstring := v_insertstring || ' AND ' || table_name || '.' || primary_key2 || '=' || plsql_table_name2 || '(m) ';
            v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF; EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; END; END LOOP; COMMIT; ';
            v_insertstring :=
                  v_insertstring
               || '  EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; WHEN OTHERS THEN'
               || ' '
               || 'cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT(''CZ_PB_INSERTION_ERR'', ''TABLENAME'', cz_pb_mgr.v_insert_table_name,''SQLERRM'',SQLERRM);'
               || ' '
               || 'ROLLBACK; insert into cz_db_logs (message, message_id,run_id,caller) values(cz_pb_mgr.v_err_message, cz_pb_mgr.v_publication_id, cz_pb_mgr.v_pb_run_id, ''INSERTINTOTABLE'');'
               || ' '
               || 'COMMIT; cz_pb_mgr.v_status_code := ''ERR''; RAISE; END; ';

            EXECUTE IMMEDIATE v_insertstring;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               ROLLBACK;
               cz_pb_mgr.v_err_message := 'Insert into ' || table_name || ': ' || SQLERRM;
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, table_name, SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               RAISE;
         END;
      END IF;

      COMMIT;
   END;

-----------------------------------------------------
-------procedure that inserts the records into target db
-------of the table referred by the table_name
   PROCEDURE insert_into_table(
      table_name IN VARCHAR2
     ,primary_key IN VARCHAR2
     ,db_link IN VARCHAR2
     ,plsql_table_list IN cz_pb_mgr.col_plsql_table_list
     ,plsql_table_name IN VARCHAR2
     ,primary_key_plsql_table IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   AS
      v_cursor NUMBER;
      v_numrows NUMBER;
      v_insertstring VARCHAR2(10000);
      current_column VARCHAR2(128);
      v_db_link VARCHAR2(128);
      v_last NUMBER;

      CURSOR col_name_cur(par_table_name VARCHAR2)
      IS
         SELECT column_name
                    FROM all_tab_columns
                   WHERE table_name = UPPER(LTRIM(RTRIM(par_table_name))) AND owner = 'CZ';

      TYPE col_name_table IS TABLE OF all_tab_columns.column_name%TYPE
         INDEX BY BINARY_INTEGER;

      col_list col_name_table;
      i BINARY_INTEGER := 1;
      match_found BOOLEAN;
   BEGIN

      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(primary_key_plsql_table.COUNT > 0))
      THEN
         v_db_link := UPPER(LTRIM(RTRIM(db_link)));
         cz_pb_mgr.v_insert_table_name := table_name;

         BEGIN
            v_insertstring := 'BEGIN FOR  M IN ' || primary_key_plsql_table.FIRST || '..' || primary_key_plsql_table.LAST || '  LOOP BEGIN ';
            v_insertstring := v_insertstring || ' insert into ' || table_name || v_db_link || ' (';

            OPEN col_name_cur(table_name);

            LOOP
               FETCH col_name_cur
                INTO current_column;

               EXIT WHEN col_name_cur%NOTFOUND;
               col_list(i) := LTRIM(RTRIM(current_column));
               i := i + 1;
               v_insertstring := v_insertstring || current_column || ',';
            END LOOP;

            CLOSE col_name_cur;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ')';
            v_insertstring := v_insertstring || '  select  ';

            IF (col_list.COUNT > 0)
            THEN
               FOR j IN col_list.FIRST .. col_list.LAST
               LOOP
                  match_found := FALSE;

                  IF (plsql_table_list.COUNT > 0)
                  THEN
                     FOR k IN plsql_table_list.FIRST .. plsql_table_list.LAST
                     LOOP
                        IF (UPPER(col_list(j)) = UPPER(plsql_table_list(k).col_name))
                        THEN
                           v_insertstring := v_insertstring || plsql_table_list(k).table_name || '(m),';
                           match_found := TRUE;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;

                  IF (NOT match_found)
                  THEN
                     v_insertstring := v_insertstring || col_list(j) || ',';
                  END IF;
               END LOOP;
            END IF;

            v_insertstring := RTRIM(v_insertstring, ',');
            v_insertstring := v_insertstring || ' FROM ' || table_name || ' WHERE ' || table_name || '.' || primary_key || ' = ' || plsql_table_name || '(m) ';
--SKM -- Added check for Single Publication Langiage
            IF (vPubSingleLang IS NOT NULL AND table_name = 'cz_localized_texts') THEN
                 v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' AND LANGUAGE = '''||vPubSingleLang||''' ';
            ELSE
                 v_insertstring := v_insertstring || ' AND deleted_flag = ''0'' ';
            END IF;
            v_insertstring := v_insertstring || ' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;  EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; END; END LOOP; COMMIT; ';
            v_insertstring :=
                  v_insertstring
               || '  EXCEPTION WHEN OTHERS THEN '
               || ' '
               || 'cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT(''CZ_PB_INSERTION_ERR'', ''TABLENAME'', cz_pb_mgr.v_insert_table_name,''SQLERRM'',SQLERRM);'
               || ' '
               || 'ROLLBACK; insert into cz_db_logs (message, message_id,run_id,caller) values(cz_pb_mgr.v_err_message, cz_pb_mgr.v_publication_id, cz_pb_mgr.v_pb_run_id, ''INSERTINTOTABLE'');'
               || ' '
               || 'COMMIT; cz_pb_mgr.v_status_code := ''ERR''; RAISE; END; ';

            EXECUTE IMMEDIATE v_insertstring;
            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               ROLLBACK;
               RAISE;
         END;
      END IF;
      COMMIT;
   END;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that insert intl texts into cz_localized_texts
-- set persistent_intl_text_id with new intl_text_id if texts are from templates
-- and if the session is model migration. Note local model migration (via model
-- conversion) does not copy any template
   PROCEDURE insert_intl_texts(p_intl_text_id_ref IN cz_pb_mgr.t_ref, p_intl_text IN VARCHAR2,
                               p_from_template IN BOOLEAN DEFAULT FALSE)
   IS
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      v_cz_intl_text_new_tbl cz_pb_mgr.t_ref;
      v_cz_intl_text_old_tbl cz_pb_mgr.t_ref;
      l_ui_def_id_tbl cz_pb_mgr.t_ref;
      l_model_id_tbl cz_pb_mgr.t_ref;
      rec_count PLS_INTEGER := 0;
   BEGIN
      IF (p_intl_text_id_ref.COUNT > 0)
      THEN
         cz_pb_mgr.v_cz_intl_text_new_ref.DELETE;
         cz_pb_mgr.v_cz_intl_text_old_ref.DELETE;
         cz_pb_mgr.v_intl_text_model_tbl.DELETE;
         cz_pb_mgr.v_intl_text_ui_tbl.DELETE;

         FOR c IN p_intl_text_id_ref.FIRST .. p_intl_text_id_ref.LAST
         LOOP
            IF (p_intl_text_id_ref(c) IS NOT NULL)
            THEN
               v_cz_intl_text_new_tbl.DELETE;
               v_cz_intl_text_old_tbl.DELETE;
               l_ui_def_id_tbl.DELETE;
               l_model_id_tbl.DELETE;

               BEGIN
                  SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_intl_texts_seq
                                                    , 'cz_intl_texts_s.nextval' || cz_pb_mgr.v_db_link
                                                    ,cz_pb_mgr.v_oraclesequenceincr
                                                    )
                        ,intl_text_id, DECODE(ui_def_id, -1, NULL, ui_def_id), NVL(model_id, -1)
                  BULK COLLECT INTO v_cz_intl_text_new_tbl
                        ,v_cz_intl_text_old_tbl, l_ui_def_id_tbl, l_model_id_tbl
                    FROM cz_intl_texts
                   WHERE intl_text_id = p_intl_text_id_ref(c) AND deleted_flag = '0' AND NVL(seeded_flag, '0') = '0';
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := SUBSTR(SQLERRM, 1, 2000);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTINTLBULK', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_intl_texts', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTINTLBULK', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               END;

               rec_count := cz_pb_mgr.v_cz_intl_text_new_ref.COUNT;

               IF (v_cz_intl_text_new_tbl.COUNT > 0)
               THEN
                  FOR k IN v_cz_intl_text_new_tbl.FIRST .. v_cz_intl_text_new_tbl.LAST
                  LOOP

                     --Bug #5441580. This is the case of translatable properties, the original values will
                     --have model_id = 0, we need to redefine them to the target model's model_id.

                     IF(p_intl_text = 'prop num value of cz prop vals')THEN

                       l_model_id_tbl(k) := cz_pb_mgr.h_devl_prj_by_intl_text(v_cz_intl_text_old_tbl(k));
                     END IF;

                     IF (v_cz_intl_text_old_tbl(k) IS NOT NULL)
                     THEN
                        rec_count := rec_count + 1;
                        cz_pb_mgr.v_cz_intl_text_new_ref(rec_count) := v_cz_intl_text_new_tbl(k);
                        cz_pb_mgr.v_cz_intl_text_old_ref(rec_count) := v_cz_intl_text_old_tbl(k);
                        cz_pb_mgr.v_intl_text_model_tbl(rec_count) := l_model_id_tbl(k);
                        cz_pb_mgr.v_intl_text_ui_tbl(rec_count) := l_ui_def_id_tbl(k);
                        cz_pb_mgr.v_cz_intl_text_idx_ref(v_cz_intl_text_old_tbl(k)):=v_cz_intl_text_new_tbl(k);
                     END IF;
                  END LOOP;
               END IF;
            END IF;
         END LOOP;

         IF p_intl_text <> 'prop num value of cz prop vals' THEN
           resolve_ids(cz_pb_mgr.v_intl_text_model_tbl, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'model id of cz intl texts');
         END IF;
         resolve_ids(cz_pb_mgr.v_intl_text_ui_tbl, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def id of cz intl texts');

         IF (cz_pb_mgr.v_cz_intl_text_new_ref.COUNT > 0)
         THEN
            --------populate plsql_table_list for intl texts
            plsql_table_list.DELETE;
            rec_count := 1;
            plsql_table_list(rec_count).col_name := 'intl_text_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_intl_text_new_ref';
            rec_count := rec_count + 1;

            IF (p_from_template AND CZ_PB_MGR.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
              plsql_table_list(rec_count).col_name   := 'persistent_intl_text_id';
              plsql_table_list(rec_count).table_name := 'CZ_PB_MGR.v_cz_intl_text_new_ref';
              rec_count := rec_count + 1;
            END IF;

            plsql_table_list(rec_count).col_name := 'model_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_intl_text_model_tbl';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'ui_def_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_intl_text_ui_tbl';
            -----------insert into cz_localized_texts
            insert_into_table('cz_localized_texts'
                             ,'intl_text_id'
                             ,cz_pb_mgr.v_db_link
                             ,plsql_table_list
                             ,'cz_pb_mgr.v_cz_intl_text_old_ref'
                             ,cz_pb_mgr.v_cz_intl_text_old_ref
                             );
           IF (CZ_PB_MGR.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
            update_mm_localized_texts;
           ELSE
            update_localized_texts;
           END IF;
            cz_pb_mgr.v_cz_intl_text_new_ref.DELETE;
            cz_pb_mgr.v_cz_intl_text_old_ref.DELETE;
            v_cz_intl_text_new_tbl.DELETE;
            v_cz_intl_text_old_tbl.DELETE;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Insert into intl texts for: ' || p_intl_text || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTINTLTEXTS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END insert_intl_texts;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE refresh_ui_actions(p_global_tmpl_tbl cz_pb_mgr.t_ref)
   IS
      l_update_str VARCHAR2(2000);
   BEGIN
      IF (cz_pb_mgr.g_ui_actns_ui_uidef_old_ref.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.g_ui_actns_ui_uidef_old_ref.FIRST .. cz_pb_mgr.g_ui_actns_ui_uidef_old_ref.LAST
         LOOP
            IF (cz_pb_mgr.g_ui_actns_ui_uidef_old_ref(i) = 0)
            THEN
               l_update_str :=
                     'UPDATE cz_ui_actions'
                  || cz_pb_mgr.v_db_link
                  || '  t'
                  || ' '
                  || 'SET    (CONTEXT_COMPONENT_ID,RENDER_CONDITION_ID,UI_ACTION_TYPE,'
                  || ' '
                  || 'TARGET_UI_DEF_ID,CX_COMMAND_NAME,WINDOW_PARAMETERS,'
                  || ' '
                  || 'TARGET_WINDOW_TYPE,TARGET_WINDOW_NAME,TARGET_EXPL_NODE_ID,'
                  || ' '
                  || 'URL_PROPERTY_ID,TARGET_PERSISTENT_NODE_ID,TARGET_NODE_PATH,TARGET_PAGE_SET_ID,'
                  || 'TARGET_PAGE_ID,TARGET_URL,FRAME_NAME,TARGET_ANCHOR,'
                  || 'PROCESSING_PAGE_TEMPL_ID,PROC_PAGE_TEMPL_UI_DEF_ID,'
                  || 'PROCESSING_CAPTION_TEXT_ID,PAGE_TITLE_TEXT_ID,MAIN_MESSAGE_TEXT_ID) '
                  || '='
                  || ' '
                  || '( SELECT :1,:2,UI_ACTION_TYPE,:3,CX_COMMAND_NAME,WINDOW_PARAMETERS,'
                  || ' '
                  || 'TARGET_WINDOW_TYPE,TARGET_WINDOW_NAME,:4,URL_PROPERTY_ID,'
                  || 'TARGET_PERSISTENT_NODE_ID,TARGET_NODE_PATH,TARGET_PAGE_SET_ID,'
                  || 'TARGET_PAGE_ID,TARGET_URL,FRAME_NAME,TARGET_ANCHOR,'
                  || ':5,:6,:7,:8,:9 '
                  || 'FROM cz_ui_actions WHERE  ui_def_id = 0'
                  || ' '
                  || 'AND ui_action_id = :10 )'
                  || ' '
                  || 'WHERE t.ui_def_id = 1'
                  || ' '
                  || 'AND t.ui_action_id = :11';

               EXECUTE IMMEDIATE l_update_str
                           USING cz_pb_mgr.g_ui_actns_ctx_comp_tbl(i)
                                ,cz_pb_mgr.g_ui_actns_ren_cond_tbl(i)
                                ,cz_pb_mgr.g_ui_actns_ui_tgtui_ref(i)
                                ,cz_pb_mgr.g_ui_actns_tgtexpl_ref(i)
                                ,cz_pb_mgr.g_uiact_prcpg_templ_tbl(i)
                                ,cz_pb_mgr.g_uiact_prcpg_tmpui_tbl(i)
                                ,cz_pb_mgr.g_uiact_prc_caption_tbl(i)
                                ,cz_pb_mgr.g_uiact_pg_title_tbl(i)
                                ,cz_pb_mgr.g_uiact_main_msg_tbl(i)
                                ,cz_pb_mgr.g_ui_actns_ui_act_id_old_ref(i)
                                ,cz_pb_mgr.g_ui_actns_ui_act_id_ref(i);
            END IF;
         END LOOP;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END refresh_ui_actions;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE refresh_global_templates(p_global_tmpl_tbl cz_pb_mgr.t_ref)
   IS
      l_update_str VARCHAR2(2000);
   BEGIN
      IF (cz_pb_mgr.g_ui_templates_old_temp_id_ref.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.g_ui_templates_old_temp_id_ref.FIRST .. cz_pb_mgr.g_ui_templates_old_temp_id_ref.LAST
         LOOP
            IF (cz_pb_mgr.g_ui_templates_ui_def_old_ref(i) = 0)
            THEN
               l_update_str :=
                     'UPDATE cz_ui_templates'
                  || cz_pb_mgr.v_db_link
                  || '  t'
                  || ' '
                  || 'SET    (TEMPLATE_NAME,TEMPLATE_TYPE,PARENT_CONTAINER_TYPE,BUTTON_BAR_TEMPLATE_ID'
                  || ' '
                  || ',MESSAGE_TYPE,MAIN_MESSAGE_ID,TITLE_ID,LAYOUT_UI_STYLE,ROOT_REGION_TYPE'
                  || ' '
                  || ',BUTTON_BAR_TEMPL_UIDEF_ID,ROOT_ELEMENT_SIGNATURE_ID,TEMPLATE_USAGE'
                  || ' '
                  || ') ='
                  || ' '
                  || '( SELECT TEMPLATE_NAME,TEMPLATE_TYPE,PARENT_CONTAINER_TYPE,:1,MESSAGE_TYPE,'
                  || ' '
                  || ':2,:3,LAYOUT_UI_STYLE,ROOT_REGION_TYPE,:4,ROOT_ELEMENT_SIGNATURE_ID,'
                  || ' '
                  || 'TEMPLATE_USAGE FROM cz_ui_templates WHERE  ui_def_id = 0'
                  || ' '
                  || 'AND template_id = :5 )'
                  || ' '
                  || 'WHERE t.ui_def_id = 1'
                  || ' '
                  || 'AND t.template_id = :6';

               EXECUTE IMMEDIATE l_update_str
                           USING cz_pb_mgr.g_ui_templates_button_tbl(i)
                                ,cz_pb_mgr.g_ui_templates_msg_id_ref(i)
                                ,cz_pb_mgr.g_ui_templates_title_ref(i)
                                ,cz_pb_mgr.g_ui_templates_but_uidef_id(i)
                                ,cz_pb_mgr.g_ui_templates_old_temp_id_ref(i)
                                ,cz_pb_mgr.g_ui_templates_new_temp_id_ref(i);
            END IF;
         END LOOP;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END refresh_global_templates;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----collect all os style UI(s)
   PROCEDURE get_oa_uis(p_src_models IN cz_pb_mgr.t_ref, x_oa_ui_def_ref IN OUT NOCOPY cz_pb_mgr.t_ref, x_oa_ui_def_tbl IN OUT NOCOPY cz_pb_mgr.t_ref)
   AS
      v_ui_def_count NUMBER := 0;
      rec_count NUMBER := 0;
      v_src_uis_tbl cz_pb_mgr.t_ref;
      l_export_model_id cz_devl_projects.devl_project_id%TYPE;
      l_menu_caption_rule_tbl cz_pb_mgr.t_ref;
      l_page_caption_rule_tbl cz_pb_mgr.t_ref;
      l_from_mt_id_tbl cz_pb_mgr.t_ref;
   BEGIN
      IF (p_src_models.COUNT > 0)
      THEN
         x_oa_ui_def_tbl.DELETE;
         l_menu_caption_rule_tbl.DELETE;
         l_page_caption_rule_tbl.DELETE;

         FOR i IN p_src_models.FIRST .. p_src_models.LAST
         LOOP
            l_export_model_id := p_src_models(i);
            v_src_uis_tbl.DELETE;

            BEGIN
               SELECT cz_ui_defs.ui_def_id, cz_ui_defs.menu_caption_rule_id, cz_ui_defs.page_caption_rule_id, cz_ui_defs.from_master_template_id
               BULK COLLECT INTO v_src_uis_tbl, l_menu_caption_rule_tbl, l_page_caption_rule_tbl, l_from_mt_id_tbl
                 FROM cz_ui_defs
                WHERE cz_ui_defs.devl_project_id = l_export_model_id AND cz_ui_defs.ui_style = oa_ui_style AND cz_ui_defs.deleted_flag = '0';
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  -----if there are no UI do not care
                  NULL;
               WHEN OTHERS
               THEN
                  RAISE;
            END;

            IF (v_src_uis_tbl.COUNT > 0)
            THEN
               FOR i IN v_src_uis_tbl.FIRST .. v_src_uis_tbl.LAST
               LOOP
                  v_ui_def_count := x_oa_ui_def_ref.COUNT + 1;
                  rec_count := x_oa_ui_def_tbl.COUNT + 1;
                  v_master_template_id_ref(rec_count) := l_from_mt_id_tbl(i);
                  x_oa_ui_def_ref(v_ui_def_count) := v_src_uis_tbl(i);
                  x_oa_ui_def_tbl(rec_count) := v_src_uis_tbl(i);
                  cz_pb_mgr.v_ui_defs_mcpt_rule_ref(v_ui_def_count) := l_menu_caption_rule_tbl(i);
                  cz_pb_mgr.v_ui_defs_pcpt_rule_ref(v_ui_def_count) := l_page_caption_rule_tbl(i);
               END LOOP;
            END IF;
         END LOOP;                                     /* end loop of FOR I IN p_src_models.FIRST */
      END IF;                                          /* end if of (p_src_models.COUNT > 0) */
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END get_oa_uis;

-------------------
   FUNCTION createelement(p_namespace IN OUT NOCOPY VARCHAR2, p_tagname IN VARCHAR2)
      RETURN jdr_docbuilder.ELEMENT
   IS
      l_child_element jdr_docbuilder.ELEMENT;
   BEGIN
      IF (p_namespace IS NULL)
      THEN
         p_namespace := 'jrad:';
      END IF;

      l_child_element := jdr_docbuilder.createelement(p_namespace, p_tagname);
      RETURN l_child_element;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;

----------------------------------------------
   PROCEDURE synch_user_attribute(attrval IN OUT NOCOPY VARCHAR2)
   AS
      l_new_persistentid NUMBER;
      l_temp_attr3_name VARCHAR2(250);
      l_attr3_name VARCHAR2(250);
      l_attr3_name_value_new VARCHAR2(250);
      l_attr3_name_value_old VARCHAR2(250);
      l_equal_pos NUMBER;
      l_pipe_pos NUMBER;
      l_cnt NUMBER;
      l_pipe VARCHAR2(1);
      l_old_id VARCHAR2(250);
      l_last_count NUMBER;
   BEGIN
-- Check for user:attribute1 or user:attribute2 or user:attribute3
--1. loop till all the name-value pairs are replaced with the new persistent ids values.
--2. get the value, check if there is any entry into the global array
--3. replace the value with the new one.
      l_temp_attr3_name := attrval;
      l_cnt := 0;

      WHILE(l_temp_attr3_name IS NOT NULL)
      LOOP                                                                                    -- check if there are '|' at the begining of the string
         IF (LENGTH(l_temp_attr3_name) = l_last_count)
         THEN
            EXIT;
         ELSE
            l_last_count := LENGTH(l_temp_attr3_name);
         END IF;

         l_pipe := SUBSTR(l_temp_attr3_name, 0, 1);

         WHILE(l_pipe = '|')
         LOOP
            --if ( l_pipe = '|' ) then
            -- trim  to remove '|' from the start till no '|' are found
            l_temp_attr3_name := SUBSTR(l_temp_attr3_name, 2, LENGTH(l_temp_attr3_name));
            l_pipe := SUBSTR(l_temp_attr3_name, 0, 1);
         --continue;
         END LOOP;

         l_equal_pos := INSTR(l_temp_attr3_name, '=');
         l_attr3_name := SUBSTR(l_temp_attr3_name, l_cnt, l_equal_pos - 1);
         l_pipe_pos := INSTR(l_temp_attr3_name, '|');

         IF (l_pipe_pos = 0)
         THEN
            l_old_id := SUBSTR(l_temp_attr3_name, l_equal_pos + 1);
            l_attr3_name_value_old := l_temp_attr3_name;
         ELSE
            l_old_id := SUBSTR(l_temp_attr3_name, l_equal_pos + 1,(l_pipe_pos - l_equal_pos) - 1);
            l_attr3_name_value_old := SUBSTR(l_temp_attr3_name, 0, l_pipe_pos - 1);
         END IF;

         BEGIN
            IF (l_attr3_name = 'actionId')
            THEN
               IF (cz_pb_mgr.g_ui_actions_id_idx_ref.EXISTS(l_old_id))
               THEN
                  l_new_persistentid := cz_pb_mgr.g_ui_actions_id_idx_ref(l_old_id);
               END IF;
            ELSIF(l_attr3_name IN
                     ('displayCondnId'
                     ,'enabledCondnId'
                     ,'captionRuleId'
                     ,'colDisplayCondnId'
                     ,'liDisplayCondnId'
                     ,'rowDisplayCondnId'
                     ,'rowEnabledCondnId'
                     ,'rolloverRuleId'
                     ,'tableSummaryRuleId'
                     ,'switcherCondnId'
                     )
                 )
            THEN
               IF (cz_pb_mgr.v_cz_rules_rule_id_idx_ref.EXISTS(l_old_id))
               THEN
                  l_new_persistentid := cz_pb_mgr.v_cz_rules_rule_id_idx_ref(l_old_id);
               END IF;
            ELSIF(l_attr3_name IN
                     ('urlIntlTextId', 'captionIntlTextId', 'rolloverIntlTextId', 'tableSummaryIntlTextId', 'cellIntlTextId', 'imageSourceIntlTextId')
                 )
            THEN
               IF (cz_pb_mgr.v_cz_intl_text_idx_ref.EXISTS(l_old_id))
               THEN
                  l_new_persistentid := cz_pb_mgr.v_cz_intl_text_idx_ref(l_old_id);
               END IF;
            END IF;

            IF (l_new_persistentid IS NOT NULL)
            THEN
               l_attr3_name_value_new := REPLACE(l_attr3_name_value_old, l_old_id, l_new_persistentid);
               attrval := REPLACE(attrval, l_attr3_name_value_old, l_attr3_name_value_new);
               l_new_persistentid := NULL;
            END IF;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               -- do nothing
               -- since , all the ref tables will hold only non-seeded ids,
               -- the only time we will fall in this exception is when we try to look up seeded ids
               l_new_persistentid := NULL;
            WHEN OTHERS
            THEN
               RAISE;
         END;

         IF (l_pipe_pos = 0)
         THEN
            l_temp_attr3_name := NULL;
         ELSE
            l_temp_attr3_name := SUBSTR(l_temp_attr3_name, l_pipe_pos + 1, LENGTH(l_temp_attr3_name));
         END IF;
      END LOOP;
   END;

-----------------------------------------------------
   PROCEDURE exploretree(
      p_jrad_parent_element IN jdr_docbuilder.ELEMENT
     ,p_dom_parent_element IN xmldom.domnode
     ,p_grouping_tag IN VARCHAR2
     ,p_link_name IN VARCHAR2
   )
   IS
      l_child_nodes xmldom.domnodelist;
      l_child_node xmldom.domnode;
      l_parent_xml_node xmldom.domnode;
      l_child_count NUMBER := 0;
      l_namespace VARCHAR2(255);
      l_tagname VARCHAR2(255);
      l_tag_name VARCHAR2(255);
      l_attributes xmldom.domnamednodemap;
      l_attrib_node xmldom.domnode;
      l_attrib_count NUMBER := 0;
      attrname VARCHAR2(255);
      attrval VARCHAR2(4000);
      l_groupingns VARCHAR2(255);
      l_groupingtagname VARCHAR2(255);
      l_grouping_tag VARCHAR2(255);
      l_parent_element jdr_docbuilder.ELEMENT;
      l_child_element jdr_docbuilder.ELEMENT;
      l_ampers VARCHAR2(1) := fnd_global.local_chr(38);
      l_parent_tag_name VARCHAR2(255);
   BEGIN
      l_child_nodes := xmldom.getchildnodes(p_dom_parent_element);
      l_child_count := xmldom.getlength(l_child_nodes);
      l_parent_element := p_jrad_parent_element;

      IF (l_child_count > 0)
      THEN
         FOR childcount IN 0 .. l_child_count - 1
         LOOP
            l_child_node := xmldom.item(l_child_nodes, childcount);
            l_grouping_tag := '';
            l_attributes := xmldom.getattributes(l_child_node);
            l_attrib_count := xmldom.getlength(l_attributes);
            l_tag_name := xmldom.getnodename(l_child_node);
            l_parent_xml_node := xmldom.getparentnode(l_child_node);

            IF NOT(xmldom.isnull(l_parent_xml_node))
            THEN
               l_parent_tag_name := xmldom.getnodename(l_parent_xml_node);
            END IF;

            IF ((l_attrib_count = 0) AND(l_tag_name NOT IN('ui:firePartialAction')))
            THEN
               l_grouping_tag := l_tag_name;
            END IF;

            IF (p_grouping_tag IS NOT NULL)
            THEN
               l_namespace := SUBSTR(xmldom.getnodename(l_child_node), 1, INSTR(xmldom.getnodename(l_child_node), ':'));
               l_tagname := SUBSTR(xmldom.getnodename(l_child_node), INSTR(xmldom.getnodename(l_child_node), ':') + 1);
               l_child_element := createelement(l_namespace, l_tagname);
               l_attributes := xmldom.getattributes(l_child_node);

               IF (l_attrib_count > 0)
               THEN
                  FOR attrcount IN 0 .. l_attrib_count - 1
                  LOOP
                     l_attrib_node := xmldom.item(l_attributes, attrcount);
                     attrname := xmldom.getnodename(l_attrib_node);
                     attrval := xmldom.getnodevalue(l_attrib_node);
                     attrval := REPLACE(attrval, l_ampers, l_ampers || 'amp;');
                     attrval := REPLACE(attrval, '>', l_ampers || 'gt;');
                     attrval := REPLACE(attrval, '<', l_ampers || 'lt;');
                     attrval := REPLACE(attrval, '"', l_ampers || 'quot;');
                     attrval := REPLACE(attrval, '''', l_ampers || 'apos;');
                     jdr_docbuilder.setattribute(l_child_element, attrname, attrval);
                  END LOOP;
               END IF;

               l_groupingns := SUBSTR(p_grouping_tag, 1, INSTR(p_grouping_tag, ':'));
               l_groupingtagname := SUBSTR(p_grouping_tag, INSTR(p_grouping_tag, ':') + 1);

               IF (l_groupingns IS NULL)
               THEN
                  l_groupingns := 'jrad:';
               END IF;

               jdr_docbuilder.addchild(p_jrad_parent_element, l_groupingns, l_groupingtagname, l_child_element);
               exploretree(l_child_element, l_child_node, l_grouping_tag, p_link_name);
            ELSE
               l_namespace := SUBSTR(xmldom.getnodename(l_child_node), 1, INSTR(xmldom.getnodename(l_child_node), ':'));
               l_tagname := SUBSTR(xmldom.getnodename(l_child_node), INSTR(xmldom.getnodename(l_child_node), ':') + 1);
               l_child_element := createelement(l_namespace, l_tagname);

               IF (l_attrib_count > 0)
               THEN
                  FOR attrcount IN 0 .. l_attrib_count - 1
                  LOOP
                     l_attrib_node := xmldom.item(l_attributes, attrcount);
                     attrname := xmldom.getnodename(l_attrib_node);
                     attrval := xmldom.getnodevalue(l_attrib_node);
                     attrval := REPLACE(attrval, l_ampers, l_ampers || 'amp;');
                     attrval := REPLACE(attrval, '>', l_ampers || 'gt;');
                     attrval := REPLACE(attrval, '<', l_ampers || 'lt;');
                     attrval := REPLACE(attrval, '"', l_ampers || 'quot;');
                     attrval := REPLACE(attrval, '''', l_ampers || 'apos;');
                     jdr_docbuilder.setattribute(l_child_element, attrname, attrval);
                  END LOOP;
               END IF;

               IF (l_grouping_tag IS NULL)
               THEN
                  jdr_docbuilder.addchild(p_jrad_parent_element, l_child_element);
                  exploretree(l_child_element, l_child_node, l_grouping_tag, p_link_name);
               ELSE
                  exploretree(p_jrad_parent_element, l_child_node, l_grouping_tag, p_link_name);
               END IF;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END exploretree;

----------------------------------------------------
-- ancestorNode="docname.ancestorid", where docname normally pointing to itself,
--                               ancestor being immediate parent or higher level's
-- e.g. /oracle/apps/cz/runtime/oa/webui/templates/summary/28501_170._czc233440-xxx
--      /oracle/apps/cz/runtime/oa/webui/regions/ui44563/Page_44563_1.16496045-yyy
PROCEDURE handle_ancestorNode(p_old_doc_name IN VARCHAR2, p_new_doc_name IN VARCHAR2, p_chunk IN OUT NOCOPY LONG)
IS
BEGIN
  IF instr(p_chunk, 'ancestorNode="' || p_old_doc_name || '.') > 0 THEN
    p_chunk := replace(p_chunk, 'ancestorNode="' || p_old_doc_name || '.',
                                'ancestorNode="' || p_new_doc_name || '.');
  END IF;
END handle_ancestorNode;

----------------------------------------------------
--There are some issues with having the p_chunk
--parameter on replace_extends as a CLOB.  For some reason, the getLength on a CLOB for certain
--JRAD documents was returning a 0, and UI copy procedure was failing.
--Retaining this parameter as LONG and changing the places where we were
--calling the procedure to LONG so we be consistent everywhere
--See Bug 4930937 for symptoms of the bug.
PROCEDURE replace_extends(p_chunk IN OUT NOCOPY LONG)
IS
BEGIN
  IF (cz_pb_mgr.g_ui_templates_jrad_old_ref.COUNT > 0) THEN
    FOR i IN cz_pb_mgr.g_ui_templates_jrad_old_ref.FIRST .. cz_pb_mgr.g_ui_templates_jrad_old_ref.LAST
    LOOP
      IF (INSTR(p_chunk, cz_pb_mgr.g_ui_templates_jrad_old_ref(i) || '"') > 0) THEN
        p_chunk := REPLACE(p_chunk, cz_pb_mgr.g_ui_templates_jrad_old_ref(i) || '"', cz_pb_mgr.g_ui_templates_jrad_new_ref(i) || '"');
      END IF;
    END LOOP;
  END IF;

  IF cz_pb_mgr.g_tmpl_jrad_old_tbl.COUNT > 0 THEN
    FOR i IN cz_pb_mgr.g_tmpl_jrad_old_tbl.FIRST .. cz_pb_mgr.g_tmpl_jrad_old_tbl.LAST LOOP
      IF INSTR(p_chunk, cz_pb_mgr.g_tmpl_jrad_old_tbl(i) || '"') > 0 THEN
        p_chunk := REPLACE(p_chunk, cz_pb_mgr.g_tmpl_jrad_old_tbl(i) || '"', cz_pb_mgr.g_tmpl_jrad_new_tbl(i) || '"');
      END IF;
    END LOOP;
  END IF;
END replace_extends;

----------------------------------------------------
   PROCEDURE collect_chunks(
      p_document_name IN VARCHAR2
     ,p_link_name IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   IS
      l_length BINARY_INTEGER;
      l_buffer VARCHAR2(32767);
      firstchunk VARCHAR2(32767);
      document_is_null EXCEPTION;
      l_seq_nbr NUMBER := 0;

      TYPE chunk_record IS RECORD(
         jrad_doc VARCHAR2(255)
        ,seq_nbr NUMBER
        ,xml_chunk VARCHAR2(32767)
      );

      TYPE chunk_record_tbl IS TABLE OF chunk_record
         INDEX BY BINARY_INTEGER;

      l_chunk_tbl chunk_record_tbl;
      l_exportfinished BOOLEAN;
   BEGIN
      pbdebug := 22021;
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      x_msg_count := 0;
      x_msg_data := '';
      jdr_docbuilder.REFRESH;

      IF (p_document_name IS NULL) THEN
         RAISE document_is_null;
      END IF;

      firstchunk := jdr_utils.exportdocument(p_document_name, l_exportfinished);

      IF (firstchunk IS NULL) THEN
         RAISE document_is_null;
      END IF;

      l_buffer := LTRIM(RTRIM(firstchunk));

      IF (l_buffer IS NOT NULL) THEN
         l_seq_nbr := l_seq_nbr + 1;
         l_chunk_tbl(l_seq_nbr).jrad_doc := p_document_name;
         l_chunk_tbl(l_seq_nbr).seq_nbr := l_seq_nbr;
         l_chunk_tbl(l_seq_nbr).xml_chunk := l_buffer;
      END IF;

      LOOP
         l_buffer := jdr_utils.exportdocument(NULL, l_exportfinished);
         l_buffer := LTRIM(RTRIM(l_buffer));
         EXIT WHEN l_buffer IS NULL;

         IF (l_buffer IS NOT NULL) THEN
            l_seq_nbr := l_seq_nbr + 1;
            l_chunk_tbl(l_seq_nbr).jrad_doc := p_document_name;
            l_chunk_tbl(l_seq_nbr).seq_nbr := l_seq_nbr;
            l_chunk_tbl(l_seq_nbr).xml_chunk := l_buffer;
         END IF;
      END LOOP;

      IF (l_chunk_tbl.COUNT > 0) THEN
         FOR i IN l_chunk_tbl.FIRST .. l_chunk_tbl.LAST
         LOOP
            EXECUTE IMMEDIATE 'insert into cz_jrad_chunks' || p_link_name || ' (jrad_doc,seq_nbr,xml_chunk)' || ' ' || 'values (:1,:2,:3)'
                        USING l_chunk_tbl(i).jrad_doc, l_chunk_tbl(i).seq_nbr, l_chunk_tbl(i).xml_chunk;
         END LOOP;
      END IF;

      COMMIT;
      jdr_docbuilder.REFRESH;
   EXCEPTION
      WHEN document_is_null THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := cz_utils.get_text('CZ_NO_JRADDOC_EXISTS', 'DOC', p_document_name);
         RAISE;
      WHEN OTHERS THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := SQLERRM;
         RAISE;
   END collect_chunks;

----------------------------------------------------
   -- NOTE: p_document_type of NULL (default) represents a UI content template document.
   --       To collect JRAD chunks for UI pages, UI_PAGE should be passed as input value.
   PROCEDURE collect_chunks(
      p_document_name IN VARCHAR2
     ,p_new_document_name IN VARCHAR2
     ,p_link_name IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
     ,p_document_type IN VARCHAR2 DEFAULT NULL
   )
   IS
      amt BINARY_INTEGER := 32767;
      l_length BINARY_INTEGER;
      l_offset BINARY_INTEGER := 1;
      l_buffer VARCHAR2(32767);
      firstchunk VARCHAR2(32767);
      document_is_null EXCEPTION;
      l_seq_nbr NUMBER := 0;
      l_old_ui_def VARCHAR2(200);
      l_new_ui_def VARCHAR2(300);
      l_lob CLOB;
      l_lob_temp CLOB;
      p xmlparser.parser;
      doc xmldom.domdocument;
      nl xmldom.domnodelist;
      one_node xmldom.domnode;
      one_element xmldom.domelement;
      l_value VARCHAR2(32767);
      nodeMap xmldom.DOMNamedNodeMap;
      n xmldom.DOMNode;
      attrname varchar2(100);
      len2 NUMBER;

      TYPE chunk_record IS RECORD(
         jrad_doc VARCHAR2(255)
        ,seq_nbr NUMBER
        ,xml_chunk VARCHAR2(32767)
      );

      TYPE chunk_record_tbl IS TABLE OF chunk_record
         INDEX BY BINARY_INTEGER;

      l_chunk_tbl chunk_record_tbl;
      l_exportfinished BOOLEAN;
   BEGIN
      pbdebug := 22022;
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      x_msg_count := 0;
      x_msg_data := '';
      jdr_docbuilder.REFRESH;

      IF (p_document_name IS NULL) THEN
         RAISE document_is_null;
      END IF;

      firstchunk := jdr_utils.exportdocument(p_document_name, l_exportfinished);

      IF (firstchunk IS NULL) THEN
         RAISE document_is_null;
      END IF;

      l_buffer := LTRIM(RTRIM(firstchunk));

      IF (l_buffer IS NOT NULL) THEN
         l_seq_nbr := l_seq_nbr + 1;
         l_chunk_tbl(l_seq_nbr).jrad_doc := p_new_document_name;
         l_chunk_tbl(l_seq_nbr).seq_nbr := l_seq_nbr;
         l_chunk_tbl(l_seq_nbr).xml_chunk := l_buffer;
      END IF;

      LOOP
         l_buffer := jdr_utils.exportdocument(NULL, l_exportfinished);
         l_buffer := LTRIM(RTRIM(l_buffer));
         EXIT WHEN l_buffer IS NULL;

         IF (l_buffer IS NOT NULL) THEN
            l_seq_nbr := l_seq_nbr + 1;
            l_chunk_tbl(l_seq_nbr).jrad_doc := p_new_document_name;
            l_chunk_tbl(l_seq_nbr).seq_nbr := l_seq_nbr;
            l_chunk_tbl(l_seq_nbr).xml_chunk := l_buffer;
         END IF;
      END LOOP;

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
         IF (l_chunk_tbl.COUNT > 0) THEN
            SYS.DBMS_LOB.createtemporary(l_lob, TRUE, DBMS_LOB.SESSION);
            SYS.DBMS_LOB.OPEN(l_lob, DBMS_LOB.lob_readwrite);

            FOR i IN l_chunk_tbl.FIRST .. l_chunk_tbl.LAST
            LOOP
               -- collect the entire document in the CLOB
               l_length := LENGTH(l_chunk_tbl(i).xml_chunk);
               SYS.DBMS_LOB.writeappend(l_lob, l_length, l_chunk_tbl(i).xml_chunk);
            END LOOP;

            -- parse the document for user:attribute3
            -- call synch_user_attribute
            l_length := SYS.DBMS_LOB.getlength(l_lob);
            p := xmlparser.newparser;
            xmlparser.parseclob(p, l_lob);
            SYS.DBMS_LOB.CLOSE(l_lob);
            SYS.DBMS_LOB.freetemporary(l_lob);
            doc := xmlparser.getdocument(p);
            nl := xmldom.getelementsbytagname(doc, '*');

            IF (p_document_type IS  NULL )THEN
		    FOR node_index IN 0 .. xmldom.getlength(nl) - 1
		    LOOP
		       one_node := xmldom.item(nl, node_index);
		       one_element := xmldom.makeelement(one_node);
		       --node_attr := xmldom.getattributenode(one_element, 'user:attribute3');
		       -- This is a workaround for bug 5211850 till the API xmldom.getattributenode is fixed
		       -- get all attributes of element
		       nodeMap := xmldom.getAttributes(one_node);

		       IF (xmldom.isNull(nodeMap) = FALSE) THEN
			  len2 := xmldom.getLength(nodeMap);
			  -- loop through attributes
			  FOR i IN 0..len2-1 LOOP
			      n := xmldom.item(nodeMap, i);
			      attrname := xmldom.getNodeName(n);
			      IF(attrname='user:attribute3' ) THEN
				 l_value := xmldom.getNodeValue(n);
				 EXIT;
			      END IF;
			  END LOOP;
		       END IF;

		       IF (l_value IS NOT NULL) THEN
			     synch_user_attribute(l_value);
			     xmldom.setattribute(one_element, 'user:attribute3', l_value);
			     l_value:=NULL;
		       END IF;
		    END LOOP;
            END IF;
            -- Break the document to insert into the  cz_jrad_chunks
            SYS.DBMS_LOB.createtemporary(l_lob_temp, TRUE, DBMS_LOB.SESSION);
            SYS.DBMS_LOB.OPEN(l_lob_temp, DBMS_LOB.lob_readwrite);
            xmldom.writetoclob(doc, l_lob_temp);

            FOR i IN l_chunk_tbl.FIRST .. l_chunk_tbl.LAST
            LOOP
               SYS.DBMS_LOB.READ(l_lob_temp, amt, l_offset, l_buffer);
               l_chunk_tbl(i).xml_chunk := l_buffer;
               l_offset := l_offset + amt;
               l_buffer := NULL;
            END LOOP;

            SYS.DBMS_LOB.CLOSE(l_lob_temp);
            SYS.DBMS_LOB.freetemporary(l_lob_temp);
            xmlparser.freeparser(p);
            xmldom.freeDocument(doc);
         END IF;
      END IF;

      IF (l_chunk_tbl.COUNT > 0) THEN
         FOR i IN l_chunk_tbl.FIRST .. l_chunk_tbl.LAST
         LOOP
            replace_extends(l_chunk_tbl(i).xml_chunk);
            handle_ancestorNode(p_document_name, p_new_document_name, l_chunk_tbl(i).xml_chunk);
            EXECUTE IMMEDIATE 'insert into cz_jrad_chunks' || p_link_name || ' (jrad_doc,seq_nbr,xml_chunk)' || ' ' || 'values (:1,:2,:3)'
                        USING l_chunk_tbl(i).jrad_doc, l_chunk_tbl(i).seq_nbr, l_chunk_tbl(i).xml_chunk;
         END LOOP;
      END IF;

      COMMIT;
      jdr_docbuilder.REFRESH;
   EXCEPTION
      WHEN document_is_null THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := cz_utils.get_text('CZ_NO_JRADDOC_EXISTS', 'DOC', p_document_name);
         RAISE;
      WHEN OTHERS THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := SQLERRM;
         RAISE;
   END collect_chunks;

------------------------------------
   PROCEDURE insert_jrad_docs
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;

      CURSOR jrad_docs_cur
      IS
         SELECT DISTINCT jrad_doc
                    FROM cz_jrad_chunks;

      CURSOR jrad_chunks_cur(p_jrad_doc VARCHAR2)
      IS
         SELECT   xml_chunk
             FROM cz_jrad_chunks
            WHERE jrad_doc = p_jrad_doc
         ORDER BY seq_nbr;

      l_jrad_doc VARCHAR2(255);
      l_chunk VARCHAR2(32767);
      l_lob CLOB;
      l_offset PLS_INTEGER := 1;
      l_length BINARY_INTEGER;
      l_doc_id NUMBER;
      p xmlparser.parser;
      doc xmldom.domdocument;
      nl xmldom.domnodelist;
      len NUMBER;
      n xmldom.domnode;
      top_node xmldom.domnode;
      l_parent_node xmldom.domnode;
      v_ns VARCHAR2(255);
      v_el VARCHAR2(255);
      len1 NUMBER;
      len2 NUMBER;
      nnm xmldom.domnamednodemap;
      attrname VARCHAR2(255);
      attrval VARCHAR2(255);
      newattrname VARCHAR2(255);
      name_space VARCHAR2(255);
      tag_name VARCHAR2(255);
      l_doc jdr_docbuilder.document;
      top_element jdr_docbuilder.ELEMENT;
      g_document jdr_docbuilder.document;
      l_new_document jdr_docbuilder.document;
      jrad_save_status PLS_INTEGER;
      document_is_null EXCEPTION;
      l_msg VARCHAR2(2000);

      TYPE char_tbl_type IS TABLE OF VARCHAR2(255);

      g_toplevel_attr_tbl char_tbl_type := char_tbl_type('version', 'xml:lang', 'xmlns:oa', 'xmlns:ui', 'xmlns:jrad', 'xmlns:user', 'xmlns');
   BEGIN
      pbdebug := 22024;

      OPEN jrad_docs_cur;

      LOOP
         jdr_docbuilder.REFRESH;

         FETCH jrad_docs_cur
          INTO l_jrad_doc;

         EXIT WHEN jrad_docs_cur%NOTFOUND;
         SYS.DBMS_LOB.createtemporary(l_lob, TRUE, DBMS_LOB.SESSION);
         SYS.DBMS_LOB.OPEN(l_lob, DBMS_LOB.lob_readwrite);

         OPEN jrad_chunks_cur(l_jrad_doc);

         LOOP
            FETCH jrad_chunks_cur
             INTO l_chunk;

            EXIT WHEN jrad_chunks_cur%NOTFOUND;

             --There are some issues with having the p_chunk
             --parameter on replace extends as a CLOB.  For some reason, the getLength on a CLOB for certain
             --JRAD documents was returning a 0, and UI copy procedure was failing.
             --Retaining this parameter as LONG and changing the places where we were
             --calling the procedure to LONG so we be consistent everywhere
             --See Bug 4930937 for symptoms of the bug.
            IF (l_chunk IS NOT NULL)
            THEN
               -- for schema migration, no need to do any replacement; for remote publishing (or migration),
               -- the replacement is done before this gets called (e.g., when collect_chunks)
               -- and the two templ arrays are empty anyway
               -- replace_extends(l_chunk);
               l_length := LENGTH(l_chunk);
               SYS.DBMS_LOB.writeappend(l_lob, l_length, l_chunk);
            END IF;
         END LOOP;

         CLOSE jrad_chunks_cur;

         l_length := SYS.DBMS_LOB.getlength(l_lob);
         p := xmlparser.newparser;
         xmlparser.parseclob(p, l_lob);
         doc := xmlparser.getdocument(p);
         SYS.DBMS_LOB.CLOSE(l_lob);
         SYS.DBMS_LOB.freetemporary(l_lob);
         l_doc := jdr_docbuilder.createdocument(l_jrad_doc);
         top_node := xmldom.makenode(xmldom.getdocumentelement(doc));

         IF (g_toplevel_attr_tbl.COUNT > 0)
         THEN
            FOR i IN g_toplevel_attr_tbl.FIRST .. g_toplevel_attr_tbl.LAST
            LOOP
               BEGIN
                  xmldom.removeattribute(xmldom.makeelement(top_node), g_toplevel_attr_tbl(i));
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     NULL;
               END;
            END LOOP;
         END IF;

         name_space := SUBSTR(xmldom.getnodename(top_node), 1, INSTR(xmldom.getnodename(top_node), ':'));
         tag_name := SUBSTR(xmldom.getnodename(top_node), INSTR(xmldom.getnodename(top_node), ':') + 1);
         top_element := createelement(name_space, tag_name);
         nnm := xmldom.getattributes(top_node);

         IF (xmldom.isnull(nnm) = FALSE)
         THEN
            len2 := xmldom.getlength(nnm);

            FOR i IN 0 .. len2 - 1
            LOOP
               n := xmldom.item(nnm, i);
               attrname := xmldom.getnodename(n);
               attrval := xmldom.getnodevalue(n);
               jdr_docbuilder.setattribute(top_element, attrname, attrval);
            END LOOP;
         END IF;

         jdr_docbuilder.settoplevelelement(l_doc, top_element);

         BEGIN
            exploretree(top_element, top_node, '', ' ');
         EXCEPTION
            WHEN OTHERS
            THEN
               RAISE_APPLICATION_ERROR(-20001, 'EXPLORETREE_ERROR') ;
         END;

         jrad_save_status := jdr_docbuilder.SAVE;
         xmlparser.freeparser(p);
         xmldom.freeDocument(doc);
         COMMIT;
         jdr_docbuilder.REFRESH;
      END LOOP;

      CLOSE jrad_docs_cur;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         ROLLBACK;
         jdr_docbuilder.REFRESH;
         IF l_jrad_doc is not null THEN
             l_msg := l_jrad_doc || '-'  || SQLERRM;
         ELSE
             l_msg := SQLERRM;
         END IF;

         INSERT INTO cz_db_logs
                     (logtime, caller, MESSAGE
                     )
              VALUES (SYSDATE, 'CZJRADLOAD', l_msg
                     );

         COMMIT;
         RAISE;
   END;

--------------------------------------------------
   PROCEDURE export_jrad_docs(
      p_document_name IN VARCHAR2
     ,p_link_name IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   IS
   BEGIN
      pbdebug := 22025;

      EXECUTE IMMEDIATE ' begin delete from cz_jrad_chunks' || p_link_name || '; commit; end; ';

      collect_chunks(p_document_name, p_link_name, x_return_status, x_msg_count, x_msg_data);

      EXECUTE IMMEDIATE ' begin cz_pb_mgr.insert_jrad_docs' || p_link_name || '; end; ';

      EXECUTE IMMEDIATE ' begin delete from cz_jrad_chunks' || p_link_name || '; commit; end; ';
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := cz_utils.get_text('CZ_NO_JRADDOC_EXISTS', 'DOC', p_document_name);
      WHEN OTHERS
      THEN
         x_return_status := fnd_api.g_ret_sts_unexp_error;
         x_msg_count := 1;
         x_msg_data := cz_utils.get_text('CZ_JRADDOC_EXPERR', 'ERR', SQLERRM);
   END export_jrad_docs;

----------------------------------------------------
   PROCEDURE export_jrad_docs(
      p_ui_def_id IN NUMBER
     ,p_link_name IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   IS
      l_jrad_doc_tbl jraddoc_type_tbl;
      l_link_name cz_servers.fndnam_link_name%TYPE;
      link_name_is_null EXCEPTION;
   BEGIN
      pbdebug := 22026;

      IF (p_link_name IS NULL)
      THEN
         RAISE link_name_is_null;
      ELSE
         l_link_name := '@' || p_link_name;
      END IF;

      SELECT jrad_doc
      BULK COLLECT INTO l_jrad_doc_tbl
        FROM cz_ui_pages
       WHERE cz_ui_pages.ui_def_id = p_ui_def_id AND cz_ui_pages.deleted_flag = '0';

      IF (l_jrad_doc_tbl.COUNT > 0)
      THEN
         EXECUTE IMMEDIATE ' begin delete from cz_jrad_chunks' || l_link_name || '; commit; end; ';

         FOR i IN l_jrad_doc_tbl.FIRST .. l_jrad_doc_tbl.LAST
         LOOP
            collect_chunks(l_jrad_doc_tbl(i), l_link_name, x_return_status, x_msg_count, x_msg_data);
         END LOOP;

         EXECUTE IMMEDIATE ' begin cz_pb_mgr.insert_jrad_docs' || l_link_name || '; end; ';

         EXECUTE IMMEDIATE ' begin delete from cz_jrad_chunks' || l_link_name || '; commit; end; ';
      END IF;
   EXCEPTION
      WHEN link_name_is_null
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := 'Db Link Name is Null';
         log_pb_errors(x_msg_data, '2', 'EXPORTJRADDOCS', SQLCODE);
      WHEN NO_DATA_FOUND
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := cz_utils.get_text('CZ_NO_JRADDOC_EXISTS', 'DOC', p_ui_def_id);
      WHEN OTHERS
      THEN
         x_return_status := fnd_api.g_ret_sts_unexp_error;
         x_msg_count := 1;
         x_msg_data := cz_utils.get_text('CZ_JRADDOC_EXPERR', 'ERR', SQLERRM);
   END export_jrad_docs;

------>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE export_template_jrad_docs(
      p_ui_def_id IN NUMBER
     ,p_template_id IN NUMBER
     ,p_link_name IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   IS
      l_jrad_doc_tbl jraddoc_type_tbl;
   BEGIN
      pbdebug := 22026;

      SELECT jrad_doc
      BULK COLLECT INTO l_jrad_doc_tbl
        FROM cz_ui_templates
       WHERE cz_ui_templates.ui_def_id = p_ui_def_id
         AND cz_ui_templates.template_id = p_template_id
         AND cz_ui_templates.seeded_flag = '0'
         AND cz_ui_templates.deleted_flag = '0';

      IF (l_jrad_doc_tbl.COUNT > 0)
      THEN
         EXECUTE IMMEDIATE ' begin delete from cz_jrad_chunks' || p_link_name || '; commit; end; ';

         FOR i IN l_jrad_doc_tbl.FIRST .. l_jrad_doc_tbl.LAST
         LOOP
            collect_chunks(l_jrad_doc_tbl(i), p_link_name, x_return_status, x_msg_count, x_msg_data);
         END LOOP;

         EXECUTE IMMEDIATE ' begin cz_pb_mgr.insert_jrad_docs' || p_link_name || '; end; ';

         EXECUTE IMMEDIATE ' begin delete from cz_jrad_chunks' || p_link_name || '; commit; end; ';
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := cz_utils.get_text('CZ_JRADDOC_EXPERR', 'ERR', SQLERRM);
   END export_template_jrad_docs;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE export_template_jrad_docs(
      p_link_name IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   IS
      l_ui_def_id_tbl cz_pb_mgr.t_ref;
      l_template_id_tbl cz_pb_mgr.t_ref;
      l_link_name cz_servers.fndnam_link_name%TYPE;
      link_name_is_null EXCEPTION;
   BEGIN
      IF (p_link_name IS NULL)
      THEN
         RAISE link_name_is_null;
      ELSE
         l_link_name := '@' || p_link_name;
      END IF;

      SELECT ui_def_id, template_id
      BULK COLLECT INTO l_ui_def_id_tbl, l_template_id_tbl
        FROM cz_ui_templates
       WHERE cz_ui_templates.deleted_flag = '0'
         AND cz_ui_templates.seeded_flag = '0'
         AND (   cz_ui_templates.ui_def_id = 0
              OR cz_ui_templates.ui_def_id IN(
                    SELECT ui_def_id
                      FROM cz_ui_defs
                     WHERE cz_ui_defs.deleted_flag = '0'
                       AND cz_ui_defs.devl_project_id IN(SELECT object_id
                                                           FROM cz_rp_entries
                                                          WHERE cz_rp_entries.object_type = 'PRJ' AND cz_rp_entries.deleted_flag = '0'))
             );

      IF (l_ui_def_id_tbl.COUNT > 0)
      THEN
         FOR i IN l_ui_def_id_tbl.FIRST .. l_ui_def_id_tbl.LAST
         LOOP
            x_return_status := FND_API.G_RET_STS_SUCCESS;
            x_msg_data := '';
            export_template_jrad_docs(l_ui_def_id_tbl(i), l_template_id_tbl(i), l_link_name, x_return_status, x_msg_count, x_msg_data);

            IF (x_return_status = FND_API.G_RET_STS_ERROR)
            THEN
               log_pb_errors(x_msg_data, '0', 'EXPORTJRADDOCS', SQLCODE);
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN link_name_is_null
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := 'Db Link Name is Null';
         log_pb_errors(x_msg_data, '2', 'EXPORTJRADDOCS', SQLCODE);
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := SQLERRM;
         log_pb_errors(x_msg_data, '2', 'EXPORTJRADDOCS', SQLCODE);
   END export_template_jrad_docs;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_into_repository(p_old_document_name IN VARCHAR2, p_new_document_name IN VARCHAR2)
   IS
      l_lob CLOB;
      l_offset PLS_INTEGER := 1;
      l_length BINARY_INTEGER;
      l_doc_id NUMBER;
      l_buffer LONG;
      firstchunk LONG;
      p xmlparser.parser;
      doc xmldom.domdocument;
      nl xmldom.domnodelist;
      len NUMBER;
      n xmldom.domnode;
      top_node xmldom.domnode;
      l_parent_node xmldom.domnode;
      v_ns VARCHAR2(255);
      v_el VARCHAR2(255);
      len1 NUMBER;
      len2 NUMBER;
      nnm xmldom.domnamednodemap;
      attrname VARCHAR2(255);
      attrval VARCHAR2(255);
      newattrname VARCHAR2(255);
      name_space VARCHAR2(255);
      tag_name VARCHAR2(255);
      l_doc jdr_docbuilder.document;
      top_element jdr_docbuilder.ELEMENT;
      g_document jdr_docbuilder.document;
      l_new_document jdr_docbuilder.document;
      jrad_save_status PLS_INTEGER;
      document_is_null EXCEPTION;

      TYPE char_tbl_type IS TABLE OF VARCHAR2(255);

      g_toplevel_attr_tbl char_tbl_type := char_tbl_type('version', 'xml:lang', 'xmlns:oa', 'xmlns:ui', 'xmlns:jrad', 'xmlns:user', 'xmlns');
      l_exportfinished BOOLEAN;
   BEGIN
      pbdebug := 22027;
      jdr_docbuilder.REFRESH;

      IF (p_old_document_name IS NULL)
      THEN
         RAISE document_is_null;
      END IF;

      --There are some issues with having the p_chunk
      --parameter as a CLOB.  For some reason, the getLength on a CLOB for certain
      --JRAD documents was returning a 0, and UI copy procedure was failing.
      --Retaining this parameter as LONG and changing the places where we were
      --calling the procedure to LONG so we be consistent everywhere
      --See Bug 4930937 for symptoms of the bug.
      SYS.DBMS_LOB.createtemporary(l_lob, TRUE, DBMS_LOB.SESSION);
      SYS.DBMS_LOB.OPEN(l_lob, DBMS_LOB.lob_readwrite);
      firstchunk := jdr_utils.exportdocument(p_old_document_name, l_exportfinished);
      replace_extends(firstchunk);
      handle_ancestorNode(p_old_document_name, p_new_document_name, firstchunk);

      IF (firstchunk IS NULL)
      THEN
         RAISE document_is_null;
      END IF;

      BEGIN
         SYS.DBMS_LOB.writeappend(l_lob, LENGTH(firstchunk), firstchunk);
      EXCEPTION
         WHEN OTHERS
         THEN
            NULL; ---- for negative index to be ignored
      END;

      --There are some issues with having the p_chunk
      --parameter on replace_extends as a CLOB.  For some reason, the getLength on a CLOB for certain
      --JRAD documents was returning a 0, and UI copy procedure was failing.
      --Retaining this parameter as LONG and changing the places where we were
      --calling the procedure to LONG so we be consistent everywhere
      --See Bug 4930937 for symptoms of the bug.
      LOOP
         l_buffer := jdr_utils.exportdocument(NULL, l_exportfinished);
         EXIT WHEN l_buffer IS NULL;
         replace_extends(l_buffer);
         handle_ancestorNode(p_old_document_name, p_new_document_name, l_buffer);
         l_length := LENGTH(l_buffer);
         SYS.DBMS_LOB.writeappend(l_lob, l_length, l_buffer);
      END LOOP;

      l_length := SYS.DBMS_LOB.getlength(l_lob);
      p := xmlparser.newparser;
      xmlparser.parseclob(p, l_lob);
      doc := xmlparser.getdocument(p);
      SYS.DBMS_LOB.CLOSE(l_lob);
      SYS.DBMS_LOB.freetemporary(l_lob);
      l_doc := jdr_docbuilder.createdocument(p_new_document_name);
      top_node := xmldom.makenode(xmldom.getdocumentelement(doc));

      IF (g_toplevel_attr_tbl.COUNT > 0)
      THEN
         FOR i IN g_toplevel_attr_tbl.FIRST .. g_toplevel_attr_tbl.LAST
         LOOP
            BEGIN
               xmldom.removeattribute(xmldom.makeelement(top_node), g_toplevel_attr_tbl(i));
            EXCEPTION
               WHEN OTHERS
               THEN
                  NULL;
            END;
         END LOOP;
      END IF;

      name_space := SUBSTR(xmldom.getnodename(top_node), 1, INSTR(xmldom.getnodename(top_node), ':'));
      tag_name := SUBSTR(xmldom.getnodename(top_node), INSTR(xmldom.getnodename(top_node), ':') + 1);
      top_element := createelement(name_space, tag_name);
      nnm := xmldom.getattributes(top_node);

      IF (xmldom.isnull(nnm) = FALSE)
      THEN
         len2 := xmldom.getlength(nnm);

         FOR i IN 0 .. len2 - 1
         LOOP
            n := xmldom.item(nnm, i);
            attrname := xmldom.getnodename(n);
            attrval := xmldom.getnodevalue(n);
            jdr_docbuilder.setattribute(top_element, attrname, attrval);
         END LOOP;
      END IF;

      jdr_docbuilder.settoplevelelement(l_doc, top_element);

      BEGIN
         exploretree(top_element, top_node, '', ' ');
      EXCEPTION
         WHEN OTHERS
         THEN
            RAISE_APPLICATION_ERROR(-20001, 'EXPLORETREE_ERROR') ;
      END;

      jrad_save_status := jdr_docbuilder.SAVE;
      xmlparser.freeparser(p);
      COMMIT;
      cz_pb_mgr.g_jrad_trans_list := jdr_utils.translationlist();
      cz_pb_mgr.g_jrad_trans_list := jdr_utils.gettranslations(p_old_document_name);

      IF (cz_pb_mgr.g_jrad_trans_list IS NOT NULL)
      THEN
         jdr_utils.savetranslations(p_new_document_name, cz_pb_mgr.g_jrad_trans_list);
      END IF;

      jdr_docbuilder.REFRESH;
      COMMIT;
   EXCEPTION
      WHEN document_is_null
      THEN
         NULL;
      WHEN OTHERS
      THEN
         EXECUTE IMMEDIATE 'BEGIN jdr_docbuilder.refresh; END;';

         RAISE;
   END insert_into_repository;

-------------------------------------------------------
-- p_document_type is used to decide if id replacement on xml doc is needed in a remote model migration session:
-- if it is null (template jrad docs), replacement will be done via collect_chunks -> synch_user_attribute,
-- otherwise (page xml docs), no replacement will be performed.
   PROCEDURE insert_into_repository(p_old_document_name IN VARCHAR2, p_new_document_name IN VARCHAR2, p_link_name IN VARCHAR2 , p_document_type IN VARCHAR2 DEFAULT NULL)
   IS
      document_is_null EXCEPTION;
      l_return_status VARCHAR2(1);
      l_msg_count NUMBER := 0;
      l_msg_data VARCHAR2(2000);
   BEGIN
      pbdebug := 22028;

      IF (cz_pb_mgr.v_server_id <> 0)
      THEN
         jdr_docbuilder.REFRESH;

         IF (p_old_document_name IS NULL)
         THEN
            RAISE document_is_null;
         END IF;

         EXECUTE IMMEDIATE ' begin delete from cz_jrad_chunks' || p_link_name || ' commit; end; ';

         collect_chunks(p_old_document_name, p_new_document_name, p_link_name, l_return_status, l_msg_count, l_msg_data , p_document_type);

         EXECUTE IMMEDIATE ' begin cz_pb_mgr.insert_jrad_docs' || p_link_name || '; end; ';

         EXECUTE IMMEDIATE ' begin delete from cz_jrad_chunks' || p_link_name || '; commit; end; ';
      ELSE
         insert_into_repository(p_old_document_name, p_new_document_name);
      END IF;
   EXCEPTION
      WHEN document_is_null
      THEN
         NULL;
      WHEN EXPLORETREE_ERROR THEN
         fnd_message.set_name('FND', 'FND_AS_UNEXPECTED_ERROR');
         fnd_message.set_token('ERROR_TEXT', SQLERRM);
         fnd_message.set_token('PKG_NAME', 'cz_pb_mgr');
         fnd_message.set_token('PROCEDURE_NAME', 'INSERT_JRAD_DOCS');
         cz_pb_mgr.v_err_message := fnd_message.get;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.EXPLORETREE', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;

         RAISE;
      WHEN OTHERS
      THEN
         EXECUTE IMMEDIATE 'BEGIN jdr_docbuilder.refresh; END;';

         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_JRAD_DOC_ERR', 'JRADDOC', p_old_document_name, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTINTOJRADREPOS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;

         RAISE;
   END insert_into_repository;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----collect from cz_ui_pages
   PROCEDURE bulk_collect_ui_pages
   IS
      l_cz_ui_pages_ui_def_tbl cz_pb_mgr.t_ref;
      l_cz_ui_pages_jrad_doc_tbl varchar_tbl_type;
      l_cz_ui_pages_capt_id_tbl cz_pb_mgr.t_ref;
      l_cz_page_stat_templ_tbl cz_pb_mgr.t_ref;
      l_cz_page_stat_uidef_tbl cz_pb_mgr.t_ref;
      l_cz_ui_pages_pgtmplid_tbl cz_pb_mgr.t_ref;
      l_cz_ui_pages_pgtmplui_tbl cz_pb_mgr.t_ref;
      l_cz_ui_pages_dis_cond_tbl cz_pb_mgr.t_ref;
      l_cz_ui_pages_enb_cond_tbl cz_pb_mgr.t_ref;
      l_cz_ui_pages_expl_node_tbl cz_pb_mgr.t_ref;
      l_rec_count NUMBER;
   BEGIN
      pbdebug := 22029;

      IF (cz_pb_mgr.v_cz_ui_defs_old_oa_ref.COUNT > 0)
      THEN
         cz_pb_mgr.g_cz_ui_pages_ui_def_ref.DELETE;
         cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref.DELETE;
         cz_pb_mgr.g_cz_ui_pages_capt_id_ref.DELETE;
         cz_pb_mgr.g_pages_ui_def_old_ref.DELETE;
         cz_pb_mgr.g_cz_ui_old_jrad_doc_ref.DELETE;
         -- cz_pb_mgr.v_intl_text_ui_tbl.DELETE;
         -- cz_pb_mgr.v_intl_text_model_tbl.DELETE;
         cz_pb_mgr.g_cz_ui_pages_stat_templ.DELETE;
         cz_pb_mgr.g_cz_ui_pages_stat_ui.DELETE;
         cz_pb_mgr.g_cz_uipg_tmplid_tbl.DELETE;
         cz_pb_mgr.g_cz_uipg_tmplui_tbl.DELETE;
         cz_pb_mgr.g_cz_ui_pages_dis_cond_tbl.DELETE;
         cz_pb_mgr.g_cz_ui_pages_enb_cond_tbl.DELETE;
         cz_pb_mgr.g_cz_ui_pages_expl_tbl.DELETE;

         FOR uidef IN cz_pb_mgr.v_cz_ui_defs_old_oa_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_oa_ref.LAST
         LOOP
            l_cz_ui_pages_ui_def_tbl.DELETE;
            l_cz_ui_pages_jrad_doc_tbl.DELETE;
            l_cz_ui_pages_capt_id_tbl.DELETE;
            l_cz_page_stat_templ_tbl.DELETE;
            l_cz_page_stat_uidef_tbl.DELETE;
            l_cz_ui_pages_pgtmplid_tbl.DELETE;
            l_cz_ui_pages_pgtmplui_tbl.DELETE;
            l_cz_ui_pages_dis_cond_tbl.DELETE;
            l_cz_ui_pages_enb_cond_tbl.DELETE;
            l_cz_ui_pages_expl_node_tbl.DELETE;

            SELECT ui_def_id, jrad_doc, caption_text_id, page_status_template_id
                  ,page_status_templ_uidef_id, outer_page_template_id, outer_page_templ_uidef_id, display_condition_id
                  ,enabled_condition_id, pagebase_expl_node_id
            BULK COLLECT INTO l_cz_ui_pages_ui_def_tbl, l_cz_ui_pages_jrad_doc_tbl, l_cz_ui_pages_capt_id_tbl, l_cz_page_stat_templ_tbl
                  ,l_cz_page_stat_uidef_tbl, l_cz_ui_pages_pgtmplid_tbl, l_cz_ui_pages_pgtmplui_tbl, l_cz_ui_pages_dis_cond_tbl
                  ,l_cz_ui_pages_enb_cond_tbl, l_cz_ui_pages_expl_node_tbl
              FROM cz_ui_pages
             WHERE cz_ui_pages.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_oa_ref(uidef) AND cz_ui_pages.deleted_flag = record_not_deleted;

            IF (l_cz_ui_pages_ui_def_tbl.COUNT > 0)
            THEN
               l_rec_count := cz_pb_mgr.g_pages_ui_def_old_ref.COUNT;

               FOR uidefref IN l_cz_ui_pages_ui_def_tbl.FIRST .. l_cz_ui_pages_ui_def_tbl.LAST
               LOOP
                  l_rec_count := l_rec_count + 1;
                 -- cz_pb_mgr.g_cz_ui_pages_ui_def_ref(l_rec_count) := l_cz_ui_pages_ui_def_tbl(uidefref);
                  -- cz_pb_mgr.v_intl_text_ui_tbl(l_rec_count) := l_cz_ui_pages_ui_def_tbl(uidefref);
                  cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref(l_rec_count) := l_cz_ui_pages_jrad_doc_tbl(uidefref);
                  cz_pb_mgr.g_cz_ui_pages_capt_id_ref(l_rec_count) := l_cz_ui_pages_capt_id_tbl(uidefref);
                  cz_pb_mgr.g_pages_ui_def_old_ref(l_rec_count) := l_cz_ui_pages_ui_def_tbl(uidefref);
                  cz_pb_mgr.g_cz_ui_old_jrad_doc_ref(l_rec_count) := l_cz_ui_pages_jrad_doc_tbl(uidefref);
                  cz_pb_mgr.g_cz_ui_pages_stat_templ(l_rec_count) := l_cz_page_stat_templ_tbl(uidefref);
                  cz_pb_mgr.g_cz_ui_pages_stat_ui(l_rec_count) := l_cz_page_stat_uidef_tbl(uidefref);
                  -- cz_pb_mgr.v_intl_text_model_tbl(l_rec_count) := -1;
                  cz_pb_mgr.g_cz_uipg_tmplid_tbl(l_rec_count) := l_cz_ui_pages_pgtmplid_tbl(uidefref);
                  cz_pb_mgr.g_cz_uipg_tmplui_tbl(l_rec_count) := l_cz_ui_pages_pgtmplui_tbl(uidefref);
                  cz_pb_mgr.g_cz_ui_pages_dis_cond_tbl(l_rec_count) := l_cz_ui_pages_dis_cond_tbl(uidefref);
                  cz_pb_mgr.g_cz_ui_pages_enb_cond_tbl(l_rec_count) := l_cz_ui_pages_enb_cond_tbl(uidefref);
                  cz_pb_mgr.g_cz_ui_pages_expl_tbl(l_rec_count) := l_cz_ui_pages_expl_node_tbl(uidefref);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_pages', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIPAGES', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_ui_pages;

-------------------------------------------------------------------------
-------insert into cz_ui_pages
   PROCEDURE insert_into_ui_pages
   IS
      rec_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      pbdebug := 22030;

      IF (cz_pb_mgr.g_pages_ui_def_old_ref.COUNT > 0)
      THEN
         ----resolve  ui_def_id of ui pages
         resolve_ids(cz_pb_mgr.g_pages_ui_def_old_ref,cz_pb_mgr.g_cz_ui_pages_ui_def_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of ui pages');

         -- resolve page status and outer page templates
         IF cz_pb_mgr.v_session_parameter = pub_model OR cz_pb_mgr.v_server_id <> 0 THEN
           resolve_tmpl_ui_defs(g_cz_ui_pages_stat_ui, g_cz_ui_pages_stat_ui, g_cz_ui_pages_stat_templ, v_cz_ui_defs_idx_ref, 'pg status templ uidefs of ui pages');
           resolve_ids(cz_pb_mgr.g_cz_ui_pages_stat_templ, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'pg stat templs of ui pages', ENTITY_TYPE_UCT);
           resolve_tmpl_ui_defs(g_cz_uipg_tmplui_tbl, g_cz_uipg_tmplui_tbl,g_cz_uipg_tmplid_tbl, v_cz_ui_defs_idx_ref, 'outer pg templ uidefs of ui pages');
           resolve_ids(cz_pb_mgr.g_cz_uipg_tmplid_tbl, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'outer page tmpl id of ui pages', ENTITY_TYPE_UCT);
         END IF;

         ----caption ids of ui pages
         resolve_intl_texts(cz_pb_mgr.g_cz_ui_pages_capt_id_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'caption ids of cz ui pages');

         resolve_ids(cz_pb_mgr.g_cz_ui_pages_dis_cond_tbl, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'disabled condition of ui pages');
         resolve_ids(cz_pb_mgr.g_cz_ui_pages_enb_cond_tbl, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'enabled condition of ui pages');
         resolve_ids(cz_pb_mgr.g_cz_ui_pages_expl_tbl, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'expl node id of ui pages');
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_ui_pages_ui_def_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'jrad_doc';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'PAGE_STATUS_TEMPLATE_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_ui_pages_stat_templ';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'PAGE_STATUS_TEMPL_UIDEF_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_ui_pages_stat_ui';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'OUTER_PAGE_TEMPLATE_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_uipg_tmplid_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'OUTER_PAGE_TEMPL_UIDEF_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_uipg_tmplui_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'DISPLAY_CONDITION_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_ui_pages_dis_cond_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ENABLED_CONDITION_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_ui_pages_enb_cond_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'PAGEBASE_EXPL_NODE_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_ui_pages_expl_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'CAPTION_TEXT_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cz_ui_pages_capt_id_ref';
         insert_into_table('cz_ui_pages'
                          ,'ui_def_id'
                          ,'jrad_doc'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.g_pages_ui_def_old_ref'
                          ,'cz_pb_mgr.g_cz_ui_old_jrad_doc_ref'
                          ,cz_pb_mgr.g_pages_ui_def_old_ref
                          ,cz_pb_mgr.g_cz_ui_old_jrad_doc_ref
                          );
      END IF;
   END insert_into_ui_pages;

----------------------------------------------------------
---------bulk collect ui page sets
   PROCEDURE bulk_collect_page_sets
   IS
      l_rec_count NUMBER := 0;
      l_page_sets_ui_tbl cz_pb_mgr.t_ref;
      l_page_sets_pg_tbl cz_pb_mgr.t_ref;
      l_pagebase_expl_tbl cz_pb_mgr.t_ref;
      l_train_jrad_doc_tbl varchar_type_tbl;
   BEGIN
      pbdebug := 22031;

      IF (cz_pb_mgr.v_cz_ui_defs_old_oa_ref.COUNT > 0)
      THEN
         cz_pb_mgr.g_page_sets_ui_old_ref.DELETE;
         cz_pb_mgr.g_page_sets_ui_ref.DELETE;
         cz_pb_mgr.g_page_sets_pg_tbl.DELETE;
         cz_pb_mgr.g_page_sets_jrad_doc_ref.DELETE;
         cz_pb_mgr.g_page_sets_expl_tbl.DELETE;

         FOR uidef IN cz_pb_mgr.v_cz_ui_defs_old_oa_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_oa_ref.LAST
         LOOP
            SELECT ui_def_id, page_set_id, train_jrad_doc, pagebase_expl_node_id
            BULK COLLECT INTO l_page_sets_ui_tbl, l_page_sets_pg_tbl, l_train_jrad_doc_tbl, l_pagebase_expl_tbl
              FROM cz_ui_page_sets
             WHERE cz_ui_page_sets.deleted_flag = record_not_deleted AND cz_ui_page_sets.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_oa_ref(uidef);

            IF (l_page_sets_ui_tbl.COUNT > 0)
            THEN
               l_rec_count := cz_pb_mgr.g_page_sets_ui_old_ref.COUNT;

               FOR pageset IN l_page_sets_ui_tbl.FIRST .. l_page_sets_ui_tbl.LAST
               LOOP
                  l_rec_count := l_rec_count + 1;
                  cz_pb_mgr.g_page_sets_ui_old_ref(l_rec_count) := l_page_sets_ui_tbl(pageset);
                  --cz_pb_mgr.g_page_sets_ui_ref(l_rec_count) := l_page_sets_ui_tbl(pageset);
                  cz_pb_mgr.g_page_sets_pg_tbl(l_rec_count) := l_page_sets_pg_tbl(pageset);
                  cz_pb_mgr.g_page_sets_jrad_doc_ref(l_rec_count) := l_train_jrad_doc_tbl(pageset);
                  cz_pb_mgr.g_page_sets_expl_tbl(l_rec_count) := l_pagebase_expl_tbl(pageset);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_page_sets', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIPAGESETS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_page_sets;

---------------------------------------------------------------
----insert into cz_ui_page_sets
   PROCEDURE insert_into_ui_page_sets
   IS
      rec_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      IF (cz_pb_mgr.g_page_sets_ui_old_ref.COUNT > 0)
      THEN
         pbdebug := 22032;
         ----resolve  ui_def_id of page sets
         resolve_ids(cz_pb_mgr.g_page_sets_ui_old_ref,cz_pb_mgr.g_page_sets_ui_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of page sets');
         resolve_ids(cz_pb_mgr.g_page_sets_expl_tbl, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'expl node id of page sets');
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_sets_ui_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'train_jrad_doc';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_sets_jrad_doc_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'pagebase_expl_node_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_sets_expl_tbl';
         insert_into_table('cz_ui_page_sets'
                          ,'ui_def_id'
                          ,'page_set_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.g_page_sets_ui_old_ref'
                          ,'cz_pb_mgr.g_page_sets_pg_tbl'
                          ,cz_pb_mgr.g_page_sets_ui_old_ref
                          ,cz_pb_mgr.g_page_sets_pg_tbl
                          );
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_ui_page_sets', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UIPAGESETS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END insert_into_ui_page_sets;

------------------------------------------------------------------------
-----bulk collect from page refs
   PROCEDURE bulk_collect_page_refs
   IS
      l_page_refs_set_id_tbl cz_pb_mgr.t_ref;
      l_page_refs_ui_def_tbl cz_pb_mgr.t_ref;
      l_page_refs_pg_ref_id_tbl cz_pb_mgr.t_ref;
      l_page_refs_cond_id_tbl cz_pb_mgr.t_ref;
      l_page_refs_capt_id_tbl cz_pb_mgr.t_ref;
      l_page_refs_prop_id_tbl cz_pb_mgr.t_ref;
      l_page_refs_tgt_ui_tbl cz_pb_mgr.t_ref;
      l_page_refs_tgt_pg_set_tbl cz_pb_mgr.t_ref;
      l_page_refs_tgt_pg_id_tbl cz_pb_mgr.t_ref;
      l_page_refs_pg_set_tbl cz_pb_mgr.t_ref;
      l_page_refs_pg_ref_tbl cz_pb_mgr.t_ref;
      l_page_refs_tgt_expl_tbl cz_pb_mgr.t_ref;
      l_page_refs_cpt_rule_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.v_cz_ui_defs_old_oa_ref.COUNT > 0)
      THEN
         cz_pb_mgr.g_page_refs_ui_def_old_ref.DELETE;
         cz_pb_mgr.g_page_refs_ui_def_new_ref.DELETE;
         cz_pb_mgr.g_page_refs_cond_id_ref.DELETE;
         cz_pb_mgr.g_page_refs_capt_id_ref.DELETE;
         cz_pb_mgr.g_page_refs_tgt_ui_ref.DELETE;
         cz_pb_mgr.g_page_refs_pg_set_ref.DELETE;
         cz_pb_mgr.g_page_refs_pg_ref_ref.DELETE;
         -- cz_pb_mgr.v_intl_text_ui_tbl.DELETE;
         -- cz_pb_mgr.v_intl_text_model_tbl.DELETE;
         cz_pb_mgr.g_page_refs_tgt_expl_tbl.DELETE;
         cz_pb_mgr.g_page_refs_cpt_rule_tbl.DELETE;
         pbdebug := 22033;

         FOR uidef IN cz_pb_mgr.v_cz_ui_defs_old_oa_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_oa_ref.LAST
         LOOP
            l_page_refs_ui_def_tbl.DELETE;
            l_page_refs_cond_id_tbl.DELETE;
            l_page_refs_capt_id_tbl.DELETE;
            l_page_refs_tgt_ui_tbl.DELETE;
            l_page_refs_tgt_expl_tbl.DELETE;
            l_page_refs_cpt_rule_tbl.DELETE;

            SELECT ui_def_id, page_set_id, page_ref_id, condition_id, caption_text_id
                  ,target_ui_def_id, target_expl_node_id, caption_rule_id
            BULK COLLECT INTO l_page_refs_ui_def_tbl, l_page_refs_pg_set_tbl, l_page_refs_pg_ref_tbl, l_page_refs_cond_id_tbl, l_page_refs_capt_id_tbl
                  ,l_page_refs_tgt_ui_tbl, l_page_refs_tgt_expl_tbl, l_page_refs_cpt_rule_tbl
              FROM cz_ui_page_refs
             WHERE cz_ui_page_refs.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_oa_ref(uidef) AND cz_ui_page_refs.deleted_flag = record_not_deleted;

            IF (l_page_refs_ui_def_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.g_page_refs_ui_def_old_ref.COUNT;

               FOR pageref IN l_page_refs_ui_def_tbl.FIRST .. l_page_refs_ui_def_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                 -- cz_pb_mgr.g_page_refs_ui_def_new_ref(rec_count) := l_page_refs_ui_def_tbl(pageref);
                  cz_pb_mgr.g_page_refs_ui_def_old_ref(rec_count) := l_page_refs_ui_def_tbl(pageref);
                  -- cz_pb_mgr.v_intl_text_ui_tbl(rec_count) := l_page_refs_ui_def_tbl(pageref);
                  -- cz_pb_mgr.v_intl_text_model_tbl(rec_count) := -1;
                  cz_pb_mgr.g_page_refs_pg_set_ref(rec_count) := l_page_refs_pg_set_tbl(pageref);
                  cz_pb_mgr.g_page_refs_pg_ref_ref(rec_count) := l_page_refs_pg_ref_tbl(pageref);
                  cz_pb_mgr.g_page_refs_cond_id_ref(rec_count) := l_page_refs_cond_id_tbl(pageref);
                  cz_pb_mgr.g_page_refs_capt_id_ref(rec_count) := l_page_refs_capt_id_tbl(pageref);
                  cz_pb_mgr.g_page_refs_tgt_ui_ref(rec_count) := l_page_refs_tgt_ui_tbl(pageref);
                  cz_pb_mgr.g_page_refs_tgt_expl_tbl(rec_count) := l_page_refs_tgt_expl_tbl(pageref);
                  cz_pb_mgr.g_page_refs_cpt_rule_tbl(rec_count) := l_page_refs_cpt_rule_tbl(pageref);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_page_refs', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIPAGEREFS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_page_refs;

-------------------------------------------------
------insert into page refs
   PROCEDURE insert_into_ui_page_refs
   IS
      rec_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      IF (cz_pb_mgr.g_page_refs_ui_def_old_ref.COUNT > 0)
      THEN
         pbdebug := 22034;
         ----resolve  ui_def_id
         resolve_ids(cz_pb_mgr.g_page_refs_ui_def_old_ref,cz_pb_mgr.g_page_refs_ui_def_new_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of page sets');
         ---create rules for g_page_refs_cond_id_ref
         resolve_ids(cz_pb_mgr.g_page_refs_cpt_rule_tbl, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'caption rule id of page sets');
         resolve_ids(cz_pb_mgr.g_page_refs_cond_id_ref, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'condition id of page sets');
         ----caption ids of ui pages
         -----insert_intl_texts(cz_pb_mgr.g_page_refs_capt_id_ref,'caption ids of cz ui page refs');
         resolve_intl_texts(cz_pb_mgr.g_page_refs_capt_id_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'caption ids of cz ui page refs');
         ----resolve expl id
         resolve_ids(cz_pb_mgr.g_page_refs_tgt_expl_tbl, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'expl ids of page refs');
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_refs_ui_def_new_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'caption_text_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_refs_capt_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'target_ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_refs_tgt_ui_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'target_expl_node_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_refs_tgt_expl_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'caption_rule_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_refs_cpt_rule_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'condition_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_page_refs_cond_id_ref';
         -- should call resolve_ids instead
         resolve_ref_ids_not_found(cz_pb_mgr.g_page_refs_ui_def_new_ref
                                  ,cz_pb_mgr.v_cz_ui_defs_old_ref
                                  ,cz_pb_mgr.v_cz_ui_defs_idx_ref
                                  ,cz_pb_mgr.g_page_refs_tgt_ui_ref
                                  ,'cz_ui_page_refs.target_ui_def_id'
                                  ,cz_pb_mgr.v_status_code
                                  );
         insert_into_table('cz_ui_page_refs'
                          ,'ui_def_id'
                          ,'page_set_id'
                          ,'page_ref_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.g_page_refs_ui_def_old_ref'
                          ,'cz_pb_mgr.g_page_refs_pg_set_ref'
                          ,'cz_pb_mgr.g_page_refs_pg_ref_ref'
                          ,cz_pb_mgr.g_page_refs_ui_def_old_ref
                          ,cz_pb_mgr.g_page_refs_pg_set_ref
                          ,cz_pb_mgr.g_page_refs_pg_ref_ref
                          );
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_ui_page_refs', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UIPAGEREFS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END insert_into_ui_page_refs;

--------------------------------------------------
-----bulk collect from ui refs
   PROCEDURE bulk_collect_ui_refs
   IS
      l_ui_refs_ui_def_tbl cz_pb_mgr.t_ref;
      l_ui_refs_ref_ui_def_tbl cz_pb_mgr.t_ref;
      l_ui_refs_expl_id_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.v_cz_ui_defs_old_oa_ref.COUNT > 0)
      THEN
         cz_pb_mgr.g_ui_refs_old_ui_def_ref.DELETE;
         cz_pb_mgr.g_ui_refs_new_ui_def_ref.DELETE;
         cz_pb_mgr.g_ui_refs_ref_ui_def_ref.DELETE;
         cz_pb_mgr.g_ui_refs_expl_id_ref.DELETE;
         cz_pb_mgr.g_ui_refs_ref_ui_def_old_ref.DELETE;
         cz_pb_mgr.g_ui_refs_expl_id_old_ref.DELETE;

         FOR uidef IN cz_pb_mgr.v_cz_ui_defs_old_oa_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_oa_ref.LAST
         LOOP
            l_ui_refs_ui_def_tbl.DELETE;
            l_ui_refs_ref_ui_def_tbl.DELETE;
            l_ui_refs_expl_id_tbl.DELETE;

            SELECT ui_def_id, ref_ui_def_id, model_ref_expl_id
            BULK COLLECT INTO l_ui_refs_ui_def_tbl, l_ui_refs_ref_ui_def_tbl, l_ui_refs_expl_id_tbl
              FROM cz_ui_refs
             WHERE cz_ui_refs.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_oa_ref(uidef) AND cz_ui_refs.deleted_flag = record_not_deleted;

            IF (l_ui_refs_ui_def_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.g_ui_refs_old_ui_def_ref.COUNT;

               FOR uiref IN l_ui_refs_ui_def_tbl.FIRST .. l_ui_refs_ui_def_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.g_ui_refs_old_ui_def_ref(rec_count) := l_ui_refs_ui_def_tbl(uiref);
                 -- cz_pb_mgr.g_ui_refs_new_ui_def_ref(rec_count) := l_ui_refs_ui_def_tbl(uiref);
                  cz_pb_mgr.g_ui_refs_ref_ui_def_ref(rec_count) := l_ui_refs_ref_ui_def_tbl(uiref);
                  cz_pb_mgr.g_ui_refs_ref_ui_def_old_ref(rec_count) := l_ui_refs_ref_ui_def_tbl(uiref);
                  cz_pb_mgr.g_ui_refs_expl_id_ref(rec_count) := l_ui_refs_expl_id_tbl(uiref);
                  cz_pb_mgr.g_ui_refs_expl_id_old_ref(rec_count) := l_ui_refs_expl_id_tbl(uiref);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_refs', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIREFS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_ui_refs;

-----------------------------------------------------------------
------insert into cz_ui_refs
   PROCEDURE insert_into_ui_refs
   IS
      rec_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      IF (cz_pb_mgr.g_ui_refs_old_ui_def_ref.COUNT > 0)
      THEN
         ----resolve  ui_def_id
         resolve_ids(cz_pb_mgr.g_ui_refs_old_ui_def_ref,cz_pb_mgr.g_ui_refs_new_ui_def_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of ui refs');
         ----resolve  model ref expl id
         resolve_ids(cz_pb_mgr.g_ui_refs_expl_id_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'expl ids of page refs');
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_refs_new_ui_def_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ref_ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_refs_ref_ui_def_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'model_ref_expl_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_refs_expl_id_ref';
         -- should call resolve_ids instead
         resolve_ref_ids_not_found(cz_pb_mgr.g_ui_refs_new_ui_def_ref
                                  ,cz_pb_mgr.v_cz_ui_defs_old_ref
                                  ,cz_pb_mgr.v_cz_ui_defs_idx_ref
                                  ,cz_pb_mgr.g_ui_refs_ref_ui_def_ref
                                  ,'cz_ui_refs.ref_ui_def_id'
                                  ,cz_pb_mgr.v_status_code
                                  );
         insert_into_table('cz_ui_refs'
                          ,'ui_def_id'
                          ,'ref_ui_def_id'
                          ,'model_ref_expl_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.g_ui_refs_old_ui_def_ref'
                          ,'cz_pb_mgr.g_ui_refs_ref_ui_def_old_ref'
                          ,'cz_pb_mgr.g_ui_refs_expl_id_old_ref'
                          ,cz_pb_mgr.g_ui_refs_old_ui_def_ref
                          ,cz_pb_mgr.g_ui_refs_ref_ui_def_old_ref
                          ,cz_pb_mgr.g_ui_refs_expl_id_old_ref
                          );
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_ui_refs', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UIREFS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END;

------------------------------------------------------------
-----bulk collect from ui ps maps
   PROCEDURE bulk_collect_ui_ps_maps
   IS
      l_ui_ps_maps_ui_def_tbl cz_pb_mgr.t_ref;
      l_ui_ps_maps_ctrl_tmp_tbl cz_pb_mgr.t_ref;
      l_ui_ps_maps_page_id_tbl cz_pb_mgr.t_ref;
      l_ui_ps_maps_expl_id_tbl cz_pb_mgr.t_ref;
      l_ui_ps_maps_elem_sig_tbl cz_pb_mgr.t_ref;
      l_ui_ps_maps_ctrl_temp_ui_tbl cz_pb_mgr.t_ref;
      l_ui_ps_maps_element_tbl varchar_type_tbl;
      l_ui_ps_maps_tgt_pg_ui_def_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.v_cz_ui_defs_old_oa_ref.COUNT > 0)
      THEN
         cz_pb_mgr.g_ui_ps_maps_old_ui_def_ref.DELETE;
         cz_pb_mgr.g_ui_ps_maps_new_ui_def_ref.DELETE;
         cz_pb_mgr.g_ui_ps_maps_ctrl_tmp_ref.DELETE;
         cz_pb_mgr.g_ui_ps_maps_page_id_tbl.DELETE;
         cz_pb_mgr.g_ui_ps_maps_element_tbl.DELETE;
         cz_pb_mgr.g_ui_ps_maps_expl_id_tbl.DELETE;
         cz_pb_mgr.g_ui_ps_maps_templ_ui_tbl.DELETE;
         cz_pb_mgr.g_ui_ps_maps_elem_sig_tbl.DELETE;
         cz_pb_mgr.g_ui_ps_maps_tgt_pg_ui_def_tbl.DELETE;

         FOR uidef IN cz_pb_mgr.v_cz_ui_defs_old_oa_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_oa_ref.LAST
         LOOP
            l_ui_ps_maps_ui_def_tbl.DELETE;
            l_ui_ps_maps_ctrl_tmp_tbl.DELETE;
            l_ui_ps_maps_page_id_tbl.DELETE;
            l_ui_ps_maps_element_tbl.DELETE;
            l_ui_ps_maps_expl_id_tbl.DELETE;
            l_ui_ps_maps_ctrl_temp_ui_tbl.DELETE;
            l_ui_ps_maps_elem_sig_tbl.DELETE;
            l_ui_ps_maps_tgt_pg_ui_def_tbl.DELETE;

            BEGIN
               SELECT ui_def_id, ctrl_template_id, page_id, element_id
                     ,model_ref_expl_id, ctrl_template_ui_def_id, element_signature_id, target_page_ui_def_id
               BULK COLLECT INTO l_ui_ps_maps_ui_def_tbl, l_ui_ps_maps_ctrl_tmp_tbl, l_ui_ps_maps_page_id_tbl, l_ui_ps_maps_element_tbl
                     ,l_ui_ps_maps_expl_id_tbl, l_ui_ps_maps_ctrl_temp_ui_tbl, l_ui_ps_maps_elem_sig_tbl, l_ui_ps_maps_tgt_pg_ui_def_tbl
                 FROM cz_ui_page_elements
                WHERE cz_ui_page_elements.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_oa_ref(uidef)
                  AND cz_ui_page_elements.deleted_flag = record_not_deleted;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
            END;

            IF (l_ui_ps_maps_ui_def_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.g_ui_ps_maps_old_ui_def_ref.COUNT;

               FOR uimap IN l_ui_ps_maps_ui_def_tbl.FIRST .. l_ui_ps_maps_ui_def_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.g_ui_ps_maps_old_ui_def_ref(rec_count) := l_ui_ps_maps_ui_def_tbl(uimap);
                 -- cz_pb_mgr.g_ui_ps_maps_new_ui_def_ref(rec_count) := l_ui_ps_maps_ui_def_tbl(uimap);
                  cz_pb_mgr.g_ui_ps_maps_ctrl_tmp_ref(rec_count) := l_ui_ps_maps_ctrl_tmp_tbl(uimap);
                  cz_pb_mgr.g_ui_ps_maps_page_id_tbl(rec_count) := l_ui_ps_maps_page_id_tbl(uimap);
                  cz_pb_mgr.g_ui_ps_maps_element_tbl(rec_count) := l_ui_ps_maps_element_tbl(uimap);
                  cz_pb_mgr.g_ui_ps_maps_expl_id_tbl(rec_count) := l_ui_ps_maps_expl_id_tbl(uimap);
                  cz_pb_mgr.g_ui_ps_maps_templ_ui_tbl(rec_count) := l_ui_ps_maps_ctrl_temp_ui_tbl(uimap);
                  cz_pb_mgr.g_ui_ps_maps_elem_sig_tbl(rec_count) := l_ui_ps_maps_elem_sig_tbl(uimap);
                  cz_pb_mgr.g_ui_ps_maps_tgt_pg_ui_def_tbl(rec_count) := l_ui_ps_maps_tgt_pg_ui_def_tbl(uimap);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_ps_maps', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIPSMAPS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_ui_ps_maps;

------------------------------------------------------------------------
----insert into ui_ps_maps
   PROCEDURE insert_ui_ps_maps
   IS
      rec_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      IF (cz_pb_mgr.g_ui_ps_maps_old_ui_def_ref.COUNT > 0)
      THEN
         ----resolve  ui_def_id
         resolve_ids(cz_pb_mgr.g_ui_ps_maps_old_ui_def_ref,cz_pb_mgr.g_ui_ps_maps_new_ui_def_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of ui ps maps');

         IF cz_pb_mgr.v_session_parameter = pub_model OR cz_pb_mgr.v_server_id <> 0 THEN
           resolve_tmpl_ui_defs(cz_pb_mgr.g_ui_ps_maps_templ_ui_tbl, cz_pb_mgr.g_ui_ps_maps_ctrl_tmp_ref, 'ctrl tmp ui def ids of ui ps maps');
           resolve_ids(cz_pb_mgr.g_ui_ps_maps_ctrl_tmp_ref, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'ctrl template id of ui ps maps', ENTITY_TYPE_UCT);
         END IF;

         resolve_ids(cz_pb_mgr.g_ui_ps_maps_expl_id_tbl, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'model ref expl id of page elements');
         resolve_ids(cz_pb_mgr.g_ui_ps_maps_elem_sig_tbl, cz_pb_mgr.v_sig_idx_ref, 'element_signature id of page elements', ENTITY_TYPE_SIGNATURE);

         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_ps_maps_new_ui_def_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ctrl_template_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_ps_maps_ctrl_tmp_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'model_ref_expl_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_ps_maps_expl_id_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ctrl_template_ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_ps_maps_templ_ui_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'element_signature_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_ps_maps_elem_sig_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'TARGET_PAGE_UI_DEF_ID';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_ps_maps_tgt_pg_ui_def_tbl';
         -- should call resolve_ids instead
         resolve_ref_ids_not_found(cz_pb_mgr.g_ui_ps_maps_new_ui_def_ref
                                  ,cz_pb_mgr.v_cz_ui_defs_old_ref
                                  ,cz_pb_mgr.v_cz_ui_defs_idx_ref
                                  ,cz_pb_mgr.g_ui_ps_maps_tgt_pg_ui_def_tbl
                                  ,'cz_ui_page_elements.target_page_ui_def_id'
                                  ,cz_pb_mgr.v_status_code
                                  );
         insert_into_table('cz_ui_page_elements'
                          ,'ui_def_id'
                          ,'page_id'
                          ,'element_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.g_ui_ps_maps_old_ui_def_ref'
                          ,'cz_pb_mgr.g_ui_ps_maps_page_id_tbl'
                          ,'cz_pb_mgr.g_ui_ps_maps_element_tbl'
                          ,cz_pb_mgr.g_ui_ps_maps_old_ui_def_ref
                          ,cz_pb_mgr.g_ui_ps_maps_page_id_tbl
                          ,cz_pb_mgr.g_ui_ps_maps_element_tbl
                          );
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_ui_page_elements', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UIPSMAPS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END insert_ui_ps_maps;
------------------------------------------------------------
   PROCEDURE insert_template_elements(
      p_template_id IN NUMBER
     ,p_ui_def_id IN NUMBER
     ,p_element_type IN NUMBER
     ,p_element_id IN NUMBER
     ,p_persistent_element_id IN NUMBER
     ,p_link_name IN VARCHAR2
   )
   IS
      l_str VARCHAR2(2000);

   --Bug 5525718 - In case of migration the ui_def_id should be 0

     l_ui_def_id              NUMBER := 1;
     l_persistent_element_id  CZ_UI_TEMPLATE_ELEMENTS.persistent_element_id%TYPE := p_persistent_element_id;

   BEGIN

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
       l_ui_def_id := 0;
       l_persistent_element_id := p_element_id;
      END IF;

      l_str :=
            'insert into cz_ui_template_elements'
         || p_link_name
         || '  (TEMPLATE_ID,UI_DEF_ID,'
         || ' '
         || 'ELEMENT_TYPE,ELEMENT_ID,PERSISTENT_ELEMENT_ID,DELETED_FLAG,seeded_flag)'
         || ' '
         || 'VALUES (:1,:2,:3,:4,:5,''0'',''0'') ';

      EXECUTE IMMEDIATE l_str
                  USING p_template_id,l_ui_def_id, p_element_type, p_element_id, l_persistent_element_id;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END insert_template_elements;

-----------------------------------------
   PROCEDURE update_template_elements(p_template_id IN NUMBER, p_ui_def_id IN NUMBER, p_link_name IN VARCHAR2)
   IS
      l_str VARCHAR2(2000);
   BEGIN
      l_str :=
           'DELETE FROM cz_ui_template_elements' || p_link_name || '  t' || ' ' || 'WHERE t.template_id =  :1' || ' ' || 'AND t.ui_def_id   = :2' ;

      EXECUTE IMMEDIATE l_str
                  USING p_template_id, p_ui_def_id;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END update_template_elements;

-------------------------------------------
   PROCEDURE create_uit_publication(
      p_template_id IN NUMBER
     ,p_old_templ_id IN NUMBER
     ,p_source_tgt_flag IN VARCHAR2
     ,p_link_name IN VARCHAR2
     ,p_server_id IN NUMBER
     ,p_src_id IN NUMBER
     ,p_tgt_id IN NUMBER
   )
   IS
      l_inst_str VARCHAR2(2000);
      l_uit_date DATE;
      l_applicable_from DATE := cz_utils.epoch_begin;
      l_applicable_until DATE := cz_utils.epoch_end;
      l_status NUMBER := 0;
      l_ref_cursor ref_cursor;
      l_src_pb_id cz_model_publications.publication_id%TYPE;
      l_tgt_pb_id cz_model_publications.publication_id%TYPE;
      l_pub_mode cz_model_publications.publication_mode%TYPE := cz_model_migration_pvt.mode_publication;
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         l_inst_str :=
               'UPDATE cz_model_publications'
            || p_link_name
            || ' t'
            || ' '
            || 'SET   t.last_update_date = sysdate'
            || ' '
            || 'WHERE t.object_id = :1'
            || ' '
            || 'AND  t.object_type = ''UIT'''
            || ' '
            || 'AND  t.server_id = :2'
            || ' '
            || 'AND  t.source_target_flag = :3'
            || ' '
            || 'AND  t.deleted_flag = ''0'' ';

         EXECUTE IMMEDIATE l_inst_str
                     USING p_template_id, cz_pb_mgr.v_server_id, p_source_tgt_flag;

         IF (SQL%ROWCOUNT = 0)
         THEN
            IF (p_source_tgt_flag = g_source_flag)
            THEN
               l_src_pb_id := p_src_id;
               l_tgt_pb_id := p_tgt_id;
            ELSIF(p_source_tgt_flag = g_target_flag)
            THEN
               l_src_pb_id := p_tgt_id;
               l_tgt_pb_id := p_src_id;
            END IF;

            l_inst_str :=
                  'INSERT INTO cz_model_publications'
               || p_link_name
               || ' '
               || '(PUBLICATION_ID,'
               || ' '
               || 'MODEL_ID,'
               || ' '
               || 'OBJECT_ID,'
               || ' '
               || 'OBJECT_TYPE,'
               || ' '
               || 'SERVER_ID,'
               || ' '
               || 'PUBLICATION_MODE,'
               || ' '
               || 'UI_DEF_ID,'
               || ' '
               || 'UI_STYLE,'
               || ' '
               || 'APPLICABLE_FROM,'
               || ' '
               || 'APPLICABLE_UNTIL,'
               || ' '
               || 'EXPORT_STATUS,'
               || ' '
               || 'DELETED_FLAG,'
               || ' '
               || 'MODEL_LAST_STRUCT_UPDATE,'
               || ' '
               || 'MODEL_LAST_LOGIC_UPDATE,'
               || ' '
               || 'MODEL_LAST_UPDATED,'
               || ' '
               || 'SOURCE_TARGET_FLAG,'
               || ' '
               || 'SOURCE_MODEL_ID,'
               || ' '
               || 'disabled_flag,'
               || ' '
               || 'remote_publication_id )'
               || ' '
               || 'SELECT :1,:2,:3,''UIT'',:4,'''
               || l_pub_mode
               || ''',1,7,:5,:6,''OK'',''0'',sysdate,sysdate,sysdate,:7,:8, 0,:9 FROM  dual';

            EXECUTE IMMEDIATE l_inst_str
                        USING l_src_pb_id
                             ,p_template_id
                             ,p_template_id
                             ,p_server_id
                             ,l_applicable_from
                             ,l_applicable_until
                             ,p_source_tgt_flag
                             ,p_old_templ_id
                             ,l_tgt_pb_id;
         END IF;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_model_publications', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_RULES', SQLCODE);
         RAISE;
   END create_uit_publication;

--------------------------------
   PROCEDURE insert_template_elements
   IS
      l_src_pb_id NUMBER;
      l_tgt_pb_id NUMBER;
      rec_count NUMBER := 0;

      l_upd_template_ids_tbl t_ref;
      l_str                  VARCHAR2(4000);
      l_ui_def_id            NUMBER;

   BEGIN
      IF ((cz_pb_mgr.l_template_id_ref.COUNT > 0) AND(cz_pb_mgr.v_session_parameter <> model_copy) AND(cz_pb_mgr.v_status_code <> PUBLICATION_ERROR))
      THEN

         IF (CZ_PB_MGR.v_session_parameter = cz_model_migration_pvt.migrate_model)
         THEN
           l_ui_def_id := 0;
         ELSE
           l_ui_def_id := 1;
         END IF;

         l_str := 'update cz_ui_templates'|| CZ_PB_MGR.v_db_link || '  set template_rev_nbr=template_rev_nbr+1 '
                   || ' where template_id=:1 and ui_def_id=:2';

         FOR i IN l_template_id_ref.FIRST..l_template_id_ref.LAST
         LOOP
           IF NOT(l_upd_template_ids_tbl.EXISTS(l_template_id_ref(i))) THEN
             update_template_elements(l_template_id_ref(i), l_ui_def_id, CZ_PB_MGR.v_db_link);

             IF l_ui_def_id = 0 THEN -- bump up template_rev_nvr only in case of Migration --
                EXECUTE IMMEDIATE l_str
                  USING CZ_PB_MGR.l_template_id_ref(i), l_ui_def_id;
             END IF;

             l_upd_template_ids_tbl(l_template_id_ref(i)) := i;
           END IF;
         END LOOP;

         --Removing a call to resolve_ids here. The problem with this call is that l_element_id_ref table contains elements of all
         --types (rules, texts and actions), while the resolution was made against g_ui_actions_id_idx_ref, which contains only
         --actions. So, there was a possibility that some other element type id will get overriden. The resolution is moved to the
         --collect_global_actions procedure.
         FOR i IN CZ_PB_MGR.l_template_id_ref.FIRST .. CZ_PB_MGR.l_template_id_ref.LAST
         LOOP
            -----insert into cz_ui_template_elements
            insert_template_elements(CZ_PB_MGR.l_template_id_ref(i)
                                    ,l_ui_def_id
                                    ,CZ_PB_MGR.l_element_type_ref(i)
                                    ,CZ_PB_MGR.l_element_id_ref(i)
                                    ,CZ_PB_MGR.l_pers_elem_ref(i)
                                    ,CZ_PB_MGR.v_db_link
                                    );
         END LOOP;

      END IF;

      COMMIT;

      IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model AND cz_pb_mgr.g_ui_templates_old_temp_id_ref.COUNT > 0)
      THEN
         -- array already has the new ids
         -- resolve_ids(cz_pb_mgr.g_ui_templates_new_temp_id_ref, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'resolve global templates');

         FOR i IN cz_pb_mgr.g_ui_templates_old_temp_id_ref.FIRST .. cz_pb_mgr.g_ui_templates_old_temp_id_ref.LAST
         LOOP
            IF (cz_pb_mgr.g_ui_templates_ui_def_old_ref(i) = 0)
            THEN
               SELECT cz_model_publications_s.NEXTVAL
                 INTO l_src_pb_id
                 FROM DUAL;

               l_tgt_pb_id :=
                  cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_model_publications_seq
                                             , 'cz_model_publications_s.nextval' || cz_pb_mgr.v_db_link
                                             ,cz_pb_mgr.v_oraclesequenceincr
                                             );

          --     IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model) THEN
                  create_uit_publication(cz_pb_mgr.g_ui_templates_old_temp_id_ref(i)
                                        ,cz_pb_mgr.g_ui_templates_old_temp_id_ref(i)
                                        ,g_source_flag
                                        ,' '
                                        ,cz_pb_mgr.v_server_id
                                        ,l_src_pb_id
                                        ,l_tgt_pb_id
                                        );
                  create_uit_publication(cz_pb_mgr.g_ui_templates_new_temp_id_ref(i)
                                        ,cz_pb_mgr.g_ui_templates_old_temp_id_ref(i)
                                        ,g_target_flag
                                        ,cz_pb_mgr.v_db_link
                                        ,cz_pb_mgr.v_server_id
                                        ,l_src_pb_id
                                        ,l_tgt_pb_id
                                        );
          --     END IF;
            END IF;
         END LOOP;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
        cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
        cz_pb_mgr.v_err_message  := SQLERRM;
        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'INSERT_TEMPLATE_ELEMENTS', SQLCODE);
        cz_pb_mgr.global_export_retcode := 2;
        rollback_data(cz_pb_mgr.v_db_link);
        RAISE;
   END insert_template_elements;

------------------------------------------------------------
----insert into cz_ui_templates
   PROCEDURE insert_ui_templates
   IS
      rec_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      failed_to_lock_template EXCEPTION;
      failed_to_unlock_template EXCEPTION;
      l_locked_templates cz_security_pvt.number_type_tbl;
      l_templates_to_lock cz_security_pvt.number_type_tbl;
      l_return_status VARCHAR2(1);
      l_msg_count NUMBER;
      l_msg_data VARCHAR2(2000);
      l_msg_index NUMBER;
   BEGIN
      IF (cz_pb_mgr.g_ui_templates_old_temp_id_ref.COUNT = 0) THEN RETURN; END IF;

         ----lock content templates to be moved
         FOR i IN cz_pb_mgr.g_ui_templates_old_temp_id_ref.FIRST .. cz_pb_mgr.g_ui_templates_old_temp_id_ref.LAST
         LOOP
            l_templates_to_lock(l_templates_to_lock.COUNT + 1) := cz_pb_mgr.g_ui_templates_old_temp_id_ref(i);
         END LOOP;

         cz_security_pvt.lock_template(1.0
                                      ,l_templates_to_lock
                                      ,fnd_api.g_true
                                      ,fnd_api.g_true
                                      ,l_locked_templates
                                      ,l_return_status
                                      ,l_msg_count
                                      ,l_msg_data
                                      );

         IF (l_return_status <> FND_API.G_RET_STS_SUCCESS)
         THEN
            RAISE failed_to_lock_template;
         END IF;

         -----resplve templates
         --bug 5191745
         --before the fix, even for model migration, the ui_def_ids were being populated
         --with a value of '1' for CZ_UI_TEMPLATES record.
         --The ideal fix would have been to call 'resolve_tmpl_ui_defs' on its own, because
         --'resolve_tmpl_ui_defs' already checks for model migration condition
         --and assigns the ui_def_id correctly.
         --But there is a possibility that it would introduce regression in publishing
         --and taking the safer route here.
         IF (cz_pb_mgr.v_session_parameter = pub_model)
         THEN
            resolve_ids(cz_pb_mgr.g_ui_templates_ui_def_new_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'resolving ui defs of templates');
         ELSE
            resolve_tmpl_ui_defs(cz_pb_mgr.g_ui_templates_ui_def_new_ref, cz_pb_mgr.g_ui_templates_old_temp_id_ref, 'resolving ui defs of templates');
         END IF;
         -----resolve button bar templates
         resolve_tmpl_ui_defs(cz_pb_mgr.g_ui_templates_but_uidef_id, cz_pb_mgr.g_ui_templates_button_tbl, 'button templates ui def');
         resolve_ids(cz_pb_mgr.g_ui_templates_button_tbl, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'buton templates of ui templates', ENTITY_TYPE_UCT);

         ----copy xml doc
         -- IF (cz_pb_mgr.g_ui_templates_jrad_new_ref.COUNT > 0) THEN
            FOR doc IN cz_pb_mgr.g_ui_templates_jrad_new_ref.FIRST .. cz_pb_mgr.g_ui_templates_jrad_new_ref.LAST
            LOOP
               IF (cz_pb_mgr.g_ui_templates_jrad_new_ref(doc) IS NOT NULL)
               THEN
                  insert_into_repository(cz_pb_mgr.g_ui_templates_jrad_old_ref(doc), cz_pb_mgr.g_ui_templates_jrad_new_ref(doc), cz_pb_mgr.v_db_link);
               END IF;
            END LOOP;
         -- END IF;

         -- main msg and title intl text records handled in insert_jrad_ui_intl_texts
         resolve_intl_texts(cz_pb_mgr.g_ui_templates_msg_id_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'main message ids of cz ui templates');
         resolve_intl_texts(cz_pb_mgr.g_ui_templates_title_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'title ids of cz ui templates');

         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'template_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_new_temp_id_ref';

         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'main_message_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_msg_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'title_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_title_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_ui_def_new_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'jrad_doc';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_jrad_new_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'button_bar_template_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_button_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'button_bar_templ_uidef_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_but_uidef_id';

         insert_into_table('CZ_UI_TEMPLATES'
                             ,'template_id'
                             ,'ui_def_id'
                             ,cz_pb_mgr.v_db_link
                             ,plsql_table_list
                             ,'cz_pb_mgr.g_ui_templates_old_temp_id_ref'
                             ,'cz_pb_mgr.g_ui_templates_ui_def_old_ref'
                             ,cz_pb_mgr.g_ui_templates_old_temp_id_ref
                             ,cz_pb_mgr.g_ui_templates_ui_def_old_ref
                             );
         IF(cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model) THEN
            refresh_global_templates(cz_pb_mgr.g_ui_templates_old_temp_id_ref);
         END IF;

         IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
            ----------begin insert into cz_rp_entries----------------
            plsql_table_list.DELETE;
            rec_count := 1;
            plsql_table_list(rec_count).col_name := 'object_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_new_temp_id_ref';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'object_type';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_templates_obj_type';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'enclosing_folder';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_enclosing_fld_rp_entry';
            insert_into_rp_entries('cz_rp_entries'
                                  ,'object_id'
                                  ,'object_type'
                                  ,cz_pb_mgr.v_db_link
                                  ,plsql_table_list
                                  ,'cz_pb_mgr.g_ui_templates_old_temp_id_ref'
                                  ,'cz_pb_mgr.g_ui_templates_obj_type'
                                  ,cz_pb_mgr.g_ui_templates_old_temp_id_ref
                                  ,cz_pb_mgr.g_ui_templates_obj_type
                                  );
         ----------end insert into cz_rp_entries----------------
         END IF;
      -- END IF;

      cz_security_pvt.unlock_template(1.0, l_locked_templates, fnd_api.g_true, fnd_api.g_true, l_return_status, l_msg_count, l_msg_data);

      IF (l_return_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         RAISE failed_to_unlock_template;
      END IF;
   EXCEPTION
      WHEN failed_to_lock_template
      THEN
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         l_msg_index := 1;

         WHILE l_msg_count > 0
         LOOP
            l_msg_data := fnd_msg_pub.get(l_msg_index, fnd_api.g_false);
            cz_pb_mgr.error_msg_populate(l_msg_data, 'cz_pb_mgr.CZINSERTTEMPLATES', SQLCODE);
            l_msg_index := l_msg_index + 1;
            l_msg_count := l_msg_count - 1;
         END LOOP;

         cz_security_pvt.unlock_template(1.0, l_locked_templates, fnd_api.g_true, fnd_api.g_true, l_return_status, l_msg_count, l_msg_data);
         raise_application_error('-20020', 'FAILED_TO_LOCK_TEMPLATE');
      WHEN failed_to_unlock_template
      THEN
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         l_msg_index := 1;

         WHILE l_msg_count > 0
         LOOP
            l_msg_data := fnd_msg_pub.get(l_msg_index, fnd_api.g_false);
            cz_pb_mgr.error_msg_populate(l_msg_data, 'cz_pb_mgr.CZINSERTTEMPLATES', SQLCODE);
            l_msg_index := l_msg_index + 1;
            l_msg_count := l_msg_count - 1;
         END LOOP;

         raise_application_error('-20030', 'FAILED_TO_UNLOCK_TEMPLATE');
      WHEN OTHERS
      THEN
         cz_security_pvt.unlock_template(1.0, l_locked_templates, fnd_api.g_true, fnd_api.g_true, l_return_status, l_msg_count, l_msg_data);
         RAISE;
   END insert_ui_templates;

--------------------------------------------------------------
----bulk collect from cz_ui_cont_type_templs
   PROCEDURE bulk_collect_cont_type_templs(p_cz_ui_defs_old_oa_ref cz_pb_mgr.t_ref)
   IS
      l_cnt_typ_tmpls_tmpid_tbl cz_pb_mgr.t_ref;
      l_cnt_typ_tmpls_uidef_tbl cz_pb_mgr.t_ref;
      l_cnt_typ_tmpls_tgtuidef_tbl cz_pb_mgr.t_ref;
      l_cnt_typ_tmpls_cont_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
   BEGIN
      IF (p_cz_ui_defs_old_oa_ref.COUNT > 0)
      THEN
         cz_pb_mgr.g_cnt_typ_tmpls_tmpid_ref.DELETE;
         cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref.DELETE;
         cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref.DELETE;

         FOR uidef IN p_cz_ui_defs_old_oa_ref.FIRST .. p_cz_ui_defs_old_oa_ref.LAST
         LOOP
            l_cnt_typ_tmpls_tmpid_tbl.DELETE;
            l_cnt_typ_tmpls_uidef_tbl.DELETE;
            l_cnt_typ_tmpls_cont_tbl.DELETE;
            l_cnt_typ_tmpls_tgtuidef_tbl.DELETE;

            IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
            THEN
               SELECT ui_def_id, template_id, template_ui_def_id, content_type
               BULK COLLECT INTO l_cnt_typ_tmpls_uidef_tbl, l_cnt_typ_tmpls_tmpid_tbl, l_cnt_typ_tmpls_tgtuidef_tbl, l_cnt_typ_tmpls_cont_tbl
                 FROM cz_ui_cont_type_templs
                WHERE cz_ui_cont_type_templs.ui_def_id = p_cz_ui_defs_old_oa_ref(uidef) AND cz_ui_cont_type_templs.deleted_flag = record_not_deleted;
            ELSE
               SELECT ui_def_id, template_id, template_ui_def_id, content_type
               BULK COLLECT INTO l_cnt_typ_tmpls_uidef_tbl, l_cnt_typ_tmpls_tmpid_tbl, l_cnt_typ_tmpls_tgtuidef_tbl, l_cnt_typ_tmpls_cont_tbl
                 FROM cz_ui_cont_type_templs
                WHERE cz_ui_cont_type_templs.ui_def_id = p_cz_ui_defs_old_oa_ref(uidef)
                  AND cz_ui_cont_type_templs.seeded_flag <> seed_data
                  AND cz_ui_cont_type_templs.deleted_flag = record_not_deleted
                  AND cz_ui_cont_type_templs.master_template_flag <> '1';
            END IF;

            IF (l_cnt_typ_tmpls_uidef_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref.COUNT;

               FOR uitmp IN l_cnt_typ_tmpls_uidef_tbl.FIRST .. l_cnt_typ_tmpls_uidef_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.g_cnt_typ_tmpls_tmpid_ref(rec_count) := l_cnt_typ_tmpls_tmpid_tbl(uitmp);
                  cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref(rec_count) := l_cnt_typ_tmpls_uidef_tbl(uitmp);
                 -- cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref(rec_count) := l_cnt_typ_tmpls_uidef_tbl(uitmp);
                  cz_pb_mgr.g_cnt_typ_tmpls_tgtuidef_ref(rec_count) := l_cnt_typ_tmpls_tgtuidef_tbl(uitmp);
                  cz_pb_mgr.g_cnt_typ_tmpls_cont_ref(rec_count) := l_cnt_typ_tmpls_cont_tbl(uitmp);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_cont_templates', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UICONTTEMPLATES', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_cont_type_templs;

--------------------------------------------------------------------------
----bulk collect from cz_ui_cont_type_templs
   PROCEDURE bulk_collect_ui_actions(p_old_ui_def_tbl IN cz_pb_mgr.t_ref)
   IS
      l_ui_actns_ui_act_id_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ui_uidef_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ui_tgtui_tbl cz_pb_mgr.t_ref;
      l_ui_actns_tgtexpl_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ctx_comp_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ren_cond_tbl cz_pb_mgr.t_ref;
      l_prcpg_templ_tbl cz_pb_mgr.t_ref;
      l_prcpg_tmpui_tbl cz_pb_mgr.t_ref;
      l_prc_caption_tbl cz_pb_mgr.t_ref;
      l_pg_title_tbl    cz_pb_mgr.t_ref;
      l_main_msg_tbl    cz_pb_mgr.t_ref;
      rec_count NUMBER;
   BEGIN
      IF (p_old_ui_def_tbl.COUNT > 0) THEN
         rec_count := cz_pb_mgr.g_ui_actns_ui_act_id_ref.COUNT;

         FOR uidef IN p_old_ui_def_tbl.FIRST .. p_old_ui_def_tbl.LAST
         LOOP
            l_ui_actns_ui_act_id_tbl.DELETE;
            l_ui_actns_ui_uidef_tbl.DELETE;
            l_ui_actns_ui_tgtui_tbl.DELETE;
            l_ui_actns_tgtexpl_tbl.DELETE;
            l_ui_actns_ctx_comp_tbl.DELETE;
            l_ui_actns_ren_cond_tbl.DELETE;
            l_prcpg_templ_tbl.DELETE;
	    l_prcpg_tmpui_tbl.DELETE;
	    l_prc_caption_tbl.DELETE;
	    l_pg_title_tbl.DELETE;
            l_main_msg_tbl.DELETE;

            SELECT ui_action_id, ui_def_id, target_ui_def_id, target_expl_node_id, context_component_id
                  ,render_condition_id, PROCESSING_PAGE_TEMPL_ID, PROC_PAGE_TEMPL_UI_DEF_ID
                  ,PROCESSING_CAPTION_TEXT_ID, PAGE_TITLE_TEXT_ID, MAIN_MESSAGE_TEXT_ID
            BULK COLLECT INTO l_ui_actns_ui_act_id_tbl, l_ui_actns_ui_uidef_tbl, l_ui_actns_ui_tgtui_tbl
                  ,l_ui_actns_tgtexpl_tbl, l_ui_actns_ctx_comp_tbl, l_ui_actns_ren_cond_tbl
                  ,l_prcpg_templ_tbl,l_prcpg_tmpui_tbl,l_prc_caption_tbl,l_pg_title_tbl,l_main_msg_tbl
              FROM cz_ui_actions
             WHERE cz_ui_actions.ui_def_id = p_old_ui_def_tbl(uidef)
               AND cz_ui_actions.deleted_flag = record_not_deleted
               AND cz_ui_actions.seeded_flag <> seed_data;

-- Processing page ER#9656558
-- insert processing page related texts here
		insert_intl_texts(l_prc_caption_tbl, 'processing page caption intl texts');
		insert_intl_texts(l_pg_title_tbl, 'processing page title intl texts');
		insert_intl_texts(l_main_msg_tbl, 'processing page main message intl texts');

            IF (l_ui_actns_ui_act_id_tbl.COUNT > 0) THEN
               FOR uitmp IN l_ui_actns_ui_act_id_tbl.FIRST .. l_ui_actns_ui_act_id_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.g_ui_actns_ui_act_id_ref(rec_count) := l_ui_actns_ui_act_id_tbl(uitmp);
                  cz_pb_mgr.g_ui_actns_ui_act_id_old_ref(rec_count) := l_ui_actns_ui_act_id_tbl(uitmp);
                  cz_pb_mgr.g_ui_actns_ui_tgtui_ref(rec_count) := l_ui_actns_ui_tgtui_tbl(uitmp);
                  cz_pb_mgr.g_ui_actns_ui_uidef_old_ref(rec_count) := l_ui_actns_ui_uidef_tbl(uitmp);
                  cz_pb_mgr.g_ui_actns_tgtexpl_ref(rec_count) := l_ui_actns_tgtexpl_tbl(uitmp);
                  cz_pb_mgr.g_ui_actns_ctx_comp_tbl(rec_count) := l_ui_actns_ctx_comp_tbl(uitmp);
                  cz_pb_mgr.g_ui_actns_ren_cond_tbl(rec_count) := l_ui_actns_ren_cond_tbl(uitmp);
                  cz_pb_mgr.g_uiact_prcpg_templ_tbl(rec_count) := l_prcpg_templ_tbl(uitmp);
                  cz_pb_mgr.g_uiact_prcpg_tmpui_tbl(rec_count) := l_prcpg_tmpui_tbl(uitmp);
                  cz_pb_mgr.g_uiact_prc_caption_tbl(rec_count) := l_prc_caption_tbl(uitmp);
                  cz_pb_mgr.g_uiact_pg_title_tbl(rec_count) := l_pg_title_tbl(uitmp);
                  cz_pb_mgr.g_uiact_main_msg_tbl(rec_count) := l_main_msg_tbl(uitmp);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_actions', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIACTIONS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_ui_actions;

----------------------------------------------------------
----bulk collect from cz_ui_cont_type_templs
   PROCEDURE bulk_collect_ui_images(p_old_ui_def_tbl cz_pb_mgr.t_ref)
   IS
      l_ui_images_ui_tbl cz_pb_mgr.t_ref;
      l_ui_images_usg_tbl cz_pb_mgr.t_ref;
      l_ui_images_enty_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
   BEGIN
      IF (p_old_ui_def_tbl.COUNT > 0)
      THEN
         cz_pb_mgr.v_ui_images_ui_ref.DELETE;
         cz_pb_mgr.v_ui_images_ui_tbl.DELETE;
         cz_pb_mgr.v_ui_images_usg_tbl.DELETE;
         cz_pb_mgr.v_ui_images_enty_tbl.DELETE;

         FOR uidef IN p_old_ui_def_tbl.FIRST .. p_old_ui_def_tbl.LAST
         LOOP
            l_ui_images_ui_tbl.DELETE;

            SELECT ui_def_id, image_usage_code, entity_code
            BULK COLLECT INTO l_ui_images_ui_tbl, l_ui_images_usg_tbl, l_ui_images_enty_tbl
              FROM cz_ui_images
             WHERE cz_ui_images.ui_def_id = p_old_ui_def_tbl(uidef)
               AND cz_ui_images.deleted_flag = record_not_deleted
               AND cz_ui_images.seeded_flag <> seed_data;

            IF (l_ui_images_ui_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.v_ui_images_ui_tbl.COUNT;

               FOR uitmp IN l_ui_images_ui_tbl.FIRST .. l_ui_images_ui_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                 -- cz_pb_mgr.v_ui_images_ui_ref(rec_count) := l_ui_images_ui_tbl(uitmp);
                  cz_pb_mgr.v_ui_images_ui_tbl(rec_count) := l_ui_images_ui_tbl(uitmp);
                  cz_pb_mgr.v_ui_images_usg_tbl(rec_count) := l_ui_images_usg_tbl(uitmp);
                  cz_pb_mgr.v_ui_images_enty_tbl(rec_count) := l_ui_images_enty_tbl(uitmp);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_images', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIIMAGES', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_ui_images;

----------------------------------------------------------
----procedure that returns global templates
   PROCEDURE get_global_templates(
      p_templates_tbl IN cz_pb_mgr.t_ref
     ,x_global_templates_tbl OUT NOCOPY cz_pb_mgr.t_ref
     ,x_not_global_templ_tbl OUT NOCOPY cz_pb_mgr.t_ref
   )
   IS
      rec_count NUMBER := 0;
      l_tmp_id NUMBER := 0;
   BEGIN
      IF (p_templates_tbl.COUNT > 0)
      THEN
         FOR tempid IN p_templates_tbl.FIRST .. p_templates_tbl.LAST
         LOOP
            BEGIN
               SELECT 1
                 INTO l_tmp_id
                 FROM cz_ui_templates
                WHERE cz_ui_templates.ui_def_id IS NULL AND cz_ui_templates.template_id = p_templates_tbl(tempid);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  l_tmp_id := 0;
            END;

            IF (l_tmp_id = 1)
            THEN
               rec_count := x_global_templates_tbl.COUNT + 1;
               x_global_templates_tbl(rec_count) := p_templates_tbl(tempid);
            ELSE
               rec_count := x_global_templates_tbl.COUNT + 1;
               x_not_global_templ_tbl(rec_count) := p_templates_tbl(tempid);
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END get_global_templates;

-----------------------------------------------------------------------------
   PROCEDURE copy_jrad_docs
   IS
      l_new_document VARCHAR2(255);
   BEGIN
      pbdebug := 22035;

      IF (cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref.COUNT > 0)
      THEN
         FOR doc IN cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref.FIRST .. cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref.LAST
         LOOP
            l_new_document :=
               REPLACE(cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref(doc)
                      ,TO_CHAR(cz_pb_mgr.g_pages_ui_def_old_ref(doc))
                      ,TO_CHAR(cz_pb_mgr.v_cz_ui_defs_idx_ref(cz_pb_mgr.g_pages_ui_def_old_ref(doc)))
                      );
            insert_into_repository(cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref(doc), l_new_document, cz_pb_mgr.v_db_link , 'UI_PAGE');
            cz_pb_mgr.g_cz_ui_pages_jrad_doc_ref(doc) := l_new_document;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END copy_jrad_docs;

---------------------------------------------------------------------
   PROCEDURE copy_train_docs
   IS
      l_new_document VARCHAR2(255);
   BEGIN
      IF (cz_pb_mgr.g_page_sets_jrad_doc_ref.COUNT > 0)
      THEN
         FOR doc IN cz_pb_mgr.g_page_sets_jrad_doc_ref.FIRST .. cz_pb_mgr.g_page_sets_jrad_doc_ref.LAST
         LOOP
            l_new_document :=
               REPLACE(cz_pb_mgr.g_page_sets_jrad_doc_ref(doc)
                      ,'ui' || TO_CHAR(cz_pb_mgr.g_page_sets_ui_old_ref(doc))
                      ,'ui' || TO_CHAR(cz_pb_mgr.v_cz_ui_defs_idx_ref(cz_pb_mgr.g_page_sets_ui_old_ref(doc)))
                      );
            insert_into_repository(cz_pb_mgr.g_page_sets_jrad_doc_ref(doc), l_new_document, cz_pb_mgr.v_db_link, 'ui page set');
            cz_pb_mgr.g_page_sets_jrad_doc_ref(doc) := l_new_document;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END copy_train_docs;

---------------------------------------------
   PROCEDURE insert_ref_templates
   IS
      l_template_id_tbl cz_pb_mgr.t_ref;
      l_ref_template_id_tbl cz_pb_mgr.t_ref;
      l_template_ui_tbl cz_pb_mgr.t_ref;
      l_ref_templ_ui_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      IF (cz_pb_mgr.g_ui_templates_old_temp_id_ref.COUNT > 0)
      THEN
         cz_pb_mgr.g_template_id_ref.DELETE;
         cz_pb_mgr.g_ref_template_id_ref.DELETE;
         cz_pb_mgr.g_template_ui_ref.DELETE;
         cz_pb_mgr.g_ref_templ_ui_ref.DELETE;
         cz_pb_mgr.g_template_id_old_ref.DELETE;
         cz_pb_mgr.g_ref_template_id_old_ref.DELETE;

         FOR i IN cz_pb_mgr.g_ui_templates_old_temp_id_ref.FIRST .. cz_pb_mgr.g_ui_templates_old_temp_id_ref.LAST
         LOOP
            l_template_id_tbl.DELETE;
            l_ref_template_id_tbl.DELETE;
            l_template_ui_tbl.DELETE;
            l_ref_templ_ui_tbl.DELETE;

            BEGIN
               SELECT template_id, ref_template_id, template_ui_def_id, ref_template_ui_def_id
               BULK COLLECT INTO l_template_id_tbl, l_ref_template_id_tbl, l_template_ui_tbl, l_ref_templ_ui_tbl
                 FROM cz_ui_ref_templates
                WHERE cz_ui_ref_templates.template_id = cz_pb_mgr.g_ui_templates_old_temp_id_ref(i) AND cz_ui_ref_templates.deleted_flag = '0';
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
            END;

            IF (l_template_id_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.g_TEMPLATE_ID_old_ref.COUNT;

               FOR j IN l_template_id_tbl.FIRST .. l_template_id_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                 -- cz_pb_mgr.g_template_id_ref(rec_count) := l_template_id_tbl(j);
                  cz_pb_mgr.g_ref_template_id_ref(rec_count) := l_ref_template_id_tbl(j);
                  cz_pb_mgr.g_ref_template_id_old_ref(rec_count) := l_ref_template_id_tbl(j);
                  cz_pb_mgr.g_template_ui_ref(rec_count) := l_template_ui_tbl(j);
                  cz_pb_mgr.g_ref_templ_ui_ref(rec_count) := l_ref_templ_ui_tbl(j);
                  cz_pb_mgr.g_template_id_old_ref(rec_count) := l_template_id_tbl(j);
               END LOOP;
            END IF;
         END LOOP;

         resolve_ids(cz_pb_mgr.g_TEMPLATE_ID_old_ref,cz_pb_mgr.g_template_id_ref, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'resolve template id of ref templates');
         resolve_ids(cz_pb_mgr.g_ref_template_id_ref, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'resolve ref template id of ref templates', ENTITY_TYPE_UCT);
         resolve_tmpl_ui_defs(cz_pb_mgr.g_template_ui_ref, cz_pb_mgr.g_template_id_old_ref, 'resolve template ui def of ref templates');
         resolve_tmpl_ui_defs(cz_pb_mgr.g_ref_templ_ui_ref, cz_pb_mgr.g_ref_template_id_old_ref, 'resolve ref template ui def of ref templates');
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'template_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_TEMPLATE_ID_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ref_template_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_REF_TEMPLATE_ID_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'template_ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_TEMPLATE_UI_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ref_template_ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_REF_TEMPL_UI_ref';
         insert_into_table('CZ_UI_REF_TEMPLATES'
                          ,'template_id'
                          ,'ref_template_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.g_TEMPLATE_ID_old_ref'
                          ,'cz_pb_mgr.g_REF_TEMPLATE_ID_old_ref'
                          ,cz_pb_mgr.g_template_id_old_ref
                          ,cz_pb_mgr.g_ref_template_id_old_ref
                          );
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END insert_ref_templates;

------------------------------------------------------
   PROCEDURE export_signatures(p_sig_array IN t_ref)
   IS
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      l_signature_new_tbl cz_pb_mgr.t_ref;
      l_signature_old_tbl cz_pb_mgr.t_ref;
      l_arg_sig_tbl cz_pb_mgr.t_ref;
      l_data_sig_tbl cz_pb_mgr.t_ref;
      l_sig_count NUMBER := 0;
      rec_count NUMBER := 0;
      l_arg_ind_tbl cz_pb_mgr.t_ref;
   BEGIN
      IF (p_sig_array.COUNT > 0)
      THEN
         cz_pb_mgr.v_sig_new_ref.DELETE;
         cz_pb_mgr.v_sig_old_ref.DELETE;
         cz_pb_mgr.v_sig_idx_ref.DELETE;
         cz_pb_mgr.v_arg_sig_old_tbl.DELETE;
         cz_pb_mgr.v_arg_sig_tbl.DELETE;
         cz_pb_mgr.v_data_sig_tbl.DELETE;

         FOR sigid IN p_sig_array.FIRST .. p_sig_array.LAST
         LOOP
            l_signature_old_tbl.DELETE;
            l_signature_new_tbl.DELETE;

            BEGIN
               SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_signatures_seq
                                                 , 'cz_signatures_s.nextval' || cz_pb_mgr.v_db_link
                                                 ,cz_pb_mgr.v_oraclesequenceincr
                                                 )
                     ,signature_id
               BULK COLLECT INTO l_signature_new_tbl
                     ,l_signature_old_tbl
                 FROM cz_signatures
                WHERE cz_signatures.signature_id = p_sig_array(sigid)
                  AND cz_signatures.deleted_flag = record_not_deleted
                  AND cz_signatures.seeded_flag <> seed_data;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
            END;

            IF (l_signature_old_tbl.COUNT > 0)
            THEN
               FOR i IN l_signature_old_tbl.FIRST .. l_signature_old_tbl.LAST
               LOOP
                  IF (NOT cz_pb_mgr.v_sig_idx_ref.EXISTS(l_signature_old_tbl(i)))
                  THEN
                     l_sig_count := cz_pb_mgr.v_sig_new_ref.COUNT + 1;
                     cz_pb_mgr.v_sig_new_ref(l_sig_count) := l_signature_new_tbl(i);
                     cz_pb_mgr.v_sig_old_ref(l_sig_count) := l_signature_old_tbl(i);
                     cz_pb_mgr.v_sig_idx_ref(l_signature_old_tbl(i)):=l_signature_new_tbl(i);
                  END IF;
               END LOOP;
            END IF;
         END LOOP;

         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'signature_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_sig_new_ref';
         insert_into_table('cz_signatures', 'signature_id', cz_pb_mgr.v_db_link, plsql_table_list, 'cz_pb_mgr.v_sig_old_ref', cz_pb_mgr.v_sig_old_ref);
      END IF;

      IF (cz_pb_mgr.v_sig_old_ref.COUNT > 0)
      THEN
         FOR j IN cz_pb_mgr.v_sig_old_ref.FIRST .. cz_pb_mgr.v_sig_old_ref.LAST
         LOOP
            SELECT argument_signature_id, datatype_signature_id, argument_index
            BULK COLLECT INTO l_arg_sig_tbl, l_data_sig_tbl, l_arg_ind_tbl
              FROM cz_signature_arguments
             WHERE cz_signature_arguments.argument_signature_id = cz_pb_mgr.v_sig_old_ref(j)
               AND cz_signature_arguments.deleted_flag = record_not_deleted
               AND cz_signature_arguments.seeded_flag <> seed_data;

            IF (l_arg_sig_tbl.COUNT > 0)
            THEN
               FOR k IN l_arg_sig_tbl.FIRST .. l_arg_sig_tbl.LAST
               LOOP
                  l_sig_count := cz_pb_mgr.v_arg_sig_old_tbl.COUNT + 1;
                  cz_pb_mgr.v_arg_sig_old_tbl(l_sig_count) := l_arg_sig_tbl(k);
                 -- cz_pb_mgr.v_arg_sig_tbl(l_sig_count) := l_arg_sig_tbl(k);
                  cz_pb_mgr.v_data_sig_tbl(l_sig_count) := l_data_sig_tbl(k);
                  cz_pb_mgr.v_arg_ind_old_tbl(l_sig_count) := l_arg_ind_tbl(k);
               END LOOP;
            END IF;
         END LOOP;

         ----resolve ids
         resolve_ids(cz_pb_mgr.v_arg_sig_old_tbl,cz_pb_mgr.v_arg_sig_tbl, cz_pb_mgr.v_sig_idx_ref, 'arg sig ids cz signature arguments');
         resolve_ids(cz_pb_mgr.v_data_sig_tbl, cz_pb_mgr.v_sig_idx_ref, 'data sig ids cz signature arguments', ENTITY_TYPE_SIGNATURE);
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'argument_signature_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_arg_sig_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'datatype_signature_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_data_sig_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'argument_index';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_arg_ind_old_tbl';
         insert_into_table('cz_signature_arguments'
                          ,'argument_signature_id'
                          ,'argument_index'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.v_arg_sig_old_tbl'
                          ,'cz_pb_mgr.v_arg_ind_old_tbl'
                          ,cz_pb_mgr.v_arg_sig_old_tbl
                          ,cz_pb_mgr.v_arg_ind_old_tbl
                          );
         l_signature_new_tbl.DELETE;
         l_signature_old_tbl.DELETE;
         l_arg_sig_tbl.DELETE;
         l_data_sig_tbl.DELETE;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Insert into signature sets for: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SIGNATURESETS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END export_signatures;

-------------------------------------------------------------------------------
   PROCEDURE insert_jrad_ui_intl_texts
   IS
      l_intl_text_id_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
   BEGIN
      cz_pb_mgr.g_intl_text_id_ref.DELETE;

      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0) THEN
         FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
         LOOP
            l_intl_text_id_tbl.DELETE;

            BEGIN
               SELECT intl_text_id
               BULK COLLECT INTO l_intl_text_id_tbl
                 FROM cz_intl_texts txt, cz_ui_defs ui
                WHERE txt.model_id = cz_pb_mgr.v_models_to_be_exported(i)
                  AND txt.deleted_flag = '0'
                  AND NVL(txt.seeded_flag, '0') = '0'
                  AND NVL(txt.ui_def_id, -1) = ui.ui_def_id
                  AND txt.model_id = ui.devl_project_id
                  AND ui.deleted_flag = '0' AND ui_style = g_ui_style_jrad;
            EXCEPTION
               WHEN NO_DATA_FOUND THEN
                  NULL;
            END;

            IF (l_intl_text_id_tbl.COUNT > 0) THEN
               FOR j IN l_intl_text_id_tbl.FIRST .. l_intl_text_id_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.g_intl_text_id_ref(rec_count) := l_intl_text_id_tbl(j);
               END LOOP;
            END IF;
         END LOOP;

        IF (rec_count > 0) THEN
          insert_intl_texts(CZ_PB_MGR.g_intl_text_id_ref, 'caption texts of JRAD UI');
        END IF;
      END IF;

      -- main msg and title ids collected in get_oa_tmpls
      IF cz_pb_mgr.g_ui_templates_msg_id_ref.COUNT > 0 THEN
        rec_count := 0;
        CZ_PB_MGR.g_intl_text_id_ref.DELETE;

        FOR i IN cz_pb_mgr.g_ui_templates_msg_id_ref.FIRST .. cz_pb_mgr.g_ui_templates_msg_id_ref.LAST LOOP
          IF cz_pb_mgr.g_ui_templates_msg_id_ref(i) IS NOT NULL THEN
            rec_count := rec_count + 1;
            cz_pb_mgr.g_intl_text_id_ref(rec_count) := cz_pb_mgr.g_ui_templates_msg_id_ref(i);
          END IF;
          IF cz_pb_mgr.g_ui_templates_title_ref(i) IS NOT NULL THEN
            rec_count := rec_count + 1;
            cz_pb_mgr.g_intl_text_id_ref(rec_count) := cz_pb_mgr.g_ui_templates_title_ref(i);
          END IF;
        END LOOP;

        IF (rec_count > 0) THEN
          insert_intl_texts(CZ_PB_MGR.g_intl_text_id_ref, 'template msg and title texts', TRUE);
        END IF;
      END IF;

   EXCEPTION
      WHEN OTHERS THEN
         cz_pb_mgr.v_err_message := 'Bulk Collect of intl texts of JRAD UI: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'INSERTJRADUIINTLTEXTS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END insert_jrad_ui_intl_texts;

-------------------------------------------------------------------------------
------copying OA style UI(s)
   PROCEDURE export_oa_uis
   IS
      rec_count NUMBER := 0;
      row_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      l_new_document VARCHAR2(255);
   BEGIN
      ----insert intl texts of JRAD UI(s)
      insert_jrad_ui_intl_texts;
      ----insert into cz_ui_templates
      insert_ui_templates;
      -----insert ref templates
      insert_ref_templates;
      ----collect ui pages
      bulk_collect_ui_pages;
      ----copy jrad docs
      copy_jrad_docs;
      ------insert into ui pages
      insert_into_ui_pages;
      ----collect page sets
      bulk_collect_page_sets;
      copy_train_docs;
      insert_into_ui_page_sets;
      -----bulk collect from page refs
      bulk_collect_page_refs;
      ----insert into cz_ui_page_refs
      insert_into_ui_page_refs;
      -----bulk collect from ui refs
      bulk_collect_ui_refs;
      ----insert into cz_ui_refs
      insert_into_ui_refs;
      -----bulk collect from ui ps maps
      bulk_collect_ui_ps_maps;
      ----insert into cz_ui_page_elements
      export_signatures(cz_pb_mgr.g_ui_ps_maps_elem_sig_tbl);
      insert_ui_ps_maps;

      -- A master template carries its own set of content templates
      -- need to resolved everything and insert separately for master templates
      -- for local migration, cz_pb_mgr.v_new_mt_id_tbl should be empty
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_new_mt_id_tbl.COUNT > 0)
      THEN
         --collect content templates
         bulk_collect_cont_type_templs(cz_pb_mgr.v_mt_old_id_tbl);
         --resolve template ids
         resolve_ids(cz_pb_mgr.g_cnt_typ_tmpls_tmpid_ref, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'tmpl ids of ui def of cont type tmpls', ENTITY_TYPE_UCT);
         --resolve ui def ids
         resolve_ids(cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref,cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref, cz_pb_mgr.v_mt_old_to_new_id, 'ui def ids of ui def of cont type tmpls');
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'template_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cnt_typ_tmpls_tmpid_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'template_ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cnt_typ_tmpls_tgtuidef_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'content_type';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cnt_typ_tmpls_cont_ref';
         insert_into_table('cz_ui_cont_type_templs'
                          ,'content_type'
                          ,'ui_def_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.g_cnt_typ_tmpls_cont_ref'
                          ,'cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref'
                          ,cz_pb_mgr.g_cnt_typ_tmpls_cont_ref
                          ,cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref
                          );
        row_count:=cz_pb_mgr.l_cnt_typ_tmpls_new_uidef_ref.COUNT;
        IF (g_cnt_typ_tmpls_new_uidef_ref.COUNT >0) THEN
           FOR i in cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref.FIRST .. cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref.LAST
           LOOP
             row_count:=row_count+1;
             cz_pb_mgr.l_cnt_typ_tmpls_cont_ref(row_count):=cz_pb_mgr.g_cnt_typ_tmpls_cont_ref(i);
             cz_pb_mgr.l_cnt_typ_tmpls_new_uidef_ref(row_count):=cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref(i);
          END LOOP;
        END IF;
      END IF;

      ----resolve  ui_def_id
      bulk_collect_cont_type_templs(cz_pb_mgr.v_cz_ui_defs_old_oa_ref);

      resolve_ids(cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref,cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of cont type tmpls');

      ----resolve tmp ui_def_id, template id
      IF cz_pb_mgr.v_session_parameter = pub_model OR cz_pb_mgr.v_server_id <> 0 THEN
        resolve_tmpl_ui_defs(cz_pb_mgr.g_cnt_typ_tmpls_tgtuidef_ref, cz_pb_mgr.g_cnt_typ_tmpls_tmpid_ref, 'tmpl uidefs of cz_ui_cont_type_templs');
        resolve_ids(cz_pb_mgr.g_cnt_typ_tmpls_tmpid_ref, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'tmpl ids of ui def of cont type tmpls', ENTITY_TYPE_UCT);
      END IF;

      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'ui_def_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'template_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cnt_typ_tmpls_tmpid_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'template_ui_def_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cnt_typ_tmpls_tgtuidef_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'content_type';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_cnt_typ_tmpls_cont_ref';
      insert_into_table('cz_ui_cont_type_templs'
                       ,'content_type'
                       ,'ui_def_id'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.g_cnt_typ_tmpls_cont_ref'
                       ,'cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref'
                       ,cz_pb_mgr.g_cnt_typ_tmpls_cont_ref
                       ,cz_pb_mgr.g_cnt_typ_tmpls_old_uidef_ref
                       );
      row_count:=cz_pb_mgr.l_cnt_typ_tmpls_new_uidef_ref.COUNT;
      IF (g_cnt_typ_tmpls_new_uidef_ref.COUNT > 0) THEN
         FOR i in cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref.FIRST .. cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref.LAST
         LOOP
              row_count:=row_count+1;
              cz_pb_mgr.l_cnt_typ_tmpls_cont_ref(row_count):=cz_pb_mgr.g_cnt_typ_tmpls_cont_ref(i);
              cz_pb_mgr.l_cnt_typ_tmpls_new_uidef_ref(row_count):=cz_pb_mgr.g_cnt_typ_tmpls_new_uidef_ref(i);
         END LOOP;
      END IF;

      ----bulk collect ui actions
      bulk_collect_ui_actions(cz_pb_mgr.v_cz_ui_defs_old_oa_ref);

      -- Note g_ui_actns_ui_act_id_ref contains both local ui actions (bulk_collect_ui_actions)
      -- and global ones (collect_global_actions). The 'new' ids in this array are the same old
      -- ids as the ones in g_ui_actns_ui_act_id_old_ref. They are real new ids only when the
      -- session is remote migration and the actions are globals.

      ----resolve  ui_def_id
      resolve_ids(cz_pb_mgr.g_ui_actns_ui_uidef_old_ref,cz_pb_mgr.g_ui_actns_ui_uidef_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of ui actions');
      -- ignore expl id resolution failure because of a ui refresh issue (see 6817586)
      resolve_ids(cz_pb_mgr.g_ui_actns_tgtexpl_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'model ref expl id of ui actions', FLD_IGNORE_NOW);
      -- context_component_id, obsolete
      -- resolve_ids(cz_pb_mgr.g_ui_actns_ctx_comp_tbl, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'ctx comp id of ui actions');
      resolve_ids(cz_pb_mgr.g_ui_actns_ren_cond_tbl, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'render condition id of ui actions');

      IF cz_pb_mgr.v_session_parameter = pub_model OR cz_pb_mgr.v_server_id <> 0 THEN
        resolve_tmpl_ui_defs(cz_pb_mgr.g_uiact_prcpg_tmpui_tbl, cz_pb_mgr.g_uiact_prcpg_templ_tbl, 'prc pg tmp uidef of ui actions');
        resolve_ids(cz_pb_mgr.g_uiact_prcpg_templ_tbl, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'prc pg templ id of ui actions', ENTITY_TYPE_UCT);
      END IF;

      resolve_intl_texts(cz_pb_mgr.g_uiact_prc_caption_tbl, cz_pb_mgr.v_cz_intl_text_idx_ref, ' prc caption ids of ui actions');
      resolve_intl_texts(cz_pb_mgr.g_uiact_pg_title_tbl, cz_pb_mgr.v_cz_intl_text_idx_ref, ' pg title ids of ui actions');
      resolve_intl_texts(cz_pb_mgr.g_uiact_main_msg_tbl, cz_pb_mgr.v_cz_intl_text_idx_ref, ' main msg ids of ui actions');

      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'ui_def_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_actns_ui_uidef_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'ui_action_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_actns_ui_act_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'target_ui_def_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_actns_ui_tgtui_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'target_expl_node_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_actns_tgtexpl_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'context_component_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_actns_ctx_comp_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'render_condition_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ui_actns_ren_cond_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'processing_page_templ_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_uiact_prcpg_templ_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'proc_page_templ_ui_def_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_uiact_prcpg_tmpui_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'processing_caption_text_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_uiact_prc_caption_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'page_title_text_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_uiact_pg_title_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'main_message_text_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_uiact_main_msg_tbl';
      -- should call resolve_ids instead
      resolve_ref_ids_not_found(cz_pb_mgr.g_ui_actns_ui_uidef_ref
                               ,cz_pb_mgr.v_cz_ui_defs_old_ref
                               ,cz_pb_mgr.v_cz_ui_defs_idx_ref
                               ,cz_pb_mgr.g_ui_actns_ui_tgtui_ref
                               ,'cz_ui_actions.target_ui_def_id'
                               ,cz_pb_mgr.v_status_code
                               );
      insert_into_table('cz_ui_actions'
                       ,'ui_action_id'
                       ,'ui_def_id'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.g_ui_actns_ui_act_id_old_ref'
                       ,'cz_pb_mgr.g_ui_actns_ui_uidef_old_ref'
                       ,cz_pb_mgr.g_ui_actns_ui_act_id_old_ref
                       ,cz_pb_mgr.g_ui_actns_ui_uidef_old_ref
                       );

      IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model)
      THEN
         refresh_ui_actions(cz_pb_mgr.g_ui_actns_ui_uidef_old_ref);
      END IF;

      ------bulk collect ui images for Master templates
      -- for local migration, cz_pb_mgr.v_new_mt_id_tbl should be empty
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_new_mt_id_tbl.COUNT > 0)
      THEN
         bulk_collect_ui_images(cz_pb_mgr.v_mt_old_id_tbl);
         resolve_ids(cz_pb_mgr.v_ui_images_ui_tbl,cz_pb_mgr.v_ui_images_ui_ref, cz_pb_mgr.v_mt_old_to_new_id, 'ui def ids of mt ui images');
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_images_ui_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'image_usage_code';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_images_usg_tbl';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'entity_code';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_images_enty_tbl';
         insert_into_table('cz_ui_images'
                          ,'ui_def_id'
                          ,'image_usage_code'
                          ,'entity_code'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.v_ui_images_ui_tbl'
                          ,'cz_pb_mgr.v_ui_images_usg_tbl'
                          ,'cz_pb_mgr.v_ui_images_enty_tbl'
                          ,cz_pb_mgr.v_ui_images_ui_tbl
                          ,cz_pb_mgr.v_ui_images_usg_tbl
                          ,cz_pb_mgr.v_ui_images_enty_tbl
                          );
	 row_count:=cz_pb_mgr.l_ui_images_ui_ref.COUNT;
         IF (cz_pb_mgr.v_ui_images_ui_ref.COUNT >0)THEN
           FOR i in cz_pb_mgr.v_ui_images_ui_ref.FIRST .. cz_pb_mgr.v_ui_images_ui_ref.LAST
           LOOP
             row_count:=row_count+1;
             cz_pb_mgr.l_ui_images_ui_ref(row_count):=cz_pb_mgr.v_ui_images_ui_ref(i);
             cz_pb_mgr.l_ui_images_enty_tbl(row_count):=cz_pb_mgr.v_ui_images_enty_tbl(i);
             cz_pb_mgr.l_ui_images_usg_tbl(row_count):=cz_pb_mgr.v_ui_images_usg_tbl(i);
           END LOOP;
         END IF;
      END IF;

      ----resolve  ui_def_id
      bulk_collect_ui_images(cz_pb_mgr.v_cz_ui_defs_old_ref);
      resolve_ids(cz_pb_mgr.v_ui_images_ui_tbl,cz_pb_mgr.v_ui_images_ui_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of ui images');
      -----insert into ui images
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'ui_def_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_images_ui_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'image_usage_code';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_images_usg_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'entity_code';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_images_enty_tbl';
      insert_into_table('cz_ui_images'
                       ,'ui_def_id'
                       ,'image_usage_code'
                       ,'entity_code'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.v_ui_images_ui_tbl'
                       ,'cz_pb_mgr.v_ui_images_usg_tbl'
                       ,'cz_pb_mgr.v_ui_images_enty_tbl'
                       ,cz_pb_mgr.v_ui_images_ui_tbl
                       ,cz_pb_mgr.v_ui_images_usg_tbl
                       ,cz_pb_mgr.v_ui_images_enty_tbl
                       );
      row_count:=cz_pb_mgr.l_ui_images_ui_ref.COUNT;
      IF (cz_pb_mgr.v_ui_images_ui_ref.COUNT > 0) THEN
        FOR i in cz_pb_mgr.v_ui_images_ui_ref.FIRST .. cz_pb_mgr.v_ui_images_ui_ref.LAST
        LOOP
          row_count:=row_count+1;
          cz_pb_mgr.l_ui_images_ui_ref(row_count):=cz_pb_mgr.v_ui_images_ui_ref(i);
          cz_pb_mgr.l_ui_images_enty_tbl(row_count):=cz_pb_mgr.v_ui_images_enty_tbl(i);
          cz_pb_mgr.l_ui_images_usg_tbl(row_count):=cz_pb_mgr.v_ui_images_usg_tbl(i);
        END LOOP;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_EXPORT_OA_UI_ERR', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_EXPORTOAUI', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END export_oa_uis;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------makes a copy of a UI and its children
   PROCEDURE export_single_oa_ui(
      p_ui_def_id IN NUMBER
     ,x_ui_def_id OUT NOCOPY NUMBER
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   IS
      ui_def_id_is_null EXCEPTION;
      ui_def_id_not_found EXCEPTION;
      not_oa_style_ui EXCEPTION;
      l_ui_def_id NUMBER;
      l_ui_style VARCHAR2(3);
      l_child_ui_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      cz_pb_mgr.v_status_code := 'OK';

      IF (p_ui_def_id IS NULL)
      THEN
         RAISE ui_def_id_is_null;
      END IF;

      BEGIN
         SELECT ui_def_id, ui_style
           INTO l_ui_def_id, l_ui_style
           FROM cz_ui_defs
          WHERE cz_ui_defs.ui_def_id = p_ui_def_id AND cz_ui_defs.deleted_flag = record_not_deleted;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RAISE ui_def_id_not_found;
      END;

      IF (l_ui_style <> oa_ui_style)
      THEN
         RAISE not_oa_style_ui;
      END IF;

      cz_pb_mgr.v_cz_ui_defs_old_oa_ref.DELETE;
      cz_pb_mgr.v_cz_ui_defs_old_ref.DELETE;
      cz_pb_mgr.v_cz_ui_defs_idx_ref.DELETE;
      cz_pb_mgr.v_cz_ui_defs_new_ref.DELETE;
      rec_count := cz_pb_mgr.v_cz_ui_defs_old_oa_ref.COUNT + 1;
      cz_pb_mgr.v_cz_ui_defs_old_oa_ref(rec_count) := l_ui_def_id;
      cz_pb_mgr.v_cz_ui_defs_old_ref(rec_count) := l_ui_def_id;
      l_child_ui_tbl.DELETE;

      BEGIN
         SELECT ref_ui_def_id
         BULK COLLECT INTO l_child_ui_tbl
           FROM cz_ui_refs
          WHERE cz_ui_refs.ui_def_id = l_ui_def_id AND cz_ui_refs.deleted_flag = record_not_deleted;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;                                                                                                       ---if no children then ignore
      END;

      IF (l_child_ui_tbl.COUNT > 0)
      THEN
         rec_count := cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT + 1;

         FOR i IN l_child_ui_tbl.FIRST .. l_child_ui_tbl.LAST
         LOOP
            rec_count := rec_count + 1;
            cz_pb_mgr.v_cz_ui_defs_old_ref(rec_count) := l_child_ui_tbl(i);
            cz_pb_mgr.v_cz_ui_defs_old_oa_ref(rec_count) := l_child_ui_tbl(i);
         END LOOP;
      END IF;

      IF (cz_pb_mgr.v_cz_ui_defs_old_oa_ref.COUNT > 0)
      THEN
         cz_pb_mgr.v_cz_ui_defs_new_ref.DELETE;
         rec_count := cz_pb_mgr.v_cz_ui_defs_new_ref.COUNT;
         IF (v_cz_ui_defs_old_ref.COUNT > 0) THEN
          FOR k IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST
          LOOP
            rec_count := rec_count + 1;
            cz_pb_mgr.v_cz_ui_defs_new_ref(rec_count) :=
                 cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_ui_defs_seq, 'cz_ui_defs_s.NEXTVAL' || cz_pb_mgr.v_db_link, cz_pb_mgr.v_oraclesequenceincr);

            IF (cz_pb_mgr.v_cz_ui_defs_old_ref(k) = p_ui_def_id)
            THEN
               x_ui_def_id := cz_pb_mgr.v_cz_ui_defs_new_ref(rec_count);
            END IF;

            cz_pb_mgr.v_cz_ui_defs_idx_ref(cz_pb_mgr.v_cz_ui_defs_old_ref(k)):=cz_pb_mgr.v_cz_ui_defs_new_ref(rec_count);
          END LOOP;
	 END IF;

         --------populate plsql_table_list for ui_defs
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_defs_new_ref';
         insert_into_table('cz_ui_defs'
                          ,'ui_def_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.v_cz_ui_defs_old_ref'
                          ,cz_pb_mgr.v_cz_ui_defs_old_ref
                          );
         ------export oa uis
         export_oa_uis;
         cz_pb_mgr.v_cz_ui_defs_old_oa_ref.DELETE;
         cz_pb_mgr.v_cz_ui_defs_old_ref.DELETE;
         cz_pb_mgr.v_cz_ui_defs_idx_ref.DELETE;
         cz_pb_mgr.v_cz_ui_defs_new_ref.DELETE;
      END IF;
   EXCEPTION
      WHEN ui_def_id_is_null
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := cz_utils.get_text('UI_DEF_ID_IS_NULL');
         x_msg_count := 1;
      WHEN ui_def_id_not_found
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := cz_utils.get_text('UI_DEF_ID_NOT_FOUND', 'UIDEFID', p_ui_def_id);
         x_msg_count := 1;
      WHEN not_oa_style_ui
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := cz_utils.get_text('NOT_OA_STYLE_UI', 'UIDEFID', p_ui_def_id);
         x_msg_count := 1;
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := cz_utils.get_text('FATAL_ERROR', 'UIDEFID', p_ui_def_id, 'ERROR', SQLERRM);
         x_msg_count := 1;
   END export_single_oa_ui;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE log_report(p_pkg_name VARCHAR2, p_routine VARCHAR2, p_ndebug NUMBER, p_msg VARCHAR2, p_log_level NUMBER)
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
      l_module_name VARCHAR2(2000);
   BEGIN
      IF (p_log_level >= fnd_log.g_current_runtime_level)
      THEN
         l_module_name := 'cz.plsql.' || p_pkg_name || '.' || p_routine || '.' || p_ndebug;
         fnd_log.STRING(p_log_level, l_module_name, p_msg);
         COMMIT;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         ROLLBACK;
   END log_report;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------------------procedure to log errors during the publication process
   PROCEDURE log_pb_errors(p_message IN VARCHAR2, p_urgency IN VARCHAR2, p_caller IN VARCHAR2, p_statuscode IN PLS_INTEGER)
   AS
      v_message VARCHAR2(2000) := NULL;
   BEGIN
      IF (p_message IS NOT NULL)
      THEN
         v_message := LTRIM(RTRIM(SUBSTR(p_message, 1, 2000)));
      ELSE
         v_message := 'Check SQLCODE in statuscode field. ';
      END IF;

      IF fnd_global.conc_request_id > 0
      THEN
         fnd_file.put_line(fnd_file.LOG, v_message);
      END IF;

      INSERT INTO cz_db_logs
                  (logtime, loguser, urgency, caller, statuscode, MESSAGE, message_id, run_id
                  )
           VALUES (SYSDATE, cz_pb_mgr.loguser, p_urgency, p_caller, p_statuscode, v_message, cz_pb_mgr.v_publication_id, cz_pb_mgr.v_pb_run_id
                  );

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in inserting into cz_db_logs: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SESSN', SQLCODE);
   END log_pb_errors;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that logs timing message
   PROCEDURE log_timing_message(p_msg IN VARCHAR2)
   IS
   BEGIN
      log_pb_errors(p_msg, 2, 'cz_pb_mgr_TIMING', 55);
   END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE log_pb_trace
   AS
      l_msg VARCHAR2(2000);
   BEGIN
      -----------log trace
      IF ((cz_pb_mgr.v_root_model_id > 0) AND(cz_pb_mgr.v_session_parameter <> model_copy))
      THEN
         cz_pb_mgr.v_err_message := 'Parent model in publication (migration) request : ' || TO_CHAR(cz_pb_mgr.v_root_model_id);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.TRACE', SQLCODE);
         cz_pb_mgr.v_err_message :=
                            'Source publication : ' || cz_pb_mgr.v_cz_model_pub_old_id || '  target publication: ' || cz_pb_mgr.v_cz_model_pub_new_id;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.TRACE', SQLCODE);
      END IF;

      IF (cz_pb_mgr.v_msg_tbl.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.v_msg_tbl.FIRST .. cz_pb_mgr.v_msg_tbl.LAST
         LOOP
            IF fnd_global.conc_request_id > 0
            THEN
               fnd_file.put_line(fnd_file.LOG, cz_pb_mgr.v_msg_tbl(i).msg_text);
            END IF;

            BEGIN
               INSERT INTO cz_db_logs
                           (logtime, caller, statuscode, MESSAGE
                           ,message_id, creation_date, run_id
                           )
                    VALUES (SYSDATE, cz_pb_mgr.v_msg_tbl(i).called_proc, cz_pb_mgr.v_msg_tbl(i).sql_code, cz_pb_mgr.v_msg_tbl(i).msg_text
                           ,cz_pb_mgr.v_publication_id, SYSDATE, cz_pb_mgr.v_pb_run_id
                           );
            EXCEPTION
               WHEN OTHERS
               THEN
                  RAISE;
            END;

            log_report('cz_pb_mgr'
                      ,cz_pb_mgr.v_msg_tbl(i).called_proc
                      ,cz_pb_mgr.v_msg_tbl(i).sql_code
                      ,cz_pb_mgr.v_msg_tbl(i).msg_text
                      ,fnd_log.level_error
                      );
         END LOOP;

         COMMIT;
      END IF;

      IF ((cz_pb_mgr.v_msg_tbl.COUNT > 0) AND(cz_pb_mgr.v_session_parameter = model_copy) AND(cz_pb_mgr.v_status_code = PUBLICATION_ERROR))
      THEN
         fnd_msg_pub.initialize;

         FOR i IN cz_pb_mgr.v_msg_tbl.FIRST .. cz_pb_mgr.v_msg_tbl.LAST
         LOOP
            IF ((cz_pb_mgr.v_msg_tbl(i).msg_text IS NOT NULL) AND(cz_pb_mgr.v_msg_tbl(i).msg_text NOT LIKE '%publication%'))
            THEN
               fnd_message.set_name('CZ', 'CZ_MODEL_COPY_ERR');
               fnd_message.set_token('ERRORMSG', cz_pb_mgr.v_msg_tbl(i).msg_text);
               fnd_msg_pub.ADD;
            END IF;
         END LOOP;
      END IF;

      cz_pb_mgr.v_msg_tbl.DELETE;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in inserting into cz_db_logs: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SESSN', SQLCODE);
         cz_pb_mgr.v_msg_tbl.DELETE;
   END log_pb_trace;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----update pup status
   PROCEDURE update_pup_status(p_publication_id cz_model_publications.publication_id%TYPE)
   IS
      l_remote_publication_id NUMBER;
   BEGIN
      UPDATE cz_model_publications
         SET export_status = 'OK'
       WHERE remote_publication_id = (SELECT remote_publication_id
                                        FROM cz_model_publications
                                       WHERE deleted_flag = '0' AND publication_id = p_publication_id AND export_status = 'ERR')
         AND export_status = 'PUP'
         AND deleted_flag = '0';
   END;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------updates export status in cZ_model_publications
   PROCEDURE update_publication_status(p_publication_id IN NUMBER, p_pb_status IN VARCHAR2, p_db_link IN VARCHAR2)
   IS
   BEGIN
      IF ((p_publication_id > 0) AND(p_pb_status IS NOT NULL))
      THEN
         cz_pb_mgr.v_insert_string :=
               'UPDATE cz_model_publications'
            || p_db_link
            || ' '
            || 'SET  export_status = :1,'
            || ' '
            || 'published = sysdate'
            || ' '
            || 'WHERE  cz_model_publications.publication_id = :2';

         EXECUTE IMMEDIATE cz_pb_mgr.v_insert_string
                     USING p_pb_status, p_publication_id;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'ERROR : updation of publication status ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UPPBSTATUS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END update_publication_status;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------------ to retrieve the db link
   FUNCTION retrieve_db_link(p_server_id PLS_INTEGER)
      RETURN VARCHAR2
   IS
      v_source_id cz_servers.server_local_id%TYPE;
      v_source_instance cz_servers.instance_name%TYPE;
      v_source_host cz_servers.hostname%TYPE;
      v_source_port cz_servers.db_listener_port%TYPE;
      v_source_owner cz_servers.cz_owner%TYPE;
      v_target_id cz_servers.server_local_id%TYPE;
      v_target_instance cz_servers.instance_name%TYPE;
      v_target_host cz_servers.hostname%TYPE;
      v_target_port cz_servers.db_listener_port%TYPE;
      v_target_owner cz_servers.cz_owner%TYPE;
      v_db_link cz_servers.cz_link_name%TYPE;

      CURSOR db_compare_cur(p_server_id PLS_INTEGER)
      IS
         SELECT   server_local_id, instance_name, hostname, db_listener_port, cz_owner, fndnam_link_name
             FROM cz_servers
            WHERE server_local_id = p_server_id OR server_local_id = 0
         ORDER BY server_local_id;

      v_compare_record db_compare_cur%ROWTYPE;
   BEGIN
      BEGIN
         OPEN db_compare_cur(p_server_id);

         LOOP
            FETCH db_compare_cur
             INTO v_compare_record;

            EXIT WHEN db_compare_cur%NOTFOUND;

            IF (v_compare_record.server_local_id = 0)
            THEN
               v_source_instance := v_compare_record.instance_name;
               v_source_host := v_compare_record.hostname;
               v_source_port := v_compare_record.db_listener_port;
               v_source_owner := v_compare_record.cz_owner;
               v_target_instance := v_compare_record.instance_name;
               v_target_host := v_compare_record.hostname;
               v_target_port := v_compare_record.db_listener_port;
               v_target_owner := v_compare_record.cz_owner;
               v_db_link := v_compare_record.fndnam_link_name;
            ELSE
               v_target_instance := v_compare_record.instance_name;
               v_target_host := v_compare_record.hostname;
               v_target_port := v_compare_record.db_listener_port;
               v_target_owner := v_compare_record.cz_owner;
               v_db_link := v_compare_record.fndnam_link_name;
            END IF;
         END LOOP;

         CLOSE db_compare_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_SRC_TO_TRGT_LINK', 'SQLERRM', SQLERRM);
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RETRIEVE_DB_LINK', SQLCODE);
      END;

      IF (((v_target_instance IS NULL) OR(v_target_host IS NULL) OR(v_target_port IS NULL)) AND(v_compare_record.server_local_id <> 0.0))
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_SRC_TO_TRGT_LINK', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RETRIEVE_DB_LINK', SQLCODE);
         cz_pb_mgr.v_status_code := 'ERR';
      END IF;

      IF (   (    (LTRIM(RTRIM(UPPER(v_source_instance))) = LTRIM(RTRIM(UPPER(v_target_instance))))
              AND (LTRIM(RTRIM(UPPER(v_source_host))) = LTRIM(RTRIM(UPPER(v_target_host))))
              AND (LTRIM(RTRIM(UPPER(v_source_port))) = LTRIM(RTRIM(UPPER(v_target_port))))
             )
          OR (p_server_id = 0)
         )
      THEN
         cz_pb_mgr.v_db_link := ' ';
      ELSE
         cz_pb_mgr.v_db_link := '@' || v_db_link || ' ';
      END IF;

      RETURN cz_pb_mgr.v_db_link;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN cz_pb_mgr.v_db_link;
   END retrieve_db_link;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----------------------procedure called from rollback data that deletes the rows
----------------------inserted into a table during publication process
PROCEDURE	delete_from_table(table_name			IN	VARCHAR2 ,
					primary_key			IN	VARCHAR2 ,
					db_link			IN	VARCHAR2 ,
					plsql_table_name		IN	VARCHAR2,
					primary_key_plsql_table	IN	cz_pb_mgr.t_ref
					)
AS

v_DeleteString  VARCHAR2(2000);
v_db_link       VARCHAR2(128);

BEGIN
      IF ( primary_key_plsql_table.COUNT > 0 ) THEN
			v_db_link  := UPPER(LTRIM(RTRIM(db_link)));
			BEGIN
				v_DeleteString  := 'BEGIN FOR  M IN '||primary_key_plsql_table.FIRST||'..'||primary_key_plsql_table.LAST||'  LOOP ';
				v_DeleteString  := v_DeleteString||' delete from '||table_name||v_db_link||' tgt ';
      	      	v_DeleteString  := v_DeleteString||' WHERE  tgt.'||primary_key||' = '||plsql_table_name||'(m) ';
				v_DeleteString  := v_DeleteString||' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;  END LOOP; COMMIT; END; ';
		 		EXECUTE IMMEDIATE v_DeleteString;
			EXCEPTION
			WHEN OTHERS THEN
				RAISE;
			END;
      END	IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
	cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT('CZ_PB_TABLE_ROLLBACK_ERR', 'TABLENAME', table_name);
	cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_pb_mgr.ROLLBACK',SQLCODE);
END	delete_from_table;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----------------------procedure called from rollback data that deletes the rows
----------------------inserted into a table during publication process

PROCEDURE delete_from_table(table_name IN VARCHAR2 ,
                            primary_key1   IN	VARCHAR2 ,
                            primary_key2   IN	VARCHAR2 ,
			    primary_key3   IN	VARCHAR2 ,
                            db_link	       IN	VARCHAR2 ,
                            plsql_table_name1 IN VARCHAR2,
			    	    plsql_table_name2 IN VARCHAR2,
				    plsql_table_name3 IN VARCHAR2,
			    	    primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref)

AS
v_cursor          NUMBER;
v_NumRows         NUMBER;
v_DeleteString 	VARCHAR2(10000);
v_db_link         VARCHAR2(128);

BEGIN
     v_db_link  := UPPER(LTRIM(RTRIM(db_link)));

 BEGIN
  IF ( primary_key_plsql_table1.COUNT > 0 ) THEN
	v_DeleteString  := 'BEGIN FOR  M IN '||primary_key_plsql_table1.FIRST||'..'||primary_key_plsql_table1.LAST||'  LOOP ';
	v_DeleteString  := v_DeleteString||' delete from '||table_name||v_db_link;
	v_DeleteString  := v_DeleteString||' WHERE '||table_name||'.'||primary_key1||' = '||plsql_table_name1||'(m) ';
	v_DeleteString  := v_DeleteString||' AND '||table_name||'.'||primary_key2||'='||plsql_table_name2||'(m) ';
	v_DeleteString  := v_DeleteString||' AND '||table_name||'.'||primary_key3||'='||plsql_table_name3||'(m) ';
	v_DeleteString  := v_DeleteString||' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;  END LOOP; COMMIT; END; ';
	EXECUTE IMMEDIATE v_DeleteString;
  END	IF;
 EXCEPTION
 WHEN OTHERS THEN
	cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT('CZ_PB_TABLE_ROLLBACK_ERR', 'TABLENAME', table_name);
	cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_pb_mgr.ROLLBACK',SQLCODE);
 END;
COMMIT;
END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----------------------procedure called from rollback data that deletes the rows
----------------------inserted into a table during publication process

PROCEDURE delete_from_table(table_name IN VARCHAR2 ,
                            primary_key1   IN	VARCHAR2 ,
                            primary_key2   IN	VARCHAR2 ,
                            db_link	       IN	VARCHAR2 ,
                            plsql_table_name1 IN VARCHAR2,
			    	    plsql_table_name2 IN VARCHAR2,
			    	    primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref)

AS
v_cursor          NUMBER;
v_NumRows         NUMBER;
v_DeleteString 	VARCHAR2(10000);
v_db_link         VARCHAR2(128);

BEGIN
     v_db_link  := UPPER(LTRIM(RTRIM(db_link)));

 BEGIN
  IF ( primary_key_plsql_table1.COUNT > 0 ) THEN
	v_DeleteString  := 'BEGIN FOR  M IN '||primary_key_plsql_table1.FIRST||'..'||primary_key_plsql_table1.LAST||'  LOOP ';
	v_DeleteString  := v_DeleteString||' delete from '||table_name||v_db_link;
	v_DeleteString  := v_DeleteString||' WHERE '||table_name||'.'||primary_key1||' = '||plsql_table_name1||'(m) ';
	v_DeleteString  := v_DeleteString||' AND '||table_name||'.'||primary_key2||'='||plsql_table_name2||'(m) ';
	v_DeleteString  := v_DeleteString||' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;  END LOOP; COMMIT; END; ';
	EXECUTE IMMEDIATE v_DeleteString;
  END	IF;
 EXCEPTION
 WHEN OTHERS THEN
	cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT('CZ_PB_TABLE_ROLLBACK_ERR', 'TABLENAME', table_name);
	cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_pb_mgr.ROLLBACK',SQLCODE);
 END;
COMMIT;
END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----------------------procedure called from rollback data that deletes the rows
----------------------inserted into a table during publication process

PROCEDURE delete_from_table(table_name IN VARCHAR2 ,
                            primary_key1   IN	VARCHAR2 ,
                            primary_key2   IN	VARCHAR2 ,
			    primary_key3   IN	VARCHAR2 ,
			    primary_key4   IN	VARCHAR2 ,
                            db_link	       IN	VARCHAR2 ,
                            plsql_table_name1 IN VARCHAR2,
			    	    plsql_table_name2 IN VARCHAR2,
				    plsql_table_name3 IN VARCHAR2,
				    plsql_table_name4 IN VARCHAR2,
			    	    primary_key_plsql_table1 IN OUT NOCOPY cz_pb_mgr.t_ref)

AS
v_cursor          NUMBER;
v_NumRows         NUMBER;
v_DeleteString 	VARCHAR2(10000);
v_db_link         VARCHAR2(128);

BEGIN
     v_db_link  := UPPER(LTRIM(RTRIM(db_link)));

 BEGIN
  IF ( primary_key_plsql_table1.COUNT > 0 ) THEN
	v_DeleteString  := 'BEGIN FOR  M IN '||primary_key_plsql_table1.FIRST||'..'||primary_key_plsql_table1.LAST||'  LOOP ';
	v_DeleteString  := v_DeleteString||' delete from '||table_name||v_db_link;
	v_DeleteString  := v_DeleteString||' WHERE '||table_name||'.'||primary_key1||' = '||plsql_table_name1||'(m) ';
	v_DeleteString  := v_DeleteString||' AND '||table_name||'.'||primary_key2||'='||plsql_table_name2||'(m) ';
	v_DeleteString  := v_DeleteString||' AND '||table_name||'.'||primary_key3||'='||plsql_table_name3||'(m) ';
	v_DeleteString  := v_DeleteString||' AND '||table_name||'.'||primary_key4||'='||plsql_table_name4||'(m) ';
	v_DeleteString  := v_DeleteString||' ; IF (MOD(M,cz_pb_mgr.RECORD_COMMIT_SIZE) = 0) THEN COMMIT; END IF;  END LOOP; COMMIT; END; ';
	EXECUTE IMMEDIATE v_DeleteString;
  END	IF;
 EXCEPTION
 WHEN OTHERS THEN
	cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT('CZ_PB_TABLE_ROLLBACK_ERR', 'TABLENAME', table_name);
	cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_pb_mgr.ROLLBACK',SQLCODE);
 END;
COMMIT;
END;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
---------procedure that deletes data of single index arrays
   PROCEDURE delete_from_idx_tables(
      p_table_name IN VARCHAR2
     ,p_primary_key IN VARCHAR2
     ,p_old_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_idx_array IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2
   )
   AS
      v_deletestring VARCHAR2(2000);
      v_idx_id NUMBER;
   BEGIN
      IF (p_old_array.COUNT > 0)
      THEN
         FOR i IN p_old_array.FIRST .. p_old_array.LAST
         LOOP
            v_idx_id := p_idx_array(p_old_array(i));
            v_deletestring := ' delete from ' || p_table_name || v_db_link || ' tgt ';
            v_deletestring := v_deletestring || ' WHERE  tgt.' || p_primary_key || ' = :1';

            EXECUTE IMMEDIATE v_deletestring
                        USING v_idx_id;

            IF (MOD(i, cz_pb_mgr.record_commit_size) = 0)
            THEN
               COMMIT;
            END IF;
         END LOOP;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error during rollback of  ' || p_table_name || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.ROLLBACK', SQLCODE);
   END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------in the model publication process
--------a model is published in its entirety
--------if an error occurs during the publishing
--------process the data that has been committed
--------on the target server is rolled back
   PROCEDURE rollback_data(p_db_link IN VARCHAR2)
   AS
      v_insert_string VARCHAR2(2000) := '';
      v_database_link VARCHAR2(128);
   BEGIN
      v_database_link := LTRIM(RTRIM(p_db_link));

      IF ((cz_pb_mgr.v_server_id IS NULL) OR(v_database_link = '@'))
      THEN
         v_database_link := NULL;
      END IF;

      delete_from_table('cz_ps_nodes', 'ps_node_id', v_database_link, 'cz_pb_mgr.v_cz_ps_nodes_new_tbl', cz_pb_mgr.v_cz_ps_nodes_new_tbl);
      delete_from_table('cz_ps_prop_vals', 'ps_node_id', v_database_link, 'cz_pb_mgr.v_cz_ps_nodes_new_tbl', cz_pb_mgr.v_cz_ps_nodes_new_tbl);
      delete_from_table('cz_devl_projects'
                       ,'devl_project_id'
                       ,v_database_link
                       ,'cz_pb_mgr.v_models_to_be_exported_new'
                       ,cz_pb_mgr.v_models_to_be_exported_new
                       );
      delete_from_table('cz_ui_defs', 'ui_def_id', v_database_link, 'cz_pb_mgr.v_cz_ui_defs_new_ref', cz_pb_mgr.v_cz_ui_defs_new_ref);
      delete_from_table('cz_ui_properties', 'ui_def_id', v_database_link, 'cz_pb_mgr.v_cz_ui_defs_new_ref', cz_pb_mgr.v_cz_ui_defs_new_ref);
      delete_from_table('cz_ui_nodes', 'ui_node_id', v_database_link, 'cz_pb_mgr.v_cz_ui_nodes_new_ref', cz_pb_mgr.v_cz_ui_nodes_new_ref);
      delete_from_table('cz_ui_node_props', 'ui_node_id', v_database_link, 'cz_pb_mgr.v_cz_ui_nodes_new_ref', cz_pb_mgr.v_cz_ui_nodes_new_ref);
      delete_from_table('cz_model_ref_expls'
                       ,'model_ref_expl_id'
                       ,v_database_link
                       ,'cz_pb_mgr.v_cz_model_ref_expls_new_ref'
                       ,cz_pb_mgr.v_cz_model_ref_expls_new_ref
                       );
      delete_from_table('cz_lce_headers', 'lce_header_id', v_database_link, 'cz_pb_mgr.v_cz_lce_headers_new_ref', cz_pb_mgr.v_cz_lce_headers_new_ref);
      delete_from_table('cz_rules', 'rule_id', v_database_link, 'cz_pb_mgr.v_cz_rules_rule_id_new_ref', cz_pb_mgr.v_cz_rules_rule_id_new_ref);
      delete_from_table('cz_des_chart_features'
                       ,'rule_id'
                       ,v_database_link
                       ,'cz_pb_mgr.v_cz_des_feature_rid_new_ref'
                       ,cz_pb_mgr.v_cz_des_feature_rid_new_ref
                       );
      delete_from_table('cz_des_chart_cells'
                       ,'rule_id'
                       ,v_database_link
                       ,'cz_pb_mgr.v_cz_des_cells_rule_id_new_ref'
                       ,cz_pb_mgr.v_cz_des_cells_rule_id_new_ref
                       );

   delete_from_table('cz_ui_pages','ui_def_id',v_database_link,'cz_pb_mgr.g_cz_ui_pages_ui_def_ref',cz_pb_mgr.g_cz_ui_pages_ui_def_ref);
   delete_from_table('cz_ui_page_elements','ui_def_id','page_id','element_id',v_database_link,'cz_pb_mgr.g_ui_ps_maps_new_ui_def_ref','cz_pb_mgr.g_ui_ps_maps_page_id_tbl','cz_pb_mgr.g_ui_ps_maps_element_tbl',cz_pb_mgr.g_ui_ps_maps_new_ui_def_ref);
   delete_from_table('cz_ui_page_refs','ui_def_id','page_set_id','page_ref_id',v_database_link,'cz_pb_mgr.g_page_refs_ui_def_new_ref','cz_pb_mgr.g_page_refs_pg_set_ref','cz_pb_mgr.g_page_refs_pg_ref_ref',cz_pb_mgr.g_page_refs_ui_def_new_ref);
   delete_from_table('cz_ui_page_sets','ui_def_id','page_set_id',v_database_link,'cz_pb_mgr.g_page_sets_ui_ref','cz_pb_mgr.g_page_sets_pg_tbl',cz_pb_mgr.g_page_sets_ui_ref);
   delete_from_table('cz_ui_refs','ui_def_id','model_ref_expl_id',v_database_link,'cz_pb_mgr.g_ui_refs_new_ui_def_ref','cz_pb_mgr.g_ui_refs_expl_id_ref',cz_pb_mgr.g_ui_refs_new_ui_def_ref);
   delete_from_table('cz_ui_cont_type_templs','ui_def_id','content_type',v_database_link,'cz_pb_mgr.l_cnt_typ_tmpls_new_uidef_ref','cz_pb_mgr.l_cnt_typ_tmpls_cont_ref',cz_pb_mgr.l_cnt_typ_tmpls_new_uidef_ref);
   delete_from_table('cz_ui_ref_templates','template_id','template_ui_def_id',
		     'ref_template_id','ref_template_ui_def_id',v_database_link,'cz_pb_mgr.g_TEMPLATE_ID_ref','cz_pb_mgr.g_TEMPLATE_UI_ref',
		     'cz_pb_mgr.g_REF_TEMPLATE_ID_ref','cz_pb_mgr.g_REF_TEMPL_UI_ref',cz_pb_mgr.g_TEMPLATE_ID_ref);
   delete_from_table('cz_ui_actions','ui_def_id','ui_action_id',v_database_link,'cz_pb_mgr.g_ui_actns_ui_uidef_ref','cz_pb_mgr.g_ui_actns_ui_act_id_ref',cz_pb_mgr.g_ui_actns_ui_uidef_ref);
   delete_from_table('cz_ui_images','ui_def_id','image_usage_code','entity_code',v_database_link,'cz_pb_mgr.l_ui_images_ui_ref','cz_pb_mgr.l_ui_images_usg_tbl','cz_pb_mgr.l_ui_images_enty_tbl',cz_pb_mgr.l_ui_images_ui_ref);
   delete_from_table('cz_signatures','signature_id',v_database_link,'cz_pb_mgr.v_sig_new_ref',cz_pb_mgr.v_sig_new_ref);
   delete_from_table('cz_signature_arguments','argument_signature_id','argument_index',v_database_link,'cz_pb_mgr.v_arg_sig_tbl','cz_pb_mgr.v_arg_ind_old_tbl',cz_pb_mgr.v_arg_sig_tbl);
   delete_from_table('cz_func_comp_specs','func_comp_id',v_database_link,'cz_pb_mgr.v_cz_func_comp_new_ref',cz_pb_mgr.v_cz_func_comp_new_ref);
   delete_from_table('cz_populators','populator_id',v_database_link,'cz_pb_mgr.v_populators_new_id_ref',cz_pb_mgr.v_populators_new_id_ref);
   delete_from_table('cz_filter_sets','filter_set_id',v_database_link,'cz_pb_mgr.v_filter_sets_new_id_ref',cz_pb_mgr.v_filter_sets_new_id_ref);
   delete_from_table('cz_archives','archive_id',v_database_link,'cz_pb_mgr.g_archives_new_ref',cz_pb_mgr.g_archives_new_ref);

   delete_from_table('cz_archives','archive_id',v_database_link,'cz_pb_mgr.mm_v_ht_sync_archives',cz_pb_mgr.mm_v_ht_sync_archives);

   delete_from_table('cz_archive_refs','archive_id','devl_project_id',v_database_link,'cz_pb_mgr.g_archive_id_ref','cz_pb_mgr.g_devl_proj_ref',cz_pb_mgr.g_archive_id_ref);
   delete_from_table('cz_localized_texts','intl_text_id',v_database_link,'cz_pb_mgr.v_cz_intl_text_new_ref',cz_pb_mgr.v_cz_intl_text_new_ref);

      delete_from_idx_tables('cz_rule_folders', 'rule_folder_id', cz_pb_mgr.v_cz_folders_id_old_ref, cz_pb_mgr.v_cz_folders_id_idx_ref);
      delete_from_idx_tables('cz_expression_nodes', 'expr_node_id', cz_pb_mgr.v_cz_enodes_enode_id_old_ref, cz_pb_mgr.v_cz_enodes_enode_id_idx_ref);

      DELETE FROM cz_pb_model_exports
            WHERE publication_id = cz_pb_mgr.v_publication_id;

      COMMIT;
      cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
      cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_FATAL_ERR', 'PUBID', cz_pb_mgr.v_publication_id, 'SQLERRM', cz_pb_mgr.v_sql_err_msg);
      cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:ROLLBACKDATA', SQLCODE);
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_ROLLBACK_ERR', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.ROLLBACK', SQLCODE);
         RAISE;
   END rollback_data;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----------procedure updates the status in cz_model_publications and cz_pb_model_exports
-----------@p_publication_id : source publication id
-----------@p_status : publication status
-----------@p_link : database link name
-----------@p_models_exported : source models that have entries in model exports
-----------@x_status : publication status parameter
   PROCEDURE update_pb_status(
      p_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,p_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
     ,p_models_exported IN OUT NOCOPY cz_pb_mgr.t_ref
     ,x_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
   )
   AS
   BEGIN
      -----update status on the source. p_link is null
      update_publication_status(p_publication_id, p_status, ' ');

      IF (p_models_exported.COUNT > 0)
      THEN
         FOR i IN p_models_exported.FIRST .. p_models_exported.LAST
         LOOP
            UPDATE cz_pb_model_exports t
               SET t.status = p_status
             WHERE t.model_id = p_models_exported(i) AND t.server_id = cz_pb_mgr.v_server_id AND t.publication_id = p_publication_id;
         END LOOP;

         COMMIT;
      END IF;

      -----set status for concurrent manager
      IF (x_status = PUBLICATION_ERROR)
      THEN
         cz_pb_mgr.global_export_retcode := 2;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_UPDATE_ERR', 'TABLENAME', 'cz_model_publications', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UPDPBSTATUS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END update_pb_status;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------function to validate the source and target schemas.
--------a source model can be published on a target server
--------having the same major and minor schema versions
--------v_count when 0 is a failure else 1 indicates success
   FUNCTION validate_schema(target_server_id PLS_INTEGER)
      RETURN NUMBER
   IS
      v_source_major_version cz_db_settings.VALUE%TYPE;
      v_source_minor_version cz_db_settings.VALUE%TYPE;
      v_target_major_version cz_db_settings.VALUE%TYPE;
      v_target_minor_version cz_db_settings.VALUE%TYPE;

      CURSOR db_link_cur(p_server_id PLS_INTEGER)
      IS
         SELECT local_name, fndnam_link_name
           FROM cz_servers
          WHERE server_local_id = p_server_id;

      v_link_record db_link_cur%ROWTYPE;
      v_str VARCHAR2(4000);
      db_schema_compare_cur ref_cursor;
      v_count PLS_INTEGER := 0;
      v_db_link cz_servers.fndnam_link_name%TYPE;
   BEGIN
      OPEN db_link_cur(target_server_id);

      LOOP
         FETCH db_link_cur
          INTO v_link_record;

         EXIT WHEN db_link_cur%NOTFOUND;
         v_db_link := '@' || v_link_record.fndnam_link_name;
         cz_pb_mgr.v_server_local_name := v_link_record.local_name;
      END LOOP;

      CLOSE db_link_cur;

      IF LTRIM(RTRIM(v_db_link)) = '@'
      THEN
         v_count := 1;
      ELSE
         OPEN db_schema_compare_cur FOR    '	select count(*)'
                                        || ' '
                                        || 'from	cz_db_settings,'
                                        || ' '
                                        || 'cz_db_settings'
                                        || v_db_link
                                        || ' tgt'
                                        || ' '
                                        || 'where	cz_db_settings.setting_id = tgt.setting_id'
                                        || ' '
                                        || 'and	cz_db_settings.value = tgt.value'
                                        || ' '
                                        || 'and	cz_db_settings.setting_id = ''MAJOR_VERSION'''
                                        || ' '
                                        || 'INTERSECT'
                                        || ' '
                                        || 'select count(*)'
                                        || ' '
                                        || 'from	cz_db_settings,'
                                        || ' '
                                        || 'cz_db_settings'
                                        || v_db_link
                                        || ' tgt'
                                        || ' '
                                        || 'where	cz_db_settings.setting_id = tgt.setting_id'
                                        || ' '
                                        || 'and	cz_db_settings.value = tgt.value'
                                        || ' '
                                        || 'and	cz_db_settings.setting_id = ''MINOR_VERSION'' ';

         LOOP
            FETCH db_schema_compare_cur
             INTO v_count;

            EXIT WHEN db_schema_compare_cur%NOTFOUND;
         END LOOP;

         CLOSE db_schema_compare_cur;
      END IF;

      --------set commit size variable
      BEGIN
         SELECT VALUE
           INTO cz_pb_mgr.record_commit_size
           FROM cz_db_settings
          WHERE cz_db_settings.setting_id = record_commit_str;
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.record_commit_size := 500;
      END;

      RETURN v_count;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_LINK_NAME');
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VALIDATE_SCHEMA', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RETURN v_count;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_SCHEMA_VALIDATION_ERR');
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VALIDATE_SCHEMA', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RETURN v_count;
   END validate_schema;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------------ procedures for refreshing item sub-schema
   PROCEDURE load_usages
   AS
      l_sql_string VARCHAR2(32000);
   BEGIN
      cz_pb_mgr.v_model_usages_tbl.DELETE;
      cz_pb_mgr.v_usages_lang_tbl.DELETE;

      BEGIN
         SELECT model_usage_id
         BULK COLLECT INTO cz_pb_mgr.v_model_usages_tbl
           FROM cz_model_usages;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cz_pb_mgr.v_err_message := 'No model usages found';
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.USGS', SQLCODE);
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_model_usages', 'SQLERRM', SQLERRM);
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.USGS', SQLCODE);
            cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            RAISE;
      END;

      IF (cz_pb_mgr.v_model_usages_tbl.COUNT > 0)
      THEN
         l_sql_string :=
               'BEGIN '
            || ' DELETE FROM CZ_MODEL_USAGES'
            || cz_pb_mgr.v_db_link
            || '; '
            || ' '
            || 'FOR I IN cz_pb_mgr.v_model_usages_tbl.FIRST..cz_pb_mgr.v_model_usages_tbl.LAST'
            || ' '
            || 'LOOP'
            || ' '
            || 'INSERT INTO cz_model_usages'
            || cz_pb_mgr.v_db_link
            || ' '
            || '(MODEL_USAGE_ID,NAME,DESCRIPTION,NOTE,IN_USE)'
            || ' '
            || 'SELECT MODEL_USAGE_ID,NAME,DESCRIPTION,NOTE,IN_USE FROM cz_model_usages t'
            || ' '
            || 'WHERE t.model_usage_id = cz_pb_mgr.v_model_usages_tbl(i);'
            || ' '
            || 'END LOOP;'
            || ' '
            || 'END;';

         EXECUTE IMMEDIATE l_sql_string;
      END IF;

      cz_pb_mgr.v_model_usages_tbl.DELETE;
      cz_pb_mgr.v_usages_lang_tbl.DELETE;

      BEGIN
         SELECT model_usage_id, LANGUAGE
         BULK COLLECT INTO cz_pb_mgr.v_model_usages_tbl, v_usages_lang_tbl
           FROM cz_model_usages_tl;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cz_pb_mgr.v_err_message := 'No model usages translations found';
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.USGS', SQLCODE);
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_model_usages_tl', 'SQLERRM', SQLERRM);
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.USGS', SQLCODE);
            cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            RAISE;
      END;

      IF (cz_pb_mgr.v_model_usages_tbl.COUNT > 0)
      THEN
         EXECUTE IMMEDIATE    'BEGIN'
                           || ' '
                           || 'DELETE FROM CZ_MODEL_USAGES_TL'
                           || cz_pb_mgr.v_db_link
                           || ';'
                           || ' '
                           || 'FOR I IN cz_pb_mgr.v_model_usages_tbl.FIRST..cz_pb_mgr.v_model_usages_tbl.LAST'
                           || ' '
                           || 'LOOP'
                           || ' '
                           || 'BEGIN'
                           || ' '
                           || 'INSERT INTO cz_model_usages_tl'
                           || cz_pb_mgr.v_db_link
                           || ' '
                           || '(MODEL_USAGE_ID,LANGUAGE,SOURCE_LANG,DESCRIPTION)'
                           || ' '
                           || 'SELECT MODEL_USAGE_ID,LANGUAGE,SOURCE_LANG,DESCRIPTION FROM cz_model_usages_tl t'
                           || ' '
                           || 'WHERE t.model_usage_id = cz_pb_mgr.v_model_usages_tbl(i)'
                           || ' '
                           || 'and t.language=cz_pb_mgr.v_usages_lang_tbl(i);'
                           || ' '
                           || 'END;'
                           || ' '
                           || 'END LOOP;'
                           || ' '
                           || 'END;';
      END IF;

      cz_pb_mgr.v_model_usages_tbl.DELETE;
      cz_pb_mgr.v_usages_lang_tbl.DELETE;
   EXCEPTION
      WHEN OTHERS
      THEN
         ROLLBACK;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERTION_ERR', 'TABLENAME', 'cz_model_usages', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.USAGES', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END load_usages;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----procedure that checks if a model has been published earlier
----@p_publication_id : publication_id of the publication request
----x_record_count : returns count of earlier publications
   PROCEDURE chk_if_aleady_published(p_publication_id IN cz_model_publications.publication_id%TYPE, x_record_count IN OUT NOCOPY NUMBER)
   AS
   BEGIN
      IF (g_object_type = MODEL_PUBLICATION)
      THEN
         SELECT COUNT(*)
           INTO x_record_count
           FROM cz_model_publications z
          WHERE z.object_id = (SELECT object_id
                                 FROM cz_model_publications
                                WHERE cz_model_publications.publication_id = p_publication_id)
            AND z.server_id = (SELECT server_id
                                 FROM cz_model_publications
                                WHERE cz_model_publications.publication_id = p_publication_id)
            AND z.model_last_struct_update =
                   (SELECT last_struct_update
                      FROM cz_devl_projects
                     WHERE cz_devl_projects.devl_project_id =
                                          (SELECT object_id
                                             FROM cz_model_publications
                                            WHERE cz_model_publications.publication_id = p_publication_id AND cz_model_publications.deleted_flag = '0'))
            AND z.export_status IN('OK', 'PUP')
            AND z.source_target_flag = g_source_flag
            AND z.deleted_flag = record_not_deleted;
      ELSIF(g_object_type = template_publication)
      THEN
         SELECT COUNT(*)
           INTO x_record_count
           FROM cz_model_publications z
          WHERE z.object_id = (SELECT object_id
                                 FROM cz_model_publications
                                WHERE cz_model_publications.publication_id = p_publication_id)
            AND z.server_id = (SELECT server_id
                                 FROM cz_model_publications
                                WHERE cz_model_publications.publication_id = p_publication_id)
            AND z.export_status IN('OK', 'PUP')
            AND z.source_target_flag = g_source_flag
            AND z.deleted_flag = record_not_deleted;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END chk_if_aleady_published;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that gets the date on which the model was last published
-----@p_model_id: model_id on the publication request
-----@p_server_id : server_id on the publication request
-----x_last_xfr_activity : last published date
   PROCEDURE get_last_xfr_activity(
      p_model_id IN cz_model_publications.model_id%TYPE
     ,p_server_id IN cz_model_publications.server_id%TYPE
     ,x_last_xfr_activity IN OUT NOCOPY DATE
   )
   AS
   BEGIN
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         SELECT last_xfr_activity
           INTO x_last_xfr_activity
           FROM cz_pb_model_exports
          WHERE cz_pb_model_exports.export_id =
                   (SELECT MAX(export_id)
                      FROM cz_pb_model_exports z
                     WHERE z.root_model_id = p_model_id
                       AND z.server_id = p_server_id
                       AND z.status = 'OK'
                       AND z.publication_id IN(
                              SELECT publication_id
                                FROM cz_model_publications
                               WHERE export_status IN('OK', 'PUP')
                                 AND server_id = p_server_id
                                 AND UPPER(publication_mode) = cz_model_migration_pvt.mode_migration));
				 --SPUPPALA bug#7116052 7-AUG-2009
      ELSE
         SELECT last_xfr_activity
           INTO x_last_xfr_activity
           FROM cz_pb_model_exports
          WHERE cz_pb_model_exports.export_id =
                   (SELECT MAX(export_id)
                      FROM cz_pb_model_exports z
                     WHERE z.root_model_id = p_model_id
                       AND z.server_id = p_server_id
                       AND z.status = 'OK'
                       AND z.publication_id IN(
                              SELECT publication_id
                                FROM cz_model_publications
                               WHERE export_status IN('OK', 'PUP')
                                 AND server_id = p_server_id
                                 AND UPPER(publication_mode) <> cz_model_migration_pvt.mode_migration));
				 --SPUPPALA bug#7116052 7-AUG-2009
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_last_xfr_activity := NULL;
   END get_last_xfr_activity;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that retrieves the last update date from cz_expression nodes
-----required to check if rules have been changed since it was last published
   PROCEDURE get_max_expr_date(p_model_id cz_model_publications.model_id%TYPE, x_expr_node_date IN OUT NOCOPY DATE)
   AS
   BEGIN
      SELECT MAX(last_update_date)
        INTO x_expr_node_date
        FROM cz_expression_nodes t
       WHERE t.deleted_flag = record_not_deleted
         AND t.expr_type <> 208
         AND EXISTS(SELECT 1
                      FROM cz_rules
                     WHERE rule_id = t.rule_id AND devl_project_id = p_model_id AND deleted_flag = record_not_deleted)
         AND t.deleted_flag = record_not_deleted
         AND t.expr_type <> 208;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_expr_node_date := cz_utils.epoch_begin;
   END get_max_expr_date;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that retrieves the last_struct_update date
-----required to check if ps structure been changed since model was last published
   PROCEDURE get_last_struct_date(p_model_id cz_model_publications.model_id%TYPE, x_last_struct_date IN OUT NOCOPY DATE)
   AS
   BEGIN
      SELECT last_struct_update
        INTO x_last_struct_date
        FROM cz_devl_projects t
       WHERE t.deleted_flag = record_not_deleted AND t.devl_project_id = p_model_id;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_last_struct_date := cz_utils.epoch_begin;
   END get_last_struct_date;

--------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that returns the source ui_defs for export
-----@p_model_id   : model that is exported
-----@p_src_models : source models array
-----x_ui_def_ref  : output of source ui defs
   PROCEDURE get_source_uis(
      p_model_id IN cz_model_publications.model_id%TYPE
     ,p_src_models IN cz_pb_mgr.t_ref
     ,x_ui_def_ref IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   AS
      v_ui_def_count NUMBER := 0;
      v_src_uis_tbl cz_pb_mgr.t_ref;
      v_cz_ui_defs_old_ref_idx_ref cz_pb_mgr.t_ref_idx_vc2;
      l_export_model_id cz_devl_projects.devl_project_id%TYPE;
   BEGIN
      IF (p_src_models.COUNT > 0)
      THEN
         x_ui_def_ref.DELETE;

         FOR i IN p_src_models.FIRST .. p_src_models.LAST
         LOOP
            l_export_model_id := p_src_models(i);
            v_src_uis_tbl.DELETE;

            BEGIN
               SELECT cz_ui_defs.ui_def_id
               BULK COLLECT INTO v_src_uis_tbl
                 FROM cz_ui_defs
                WHERE cz_ui_defs.devl_project_id = l_export_model_id
                  AND cz_ui_defs.deleted_flag = '0'
                  AND cz_ui_defs.ui_style <> 7
                  AND cz_ui_defs.NAME <> 'MUID';
            EXCEPTION
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := SUBSTR('bulk collection into cz_pb_mgr.v_cz_ui_defs_old_tbl: ' || SQLERRM, 1, 2000);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:CZUIDEFS', SQLCODE);
            END;

            IF (v_src_uis_tbl.COUNT > 0)
            THEN
               v_ui_def_count := x_ui_def_ref.COUNT;

               FOR k IN v_src_uis_tbl.FIRST .. v_src_uis_tbl.LAST
               LOOP
                  IF (NOT v_cz_ui_defs_old_ref_idx_ref.EXISTS(v_src_uis_tbl(k)))
                  THEN
                     v_ui_def_count := v_ui_def_count + 1;
                     x_ui_def_ref(v_ui_def_count) := v_src_uis_tbl(k);
                     v_cz_ui_defs_old_ref_idx_ref(v_src_uis_tbl(k)) := v_src_uis_tbl(k);
                  END IF;
               END LOOP;
            END IF;

            v_src_uis_tbl.DELETE;

            BEGIN
               SELECT DISTINCT ui_def_ref_id
               BULK COLLECT INTO v_src_uis_tbl
                          FROM cz_ui_nodes
                         WHERE cz_ui_nodes.ui_def_id IN(
                                  SELECT cz_ui_defs.ui_def_id
                                    FROM cz_ui_defs
                                   WHERE cz_ui_defs.devl_project_id = l_export_model_id AND cz_ui_defs.deleted_flag = '0'
                                         AND cz_ui_defs.NAME <> 'MUID')
                           AND cz_ui_nodes.ui_def_ref_id IN(
                                  SELECT cz_ui_defs.ui_def_id
                                    FROM cz_ui_defs
                                   WHERE cz_ui_defs.devl_project_id = l_export_model_id AND cz_ui_defs.deleted_flag = '0'
                                         AND cz_ui_defs.NAME <> 'MUID')
                           AND cz_ui_nodes.deleted_flag = '0'
                           AND cz_ui_nodes.ui_def_ref_id IS NOT NULL;
            EXCEPTION
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := SUBSTR('bulk collection into cz_pb_mgr.v_cz_ui_defs_old_tbl: ' || SQLERRM, 1, 2000);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:CZUIDEFS', SQLCODE);
            END;

            IF (v_src_uis_tbl.COUNT > 0)
            THEN
               v_ui_def_count := x_ui_def_ref.COUNT;

               FOR k IN v_src_uis_tbl.FIRST .. v_src_uis_tbl.LAST
               LOOP
                  IF (NOT v_cz_ui_defs_old_ref_idx_ref.EXISTS(v_src_uis_tbl(k)))
                  THEN
                     v_ui_def_count := v_ui_def_count + 1;
                     x_ui_def_ref(v_ui_def_count) := v_src_uis_tbl(k);
                     v_cz_ui_defs_old_ref_idx_ref(v_src_uis_tbl(k)) := v_src_uis_tbl(k);
                  END IF;
               END LOOP;
            END IF;
         END LOOP;                                                                                       /* end loop of FOR I IN p_src_models.FIRST */
      END IF;                                                                                                 /* end if of (p_src_models.COUNT > 0) */
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END get_source_uis;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----procedure that returns the max last_update_date of ui schema
   PROCEDURE get_max_ui_date(p_ui_def_id IN cz_model_publications.ui_def_id%TYPE, x_max_update_date IN OUT NOCOPY DATE)
   AS
      v_ui_def_id_date cz_ui_defs.last_update_date%TYPE;
      v_ui_node_id_date cz_ui_nodes.last_update_date%TYPE;
      v_ui_props_date cz_ui_nodes.last_update_date%TYPE;
      v_ui_node_props_date cz_ui_nodes.last_update_date%TYPE;
      v_ui_node_intl_date cz_ui_nodes.last_update_date%TYPE;
      v_initialized_date DATE;
      v_ui_pages_date DATE;
      v_ui_pages_capt_date DATE;
      v_ui_page_sets_date DATE;
      v_ui_page_refs_date DATE;
      v_ui_pg_ref_capt_date DATE;
      v_ui_refs_date DATE;
      v_ui_templs_date DATE;
      v_ui_cont_templs_date DATE;
      v_ui_actions_date DATE;
      v_ui_images_date DATE;
      v_page_elements_date DATE;

      CURSOR ui_def_cur(ui_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_defs
            WHERE cz_ui_defs.ui_def_id = ui_ui_def_id AND cz_ui_defs.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_nodes_cur(node_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_nodes
            WHERE cz_ui_nodes.ui_def_id = node_ui_def_id AND cz_ui_nodes.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_properties_cur(prop_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_properties
            WHERE cz_ui_properties.ui_def_id = prop_ui_def_id AND cz_ui_properties.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_node_props_cur(nodeprops_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_node_props
            WHERE cz_ui_node_props.ui_def_id = nodeprops_ui_def_id AND cz_ui_node_props.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_intl_texts_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_intl_texts
            WHERE intl_text_id IN(SELECT f.tool_tip_id
                                    FROM cz_ui_nodes f
                                   WHERE f.ui_def_id = p_ui_def_id AND f.deleted_flag = '0'
                                  UNION
                                  SELECT g.caption_id
                                    FROM cz_ui_nodes g
                                   WHERE g.ui_def_id = p_ui_def_id AND g.deleted_flag = '0')
         ORDER BY last_update_date DESC;

      CURSOR ui_pages_cur(ui_pages_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_pages
            WHERE cz_ui_pages.ui_def_id = ui_pages_def_id
         ORDER BY last_update_date DESC;

      CURSOR ui_pages_capt_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_intl_texts
            WHERE intl_text_id IN(SELECT caption_text_id
                                    FROM cz_ui_pages
                                   WHERE cz_ui_pages.ui_def_id = p_ui_def_id)
         ORDER BY last_update_date DESC;

      CURSOR ui_page_sets_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_page_sets
            WHERE cz_ui_page_sets.ui_def_id = p_ui_def_id AND cz_ui_page_sets.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_page_refs_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_page_refs
            WHERE cz_ui_page_refs.ui_def_id = p_ui_def_id AND cz_ui_page_refs.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_page_refs_capt_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_intl_texts
            WHERE intl_text_id IN(SELECT caption_text_id
                                    FROM cz_ui_page_refs
                                   WHERE cz_ui_page_refs.ui_def_id = p_ui_def_id)
         ORDER BY last_update_date DESC;

      CURSOR ui_refs_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_refs
            WHERE cz_ui_refs.ui_def_id = p_ui_def_id AND cz_ui_refs.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_templs_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_templates
            WHERE cz_ui_templates.ui_def_id = p_ui_def_id AND cz_ui_templates.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_cont_templs_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_cont_type_templs
            WHERE cz_ui_cont_type_templs.ui_def_id = p_ui_def_id AND cz_ui_cont_type_templs.deleted_flag = '0'
         ORDER BY last_update_date DESC;

      CURSOR ui_actions_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_actions
            WHERE cz_ui_actions.ui_def_id = p_ui_def_id
         ORDER BY last_update_date DESC;

      CURSOR ui_images_cur(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_images
            WHERE cz_ui_images.ui_def_id = p_ui_def_id
         ORDER BY last_update_date DESC;
      CURSOR ui_page_elements(p_ui_def_id NUMBER)
      IS
         SELECT   last_update_date
             FROM cz_ui_page_elements
            WHERE cz_ui_page_elements.ui_def_id = p_ui_def_id
         ORDER BY last_update_date DESC;
   BEGIN
      v_initialized_date := cz_utils.epoch_begin;
      v_ui_def_id_date := v_initialized_date;
      v_ui_node_id_date := v_initialized_date;
      v_ui_props_date := v_initialized_date;
      v_ui_node_props_date := v_initialized_date;
      v_ui_node_intl_date := v_initialized_date;
      v_ui_pages_date := v_initialized_date;
      v_ui_pages_capt_date := v_initialized_date;
      v_ui_page_sets_date := v_initialized_date;
      v_ui_page_refs_date := v_initialized_date;
      v_ui_pg_ref_capt_date := v_initialized_date;
      v_ui_refs_date := v_initialized_date;
      v_ui_templs_date := v_initialized_date;
      v_ui_cont_templs_date := v_initialized_date;
      v_ui_actions_date := v_initialized_date;
      v_ui_images_date := v_initialized_date;

      BEGIN
         OPEN ui_def_cur(p_ui_def_id);

         LOOP
            FETCH ui_def_cur
             INTO v_ui_def_id_date;

            EXIT WHEN ui_def_cur%NOTFOUND;
            EXIT WHEN ui_def_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_def_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_def_id_date := cz_utils.epoch_begin;

            CLOSE ui_def_cur;
      END;

      BEGIN
         OPEN ui_nodes_cur(p_ui_def_id);

         LOOP
            FETCH ui_nodes_cur
             INTO v_ui_node_id_date;

            EXIT WHEN ui_nodes_cur%NOTFOUND;
            EXIT WHEN ui_nodes_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_nodes_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_node_id_date := cz_utils.epoch_begin;

            CLOSE ui_nodes_cur;
      END;

      BEGIN
         OPEN ui_properties_cur(p_ui_def_id);

         LOOP
            FETCH ui_properties_cur
             INTO v_ui_props_date;

            EXIT WHEN ui_properties_cur%NOTFOUND;
            EXIT WHEN ui_properties_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_properties_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_props_date := cz_utils.epoch_begin;

            CLOSE ui_properties_cur;
      END;

      BEGIN
         OPEN ui_node_props_cur(p_ui_def_id);

         LOOP
            FETCH ui_node_props_cur
             INTO v_ui_node_props_date;

            EXIT WHEN ui_node_props_cur%NOTFOUND;
            EXIT WHEN ui_node_props_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_node_props_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_node_props_date := cz_utils.epoch_begin;

            CLOSE ui_node_props_cur;
      END;

      BEGIN
         OPEN ui_intl_texts_cur(p_ui_def_id);

         LOOP
            FETCH ui_intl_texts_cur
             INTO v_ui_node_intl_date;

            EXIT WHEN ui_intl_texts_cur%NOTFOUND;
            EXIT WHEN ui_intl_texts_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_intl_texts_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_node_intl_date := cz_utils.epoch_begin;

            CLOSE ui_intl_texts_cur;
      END;

      BEGIN
         OPEN ui_pages_cur(p_ui_def_id);

         LOOP
            FETCH ui_pages_cur
             INTO v_ui_pages_date;

            EXIT WHEN ui_pages_cur%NOTFOUND;
            EXIT WHEN ui_pages_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_pages_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_pages_date := cz_utils.epoch_begin;

            CLOSE ui_pages_cur;
      END;

      BEGIN
         OPEN ui_pages_capt_cur(p_ui_def_id);

         LOOP
            FETCH ui_pages_capt_cur
             INTO v_ui_pages_capt_date;

            EXIT WHEN ui_pages_capt_cur%NOTFOUND;
            EXIT WHEN ui_pages_capt_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_pages_capt_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_pages_capt_date := cz_utils.epoch_begin;

            CLOSE ui_pages_capt_cur;
      END;

      BEGIN
         OPEN ui_page_sets_cur(p_ui_def_id);

         LOOP
            FETCH ui_page_sets_cur
             INTO v_ui_page_sets_date;

            EXIT WHEN ui_page_sets_cur%NOTFOUND;
            EXIT WHEN ui_page_sets_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_page_sets_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_page_sets_date := cz_utils.epoch_begin;

            CLOSE ui_page_sets_cur;
      END;

      BEGIN
         OPEN ui_page_refs_cur(p_ui_def_id);

         LOOP
            FETCH ui_page_refs_cur
             INTO v_ui_page_refs_date;

            EXIT WHEN ui_page_refs_cur%NOTFOUND;
            EXIT WHEN ui_page_refs_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_page_refs_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_page_refs_date := cz_utils.epoch_begin;

            CLOSE ui_page_refs_cur;
      END;

      BEGIN
         OPEN ui_page_refs_capt_cur(p_ui_def_id);

         LOOP
            FETCH ui_page_refs_capt_cur
             INTO v_ui_pg_ref_capt_date;

            EXIT WHEN ui_page_refs_capt_cur%NOTFOUND;
            EXIT WHEN ui_page_refs_capt_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_page_refs_capt_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_pg_ref_capt_date := cz_utils.epoch_begin;

            CLOSE ui_page_refs_capt_cur;
      END;

      BEGIN
         OPEN ui_refs_cur(p_ui_def_id);

         LOOP
            FETCH ui_refs_cur
             INTO v_ui_refs_date;

            EXIT WHEN ui_refs_cur%NOTFOUND;
            EXIT WHEN ui_refs_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_refs_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_refs_date := cz_utils.epoch_begin;

            CLOSE ui_refs_cur;
      END;

      BEGIN
         OPEN ui_templs_cur(p_ui_def_id);

         LOOP
            FETCH ui_templs_cur
             INTO v_ui_templs_date;

            EXIT WHEN ui_templs_cur%NOTFOUND;
            EXIT WHEN ui_templs_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_templs_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_templs_date := cz_utils.epoch_begin;

            CLOSE ui_templs_cur;
      END;

      BEGIN
         OPEN ui_cont_templs_cur(p_ui_def_id);

         LOOP
            FETCH ui_cont_templs_cur
             INTO v_ui_cont_templs_date;

            EXIT WHEN ui_cont_templs_cur%NOTFOUND;
            EXIT WHEN ui_cont_templs_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_cont_templs_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_cont_templs_date := cz_utils.epoch_begin;

            CLOSE ui_cont_templs_cur;
      END;

      BEGIN
         OPEN ui_actions_cur(p_ui_def_id);

         LOOP
            FETCH ui_actions_cur
             INTO v_ui_actions_date;

            EXIT WHEN ui_actions_cur%NOTFOUND;
            EXIT WHEN ui_actions_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_actions_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_actions_date := cz_utils.epoch_begin;

            CLOSE ui_actions_cur;
      END;

      BEGIN
         OPEN ui_images_cur(p_ui_def_id);

         LOOP
            FETCH ui_images_cur
             INTO v_ui_images_date;

            EXIT WHEN ui_images_cur%NOTFOUND;
            EXIT WHEN ui_images_cur%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_images_cur;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_images_date := cz_utils.epoch_begin;

            CLOSE ui_images_cur;
      END;

      BEGIN
         OPEN ui_page_elements(p_ui_def_id);

         LOOP
            FETCH ui_page_elements
             INTO v_page_elements_date;

            EXIT WHEN ui_page_elements%NOTFOUND;
            EXIT WHEN ui_page_elements%ROWCOUNT = 1;
         END LOOP;

         CLOSE ui_page_elements;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_page_elements_date := cz_utils.epoch_begin;
            CLOSE ui_page_elements;
      END;
      BEGIN
         SELECT MAX(GREATEST(v_ui_def_id_date
                            ,v_ui_node_id_date
                            ,v_ui_props_date
                            ,v_ui_node_props_date
                            ,v_ui_node_intl_date
                            ,v_ui_pages_date
                            ,v_ui_pages_capt_date
                            ,v_ui_page_sets_date
                            ,v_ui_page_refs_date
                            ,v_ui_page_refs_date
                            ,v_ui_pg_ref_capt_date
                            ,v_ui_refs_date
                            ,v_ui_templs_date
                            ,v_ui_cont_templs_date
                            ,v_ui_actions_date
                            ,v_ui_images_date
                            ,v_page_elements_date
                            )
                   )
           INTO x_max_update_date
           FROM DUAL;
      EXCEPTION
         WHEN OTHERS
         THEN
            x_max_update_date := cz_utils.epoch_begin;
      END;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END get_max_ui_date;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure that retrieves all source models
   PROCEDURE get_source_models(p_model_id IN cz_model_publications.model_id%TYPE, x_models_tbl IN OUT NOCOPY cz_pb_mgr.t_ref)
   AS
      v_count PLS_INTEGER := 0;
      v_component_id cz_model_ref_expls.component_id%TYPE;

      CURSOR models_cur(in_root_model NUMBER)
      IS
         SELECT DISTINCT component_id
                    FROM cz_model_ref_expls x
                   WHERE x.model_id = in_root_model AND x.ps_node_type IN(263, 264) AND x.deleted_flag = '0';
   BEGIN
      x_models_tbl.DELETE;
      v_count := 0;

      OPEN models_cur(p_model_id);

      LOOP
         FETCH models_cur
          INTO v_component_id;

         EXIT WHEN models_cur%NOTFOUND;
         v_count := v_count + 1;
         x_models_tbl(v_count) := v_component_id;
      END LOOP;

      CLOSE models_cur;

      v_count := v_count + 1;
      x_models_tbl(v_count) := p_model_id;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END get_source_models;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------procedure that checks if logic has changed since the model was last published
   PROCEDURE chk_if_logic_changed(p_model_array IN cz_pb_mgr.t_ref, p_last_xfr_date IN DATE, x_record_count IN OUT NOCOPY NUMBER)
   AS
      v_last_logic_update cz_devl_projects.last_logic_update%TYPE;
      v_expr_node_date cz_ui_nodes.last_update_date%TYPE;
   BEGIN
      IF (p_model_array.COUNT > 0)
      THEN
         FOR i IN p_model_array.FIRST .. p_model_array.LAST
         LOOP
            get_max_expr_date(p_model_array(i), v_expr_node_date);

            IF ((p_last_xfr_date IS NOT NULL) AND(p_last_xfr_date < v_expr_node_date))
            THEN
               x_record_count := refresh_rules_count;
               EXIT;
            END IF;

            BEGIN
               SELECT last_logic_update
                 INTO v_last_logic_update
                 FROM cz_devl_projects
                WHERE cz_devl_projects.devl_project_id = p_model_array(i) AND cz_devl_projects.deleted_flag = '0';
            EXCEPTION
               WHEN OTHERS
               THEN
                  v_last_logic_update := NULL;
            END;

            IF ((v_last_logic_update IS NOT NULL) AND(p_last_xfr_date < v_last_logic_update))
            THEN
               x_record_count := refresh_rules_count;
               EXIT;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END chk_if_logic_changed;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------procedure that checks if archives have changed since the model was last published
   PROCEDURE chk_if_archives_changed(p_model_array IN cz_pb_mgr.t_ref, p_last_xfr_date IN DATE, x_record_count IN OUT NOCOPY NUMBER)
   AS
      v_last_archive_update cz_archives.last_update_date%TYPE;
   BEGIN
      IF (p_model_array.COUNT > 0)
      THEN
         FOR i IN p_model_array.FIRST .. p_model_array.LAST
         LOOP
            BEGIN
               SELECT GREATEST(MAX(arch.last_update_date), MAX(refs.last_update_date))
                 INTO v_last_archive_update
                 FROM cz_archives arch, cz_archive_refs refs
                WHERE refs.devl_project_id = p_model_array(i) AND arch.archive_id = refs.archive_id AND arch.deleted_flag = '0'
                      AND refs.deleted_flag = 0;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  v_last_archive_update := NULL;
            END;

            IF ((v_last_archive_update IS NOT NULL) AND(p_last_xfr_date < v_last_archive_update))
            THEN
               x_record_count := refresh_rules_count;
               EXIT;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END chk_if_archives_changed;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure checks if model structure has changed since it was last published
   PROCEDURE chk_if_struct_changed(p_model_array IN cz_pb_mgr.t_ref, p_last_xfr_date IN DATE, x_record_count IN OUT NOCOPY NUMBER)
   AS
      v_last_logic_update cz_devl_projects.last_logic_update%TYPE;
      v_last_struct_date cz_devl_projects.last_struct_update%TYPE;
   BEGIN
      IF (p_model_array.COUNT > 0)
      THEN
         FOR i IN p_model_array.FIRST .. p_model_array.LAST
         LOOP
            get_last_struct_date(p_model_array(i), v_last_struct_date);

            IF ((p_last_xfr_date IS NOT NULL) AND(p_last_xfr_date < v_last_struct_date))
            THEN
               x_record_count := -777;
               EXIT;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----get last update date for FC
   PROCEDURE get_fc_date(p_model_array IN cz_pb_mgr.t_ref, x_max_update_date IN OUT NOCOPY DATE)
   AS
      v_update_date cz_func_comp_specs.last_update_date%TYPE;
   BEGIN
      IF (p_model_array.COUNT > 0)
      THEN
         x_max_update_date := cz_utils.epoch_begin;

         FOR i IN p_model_array.FIRST .. p_model_array.LAST
         LOOP
            BEGIN
               SELECT MAX(last_update_date)
                 INTO v_update_date
                 FROM cz_func_comp_specs
                WHERE cz_func_comp_specs.devl_project_id = p_model_array(i) AND cz_func_comp_specs.deleted_flag = record_not_deleted;
            EXCEPTION
               WHEN OTHERS
               THEN
                  v_update_date := NULL;
            END;

            IF (v_update_date IS NOT NULL)
            THEN
               IF (v_update_date > x_max_update_date)
               THEN
                  x_max_update_date := v_update_date;
               END IF;
            END IF;
         END LOOP;
      END IF;
   END get_fc_date;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that retrieves the max last update date
------for ps nodes on the model
   PROCEDURE get_psnode_last_date(p_model_id IN NUMBER, x_last_update_date OUT NOCOPY DATE) AS
   BEGIN
     SELECT MAX(last_update_date)
       INTO x_last_update_date
       FROM cz_ps_nodes
      WHERE devl_project_id = p_model_id;
   EXCEPTION
     WHEN OTHERS THEN
       x_last_update_date := cz_utils.epoch_begin;
   END;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that retrieves the max last update date
------for the description on the model
   PROCEDURE get_intl_text_date(p_model_id IN NUMBER, x_last_update_date OUT NOCOPY DATE)
   AS
   BEGIN
      SELECT MAX(last_update_date)
        INTO x_last_update_date
        FROM cz_localized_texts
       WHERE model_id = p_model_id;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_last_update_date := cz_utils.epoch_begin;
   END;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE get_max_template_date(p_template_id IN NUMBER, x_max_date OUT NOCOPY DATE)
   IS
   BEGIN
      SELECT last_update_date
        INTO x_max_date
        FROM cz_ui_templates
       WHERE cz_ui_templates.template_id = p_template_id AND cz_ui_templates.deleted_flag = record_not_deleted;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_max_date := cz_utils.epoch_begin;
   END get_max_template_date;

--------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE get_template_date(p_global_templs_ref IN cz_pb_mgr.t_ref, x_max_update_date IN OUT NOCOPY DATE)
   IS
      l_last_update_date DATE;
      l_prev_date DATE := cz_utils.epoch_begin;
   BEGIN
      x_max_update_date := cz_utils.epoch_begin;

      IF (p_global_templs_ref.COUNT > 0)
      THEN
         FOR i IN p_global_templs_ref.FIRST .. p_global_templs_ref.LAST
         LOOP
            SELECT last_update_date
              INTO l_last_update_date
              FROM cz_ui_templates
             WHERE cz_ui_templates.template_id = p_global_templs_ref(i)
               AND cz_ui_templates.deleted_flag = record_not_deleted
               AND cz_ui_templates.ui_def_id = 0;

            IF (l_last_update_date > l_prev_date)
            THEN
               x_max_update_date := l_last_update_date;
            END IF;

            l_prev_date := x_max_update_date;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         x_max_update_date := cz_utils.epoch_begin;
   END get_template_date;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE get_last_templ_activity(p_global_templs_ref IN cz_pb_mgr.t_ref, p_server_id IN NUMBER, x_last_xfr_activity OUT NOCOPY DATE)
   IS
      l_last_update_date DATE;
      l_prev_date DATE := cz_utils.epoch_begin;
      rec_count NUMBER := 0;
      l_pub_mode cz_model_publications.publication_mode%TYPE := cz_model_migration_pvt.mode_publication;
   BEGIN
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         l_pub_mode := cz_model_migration_pvt.mode_migration;
      ELSIF(cz_pb_mgr.v_session_parameter = cz_pb_mgr.model_copy)
      THEN
         l_pub_mode := cz_model_migration_pvt.mode_copy;
      END IF;

      x_last_xfr_activity := cz_utils.epoch_begin;

      IF (p_global_templs_ref.COUNT > 0)
      THEN
         FOR i IN p_global_templs_ref.FIRST .. p_global_templs_ref.LAST
         LOOP
            BEGIN
               SELECT MAX(published)
                 INTO l_last_update_date
                 FROM cz_model_publications
                WHERE cz_model_publications.object_id = p_global_templs_ref(i)
                  AND cz_model_publications.deleted_flag = record_not_deleted
                  AND cz_model_publications.object_type = template_publication
                  AND UPPER(cz_model_publications.publication_mode) = l_pub_mode;
		  --SPUPPALA bug#7116052 7-AUG-2009
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
            END;

            IF (l_last_update_date >= l_prev_date)
            THEN
               x_last_xfr_activity := l_last_update_date;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_last_xfr_activity := cz_utils.epoch_begin;
   END get_last_templ_activity;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE get_effectivity_set_date(p_model_id IN NUMBER, x_last_update_date OUT NOCOPY DATE)
   IS
   BEGIN
      SELECT MAX(last_update_date)
        INTO x_last_update_date
        FROM cz_effectivity_sets
       WHERE cz_effectivity_sets.effectivity_set_id IN(
                SELECT DISTINCT effectivity_set_id
                           FROM cz_ps_nodes
                          WHERE cz_ps_nodes.devl_project_id = p_model_id
                            AND cz_ps_nodes.deleted_flag = record_not_deleted
                            AND cz_ps_nodes.effectivity_set_id IS NOT NULL);
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         x_last_update_date := cz_utils.epoch_begin;
   END get_effectivity_set_date;

--------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------get last update date for effectivity
   PROCEDURE get_eff_date(p_model_array IN cz_pb_mgr.t_ref, x_max_update_date IN OUT NOCOPY DATE)
   AS
      v_update_date cz_effectivity_sets.last_update_date%TYPE;
   BEGIN
      IF (p_model_array.COUNT > 0)
      THEN
         x_max_update_date := cz_utils.epoch_begin;

         FOR i IN p_model_array.FIRST .. p_model_array.LAST
         LOOP
            get_effectivity_set_date(p_model_array(i), v_update_date);

            IF (v_update_date > x_max_update_date)
            THEN
               x_max_update_date := v_update_date;
            END IF;
         END LOOP;
      END IF;
   END get_eff_date;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE collect_global_actions(p_elem_id_tbl IN OUT NOCOPY cz_pb_mgr.t_ref, p_elem_type_ref IN OUT NOCOPY cz_pb_mgr.t_ref)
   IS
      l_ui_actns_ui_act_id_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ui_act_new_id_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ui_uidef_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ui_tgtui_tbl cz_pb_mgr.t_ref;
      l_ui_actns_tgtexpl_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ctx_comp_tbl cz_pb_mgr.t_ref;
      l_ui_actns_ren_cond_tbl cz_pb_mgr.t_ref;
      l_prcpg_templ_tbl cz_pb_mgr.t_ref;
      l_prcpg_tmpui_tbl cz_pb_mgr.t_ref;
      l_prc_caption_tbl cz_pb_mgr.t_ref;
      l_pg_title_tbl    cz_pb_mgr.t_ref;
      l_main_msg_tbl    cz_pb_mgr.t_ref;
      l_text_tbl        t_ref;
      l_text_count      PLS_INTEGER := 0;
      rec_count         NUMBER;
   BEGIN
      IF (p_elem_id_tbl.COUNT > 0) THEN
         rec_count := cz_pb_mgr.g_ui_actns_ui_act_id_ref.COUNT;

         FOR i IN p_elem_id_tbl.FIRST .. p_elem_id_tbl.LAST
         LOOP
            l_ui_actns_ui_act_id_tbl.DELETE;
            l_ui_actns_ui_uidef_tbl.DELETE;
            l_ui_actns_ui_tgtui_tbl.DELETE;
            l_ui_actns_tgtexpl_tbl.DELETE;
            l_ui_actns_ctx_comp_tbl.DELETE;
            l_ui_actns_ren_cond_tbl.DELETE;
            l_prcpg_templ_tbl.DELETE;
	    l_prcpg_tmpui_tbl.DELETE;
	    l_prc_caption_tbl.DELETE;
	    l_pg_title_tbl.DELETE;
            l_main_msg_tbl.DELETE;

            IF (p_elem_type_ref(i) = 552) THEN
               SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_ui_actions_seq
                                                 , 'cz_ui_actions_s.nextval' || cz_pb_mgr.v_db_link
                                                 ,cz_pb_mgr.v_oraclesequenceincr
                                                 )
                     ,ui_action_id, ui_def_id, target_ui_def_id, target_expl_node_id, context_component_id
                     ,render_condition_id, PROCESSING_PAGE_TEMPL_ID, PROC_PAGE_TEMPL_UI_DEF_ID
                     ,PROCESSING_CAPTION_TEXT_ID, PAGE_TITLE_TEXT_ID, MAIN_MESSAGE_TEXT_ID
               BULK COLLECT INTO l_ui_actns_ui_act_new_id_tbl
                     ,l_ui_actns_ui_act_id_tbl, l_ui_actns_ui_uidef_tbl, l_ui_actns_ui_tgtui_tbl
                     ,l_ui_actns_tgtexpl_tbl, l_ui_actns_ctx_comp_tbl, l_ui_actns_ren_cond_tbl
                     ,l_prcpg_templ_tbl,l_prcpg_tmpui_tbl,l_prc_caption_tbl,l_pg_title_tbl,l_main_msg_tbl
                 FROM cz_ui_actions
                WHERE cz_ui_actions.ui_action_id = p_elem_id_tbl(i)
                  AND cz_ui_actions.ui_def_id = 0
                  AND cz_ui_actions.deleted_flag = record_not_deleted
                  AND cz_ui_actions.seeded_flag <> seed_data;
            END IF;

            IF (l_ui_actns_ui_act_id_tbl.COUNT > 0) THEN
               FOR j IN l_ui_actns_ui_act_id_tbl.FIRST .. l_ui_actns_ui_act_id_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;

                  IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id <> 0) THEN
                     cz_pb_mgr.g_ui_actns_ui_act_id_ref(rec_count) := l_ui_actns_ui_act_new_id_tbl(j);
                     cz_pb_mgr.g_ui_actions_id_idx_ref(l_ui_actns_ui_act_id_tbl(j)):=l_ui_actns_ui_act_new_id_tbl(j);
                  ELSE
                    cz_pb_mgr.g_ui_actns_ui_act_id_ref(rec_count) := l_ui_actns_ui_act_id_tbl(j);
                  END IF;

                  cz_pb_mgr.g_ui_actns_ui_act_id_old_ref(rec_count) := l_ui_actns_ui_act_id_tbl(j);
                  cz_pb_mgr.g_ui_actns_ui_tgtui_ref(rec_count) := l_ui_actns_ui_tgtui_tbl(j);
                  cz_pb_mgr.g_ui_actns_ui_uidef_old_ref(rec_count) := l_ui_actns_ui_uidef_tbl(j);
                  cz_pb_mgr.g_ui_actns_tgtexpl_ref(rec_count) := l_ui_actns_tgtexpl_tbl(j);
                  cz_pb_mgr.g_ui_actns_ctx_comp_tbl(rec_count) := l_ui_actns_ctx_comp_tbl(j);
                  cz_pb_mgr.g_ui_actns_ren_cond_tbl(rec_count) := l_ui_actns_ren_cond_tbl(j); -- this col not used, otherwise we would have an issue
                  cz_pb_mgr.g_uiact_prcpg_templ_tbl(rec_count) := l_prcpg_templ_tbl(j);
                  cz_pb_mgr.g_uiact_prcpg_tmpui_tbl(rec_count) := l_prcpg_tmpui_tbl(j);
                  cz_pb_mgr.g_uiact_prc_caption_tbl(rec_count) := l_prc_caption_tbl(j);
                  cz_pb_mgr.g_uiact_pg_title_tbl(rec_count) := l_pg_title_tbl(j);
                  cz_pb_mgr.g_uiact_main_msg_tbl(rec_count) := l_main_msg_tbl(j);

                  -- no template element records for page title text, main msg, prc caption text
                  -- so we need to collect them here
                  IF l_prc_caption_tbl(j) IS NOT NULL THEN
                    l_text_count := l_text_count + 1;
                    l_text_tbl(l_text_count) := l_prc_caption_tbl(j);
                  END IF;
                  IF l_pg_title_tbl(j) IS NOT NULL THEN
                    l_text_count := l_text_count + 1;
                    l_text_tbl(l_text_count) := l_pg_title_tbl(j);
                  END IF;
                  IF l_main_msg_tbl(j) IS NOT NULL THEN
                    l_text_count := l_text_count + 1;
                    l_text_tbl(l_text_count) := l_main_msg_tbl(j);
                  END IF;
               END LOOP;

               IF l_text_count > 0 THEN
                 insert_intl_texts(l_text_tbl, 'global texts from ui actions', TRUE);
               END IF;

               IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN

                 --The resolution moved here from insert_template_elements.
                 BEGIN
                    p_elem_id_tbl(i) := cz_pb_mgr.g_ui_actions_id_idx_ref(p_elem_id_tbl(i));
                 EXCEPTION
                   WHEN OTHERS THEN
                     cz_pb_mgr.v_err_message := 'Error during resolution of ui_action id = ' || p_elem_id_tbl(i) || ': ' || SQLERRM;
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIACTIONS', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                     RAISE;
                 END;
               END IF;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         NULL;
      WHEN OTHERS THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_actions', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIACTIONS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END collect_global_actions;
--------------------------------
   PROCEDURE collect_global_texts(
      p_template_id_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_element_type_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,x_status_code IN OUT NOCOPY VARCHAR2
   )
   IS
      l_elem_text_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
   BEGIN
      IF (p_template_id_ref.COUNT > 0)
      THEN
         FOR i IN p_template_id_ref.FIRST .. p_template_id_ref.LAST
         LOOP
            IF (p_element_type_ref(i) = 8)
            THEN
               rec_count := l_elem_text_tbl.COUNT + 1;
               l_elem_text_tbl(rec_count) := p_template_id_ref(i);
            END IF;
         END LOOP;

         insert_intl_texts(l_elem_text_tbl, 'global texts', TRUE);

         FOR i IN p_template_id_ref.FIRST .. p_template_id_ref.LAST
         LOOP
            IF (p_element_type_ref(i) = 8)
            THEN
               p_template_id_ref(i) := cz_pb_mgr.v_cz_intl_text_idx_ref(p_template_id_ref(i));
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_COLLECT_GL_TEXTS', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_GLTEXTS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END collect_global_texts;

---------------------------------------------------------------
PROCEDURE collect_global_rules(
      p_rule_id_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_rule_type_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,x_status IN OUT NOCOPY VARCHAR2
    )
AS
  l_new_rule_id        NUMBER;
  l_old_rule_id        NUMBER;
  v_cz_rules_rf_id     NUMBER;
  v_cz_rules_proj_id   NUMBER;
  v_cz_rules_comp_id   NUMBER;
  v_cz_rules_rea_id    NUMBER;
  v_cz_rules_eff_id    NUMBER;
  v_cz_rules_unmsg_id  NUMBER;
  v_cz_rules_expl_id   NUMBER;
  v_cz_rules_sig       NUMBER;
  v_cz_rules_ui        NUMBER;
  v_cz_eff_usage_mask  cz_rules.effective_usage_mask%TYPE;

  rec_count            NUMBER;
BEGIN
  IF (x_status = PUBLICATION_ERROR OR p_rule_id_array.COUNT = 0) THEN
    RETURN;
  END IF;

  rec_count := cz_pb_mgr.v_cz_rules_rule_id_new_ref.COUNT;

  FOR i IN p_rule_id_array.FIRST .. p_rule_id_array.LAST
  LOOP
    IF (p_rule_type_array(i) IN (RULE_TYPE_DISPLAY_CONDITION, RULE_TYPE_ENABLED_CONDITION, RULE_TYPE_CAPTION)) THEN
      BEGIN
        SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_rules_seq
                                         ,'cz_rules_s.nextval' || cz_pb_mgr.v_db_link
                                          ,cz_pb_mgr.v_oraclesequenceincr
                                          )
              ,rule_id, rule_folder_id, devl_project_id, component_id
              ,reason_id, unsatisfied_msg_id, effectivity_set_id
              ,model_ref_expl_id, signature_id, ui_def_id, effective_usage_mask
         INTO l_new_rule_id
              ,l_old_rule_id, v_cz_rules_rf_id, v_cz_rules_proj_id, v_cz_rules_comp_id
              ,v_cz_rules_rea_id, v_cz_rules_unmsg_id, v_cz_rules_eff_id
              ,v_cz_rules_expl_id, v_cz_rules_sig, v_cz_rules_ui, v_cz_eff_usage_mask
        FROM cz_rules
        WHERE rule_id = p_rule_id_array(i) AND deleted_flag = '0' AND seeded_flag = '0';

        rec_count := rec_count + 1;
        cz_pb_mgr.v_cz_rules_rule_id_idx_ref(l_old_rule_id):=l_new_rule_id;
        cz_pb_mgr.v_cz_rules_rule_id_new_ref(rec_count) := l_new_rule_id;
        cz_pb_mgr.v_cz_rules_rule_id_old_ref(rec_count) := l_old_rule_id;
        cz_pb_mgr.v_cz_rules_proj_id_ref(rec_count) := v_cz_rules_proj_id;
        cz_pb_mgr.v_cz_rules_comp_id_ref(rec_count) := v_cz_rules_comp_id;
        cz_pb_mgr.v_cz_rules_rf_id_ref(rec_count) := 0;
        cz_pb_mgr.v_cz_rules_expl_ref(rec_count) := v_cz_rules_expl_id;
        cz_pb_mgr.v_cz_rules_rea_id_ref(rec_count) := v_cz_rules_rea_id;
        cz_pb_mgr.v_cz_rules_unmsg_id_ref(rec_count) := v_cz_rules_unmsg_id;
        cz_pb_mgr.v_cz_rules_eff_id_ref(rec_count) := v_cz_rules_eff_id;
        cz_pb_mgr.v_cz_rules_sig_ref(rec_count) := v_cz_rules_sig;
        cz_pb_mgr.v_cz_rules_obj_ref(rec_count) := 'RUL';
        cz_pb_mgr.v_cz_rules_ui_ref(rec_count) := v_cz_rules_ui;
        cz_pb_mgr.v_new_rul_usg_msk_tbl(rec_count) := v_cz_eff_usage_mask;
        cz_pb_mgr.v_cz_rules_persistent_id_ref(rec_count) := l_new_rule_id;

      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          cz_pb_mgr.v_err_message := 'No rules found: ' || p_rule_id_array(i);
          cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RULES', SQLCODE);
      END;

      BEGIN
        p_rule_id_array(i) := cz_pb_mgr.v_cz_rules_rule_id_idx_ref(p_rule_id_array(i));
      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END IF;
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN
    cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_rules', 'SQLERRM', SQLERRM);
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_RULES', SQLCODE);
    x_status := PUBLICATION_ERROR;
    RAISE;
END collect_global_rules;

------------------------------------------------
   PROCEDURE collect_template_elements(p_template_ref IN cz_pb_mgr.t_ref)
   IS
      l_template_id_tbl cz_pb_mgr.t_ref;
      l_ui_def_id_tbl cz_pb_mgr.t_ref;
      l_element_type_tbl cz_pb_mgr.t_ref;
      l_element_id_tbl cz_pb_mgr.t_ref;
      l_pers_elem_tbl cz_pb_mgr.t_ref;
      l_src_pb_id NUMBER;
      l_tgt_pb_id NUMBER;
      rec_count NUMBER := 0;
   BEGIN
      l_template_id_ref.DELETE;
      l_ui_def_id_ref.DELETE;
      l_element_type_ref.DELETE;
      l_element_id_ref.DELETE;
      l_pers_elem_ref.DELETE;
      cz_pb_mgr.l_template_id_ref.DELETE;
      cz_pb_mgr.l_ui_def_id_ref.DELETE;
      cz_pb_mgr.l_element_type_ref.DELETE;
      cz_pb_mgr.l_element_id_ref.DELETE;
      cz_pb_mgr.l_pers_elem_ref.DELETE;
      cz_pb_mgr.g_ui_actns_ui_act_id_ref.DELETE;
      cz_pb_mgr.g_ui_actns_ui_uidef_ref.DELETE;
      cz_pb_mgr.g_ui_actns_ui_tgtui_ref.DELETE;
      cz_pb_mgr.g_ui_actns_tgtexpl_ref.DELETE;
      cz_pb_mgr.g_ui_actns_ctx_comp_tbl.DELETE;
      cz_pb_mgr.g_ui_actns_ren_cond_tbl.DELETE;
      cz_pb_mgr.g_uiact_prcpg_templ_tbl.DELETE;
      cz_pb_mgr.g_uiact_prcpg_tmpui_tbl.DELETE;
      cz_pb_mgr.g_uiact_prc_caption_tbl.DELETE;
      cz_pb_mgr.g_uiact_pg_title_tbl.DELETE;
      cz_pb_mgr.g_uiact_main_msg_tbl.DELETE;

      IF (p_template_ref.COUNT > 0)
      THEN
         FOR i IN p_template_ref.FIRST .. p_template_ref.LAST
         LOOP
            l_template_id_tbl.DELETE;
            l_ui_def_id_tbl.DELETE;
            l_element_type_tbl.DELETE;
            l_element_id_tbl.DELETE;
            l_pers_elem_tbl.DELETE;

            SELECT template_id, ui_def_id, element_type, element_id, persistent_element_id
            BULK COLLECT INTO l_template_id_tbl, l_ui_def_id_tbl, l_element_type_tbl, l_element_id_tbl, l_pers_elem_tbl
              FROM cz_ui_template_elements
             WHERE cz_ui_template_elements.template_id = p_template_ref(i)
               AND cz_ui_template_elements.ui_def_id = 0
               AND cz_ui_template_elements.deleted_flag = '0'
               AND cz_ui_template_elements.seeded_flag <> seed_data;

            IF (l_template_id_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.l_template_id_ref.COUNT;

               FOR j IN l_template_id_tbl.FIRST .. l_template_id_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.l_template_id_ref(rec_count) := l_template_id_tbl(j);
                  cz_pb_mgr.l_ui_def_id_ref(rec_count) := l_ui_def_id_tbl(j);
                  cz_pb_mgr.l_element_type_ref(rec_count) := l_element_type_tbl(j);
                  cz_pb_mgr.l_element_id_ref(rec_count) := l_element_id_tbl(j);
                  cz_pb_mgr.l_pers_elem_ref(rec_count) := l_pers_elem_tbl(j);
               END LOOP;
            END IF;
         END LOOP;

         IF (l_template_id_ref.COUNT > 0)
         THEN
            collect_global_actions(cz_pb_mgr.l_element_id_ref, l_element_type_ref);
            collect_global_rules(cz_pb_mgr.l_element_id_ref, l_element_type_ref, cz_pb_mgr.v_status_code);
            collect_global_texts(cz_pb_mgr.l_element_id_ref, l_element_type_ref, cz_pb_mgr.v_status_code);
            resolve_ids(cz_pb_mgr.l_template_id_ref, cz_pb_mgr.g_ui_templates_idx_temp_ref, 'template ids of template elements');
         END IF;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_template_elements', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_TMPLELEM', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END collect_template_elements;

--------------------------------------------------------------------------------
FUNCTION get_target_template(p_src_template_id IN NUMBER) RETURN NUMBER
IS
  l_template_id NUMBER := -1;
  l_ref_cursor ref_cursor;
 BEGIN
   -- using binding vars
   -- check existing in ui template table (esp for mig)?
   OPEN l_ref_cursor FOR 'SELECT object_id'
                      || ' FROM cz_model_publications'
                      || cz_pb_mgr.v_db_link
                      || ' t'
                      || ' WHERE t.source_model_id = '
                      || p_src_template_id
                      || ' AND t.object_type = ''UIT'' AND t.deleted_flag=0'
                      || ' AND t.source_target_flag = '''
                      || g_target_flag
                      || '''';

  LOOP
    FETCH l_ref_cursor INTO l_template_id;
    EXIT WHEN l_ref_cursor%NOTFOUND;
  END LOOP;

  CLOSE l_ref_cursor;

  RETURN l_template_id;
END get_target_template;

--returns the template at target server if it ever got published
--(populates cz_pb_mgr.g_ui_templates_new_temp_id_ref)
-- or generates a new id for the target.

   FUNCTION get_new_template(p_template_id IN NUMBER)
      RETURN NUMBER
   IS
      l_template_id NUMBER;
   BEGIN
      l_template_id := get_target_template(p_template_id);
      IF (l_template_id = -1) THEN
         l_template_id := cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_ui_templates,
              'cz_ui_templates_s.nextval' || cz_pb_mgr.v_db_link, cz_pb_mgr.v_oraclesequenceincr);
      END IF;

      RETURN l_template_id;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END get_new_template;

--------------------------------------------------------------------------
-- returns 0 when a template is either never published
-- or is modified after last publication else returns 1.
   PROCEDURE has_uit_changed(p_template_id IN NUMBER, p_server_id IN NUMBER, x_status IN OUT NOCOPY NUMBER)
   IS
      l_uit_update_date DATE;
      l_last_update_date DATE;
      l_template_id NUMBER;
   BEGIN
      x_status := 0;

      SELECT last_update_date
        INTO l_last_update_date
        FROM cz_model_publications
       WHERE cz_model_publications.object_id = p_template_id
         AND cz_model_publications.object_type = 'UIT'
         AND cz_model_publications.source_target_flag = g_source_flag
         AND cz_model_publications.server_id = p_server_id
         AND cz_model_publications.export_status IN('OK', 'PUP')
         AND cz_model_publications.deleted_flag = '0';

      SELECT last_update_date
        INTO l_uit_update_date
        FROM cz_ui_templates
       WHERE ui_def_id = 0 AND template_id = p_template_id AND deleted_flag = '0';

  -- if template changed since last publication
      IF (l_uit_update_date > l_last_update_date) THEN
         x_status := 0;
      ELSE
  -- get the target tempalte id for the last publication and
  -- add it to the index, such that its not processed further.
         l_template_id := get_target_template(p_template_id);
         IF l_template_id = -1 THEN
           x_status := 0;
         ELSE
           cz_pb_mgr.g_ui_templates_idx_temp_ref(p_template_id):=l_template_id;
           x_status := 1;
         END IF;
      END IF;
   -- if template never got published
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         x_status := 0;
   END has_uit_changed;
--------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PROCEDURE get_oa_tmpls
IS
  l_new_tmpl_tbl  cz_pb_mgr.t_ref;  -- new or changed templs
  l_old_tmpl_tbl  cz_pb_mgr.t_ref;  -- exported already, no change
  l_all_tmpl_tbl  cz_pb_mgr.t_ref;  -- All the templates in all the UI's
  l_all_tmpl_map  cz_pb_mgr.t_ref_idx_vc2;
  l_temp_tbl      cz_pb_mgr.t_ref;
  l_rec_count     PLS_INTEGER;
  l_template_id   NUMBER;
  l_jrad_doc      VARCHAR2(255); -- cz_ui_templates.jrad_doc%TYPE;

  -- used for synch operation and insert operation resp
  l_parent_container_type NUMBER;
  l_root_element_signature_id NUMBER;
  l_template_name    VARCHAR2(255); -- cz_ui_templates.TEMPLATE_NAME%TYPE;
  l_root_region_type VARCHAR2(255); -- cz_ui_templates.ROOT_REGION_TYPE%TYPE;

  remote_uct ref_cursor;

  document_synch EXCEPTION;

  -- check if templates published previously or if changed since publication
  -- add to the new tbl if never published or exported before but changed after publication
  -- put to the old tbl, and put src:tgt ids into g_ui_templates_idx_temp_ref map otherwise
  -- may be better to separate the new ones with the changed and then just use the
  -- new ones for insert proc while the changed for updating?
  PROCEDURE check_template_status(p_tmpl_tbl IN t_ref)
  IS
    l_status     INTEGER;
    l_old_count  PLS_INTEGER;
    l_new_count  PLS_INTEGER;
    l_all_count  PLS_INTEGER;
  BEGIN
    IF p_tmpl_tbl.COUNT > 0 THEN
      l_old_count := l_old_tmpl_tbl.COUNT;
      l_new_count := l_new_tmpl_tbl.COUNT;
      l_all_count := l_all_tmpl_tbl.COUNT;
      FOR i IN p_tmpl_tbl.FIRST .. p_tmpl_tbl.LAST LOOP
        IF NOT l_all_tmpl_map.EXISTS(p_tmpl_tbl(i)) THEN
          l_status := 0;
          l_all_count := l_all_count + 1;
          l_all_tmpl_tbl(l_all_count) := p_tmpl_tbl(i);
          has_uit_changed(p_tmpl_tbl(i), cz_pb_mgr.v_server_id, l_status);
          IF l_status = 0 THEN -- not pub'd or chg'd since pub
            l_new_count := l_new_count + 1;
            l_new_tmpl_tbl(l_new_count) := p_tmpl_tbl(i);
          ELSE
            l_old_count := l_old_count + 1;
            l_old_tmpl_tbl(l_old_count) := p_tmpl_tbl(i);
          END IF;

          l_all_tmpl_map(p_tmpl_tbl(i)) := NULL;
        END IF;
      END LOOP;
    END IF;
  END check_template_status;

BEGIN
  --For model migration, the rules related tables will be loaded in bulk_collect_rules
  --and they should not be cleared here.  Rules related tables are collected in 'collect_global_rules',
  --which is called from here.
  --For publishing, this code gets executed right in the beginning(when all the tables are empty
  --anyway), and seems redundant.  But for the risk of introducing regressions, we
  --will execute this only for publishing.
  IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model) THEN
    clear_tables('cz_rules', 'ref', cz_pb_mgr.v_status_code);
  END IF;

  cz_pb_mgr.g_ui_templates_old_temp_id_ref.DELETE;
  cz_pb_mgr.g_ui_templates_new_temp_id_ref.DELETE;
  cz_pb_mgr.g_ui_templates_idx_temp_ref.DELETE;
  cz_pb_mgr.g_ui_templates_ui_def_old_ref.DELETE;
  cz_pb_mgr.g_ui_templates_ui_def_new_ref.DELETE;
  cz_pb_mgr.g_ui_templates_msg_id_ref.DELETE;
  cz_pb_mgr.g_ui_templates_title_ref.DELETE;
  cz_pb_mgr.g_ui_templates_jrad_new_ref.DELETE;
  cz_pb_mgr.g_ui_templates_jrad_old_ref.DELETE;
  cz_pb_mgr.g_ui_templates_button_tbl.DELETE;
  cz_pb_mgr.g_ui_templates_but_uidef_id.DELETE;

  -- templates already exported and no change since, used only in replacing extends
  cz_pb_mgr.g_tmpl_jrad_old_tbl.DELETE;
  cz_pb_mgr.g_tmpl_jrad_new_tbl.DELETE;

  cz_pb_mgr.g_ui_templates_obj_type.DELETE;
  cz_pb_mgr.g_enclosing_fld_rp_entry.DELETE;

  -- templs directly referred by the UIs: not published before or changed since publication
  IF cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0 AND cz_pb_mgr.v_session_parameter <> model_copy THEN
    FOR i IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST LOOP
      l_temp_tbl.DELETE;
      SELECT template_id BULK COLLECT INTO l_temp_tbl
      FROM cz_ui_collect_tmpls_v
      WHERE cz_ui_collect_tmpls_v.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_ref(i)
      AND cz_ui_collect_tmpls_v.template_id IN
           (SELECT template_id
            FROM cz_ui_templates
            WHERE cz_ui_templates.deleted_flag = '0' AND cz_ui_templates.seeded_flag = '0'
            AND cz_ui_templates.ui_def_id = 0);

      check_template_status(l_temp_tbl);
    END LOOP;
  END IF;

  -- append changed or not published ref templs to l_new_tmpl_tbl
  -- vsingava 10th May '10, bug7243309
  -- The template changed might be referred from a non-changed and already published
  -- template. Account for that.
  l_rec_count := l_all_tmpl_tbl.COUNT;
  IF l_rec_count > 0 THEN
    FOR i IN 1 .. l_rec_count LOOP
      l_temp_tbl.DELETE;
      SELECT ref_template_id BULK COLLECT INTO l_temp_tbl
      FROM cz_ui_ref_templates
      WHERE cz_ui_ref_templates.deleted_flag = '0'
      AND cz_ui_ref_templates.seeded_flag = '0'
      AND cz_ui_ref_templates.ref_template_id IN
         (SELECT template_id
          FROM cz_ui_templates t
          WHERE t.deleted_flag = '0' AND t.seeded_flag = '0' AND t.ui_def_id = 0)
      START WITH cz_ui_ref_templates.template_id = l_all_tmpl_tbl(i)
      CONNECT BY PRIOR ref_template_id = cz_ui_ref_templates.template_id
             AND PRIOR cz_ui_ref_templates.deleted_flag = '0';

      check_template_status(l_temp_tbl);
    END LOOP;
  END IF;

  -- add button bar templs (bbt) referred by the templates to the array
  -- assume bbts have no ref tmpl, otherwise we have an issue here
  l_rec_count := l_new_tmpl_tbl.COUNT;
  IF l_rec_count > 0 THEN
    FOR i IN 1 .. l_rec_count LOOP
      l_temp_tbl.DELETE;
      SELECT button_bar_template_id BULK COLLECT INTO l_temp_tbl
      FROM cz_ui_templates
      WHERE cz_ui_templates.deleted_flag = '0'
      AND cz_ui_templates.seeded_flag = '0'
      AND cz_ui_templates.ui_def_id = 0
      AND cz_ui_templates.button_bar_template_id IS NOT NULL
      AND cz_ui_templates.template_id = l_new_tmpl_tbl(i)
      AND cz_ui_templates.button_bar_template_id IN
          (SELECT template_id
           FROM cz_ui_templates t
           WHERE t.deleted_flag = '0' AND t.seeded_flag = '0' AND t.ui_def_id = 0);

      check_template_status(l_temp_tbl);
    END LOOP;
  END IF;

  -- processing page tmpls (ppt) referred by ui actions
  -- assume ppts have no ref tmpl, no further ppt ref from the action elements (if any) of the ppts
  l_rec_count := l_new_tmpl_tbl.COUNT;
  IF l_rec_count > 0 THEN
    FOR i IN 1 .. l_rec_count LOOP
      l_temp_tbl.DELETE;
      SELECT processing_page_templ_id BULK COLLECT INTO l_temp_tbl
      FROM cz_ui_actions act
      WHERE deleted_flag = '0' AND ui_def_id = 0 AND ui_action_id IN
         (SELECT element_id FROM cz_ui_template_elements
          WHERE deleted_flag = '0' AND element_type = 552
          AND template_id = l_new_tmpl_tbl(i)
          AND ui_def_id = 0 and seeded_flag = '0')
      AND EXISTS (SELECT NULL FROM cz_ui_templates
                  WHERE deleted_flag = '0' AND ui_def_id = 0
                  AND template_id = act.processing_page_templ_id AND seeded_flag = '0');

      check_template_status(l_temp_tbl);
    END LOOP;
  END IF;

  IF (l_new_tmpl_tbl.COUNT > 0) THEN
    l_rec_count := 0;

    FOR i IN l_new_tmpl_tbl.FIRST .. l_new_tmpl_tbl.LAST LOOP
      FOR j IN (SELECT * FROM cz_ui_templates
                WHERE template_id = l_new_tmpl_tbl(i) AND ui_def_id = '0' AND deleted_flag = '0') LOOP
        IF cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model THEN
          -- The synch check will be performed here
          -- The template name will be checked over the link
          -- If the the template does not exists, then we will be using the new template that is created
          l_template_name := NULL;
          l_template_id := NULL;
          l_parent_container_type := NULL;
          l_root_region_type := NULL;
          l_root_element_signature_id := NULL;

          OPEN remote_uct FOR 'Select template_name,template_id,parent_container_type,root_region_type,'
            || 'root_element_signature_id from cz_ui_templates'
            || cz_pb_mgr.v_db_link || 't '
            || 'where t.ui_def_id = ''0'' and t.template_usage = ''0'' and '
            || 't.deleted_flag = ''0'' and t.seeded_flag = ''0'' and '
            || 't.template_name = :1 and t.template_type = :2 and nvl(t.message_type,-1) = nvl(:3,-1)'
          USING j.template_name, j.template_type, j.message_type;
          FETCH remote_uct
            INTO l_template_name, l_template_id, l_parent_container_type,
                 l_root_region_type, l_root_element_signature_id;

          IF l_template_name IS NOT NULL AND
               (   l_parent_container_type <> j.parent_container_type
                OR l_root_region_type <> j.root_region_type
                OR l_root_element_signature_id <> j.root_element_signature_id ) THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('UCT synch error', 'TABLENAME', 'cz_ui_templates', 'SQLERRM', SQLERRM);
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIGLTEMPLATES', SQLCODE);
            cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            RAISE document_synch;
          END IF;
        END IF;

        -- pub: populate all the new or changed templs to the arrays
        -- mig: only add the new templs (l_template_name IS NULL) ??
        IF cz_pb_mgr.v_session_parameter = pub_model OR l_template_name IS NULL THEN
          l_rec_count := l_rec_count + 1;
          l_template_id := get_new_template(j.template_id);
          cz_pb_mgr.g_ui_templates_new_temp_id_ref(l_rec_count) := l_template_id;
          cz_pb_mgr.g_ui_templates_old_temp_id_ref(l_rec_count) := j.template_id;
          cz_pb_mgr.g_ui_templates_ui_def_old_ref(l_rec_count) := j.ui_def_id; -- '0'
          cz_pb_mgr.g_ui_templates_ui_def_new_ref(l_rec_count) := j.ui_def_id;
          cz_pb_mgr.g_ui_templates_msg_id_ref(l_rec_count) := j.main_message_id;
          cz_pb_mgr.g_ui_templates_title_ref(l_rec_count) := j.title_id;
          cz_pb_mgr.g_ui_templates_jrad_old_ref(l_rec_count) := j.jrad_doc;
          cz_pb_mgr.g_ui_templates_button_tbl(l_rec_count) := j.button_bar_template_id;
          cz_pb_mgr.g_ui_templates_but_uidef_id(l_rec_count) := j.button_bar_templ_uidef_id;

          IF cz_pb_mgr.v_session_parameter = pub_model THEN
            cz_pb_mgr.g_ui_templates_jrad_new_ref(l_rec_count) := j.jrad_doc || '_p';
          ELSE
            cz_pb_mgr.g_ui_templates_obj_type(l_rec_count) := 'UCT';
            cz_pb_mgr.g_enclosing_fld_rp_entry(l_rec_count) := cz_pb_mgr.g_migration_tgt_folder_id;
            cz_pb_mgr.g_ui_templates_jrad_new_ref(l_rec_count) := REPLACE(j.jrad_doc,TO_CHAR(j.template_id),TO_CHAR(l_template_id));
          END IF;
        END IF;

        -- fix for bug 7047145
        -- even if UI CT is already exists on target instance we need to replace
        -- old template_ids to new ones in XML attribute "extends"
        -- To do that g_ui_templates_jrad_old_ref/g_ui_templates_jrad_new_ref must be populated
        -- these two arrays are used in replace_extends()
        -- This part shoul be executed in the loop for already published/migrated templates
        --  but current code has a mny problems in this area ( checking for ui templates
        -- which need to be published/migrated
        IF cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model AND l_template_name IS NOT NULL THEN
            l_rec_count := l_rec_count + 1;
            cz_pb_mgr.g_ui_templates_jrad_old_ref(l_rec_count) := j.jrad_doc;
            cz_pb_mgr.g_ui_templates_jrad_new_ref(l_rec_count) := REPLACE(j.jrad_doc,TO_CHAR(j.template_id),TO_CHAR(l_template_id));
        END IF;

        cz_pb_mgr.g_ui_templates_idx_temp_ref(j.template_id):=l_template_id;
      END LOOP;
    END LOOP;

    collect_template_elements(cz_pb_mgr.g_ui_templates_old_temp_id_ref);
  END IF;

  -- get jard_doc for the tmpls published before and not changed since for replacing extends
  IF l_old_tmpl_tbl.COUNT > 0 THEN
    l_rec_count := 0;
    FOR i IN l_old_tmpl_tbl.FIRST..l_old_tmpl_tbl.LAST LOOP
      SELECT jrad_doc INTO l_jrad_doc
      FROM  cz_ui_templates
      WHERE template_id  = l_old_tmpl_tbl(i) AND ui_def_id = 0 AND deleted_flag = '0';

      l_rec_count := l_rec_count + 1;
      CZ_PB_MGR.g_tmpl_jrad_old_tbl(l_rec_count) := l_jrad_doc;
      IF cz_pb_mgr.v_session_parameter = pub_model THEN
         cz_pb_mgr.g_tmpl_jrad_new_tbl(l_rec_count) := l_jrad_doc || '_p';
      ELSE
        cz_pb_mgr.g_tmpl_jrad_new_tbl(l_rec_count) :=
          REPLACE(l_jrad_doc, TO_CHAR(l_old_tmpl_tbl(i)),
                              TO_CHAR(cz_pb_mgr.g_ui_templates_idx_temp_ref(l_old_tmpl_tbl(i))));
      END IF;
    END LOOP;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_templates', 'SQLERRM', SQLERRM);
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_UIGLTEMPLATES', SQLCODE);
    cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
    RAISE;
END get_oa_tmpls;

---------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------------procedure checks if the model has been changed since it was last published
   FUNCTION has_tobe_published(publicationid IN NUMBER)
      RETURN BOOLEAN
   IS
      v_last_struct_update cz_devl_projects.last_struct_update%TYPE;
      v_models_tbl cz_pb_mgr.t_ref;
      record_count PLS_INTEGER := 0;
      v_last_update_date cz_ui_defs.last_update_date%TYPE;
      v_fc_update_date cz_func_comp_specs.last_update_date%TYPE;
      v_eff_update_date DATE;
      v_last_xfr_activity cz_pb_model_exports.last_xfr_activity%TYPE;
      l_max_template_date cz_pb_model_exports.last_xfr_activity%TYPE;
      l_capt_update_date DATE;
      l_ps_node_update_date DATE;
      v_descr_date DATE;
   BEGIN
      chk_if_aleady_published(publicationid, record_count);
      get_source_models(cz_pb_mgr.v_root_model_id, v_models_tbl);
      get_source_uis(cz_pb_mgr.v_root_model_id, v_models_tbl, cz_pb_mgr.v_cz_ui_defs_old_ref);
      get_oa_uis(v_models_tbl, cz_pb_mgr.v_cz_ui_defs_old_ref, cz_pb_mgr.v_cz_ui_defs_old_oa_ref);
      get_oa_tmpls;

      IF (record_count > 0)
      THEN
         get_last_xfr_activity(cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_server_id, v_last_xfr_activity);

         IF (g_object_type = MODEL_PUBLICATION)
         THEN
            ----check if logic has changed
            chk_if_logic_changed(v_models_tbl, v_last_xfr_activity, record_count);
            ----check if ARCHIVES got reloaded/changed
            chk_if_archives_changed(v_models_tbl, v_last_xfr_activity, record_count);
            ----check if structure has changed
            chk_if_struct_changed(v_models_tbl, v_last_xfr_activity, record_count);

            -----check if model descripton has changed
            IF (v_models_tbl.COUNT > 0)
            THEN
               FOR i IN v_models_tbl.FIRST .. v_models_tbl.LAST
               LOOP
                  get_intl_text_date(v_models_tbl(i), v_descr_date);

                  IF ((v_last_xfr_activity IS NOT NULL) AND(v_last_xfr_activity < v_descr_date))
                  THEN
                     record_count := 0;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;

            ----check if fc has changed
            get_fc_date(v_models_tbl, v_fc_update_date);

            IF ((v_last_xfr_activity IS NOT NULL) AND(v_last_xfr_activity < v_fc_update_date))
            THEN
               record_count := 0;
            END IF;

            -----check if eff has changed
            get_eff_date(v_models_tbl, v_eff_update_date);

            IF ((v_last_xfr_activity IS NOT NULL) AND(v_last_xfr_activity < v_eff_update_date))
            THEN
               record_count := 0;
            END IF;

            ----check if ps node names has changed
            IF (v_models_tbl.COUNT > 0)
            THEN
               FOR i IN v_models_tbl.FIRST .. v_models_tbl.LAST
               LOOP
                  get_psnode_last_date(v_models_tbl(i), l_ps_node_update_date);

                  IF ((v_last_xfr_activity IS NOT NULL) AND(v_last_xfr_activity < l_ps_node_update_date)) THEN
                     record_count := 0;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;

            ----check if captions text has changed
            IF (v_models_tbl.COUNT > 0)
            THEN
               FOR i IN v_models_tbl.FIRST .. v_models_tbl.LAST
               LOOP
                  BEGIN
                     SELECT MAX(last_update_date)
                       INTO l_capt_update_date
                       FROM cz_intl_texts
                      WHERE model_id = v_models_tbl(i);
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        l_capt_update_date := cz_utils.epoch_begin;
                  END;

                  IF ((v_last_xfr_activity IS NOT NULL) AND(v_last_xfr_activity < l_capt_update_date))
                  THEN
                     record_count := 0;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;

            -----check if capt rules have changed
            IF (v_models_tbl.COUNT > 0)
            THEN
               l_capt_update_date := cz_utils.epoch_begin;

               FOR i IN v_models_tbl.FIRST .. v_models_tbl.LAST
               LOOP
                  BEGIN
                     SELECT last_update_date
                       INTO l_capt_update_date
                       FROM cz_devl_projects
                      WHERE devl_project_id = v_models_tbl(i);
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        l_capt_update_date := cz_utils.epoch_begin;
                  END;

                  IF ((v_last_xfr_activity IS NOT NULL) AND(v_last_xfr_activity < l_capt_update_date))
                  THEN
                     record_count := 0;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;

            -----check if template elements have changed
            -- but actually these templs are new or changed ones!
            IF (cz_pb_mgr.g_ui_templates_old_temp_id_ref.COUNT > 0)
            THEN
               l_capt_update_date := cz_utils.epoch_begin;

               FOR i IN cz_pb_mgr.g_ui_templates_old_temp_id_ref.FIRST .. cz_pb_mgr.g_ui_templates_old_temp_id_ref.LAST
               LOOP
                  BEGIN
                     SELECT MAX(last_update_date)
                       INTO l_capt_update_date
                       FROM cz_ui_template_elements
                      WHERE template_id = cz_pb_mgr.g_ui_templates_old_temp_id_ref(i);
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        l_capt_update_date := cz_utils.epoch_begin;
                  END;

                  IF ((v_last_xfr_activity IS NOT NULL) AND(v_last_xfr_activity < l_capt_update_date))
                  THEN
                     record_count := 0;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;

            ----check if uis have changed
            cz_pb_mgr.v_ui_str := 'x';

            IF (cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0)
            THEN
               FOR i IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST
               LOOP
                  get_max_ui_date(cz_pb_mgr.v_cz_ui_defs_old_ref(i), v_last_update_date);

                  IF (v_last_xfr_activity IS NULL)
                  THEN
                     cz_pb_mgr.v_ui_str := 'UI';
                     EXIT;
                  ELSIF((v_last_xfr_activity IS NOT NULL) AND(v_last_update_date > v_last_xfr_activity))
                  THEN
                     cz_pb_mgr.v_ui_str := 'UI';
                     EXIT;
                  END IF;
               END LOOP;
            END IF;

            IF (cz_pb_mgr.g_ui_templates_old_temp_id_ref.COUNT > 0)
            THEN
               get_template_date(cz_pb_mgr.g_ui_templates_old_temp_id_ref, v_last_update_date);

               IF (v_last_xfr_activity IS NULL)
               THEN
                  cz_pb_mgr.v_ui_str := 'UI';
               ELSIF((v_last_xfr_activity IS NOT NULL) AND(v_last_update_date > v_last_xfr_activity))
               THEN
                  cz_pb_mgr.v_ui_str := 'UI';
               END IF;
            END IF;
         ELSIF(g_object_type = template_publication)
         THEN
            get_max_template_date(cz_pb_mgr.v_root_model_id, l_max_template_date);
         END IF;
      END IF;                                                                                                       /* end if of (record_count > 0) */

      IF (g_object_type = MODEL_PUBLICATION)
      THEN
         IF ((record_count > 0) AND(cz_pb_mgr.v_ui_str <> 'UI'))
         THEN
            RETURN FALSE;
         ELSIF((record_count = refresh_rules_count) AND(cz_pb_mgr.v_ui_str <> 'UI'))
         THEN
            v_refresh_rules := 'YES';
            RETURN TRUE;                                                                                                            ----refresh rules
         ELSIF(cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT = 0)
         THEN
            cz_pb_mgr.v_ui_str := 'x';
            RETURN TRUE;
         ELSE
            RETURN TRUE;
         END IF;
      ELSIF(g_object_type = template_publication)
      THEN
         IF (v_last_xfr_activity IS NULL)
         THEN
            RETURN TRUE;
         ELSIF(v_last_xfr_activity > l_max_template_date)
         THEN
            RETURN FALSE;
         ELSE
            RETURN TRUE;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_MODEL_TO_PUBLISH_ERR', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.HAS_TOBE_PUBLISHED', SQLCODE);
         cz_pb_mgr.v_err_message := LTRIM(RTRIM(SUBSTR(cz_pb_mgr.v_err_message, 1, 2000)));
         RAISE;
   END has_tobe_published;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----procedure that removes duplicate values in models array
----
   PROCEDURE add_root_model(p_root_model_id IN NUMBER, p_models_array IN OUT NOCOPY cz_pb_mgr.t_ref)
   AS
      model_idx NUMBER := 0;
      root_model_found VARCHAR2(1) := 'F';
   BEGIN
      IF (p_models_array.COUNT > 0)
      THEN
         FOR i IN p_models_array.FIRST .. p_models_array.LAST
         LOOP
            IF (p_models_array(i) = p_root_model_id)
            THEN
               root_model_found := 'T';
            END IF;
         END LOOP;
      END IF;

      IF (root_model_found <> 'T')
      THEN
         model_idx := p_models_array.COUNT + 1;
         p_models_array(model_idx) := p_root_model_id;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END add_root_model;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----procedure that returns the max node depth for a given child model
----if max node depth is greater than 1 then we need to determine the
----parent of this child (p_model_id) is exported or not.
   PROCEDURE get_max_node_depth(
      p_model_id IN cz_model_ref_expls.model_id%TYPE
     ,p_root_model_id IN cz_model_ref_expls.model_id%TYPE
     ,x_node_depth OUT NOCOPY cz_model_ref_expls.node_depth%TYPE
   )
   IS
   BEGIN
      SELECT MAX(node_depth)
        INTO x_node_depth
        FROM cz_model_ref_expls
       WHERE cz_model_ref_expls.deleted_flag = '0' AND cz_model_ref_expls.component_id = p_model_id AND cz_model_ref_expls.model_id = p_root_model_id;
   END get_max_node_depth;

-------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure that adds a parent of a child that is being exported
-------to the export array.
-------The first step is collect all models (exported and not exported) into
------l_all_models_array.  Loop over each child model in l_all_models_array
------and check if the child model node_depth is greater than 1.  If greater than 1
------then get all the parents at all levels for that child model
------check if the parent is being exported, if not add it to the export array.
------The root model is not part of any of the arrays here.  We check for
------child models only if greater than one level below.
   PROCEDURE add_parent_models(
      p_root_model_id IN cz_model_ref_expls.model_id%TYPE
     ,p_models_to_be_exported IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_models_not_to_be_exported IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   IS
      l_component_id cz_model_ref_expls.component_id%TYPE;
      l_node_depth cz_model_ref_expls.node_depth%TYPE;
      rec_count NUMBER := 0;
      l_models_exported cz_pb_mgr.t_ref_idx_vc2;
      l_models_not_exported cz_pb_mgr.t_ref_idx_vc2;
      l_all_models_array cz_pb_mgr.t_ref;

      CURSOR c_parent_models(p_component_id cz_model_ref_expls.component_id%TYPE, p_top_model_id cz_model_ref_expls.model_id%TYPE)
      IS
         SELECT component_id
           FROM cz_model_ref_expls
          WHERE cz_model_ref_expls.deleted_flag = '0'
            AND cz_model_ref_expls.ps_node_type IN(263, 264)
            AND cz_model_ref_expls.model_ref_expl_id IN(
                                                        SELECT parent_expl_node_id
                                                          FROM cz_model_ref_expls x
                                                         WHERE x.deleted_flag = '0' AND x.component_id = p_component_id
                                                               AND x.model_id = p_top_model_id);
   BEGIN
      IF (p_models_not_to_be_exported.COUNT > 0)
      THEN
         ----ALL child models both exported and non exported
         ----are collected into l_all_models_array
         l_all_models_array.DELETE;

         SELECT   x.component_id
         BULK COLLECT INTO l_all_models_array
             FROM cz_model_ref_expls x
            WHERE x.deleted_flag = '0'
              AND x.model_id = p_root_model_id
              AND (x.ps_node_type = 263 OR x.ps_node_type = 264)
              AND x.node_depth = (SELECT MAX(b.node_depth)
                                    FROM cz_model_ref_expls b
                                   WHERE x.component_id = b.component_id AND b.model_id = p_root_model_id AND b.deleted_flag = '0')
         ORDER BY node_depth DESC;

         IF (p_models_to_be_exported.COUNT > 0)
         THEN
            FOR j IN p_models_to_be_exported.FIRST .. p_models_to_be_exported.LAST
            LOOP
               l_models_exported(p_models_to_be_exported(j)) := p_models_to_be_exported(j);
            END LOOP;
         END IF;

         FOR k IN p_models_not_to_be_exported.FIRST .. p_models_not_to_be_exported.LAST
         LOOP
            l_models_not_exported(p_models_not_to_be_exported(k)) := p_models_not_to_be_exported(k);
         END LOOP;
        IF (l_all_models_array.COUNT > 0) THEN
         FOR i IN l_all_models_array.FIRST .. l_all_models_array.LAST
         LOOP
            IF (l_models_exported.EXISTS(l_all_models_array(i)))
            THEN
               ---get max node_depth from cz_model_ref_expls for the child model
               get_max_node_depth(l_all_models_array(i), p_root_model_id, l_node_depth);

               -----check if node depth > 1, we are interested only if the child model
               -----is at a level greater than 1 in the tree.
               IF (l_node_depth > 1)
               THEN
                  -----the cursor is required because, there can be multiple
                              -----occurrences of the same component at different levels
                  -----in the model tree.  In such a case all the parents of the child
                  ----- are exported
                  OPEN c_parent_models(l_all_models_array(i), p_root_model_id);

                  LOOP
                     FETCH c_parent_models
                      INTO l_component_id;

                     EXIT WHEN c_parent_models%NOTFOUND;

                     IF (NOT l_models_exported.EXISTS(l_component_id))
                     THEN
                        l_models_exported(l_component_id) := l_component_id;
                        rec_count := p_models_to_be_exported.COUNT + 1;
                        p_models_to_be_exported(rec_count) := l_component_id;
                        l_models_not_exported.DELETE(l_component_id);
                     END IF;
                  END LOOP;

                  CLOSE c_parent_models;
               END IF;
            END IF;
         END LOOP;                                                                                          /* end loop of l_all_models_array.FIRST */
        END IF;
         -----we do not want to loop over single idx arrays
         -----because we would be looping more number of times if the array is sparse
         p_models_not_to_be_exported.DELETE;
         rec_count := 0;
        IF (l_all_models_array.COUNT > 0) THEN
         FOR notexpmodel IN l_all_models_array.FIRST .. l_all_models_array.LAST
         LOOP
            IF (NOT l_models_exported.EXISTS(l_all_models_array(notexpmodel)))
            THEN
               rec_count := p_models_not_to_be_exported.COUNT + 1;
               p_models_not_to_be_exported(rec_count) := l_all_models_array(notexpmodel);
            END IF;
         END LOOP;
	END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);

         IF (c_parent_models%ISOPEN)
         THEN
            CLOSE c_parent_models;
         END IF;

         RAISE;
   END add_parent_models;
----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------Procedure that retrieves the remote model id of the target model
------@p_server_id --- server local id of target instance
------@x_status --- publication status
------@p_model_id --- source model id
------@x_remote_model_id -- retrieved remote model id
   PROCEDURE get_remote_model_id(
      p_server_id IN cz_servers.server_local_id%TYPE
     ,p_model_id IN cz_pb_model_exports.model_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
     ,x_remote_model_id IN OUT NOCOPY cz_pb_model_exports.model_id%TYPE
   )
   AS
   BEGIN
     IF ((x_status <> PUBLICATION_ERROR) AND (cz_pb_mgr.v_session_parameter <> model_copy)) THEN
       IF cz_pb_mgr.v_cz_ps_nodes_idx_tbl.EXISTS(p_model_id) THEN
         x_remote_model_id := cz_pb_mgr.v_cz_ps_nodes_idx_tbl(p_model_id);
       ELSE
         IF cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model THEN
           IF p_server_id=0 THEN
             SELECT remote_model_id INTO x_remote_model_id
             FROM cz_pb_model_exports
             WHERE export_id=(SELECT max(export_id)
                              FROM cz_pb_model_exports
                              WHERE model_id=p_model_id AND server_id=0
                              AND status='OK' AND migration_group_id=g_migration_group_id);
           ELSE
            EXECUTE IMMEDIATE    'SELECT remote_model_id '
                              || ' '
                              || 'FROM cz_pb_model_exports'
                              || ' '
                              || 'WHERE cz_pb_model_exports.server_id = :1'
                              || ' '
                              || 'AND cz_pb_model_exports.export_id = '
                              || ' '
                              || '(SELECT MIN(export_id)'
                              || ' '
                              || 'FROM cz_pb_model_exports x, cz_devl_projects'
                              || cz_pb_mgr.v_db_link
                              || ' farprj'
                              || ' '
                              || 'WHERE x.server_id = :2'
                              || ' '
                              || 'AND x.model_id = :3'
                              || ' '
                              || 'AND x.status = ''OK'''
                              || ' '
                              || 'AND x.remote_model_id = farprj.devl_project_id'
                              || ' '
                              || 'AND farprj.deleted_flag = ''0'''
                              || ' '
                              || 'AND farprj.post_migr_change_flag = :4'
                              || ' '
                              || 'AND x.migration_group_id IS NOT NULL)'
                              || ' '
                              || 'AND cz_pb_model_exports.model_id  = :5'
                              || ' '
                              || 'AND cz_pb_model_exports.status = ''OK'''
                         INTO x_remote_model_id
                        USING p_server_id, p_server_id, p_model_id, cz_model_migration_pvt.change_flag_unchanged, p_model_id;
           END IF;
         ELSE
            SELECT cz_pb_model_exports.remote_model_id
              INTO x_remote_model_id
              FROM cz_pb_model_exports
             WHERE cz_pb_model_exports.server_id = p_server_id
               AND cz_pb_model_exports.export_id =
                      (SELECT MAX(export_id)
                         FROM cz_pb_model_exports
                        WHERE cz_pb_model_exports.server_id = p_server_id
                          AND cz_pb_model_exports.model_id = p_model_id
                          AND cz_pb_model_exports.status = 'OK'
                          AND migration_group_id IS NULL)
               AND cz_pb_model_exports.model_id = p_model_id
               AND cz_pb_model_exports.status = 'OK';
         END IF;

         cz_pb_mgr.v_cz_ps_nodes_idx_tbl(p_model_id) := x_remote_model_id;
       END IF;

     ELSE
       x_remote_model_id := p_model_id;
     END IF;
   EXCEPTION
      WHEN OTHERS THEN
         cz_pb_mgr.v_err_message :=
                     'Error in retrieving remote model id from model exports for model : ' || p_model_id || ' on ' || p_server_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETREMMODELID', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_remote_model_id;
--------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------ get_models_tobe_exported gets all models to be exported and those
------ that are not to be exported to the production database
------ v_models_to_be_exported
------ v_models_not_to_be_exported
-----  call to add_root_model add the root model if it does not exist
   PROCEDURE get_models_tobe_exported(rootmodelid IN NUMBER)
   AS
      CURSOR model_cur(in_root_model NUMBER)
      IS
         SELECT DISTINCT component_id
                    FROM cz_model_ref_expls x
                   WHERE x.model_id = in_root_model AND x.deleted_flag = '0' AND(x.ps_node_type = 263 OR x.ps_node_type = 264);

      v_count PLS_INTEGER := 0;
      v_models model_id_table;
      record_index NUMBER := 0;
      not_exported_record_index NUMBER := 0;
      v_model_id cz_model_publications.model_id%TYPE;
      v_expr_last_update cz_expression_nodes.last_update_date%TYPE;
      l_exp_models_idx_ref cz_pb_mgr.t_ref_idx_vc2;
      l_intl_text_date DATE;
      l_eff_set_date DATE;
      l_max_arc_date DATE;
      l_max_ui_date DATE;
      l_ps_node_update_date DATE;
      l_remote_model_cur ref_cursor;
      l_remote_model cz_pb_model_exports.model_id%TYPE;
      l_remote_proj cz_pb_model_exports.model_id%TYPE;
      l_remote_name VARCHAR2(32000);
      child_model_ui_has_changed BOOLEAN := FALSE;
   BEGIN
      cz_pb_mgr.v_models_to_be_exported.DELETE;
      cz_pb_mgr.v_models_not_to_be_exported.DELETE;

      IF (cz_pb_mgr.v_session_parameter IN(pub_model, cz_model_migration_pvt.migrate_model))
      THEN
         OPEN model_cur(rootmodelid);

            /* Bug 5523268
             * Check the changes to the UI in Source as well
             * Check for the change in the entire reference structure.  I
             * if there is a change in the UI of child models, pick that up
             * as well;
             */

         IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
         THEN
            child_model_ui_has_changed :=has_ui_inany_chld_mdl_changed(rootmodelid);
         END IF;

         IF (cz_pb_mgr.v_ui_str = 'UI' or child_model_ui_has_changed )
         THEN
            LOOP
               FETCH model_cur
                INTO v_model_id;

               EXIT WHEN model_cur%NOTFOUND;
               record_index := record_index + 1;
               cz_pb_mgr.v_models_to_be_exported(record_index) := v_model_id;
            END LOOP;

            add_root_model(rootmodelid, cz_pb_mgr.v_models_to_be_exported);
         ELSE
            LOOP
               FETCH model_cur
                INTO v_model_id;

               EXIT WHEN model_cur%NOTFOUND;
               v_count := 0;

               IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
                 IF cz_pb_mgr.v_server_id = 0 THEN
                   SELECT COUNT(*) INTO v_count
		   FROM cz_pb_model_exports
                   WHERE model_id=v_model_id AND status=publication_ok AND server_id=0
                   AND migration_group_id=g_migration_group_id;
                 ELSE
                  EXECUTE IMMEDIATE    'SELECT COUNT(*) FROM cz_pb_model_exports x, cz_devl_projects'
                                    || cz_pb_mgr.v_db_link
                                    || ' farprj'
                                    || ' '
                                    || 'WHERE x.model_id = :1'
                                    || ' '
                                    || 'AND x.status = :2'
                                    || ' '
                                    || 'AND x.server_id = :3'
                                    || ' '
                                    || 'AND x.remote_model_id = farprj.devl_project_id'
                                    || ' '
                                    || 'AND farprj.deleted_flag = ''0'''
                                    || ' '
                                    || 'AND farprj.post_migr_change_flag = :4'
                                    || ' '
                                    || 'AND x.migration_group_id IS NOT NULL'
                               INTO v_count
                              USING v_model_id, publication_ok, cz_pb_mgr.v_server_id, cz_model_migration_pvt.change_flag_unchanged;
                 END IF;
               ELSE
                  SELECT COUNT(*)
                    INTO v_count
                    FROM cz_pb_model_exports x
                   WHERE x.model_id = v_model_id AND x.status = publication_ok AND x.server_id = cz_pb_mgr.v_server_id
                   AND migration_group_id IS NULL;
               END IF;

               IF (v_count = 0)
               THEN
                  record_index := record_index + 1;
                  cz_pb_mgr.v_models_to_be_exported(record_index) := v_model_id;
               ELSE
                  v_count := 0;

                  -------check if expr nodes have changed since the model was last published
                  SELECT MAX(last_update_date)
                    INTO v_expr_last_update
                    FROM cz_expression_nodes t
                   WHERE t.deleted_flag = '0'
                     AND t.expr_type <> 208
                     AND EXISTS(SELECT 1
                                  FROM cz_rules
                                 WHERE rule_id = t.rule_id AND devl_project_id = v_model_id AND deleted_flag = '0')
                     AND t.deleted_flag = '0'
                     AND t.expr_type <> 208;

                  IF (v_expr_last_update IS NULL)
                  THEN
                     v_expr_last_update := cz_utils.epoch_begin;
                  END IF;

                  -----effectivitity set check
                  get_effectivity_set_date(v_model_id, l_eff_set_date);

                  IF (l_eff_set_date > v_expr_last_update)
                  THEN
                     v_expr_last_update := l_eff_set_date;
                  END IF;

                  ------check if intl text has changed
                  get_intl_text_date(v_model_id, l_intl_text_date);

                  IF (l_intl_text_date > v_expr_last_update)
                  THEN
                     v_expr_last_update := l_intl_text_date;
                  END IF;

                  get_psnode_last_date(v_model_id, l_ps_node_update_date);
                  IF (l_ps_node_update_date > v_expr_last_update)
                  THEN
                     v_expr_last_update := l_ps_node_update_date;
                  END IF;


                  -----------end expr nodes check
                  SELECT GREATEST(MAX(arc.last_update_date), MAX(REF.last_update_date))
                    INTO l_max_arc_date
                    FROM cz_archives arc, cz_archive_refs REF
                   WHERE REF.devl_project_id = v_model_id AND arc.archive_id = REF.archive_id AND arc.deleted_flag = '0' AND REF.deleted_flag = '0';

                  IF l_max_arc_date IS NOT NULL AND l_max_arc_date > v_expr_last_update
                  THEN
                     v_expr_last_update := l_max_arc_date;
                  END IF;

                  -- check if any new ui created after last xfr activity
                  -- call get_max_ui_date if this check still not enough
                  SELECT MAX(creation_date) INTO l_max_ui_date
                  FROM cz_ui_defs
                  WHERE deleted_flag = '0' AND devl_project_id = v_model_id AND ui_style <> '-1';
                  IF l_max_ui_date IS NOT NULL AND l_max_ui_date > v_expr_last_update THEN
                    v_expr_last_update := l_max_ui_date;
                  END IF;

                  IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
                    IF cz_pb_mgr.v_server_id = 0 THEN
                      SELECT COUNT(*) INTO v_count
		        FROM cz_devl_projects x, cz_pb_model_exports y
		       WHERE x.devl_project_id = y.model_id
		         AND x.last_update_date < y.last_xfr_activity
		         AND y.last_xfr_activity > v_expr_last_update
		         AND y.model_id = v_model_id AND y.server_id = 0
                         AND y.status = 'OK' AND y.migration_group_id = g_migration_group_id;
                    ELSE
                     EXECUTE IMMEDIATE    'SELECT COUNT(*) FROM cz_devl_projects x, cz_pb_model_exports y, cz_devl_projects'
                                       || cz_pb_mgr.v_db_link
                                       || ' farprj'
                                       || ' '
                                       || 'WHERE x.devl_project_id = y.model_id'
                                       || ' '
                                       || 'AND x.last_update_date < y.last_xfr_activity'
                                       || ' '
                                       || 'AND y.last_xfr_activity > :1'
                                       || ' '
                                       || 'AND y.model_id = :2'
                                       || ' '
                                       || 'AND y.server_id = :3'
                                       || ' '
                                       || 'AND y.remote_model_id = farprj.devl_project_id'
                                       || ' '
                                       || 'AND farprj.deleted_flag = ''0'''
                                       || ' '
                                       || 'AND farprj.post_migr_change_flag = :4'
                                       || ' '
                                       || 'AND y.migration_group_id IS NOT NULL AND y.status = :5'
                                  INTO v_count
                                 USING v_expr_last_update, v_model_id, cz_pb_mgr.v_server_id, cz_model_migration_pvt.change_flag_unchanged, publication_ok;
                    END IF;
                  ELSE
                     SELECT COUNT(*)
                       INTO v_count
                       FROM cz_devl_projects x, cz_pb_model_exports y
                      WHERE x.devl_project_id = y.model_id
                        AND x.last_update_date < y.last_xfr_activity
                        AND y.last_xfr_activity > v_expr_last_update
                        AND y.model_id = v_model_id
                        AND y.server_id = cz_pb_mgr.v_server_id
                        AND y.status = 'OK' AND y.migration_group_id IS NULL;
                  END IF;

                  IF (v_count = 0)
                  THEN
                     record_index := record_index + 1;
                     cz_pb_mgr.v_models_to_be_exported(record_index) := v_model_id;
                  ELSE
                     -----check if the model exists and is not deleted
                     l_remote_model := 0;
                     l_remote_proj := 0;

                     BEGIN
                       get_remote_model_id(cz_pb_mgr.v_server_id, v_model_id, cz_pb_mgr.v_status_code, l_remote_model);
                     EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                           record_index := record_index + 1;
                           cz_pb_mgr.v_models_to_be_exported(record_index) := v_model_id;
                     END;

                     IF (l_remote_model > 0)
                     THEN
                        OPEN l_remote_model_cur FOR    'SELECT devl_project_id,'
                                                    || ' '
                                                    || 'REPLACE(cz_developer_utils_pvt.get_repository_path'
                                                    || cz_pb_mgr.v_db_link
                                                    || ' '
                                                    || '(devl_project_id, ''PRJ''), ''/'', ''.'')'
                                                    || ' '
                                                    || 'FROM cz_devl_projects'
                                                    || cz_pb_mgr.v_db_link
                                                    || '   t'
                                                    || ' '
                                                    || 'WHERE t.devl_project_id = :1'
                                                    || ' '
                                                    || 'AND t.deleted_flag = ''0''' USING l_remote_model;

                        LOOP
                           FETCH l_remote_model_cur
                            INTO l_remote_proj, l_remote_name;

                           EXIT WHEN l_remote_model_cur%NOTFOUND;
                        END LOOP;

                        CLOSE l_remote_model_cur;

                        IF (l_remote_proj > 0)
                        THEN
                           not_exported_record_index := not_exported_record_index + 1;
                           cz_pb_mgr.v_models_not_to_be_exported(not_exported_record_index) := v_model_id;
                           v_remote_names_not_exported(v_model_id) := l_remote_name;
                        ELSE
                           record_index := record_index + 1;
                           cz_pb_mgr.v_models_to_be_exported(record_index) := v_model_id;
                        END IF;
                     END IF;
                  END IF;
               END IF;
            END LOOP;

            add_parent_models(rootmodelid, cz_pb_mgr.v_models_to_be_exported, cz_pb_mgr.v_models_not_to_be_exported);
            add_root_model(rootmodelid, cz_pb_mgr.v_models_to_be_exported);
         END IF;

         CLOSE model_cur;
      ELSIF(cz_pb_mgr.v_session_parameter = cz_pb_mgr.model_copy)
      THEN
         l_exp_models_idx_ref.DELETE;

         OPEN model_cur(rootmodelid);

         LOOP
            FETCH model_cur
             INTO v_model_id;

            EXIT WHEN model_cur%NOTFOUND;

            IF (cz_pb_mgr.copy_root_only = 'NO')
            THEN
               record_index := record_index + 1;
               cz_pb_mgr.v_models_to_be_exported(record_index) := v_model_id;
               l_exp_models_idx_ref(v_model_id) := v_model_id;
            ELSIF(cz_pb_mgr.copy_root_only = 'YES')
            THEN
               NULL;
               ----not_exported_record_index := not_exported_record_index + 1;
            ----cz_pb_mgr.v_models_not_to_be_exported(not_exported_record_index) := v_model_id ;
            END IF;
         END LOOP;

         CLOSE model_cur;

         IF (NOT l_exp_models_idx_ref.EXISTS(rootmodelid))
         THEN
            record_index := record_index + 1;
            cz_pb_mgr.v_models_to_be_exported(record_index) := rootmodelid;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         CLOSE model_cur;

         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END get_models_tobe_exported;

---->>>>>>>>>>>>>>>>>>>>>>>>>
---------Creates an export request for each model in the PL/SQL table cz_pb_mgr.v_models_to_be_exported
   PROCEDURE create_export_request(rootmodelid IN NUMBER, modelid IN NUMBER, publicationid IN NUMBER, serverid IN NUMBER)
   AS
      v_node_depth cz_model_ref_expls.node_depth%TYPE;
   BEGIN
      SELECT NVL(MAX(node_depth), 0)
        INTO v_node_depth
        FROM cz_model_ref_expls
       WHERE model_id = rootmodelid AND component_id = modelid AND deleted_flag = '0';

      INSERT INTO cz_pb_model_exports
                  (export_id, export_seq, model_id, root_model_id, server_id, publication_id, export_reverse_seq
                  ,superseded_flag, last_xfr_activity, creation_date, last_update_date, created_by, last_updated_by, migration_group_id
                  )
           VALUES (cz_pb_model_exports_s.NEXTVAL, cz_pb_model_exports_s.CURRVAL, modelid, rootmodelid, serverid, publicationid, NVL(v_node_depth, 0)
                  ,'N', SYSDATE, SYSDATE, SYSDATE, 1, 1, cz_pb_mgr.g_migration_group_id
                  );

      SELECT cz_pb_model_exports_s.CURRVAL
        INTO cz_pb_mgr.v_export_id
        FROM DUAL;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_EXP_REQUEST_ERR', 'MODELID', modelid);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CREATE_EXPORT_REQUEST', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END create_export_request;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE create_copy_requests
   IS
   BEGIN
      IF ((cz_pb_mgr.v_session_parameter = model_copy) AND(cz_pb_mgr.v_models_not_to_be_exported.COUNT > 0))
      THEN
         FOR copyid IN cz_pb_mgr.v_models_not_to_be_exported.FIRST .. cz_pb_mgr.v_models_not_to_be_exported.LAST
         LOOP
            create_export_request(cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_models_not_to_be_exported(copyid), cz_pb_mgr.v_publication_id, 0);

            UPDATE cz_pb_model_exports
               SET remote_model_id = cz_pb_mgr.v_models_not_to_be_exported(copyid)
                  ,status = publication_ok
             WHERE cz_pb_model_exports.publication_id = cz_pb_mgr.v_publication_id
               AND cz_pb_model_exports.model_id = cz_pb_mgr.v_models_not_to_be_exported(copyid);
         END LOOP;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END create_copy_requests;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------------procedure to check publications on target instance
   PROCEDURE remote_pb_check(p_publication_id NUMBER)
   IS
      remote_pb_cv ref_cursor;
      v_publication_id NUMBER := 0;
      v_remote_link cz_servers.fndnam_link_name%TYPE;
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF ((p_publication_id > 0) AND(cz_pb_mgr.v_session_parameter <> model_copy))
         THEN
            v_remote_link := retrieve_db_link(cz_pb_mgr.v_server_id);
            cz_pb_mgr.v_insert_string :=
               'SELECT  publication_id FROM cz_model_publications' || v_remote_link || ' t' || ' ' || 'WHERE t.publication_id =  '
               || p_publication_id;

            OPEN remote_pb_cv FOR cz_pb_mgr.v_insert_string;

            LOOP
               FETCH remote_pb_cv
                INTO v_publication_id;

               EXIT WHEN remote_pb_cv%NOTFOUND;
            END LOOP;

            CLOSE remote_pb_cv;

            IF (v_publication_id = 0)
            THEN
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_REMOTE_ERR', 'PUBID', p_publication_id);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REMOTEPBCHECKID', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            END IF;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         CLOSE remote_pb_cv;

         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_REMOTE_ERR', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REMOTEPBCHECKID', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END remote_pb_check;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------insert into effectivity sets table
   PROCEDURE insert_eff_sets(
      p_eff_set_id_ref IN cz_pb_mgr.t_ref
     ,p_eff_sets_old_key IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_eff_sets_new_key IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_eff_single_idx_key IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2
     ,p_old_key_name IN VARCHAR2
     ,p_new_key_name IN VARCHAR2
     ,p_eff_text IN VARCHAR2
   )
   IS
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      v_cz_eff_sets_old_ref cz_pb_mgr.t_ref;
      v_cz_eff_sets_new_ref cz_pb_mgr.t_ref;
      check_all_null BOOLEAN := FALSE;
      v_eff_count PLS_INTEGER := 0;
      rec_count PLS_INTEGER := 0;
      l_eff_set_new_id NUMBER := NULL;
      l_eff_sets_exist_key cz_pb_mgr.t_ref;
   BEGIN
      IF (p_eff_set_id_ref.COUNT > 0)
      THEN
         p_eff_sets_old_key.DELETE;
         p_eff_sets_new_key.DELETE;
         l_eff_sets_exist_key.DELETE;
         p_eff_single_idx_key.DELETE;
         cz_pb_mgr.v_cz_eff_sets_idx_tbl.DELETE;
         cz_pb_mgr.g_eff_set_obj_type.DELETE;
         cz_pb_mgr.g_enclosing_fld_rp_entry.DELETE;
         cz_pb_mgr.v_cz_eff_sets_new_tbl.DELETE;
         check_all_null := TRUE;

         FOR p IN p_eff_set_id_ref.FIRST .. p_eff_set_id_ref.LAST
         LOOP
            IF (p_eff_set_id_ref(p) IS NOT NULL)
            THEN
               BEGIN
                  check_all_null := FALSE;
                  v_cz_eff_sets_old_ref.DELETE;
                  v_cz_eff_sets_new_ref.DELETE;

                  SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_effectivity_sets_seq
                                                    , 'cz_effectivity_sets_s.nextval' || cz_pb_mgr.v_db_link
                                                    ,cz_pb_mgr.v_oraclesequenceincr
                                                    )
                        ,effectivity_set_id
                  BULK COLLECT INTO v_cz_eff_sets_new_ref
                        ,v_cz_eff_sets_old_ref
                    FROM cz_effectivity_sets
                   WHERE cz_effectivity_sets.effectivity_set_id = p_eff_set_id_ref(p) AND cz_effectivity_sets.deleted_flag = '0';
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := SUBSTR(SQLERRM, 1, 2000);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.EFFSETS', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_effectivity_sets', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTEFFSETS', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               END;

               IF (v_cz_eff_sets_new_ref.COUNT > 0)
               THEN
                  v_eff_count := cz_pb_mgr.v_cz_eff_sets_new_tbl.COUNT;

                  FOR r IN v_cz_eff_sets_new_ref.FIRST .. v_cz_eff_sets_new_ref.LAST
                  LOOP
                     IF (v_cz_eff_sets_new_ref(r) IS NOT NULL)
                     THEN
                        IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
                        THEN
                           l_eff_set_new_id := mm_sync_eff_sets(v_cz_eff_sets_old_ref(r), v_cz_eff_sets_new_ref(r));

                           IF ((l_eff_set_new_id IS NULL) AND(NOT v_cz_eff_sets_idx_tbl.EXISTS(v_cz_eff_sets_old_ref(r))))
                           THEN
                              l_eff_set_new_id := v_cz_eff_sets_new_ref(r);
                              v_eff_count := v_eff_count + 1;
                              p_eff_sets_old_key(v_eff_count) := v_cz_eff_sets_old_ref(r);
                              p_eff_sets_new_key(v_eff_count) := l_eff_set_new_id;
                              cz_pb_mgr.g_eff_set_obj_type(v_eff_count) := 'EFF';
                              cz_pb_mgr.g_enclosing_fld_rp_entry(v_eff_count) := cz_pb_mgr.g_migration_tgt_folder_id;
                              cz_pb_mgr.v_cz_eff_sets_idx_tbl(v_cz_eff_sets_old_ref(r)):=p_eff_sets_new_key(v_eff_count);
                           ELSE
                              cz_pb_mgr.v_cz_eff_sets_idx_tbl(v_cz_eff_sets_old_ref(r)):=l_eff_set_new_id;
                           END IF;
                        ELSE
                           v_eff_count := v_eff_count + 1;
                           p_eff_sets_old_key(v_eff_count) := v_cz_eff_sets_old_ref(r);
                           p_eff_sets_new_key(v_eff_count) := v_cz_eff_sets_new_ref(r);
                           cz_pb_mgr.v_cz_eff_sets_idx_tbl(v_cz_eff_sets_old_ref(r)):=v_cz_eff_sets_new_ref(r);
                        END IF;
                     END IF;
                  END LOOP;
               END IF;
            END IF;
         END LOOP;

         ------------------insert into cz effectivity sets
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'effectivity_set_id';
         plsql_table_list(rec_count).table_name := p_new_key_name;

         IF (NOT check_all_null)
         THEN
            BEGIN
               insert_into_table('cz_effectivity_sets'
                                ,'effectivity_set_id'
                                ,cz_pb_mgr.v_db_link
                                ,plsql_table_list
                                ,p_old_key_name
                                ,p_eff_sets_old_key
                                );

               IF (p_eff_sets_new_key.COUNT > 0 AND cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
               THEN
                  ----------begin insert into cz_rp_entries----------------
                  plsql_table_list.DELETE;
                  rec_count := 1;
                  plsql_table_list(rec_count).col_name := 'object_id';
                  plsql_table_list(rec_count).table_name := p_new_key_name;
                  rec_count := rec_count + 1;
                  plsql_table_list(rec_count).col_name := 'object_type';
                  plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_eff_set_obj_type';
                  rec_count := rec_count + 1;
                  plsql_table_list(rec_count).col_name := 'enclosing_folder';
                  plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_enclosing_fld_rp_entry';
                  insert_into_rp_entries('cz_rp_entries'
                                        ,'object_id'
                                        ,'object_type'
                                        ,cz_pb_mgr.v_db_link
                                        ,plsql_table_list
                                        ,p_old_key_name
                                        ,'cz_pb_mgr.g_eff_set_obj_type'
                                        ,p_eff_sets_old_key
                                        ,cz_pb_mgr.g_eff_set_obj_type
                                        );
               ----------end insert into cz_rp_entries----------------
               END IF;

               COMMIT;
            EXCEPTION
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            END;
         END IF;

         p_eff_sets_old_key.DELETE;
         p_eff_sets_new_key.DELETE;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Insert into cz eff sets for: ' || p_eff_text;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTEFFSETS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END insert_eff_sets;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that verifies if the model being published is a BOM model
-----and is being published to a different instance different from the one
-----it has been imported from.
-----@p_server_id is the target_server_id
-----@p_model_id is the devl_project_id of the model being published
-----@cz_pb_mgr.bom_flag is the out parameter: 'Y' indicates the model is to be
-----synchronized.  'N' indicates that no sync is necessary.
   PROCEDURE verify_model_for_sync(p_server_id IN cz_servers.server_local_id%TYPE, p_model_id IN cz_devl_projects.devl_project_id%TYPE)
   AS
      v_source_server NUMBER;
      v_bom_persistent_node_id NUMBER;
      v_bom_ps_node_id NUMBER;
      v_bom_err_flag VARCHAR2(1);
      v_bom_err_msg VARCHAR2(2000);
      v_verify_model_run_id NUMBER;
      v_bomsynch_err_flag VARCHAR2(2000);
      v_model_name cz_devl_projects.NAME%TYPE;

      TYPE verify_model_message_list IS TABLE OF cz_db_logs.MESSAGE%TYPE
         INDEX BY BINARY_INTEGER;

      v_verify_model_msg_ref verify_model_message_list;
   BEGIN
      -------no synchronization required if published locally
      IF ((p_server_id <> 0) AND(g_object_type = MODEL_PUBLICATION OR cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
         )
      THEN
         -----call to this procedure made to determine if the model being published
         -----contains a BOM
         cz_runtime.get_root_bom_node(p_model_id, v_bom_persistent_node_id, v_bom_ps_node_id, v_bom_err_flag, v_bom_err_msg);

         --------v_bom_err_flag = 0 indicates that the model contains a single BOM
         --------if it contains a single BOM identify the server from where the model
            --------was imported
         IF (v_bom_err_flag = '0')
         THEN
            SELECT source_server
              INTO v_source_server
              FROM cz_xfr_project_bills
             WHERE model_ps_node_id = (SELECT devl_project_id
                                         FROM cz_ps_nodes
                                        WHERE cz_ps_nodes.ps_node_id = v_bom_ps_node_id AND cz_ps_nodes.deleted_flag = '0');

            ------if the server from where it was imported is different from the target
            ------to which it is being published then call the bom sync procedure
                        ------else no sync required
            IF (v_source_server <> p_server_id)
            THEN
               BEGIN
                  SELECT local_name
                    INTO cz_pb_mgr.v_server_local_name
                    FROM cz_servers
                   WHERE cz_servers.server_local_id = p_server_id;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_NO_SERVER_NAME_FOUND', 'SERVERID', p_server_id);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.BOMSYNCHPROCEDURE', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_SERVER_NAME_ERR', 'SERVERID', p_server_id);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.BOMSYNCHPROCEDURE', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               END;

               cz_bom_synch.verify_model(cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_server_local_name, v_bomsynch_err_flag, v_verify_model_run_id);

               ----- if v_bomsynch_err_flag is not success then set publication status to ERROR
               IF (v_bomsynch_err_flag <> cz_bom_synch.error_flag_success)
               THEN
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;

                  BEGIN
                     SELECT NAME
                       INTO v_model_name
                       FROM cz_devl_projects
                      WHERE devl_project_id = cz_pb_mgr.v_root_model_id AND deleted_flag = '0';
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        v_model_name := 'Model name not found for model_id: ' || cz_pb_mgr.v_root_model_id;
                  END;

                  cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_BOMSYNCH_VERIFY_ERR', 'MODELNAME', v_model_name);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.BOMSYNCHPROC', SQLCODE);

                  ----trap errors from verify model to populate cz_db_logs
                  BEGIN
                     SELECT MESSAGE
                     BULK COLLECT INTO v_verify_model_msg_ref
                       FROM cz_db_logs
                      WHERE cz_db_logs.run_id = v_verify_model_run_id;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        cz_pb_mgr.v_err_message := 'No messages from verify model procedure';
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VERIFYMODELMSG', SQLCODE);
                     WHEN OTHERS
                     THEN
                        cz_pb_mgr.v_err_message := 'ERROR in bulk collect of messages for verify_model_procedure: ' || SQLERRM;
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VERIFYMODELMSG', SQLCODE);
                  END;

                  IF (v_verify_model_msg_ref.COUNT > 0)
                  THEN
                     FOR j IN v_verify_model_msg_ref.FIRST .. v_verify_model_msg_ref.LAST
                     LOOP
                        IF (v_verify_model_msg_ref(j) IS NOT NULL)
                        THEN
                           cz_pb_mgr.v_err_message := v_verify_model_msg_ref(j);
                           cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VERIFYMODELMSG', SQLCODE);
                        END IF;
                     END LOOP;
                  END IF;
               ELSE
                  cz_pb_mgr.bomsynch_flag := 'Y';
               END IF;
            ELSE
               cz_pb_mgr.bomsynch_flag := 'N';
            END IF;
         ----- v_bom_err_flag = 2 then NO BOM SYNC to be done
         ELSIF(v_bom_err_flag = '2')
         THEN
            cz_pb_mgr.bomsynch_flag := 'N';
            cz_pb_mgr.v_err_message := 'No BOM component found in model: ' || TO_CHAR(p_model_id);
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VERIFYBOMSYNCH', SQLCODE);
         -----v_bom_err_flag is not 0 or 2 set the publication status to ERROR
         ELSE
            cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            cz_pb_mgr.v_err_message := 'Error: two bom models exist in model: ' || TO_CHAR(p_model_id);
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VERIFYBOMSYNCH', SQLCODE);
         END IF;
      ELSE
         cz_pb_mgr.bomsynch_flag := 'N';
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_BOMSYNCH_PROC_ERR', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.BOMSYNCHPROCEDURE', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END verify_model_for_sync;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure to get synchronized values for organization_id,
------top_item_id and product_key of cz_model_publications
------If no bom synch required, then default values are returned
   PROCEDURE get_synchronized_pb_values(p_publication_id IN NUMBER)
   IS
   BEGIN
      IF (p_publication_id > 0)
      THEN
         SELECT DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.modelpublication_orgid(organization_id), 'N', organization_id)
               ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.modelpublication_topitemid(top_item_id), 'N', top_item_id)
               ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.modelpublication_productkey(product_key), 'N', product_key)
           INTO cz_pb_mgr.v_bomsynch_org_id
               ,cz_pb_mgr.v_bomsynch_item_id
               ,cz_pb_mgr.v_bomsynch_product_key
           FROM cz_model_publications
          WHERE cz_model_publications.publication_id = p_publication_id;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_GET_SYNC_ERR', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETSYNCVALUES', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END get_synchronized_pb_values;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------function returns true when p_str is a number
------used in replace_lce_texts
   FUNCTION is_number(p_str IN VARCHAR2)
      RETURN BOOLEAN
   IS
      v_numval NUMBER;
   BEGIN
      IF (p_str IS NOT NULL)
      THEN
         v_numval := TO_NUMBER(p_str);
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN FALSE;
   END is_number;

  FUNCTION is_val_number (p_str IN VARCHAR2)
  RETURN VARCHAR2 IS

  BEGIN

     IF(is_number(p_str))
     THEN
       RETURN 'TRUE';

     ELSE

       RETURN 'FALSE';
     END IF;

  END is_val_number;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure to replace reason ids and unsatisfied message
-------ids in logic text.
-------p_logic_text: is the lce text
-------p_pattern : pattern to search for like '... ' for reason ids
-------p_column : name of the column like reason_id
-------x_logic_text: out parameter contains replaced text
PROCEDURE replace_intl_texts(p_logic_text IN VARCHAR2, p_pattern IN VARCHAR2, p_column IN VARCHAR2, x_logic_text IN OUT NOCOPY VARCHAR2)
IS
  v_search_str VARCHAR2(200);
  v_replace_str VARCHAR2(200);
  v_idx_number NUMBER;
  v_rep_idx_no NUMBER;
  v_instr PLS_INTEGER;
  v_lce_text VARCHAR2(4000);
  v_complete_str NUMBER;
  v_complete_str1 NUMBER;
  v_complete_str2 NUMBER;
  v_pattern VARCHAR2(200);
  v_lce_text_str VARCHAR2(4000);
  v_end_delim_str varchar2(25);

BEGIN
  IF (p_logic_text IS NOT NULL) THEN
    v_lce_text := p_logic_text;
    v_lce_text_str := p_logic_text;
    v_instr := INSTR(v_lce_text, p_pattern);
    WHILE (v_instr > 0)
    LOOP
      IF (p_pattern LIKE reasonid) THEN
        v_instr := v_instr + 4;
        v_pattern := p_pattern;
        v_lce_text := LTRIM(RTRIM(SUBSTR(v_lce_text, v_instr)));
      ELSE -- IF (p_pattern LIKE unmsgid) THEN
        v_pattern := LTRIM(RTRIM(SUBSTR(v_lce_text, v_instr, 5)));
        v_pattern := v_pattern || ' ';
        v_instr := v_instr + 5;
        v_lce_text := LTRIM(RTRIM(SUBSTR(v_lce_text, v_instr)));
      END IF;

      v_complete_str1 := INSTR(v_lce_text, ' ');
      v_complete_str2 := INSTR(v_lce_text, pbnewline);

      IF v_complete_str2 > 0 AND v_complete_str1 > 0 THEN
        v_complete_str := LEAST(v_complete_str1, v_complete_str2) - 1;
        IF v_complete_str1 > v_complete_str2 THEN
          v_end_delim_str := pbnewline;
        ELSE
          v_end_delim_str := ' ';
        END IF;
      ELSIF v_complete_str2 > 0 AND v_complete_str1 = 0 THEN
        v_complete_str := v_complete_str2 - 1;
        v_end_delim_str:= pbnewline;
      ELSIF v_complete_str2 = 0 AND v_complete_str1 > 0 THEN
        v_complete_str := v_complete_str1 - 1;
        v_end_delim_str:= ' ';
      ELSE -- v_complete_str2 = 0) AND(v_complete_str1 = 0
        v_complete_str := LENGTH(v_lce_text);
        v_end_delim_str := NULL;
      END IF;

      v_search_str := NULL;
      v_search_str := LTRIM(RTRIM(SUBSTR(v_lce_text, 1, v_complete_str)));

      IF (is_number(v_search_str)) THEN
        v_idx_number := TO_NUMBER(v_search_str);
        BEGIN
          v_rep_idx_no := cz_pb_mgr.v_cz_intl_text_idx_ref(v_idx_number);
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            CZ_PB_MGR.v_err_message := 'Failure in resolving '||p_column||': '||v_search_str;
            CZ_PB_MGR.error_msg_populate(CZ_PB_MGR.v_err_message ,'CZ_PB_MGR.LCETEXTS',SQLCODE);
            RAISE;
        END;

        IF v_end_delim_str IS NULL THEN
          v_lce_text_str := substr(v_lce_text_str, 1, length(v_lce_text_str)-v_complete_str) || to_char(v_rep_idx_no);
        ELSE
          v_search_str  := v_pattern || TO_CHAR(v_idx_number) || v_end_delim_str;
          v_replace_str := v_pattern || TO_CHAR(v_rep_idx_no) || v_end_delim_str;
          v_lce_text_str := REPLACE(v_lce_text_str, v_search_str, v_replace_str);
        END IF;
      END IF;

      v_instr := INSTR(v_lce_text, p_pattern);
    END LOOP;
  END IF;

  x_logic_text := v_lce_text_str;
EXCEPTION
  WHEN OTHERS THEN
    cz_pb_mgr.v_err_message := 'Error during replacing ' || p_column || ' : ' || SQLERRM;
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LCETEXTS', SQLCODE);
    cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
    RAISE;
END replace_intl_texts;

--------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_lce_load_specs(
      p_specs_attach_expl_id_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_specs_lce_header_id_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_specs_required_expl_id_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_specs_attach_comp_id_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_specs_model_id_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_specs_net_type_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_alias_name_ref IN OUT NOCOPY cz_pb_mgr.t_alias_name
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (p_specs_model_id_ref.COUNT > 0)
         THEN
            EXECUTE IMMEDIATE    'BEGIN'
                              || ' '
                              || 'IF (cz_pb_mgr.v_specs_attach_expl_id_ref.COUNT > 0) THEN '
                              || 'FOR I IN cz_pb_mgr.v_specs_attach_expl_id_ref.FIRST..cz_pb_mgr.v_specs_attach_expl_id_ref.LAST'
                              || ' '
                              || 'LOOP'
                              || ' '
                              || 'INSERT INTO cz_lce_load_specs'
                              || cz_pb_mgr.v_db_link
                              || '(ATTACHMENT_EXPL_ID'
                              || ' '
                              || ',LCE_HEADER_ID'
                              || ' '
                              || ',REQUIRED_EXPL_ID'
                              || ' '
                              || ',ATTACHMENT_COMP_ID'
                              || ' '
                              || ',MODEL_ID'
                              || ' '
                              || ',NET_TYPE'
                              || ' '
                              || ',alias_name'
                              || ' '
                              || ',DELETED_FLAG)'
                              || ' '
                              || 'values (cz_pb_mgr.v_specs_attach_expl_id_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_specs_lce_header_id_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_specs_required_expl_id_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_specs_attach_comp_id_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_specs_model_id_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_specs_net_type_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_specs_alias_name_ref(i)'
                              || ' '
                              || ',''0'''
                              || ' '
                              || ');'
                              || ' '
                              || 'END LOOP;'
                              || 'END IF; '
                              || ' '
                              || 'END;';

            COMMIT;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := 'Error during insert of lce_load_specs: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LCETEXTS', SQLCODE);
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END insert_lce_load_specs;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------copy data into cz_lce_headers
   PROCEDURE copy_lce_headers
   IS
      v_cz_lce_comp_id_tbl cz_pb_mgr.t_ref;
      v_cz_lce_expl_id_tbl cz_pb_mgr.t_ref;
      v_cz_lce_headers_new_tbl cz_pb_mgr.t_ref;
      v_cz_lce_headers_old_tbl cz_pb_mgr.t_ref;
      v_cz_lce_headers_comp_tbl cz_pb_mgr.t_ref;
      v_cz_lce_headers_expl_tbl cz_pb_mgr.t_ref;
      v_cz_lce_devl_id_tbl cz_pb_mgr.t_ref;
      v_specs_attach_expl_id_tbl cz_pb_mgr.t_ref;
      v_specs_lce_header_id_tbl cz_pb_mgr.t_ref;
      v_specs_required_expl_id_tbl cz_pb_mgr.t_ref;
      v_specs_attach_comp_id_tbl cz_pb_mgr.t_ref;
      v_specs_model_id_tbl cz_pb_mgr.t_ref;
      v_specs_net_type_tbl cz_pb_mgr.t_ref;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      v_specs_alias_name_tbl cz_pb_mgr.t_alias_name;
      rec_count NUMBER := 0;
      resolution_status VARCHAR2(200);
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
         THEN
            cz_pb_mgr.v_cz_lce_headers_new_ref.DELETE;
            cz_pb_mgr.v_cz_lce_headers_old_ref.DELETE;
            cz_pb_mgr.v_cz_lce_headers_idx_ref.DELETE;
            cz_pb_mgr.v_cz_lce_comp_id_ref.DELETE;
            cz_pb_mgr.v_cz_lce_expl_id_ref.DELETE;
            cz_pb_mgr.v_cz_lce_devl_id_ref.DELETE;

            FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
            LOOP
               cz_pb_mgr.v_cz_lce_headers_new_tbl.DELETE;
               cz_pb_mgr.v_cz_lce_headers_old_tbl.DELETE;
               v_cz_lce_comp_id_tbl.DELETE;
               v_cz_lce_expl_id_tbl.DELETE;

               BEGIN
                  SELECT cz_pb_mgr.sequence_generate(cz_lce_headers_seq
                                                    , 'cz_lce_headers_s.nextval' || cz_pb_mgr.v_db_link
                                                    ,cz_pb_mgr.v_oraclesequenceincr
                                                    )
                        ,lce_header_id, component_id, model_ref_expl_id, devl_project_id
                  BULK COLLECT INTO cz_pb_mgr.v_cz_lce_headers_new_tbl
                        ,cz_pb_mgr.v_cz_lce_headers_old_tbl, v_cz_lce_comp_id_tbl, v_cz_lce_expl_id_tbl, v_cz_lce_devl_id_tbl
                    FROM cz_lce_headers
                   WHERE cz_lce_headers.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) AND cz_lce_headers.deleted_flag = record_not_deleted;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := SUBSTR(SQLERRM, 1, 2000);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LCE', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_lce_headers', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LCE', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               END;

               rec_count := cz_pb_mgr.v_cz_lce_headers_new_ref.COUNT;

               IF (cz_pb_mgr.v_cz_lce_headers_new_tbl.COUNT > 0)
               THEN
                  FOR k IN cz_pb_mgr.v_cz_lce_headers_new_tbl.FIRST .. cz_pb_mgr.v_cz_lce_headers_new_tbl.LAST
                  LOOP
                     rec_count := rec_count + 1;
                     cz_pb_mgr.v_cz_lce_headers_new_ref(rec_count) := cz_pb_mgr.v_cz_lce_headers_new_tbl(k);
                     cz_pb_mgr.v_cz_lce_headers_old_ref(rec_count) := cz_pb_mgr.v_cz_lce_headers_old_tbl(k);
                     cz_pb_mgr.v_cz_lce_headers_idx_ref(cz_pb_mgr.v_cz_lce_headers_old_tbl(k)):=cz_pb_mgr.v_cz_lce_headers_new_tbl(k);
                     cz_pb_mgr.v_cz_lce_comp_id_ref(rec_count) := v_cz_lce_comp_id_tbl(k);
                     cz_pb_mgr.v_cz_lce_expl_id_ref(rec_count) := v_cz_lce_expl_id_tbl(k);
                     cz_pb_mgr.v_cz_lce_devl_id_ref(rec_count) := v_cz_lce_devl_id_tbl(k);
                  END LOOP;
               END IF;
            END LOOP;
         END IF;

         IF (cz_pb_mgr.v_cz_lce_headers_new_ref.COUNT > 0)
         THEN
            ------resolve component ids of cz lce headers
            resolve_ids(cz_pb_mgr.v_cz_lce_comp_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'component ids of lce headers');
            -------resolve model ref expl id
            resolve_ids(cz_pb_mgr.v_cz_lce_expl_id_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'model ref expl id of lce headers');
            -------resolve model ref expl id
            resolve_ids(cz_pb_mgr.v_cz_lce_devl_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'devl proj id of lce headers');
            ------------insert into cz lce headers
            plsql_table_list.DELETE;
            rec_count := 1;
            plsql_table_list(rec_count).col_name := 'lce_header_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_lce_headers_new_ref';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'component_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_lce_comp_id_ref';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'model_ref_expl_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_lce_expl_id_ref';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'devl_project_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_lce_devl_id_ref';
            insert_into_table('cz_lce_headers'
                             ,'lce_header_id'
                             ,cz_pb_mgr.v_db_link
                             ,plsql_table_list
                             ,'cz_pb_mgr.v_cz_lce_headers_old_ref'
                             ,cz_pb_mgr.v_cz_lce_headers_old_ref
                             );
            ------insert data into cz_lce_load_specs
            clear_tables('cz_lce_load_specs', 'ref', cz_pb_mgr.v_status_code);
            IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0) THEN
            FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
            LOOP
               BEGIN
                  v_specs_attach_expl_id_tbl.DELETE;
                  v_specs_lce_header_id_tbl.DELETE;
                  v_specs_required_expl_id_tbl.DELETE;
                  v_specs_attach_comp_id_tbl.DELETE;
                  v_specs_model_id_tbl.DELETE;
                  v_specs_net_type_tbl.DELETE;
                  v_specs_alias_name_tbl.DELETE;

                  SELECT attachment_expl_id, lce_header_id, required_expl_id, attachment_comp_id
                        ,model_id, net_type, alias_name
                  BULK COLLECT INTO v_specs_attach_expl_id_tbl, v_specs_lce_header_id_tbl, v_specs_required_expl_id_tbl, v_specs_attach_comp_id_tbl
                        ,v_specs_model_id_tbl, v_specs_net_type_tbl, v_specs_alias_name_tbl
                    FROM cz_lce_load_specs
                   WHERE cz_lce_load_specs.model_id = cz_pb_mgr.v_models_to_be_exported(i) AND cz_lce_load_specs.deleted_flag = record_not_deleted;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     NULL;
                  WHEN OTHERS
                  THEN
                     RAISE no_load_specs_data;
               END;

               rec_count := cz_pb_mgr.v_specs_model_id_ref.COUNT;

               IF (v_specs_model_id_tbl.COUNT > 0)
               THEN
                  FOR loadspeccount IN v_specs_model_id_tbl.FIRST .. v_specs_model_id_tbl.LAST
                  LOOP
                     rec_count := rec_count + 1;
                     cz_pb_mgr.v_specs_attach_expl_id_ref(rec_count) := v_specs_attach_expl_id_tbl(loadspeccount);
                     cz_pb_mgr.v_specs_lce_header_id_ref(rec_count) := v_specs_lce_header_id_tbl(loadspeccount);
                     cz_pb_mgr.v_specs_required_expl_id_ref(rec_count) := v_specs_required_expl_id_tbl(loadspeccount);
                     cz_pb_mgr.v_specs_attach_comp_id_ref(rec_count) := v_specs_attach_comp_id_tbl(loadspeccount);
                     cz_pb_mgr.v_specs_model_id_ref(rec_count) := v_specs_model_id_tbl(loadspeccount);
                     cz_pb_mgr.v_specs_net_type_ref(rec_count) := v_specs_net_type_tbl(loadspeccount);
                     cz_pb_mgr.v_specs_alias_name_ref(rec_count) := v_specs_alias_name_tbl(loadspeccount);
                  END LOOP;
               END IF;
            END LOOP;
            END IF;

            --------resolve attachment expl id
            resolve_ids(cz_pb_mgr.v_specs_attach_expl_id_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'attachment expl id of cz_lce_load_specs');
            --------resolve lce_header id
            resolve_ids(cz_pb_mgr.v_specs_lce_header_id_ref, cz_pb_mgr.v_cz_lce_headers_idx_ref, 'lce_header_id of cz_lce_load_specs');
            --------resolve required expl id
            resolve_ids(cz_pb_mgr.v_specs_required_expl_id_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'required expl id of cz_lce_load_specs');
            --------resolve attachment comp id
            resolve_ids(cz_pb_mgr.v_specs_attach_comp_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'attachment comp id of cz_lce_load_specs');
            --------resolve model id
            resolve_ids(cz_pb_mgr.v_specs_model_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'model id of cz_lce_load_specs');
            insert_lce_load_specs(cz_pb_mgr.v_specs_attach_expl_id_ref
                                 ,cz_pb_mgr.v_specs_lce_header_id_ref
                                 ,cz_pb_mgr.v_specs_required_expl_id_ref
                                 ,cz_pb_mgr.v_specs_attach_comp_id_ref
                                 ,cz_pb_mgr.v_specs_model_id_ref
                                 ,cz_pb_mgr.v_specs_net_type_ref
                                 ,cz_pb_mgr.v_specs_alias_name_ref
                                 ,cz_pb_mgr.v_status_code
                                 );
            v_cz_lce_comp_id_tbl.DELETE;
            v_cz_lce_expl_id_tbl.DELETE;
            v_cz_lce_devl_id_tbl.DELETE;
            v_specs_attach_expl_id_tbl.DELETE;
            v_specs_lce_header_id_tbl.DELETE;
            v_specs_required_expl_id_tbl.DELETE;
            v_specs_attach_comp_id_tbl.DELETE;
            v_specs_model_id_tbl.DELETE;
         END IF;
      END IF;                                                                             /* end if of cz_pb_mgr.v_status_code <> PUBLICATION_ERROR */
   EXCEPTION
      WHEN no_load_specs_data
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving data from cz_load_specs';
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.COPYLCELOADSPECS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_lce_headers', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.COPYLCEHDRS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END copy_lce_headers;

-- used only when rules not copied in publication
PROCEDURE get_rule_intl_text_ids(x_text_id_tbl OUT NOCOPY CZ_PB_MGR.t_ref)
IS
  l_text_id_tbl  CZ_PB_MGR.t_ref;
  l_counter      PLS_INTEGER := 0;
BEGIN
  FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST LOOP
    l_text_id_tbl.DELETE;
    SELECT intl_text_id BULK COLLECT INTO l_text_id_tbl
    FROM cz_intl_texts
    WHERE model_id = cz_pb_mgr.v_models_to_be_exported(i)
    AND deleted_flag = '0' AND (seeded_flag IS NULL OR seeded_flag = '0')
    AND intl_text_id IN (SELECT reason_id
                         FROM cz_rules
                         WHERE devl_project_id = cz_pb_mgr.v_models_to_be_exported(i)
                         AND deleted_flag = '0' AND reason_id IS NOT NULL
                         UNION ALL
                         SELECT unsatisfied_msg_id
                         FROM cz_rules
                         WHERE devl_project_id = cz_pb_mgr.v_models_to_be_exported(i)
                         AND deleted_flag = '0' AND unsatisfied_msg_id IS NOT NULL);
    IF l_text_id_tbl.COUNT > 0 THEN
      FOR j IN l_text_id_tbl.FIRST .. l_text_id_tbl.LAST LOOP
        l_counter := l_counter + 1;
        x_text_id_tbl(l_counter) := l_text_id_tbl(j);
      END LOOP;
    END IF;
  END LOOP;
END get_rule_intl_text_ids;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
---------procedure to copy data into cz_lce_texts
---------reason ids and unsatisfied message ids of cz rules
---------are copied and resolved in this procedure
---------
   PROCEDURE copy_lce_texts(p_copy_rules_flag IN VARCHAR2)
   IS
      TYPE lce_text_ref IS TABLE OF VARCHAR2(4000)
         INDEX BY BINARY_INTEGER;

      v_text_hdr_ref cz_pb_mgr.t_ref;
      v_text_seq_ref cz_pb_mgr.t_ref;
      v_lce_text_ref lce_text_ref;
      v_text_hdr_tbl cz_pb_mgr.t_ref;
      v_text_seq_tbl cz_pb_mgr.t_ref;
      v_lce_text_tbl cz_pb_mgr.lcetexttype;
      v_text_hdr_new_ref cz_pb_mgr.t_ref;
      v_text_seq_new_ref cz_pb_mgr.t_ref;
      v_lce_text_new_ref cz_pb_mgr.lcetexttype;
      record_count PLS_INTEGER;
      seq_nbr PLS_INTEGER;
      return_position PLS_INTEGER;
      rec_count NUMBER;
      l_text_id_tbl CZ_PB_MGR.t_ref;
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF (cz_pb_mgr.v_cz_lce_headers_old_ref.COUNT > 0)
         THEN
            v_text_hdr_ref.DELETE;
            v_text_seq_ref.DELETE;
            v_lce_text_ref.DELETE;

            FOR i IN cz_pb_mgr.v_cz_lce_headers_old_ref.FIRST .. cz_pb_mgr.v_cz_lce_headers_old_ref.LAST
            LOOP
               BEGIN
                  v_text_hdr_tbl.DELETE;
                  v_text_seq_tbl.DELETE;
                  v_lce_text_tbl.DELETE;

                  SELECT   lce_header_id, seq_nbr, lce_text
                  BULK COLLECT INTO v_text_hdr_tbl, v_text_seq_tbl, v_lce_text_tbl
                      FROM cz_lce_texts
                     WHERE cz_lce_texts.lce_header_id = cz_pb_mgr.v_cz_lce_headers_old_ref(i)
                  ORDER BY lce_header_id, seq_nbr;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_lce_texts', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_lce_texts', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               END;

               rec_count := v_text_hdr_ref.COUNT;

               IF (v_text_hdr_tbl.COUNT > 0)
               THEN
                  FOR j IN v_text_hdr_tbl.FIRST .. v_text_hdr_tbl.LAST
                  LOOP
                     rec_count := rec_count + 1;
                     v_text_hdr_ref(rec_count) := v_text_hdr_tbl(j);
                     v_text_seq_ref(rec_count) := v_text_seq_tbl(j);
                     v_lce_text_ref(rec_count) := v_lce_text_tbl(j);
                  END LOOP;
               END IF;
            END LOOP;
         END IF;

         IF (v_text_hdr_ref.COUNT > 0)
         THEN
            -------------Resolving lce header id
            resolve_ids(v_text_hdr_ref, cz_pb_mgr.v_cz_lce_headers_idx_ref, 'lce header id of cz lce texts');
         END IF;

         -------replace reason ids in lce text
         IF (v_lce_text_ref.COUNT > 0) THEN
           -- insert intl text records and populate text id lookup map if rules are not copied in publication
           IF UPPER(NVL(p_copy_rules_flag, 'YES')) <> 'YES' THEN
             get_rule_intl_text_ids(l_text_id_tbl);
             insert_intl_texts(l_text_id_tbl,'Reason and unsatisfied msg ids of rules');
           END IF;

           FOR j IN v_lce_text_ref.FIRST .. v_lce_text_ref.LAST
           LOOP
             replace_intl_texts(v_lce_text_ref(j), reasonid, 'REASONID', v_lce_text_ref(j));
           END LOOP;
         END IF;

         ----replace unsatisfied message ids
         IF (v_lce_text_ref.COUNT > 0)
         THEN
            FOR j IN v_lce_text_ref.FIRST .. v_lce_text_ref.LAST
            LOOP
               replace_intl_texts(v_lce_text_ref(j), unmsgid, 'UNSATMSGID', v_lce_text_ref(j));
            END LOOP;
         END IF;

         IF (v_text_hdr_ref.COUNT > 0)
         THEN
            record_count := 0;
            seq_nbr := 0;

            FOR i IN v_text_hdr_ref.FIRST .. v_text_hdr_ref.LAST
            LOOP
               record_count := record_count + 1;
               seq_nbr := seq_nbr + 1;

               IF (v_text_seq_ref(i) = 1)
               THEN
                  seq_nbr := 1;
               END IF;

               IF (LENGTH(v_lce_text_ref(i)) > 2000)
               THEN
                  v_text_hdr_new_ref(record_count) := v_text_hdr_ref(i);
                  v_text_seq_new_ref(record_count) := seq_nbr;
                  v_lce_text_new_ref(record_count) := SUBSTR(v_lce_text_ref(i), 1, 2000);
                  return_position := INSTR(v_lce_text_new_ref(record_count), pbnewline, -1);
                  v_lce_text_new_ref(record_count) := SUBSTR(v_lce_text_ref(i), 1, return_position);
                  record_count := record_count + 1;
                  seq_nbr := seq_nbr + 1;
                  v_text_hdr_new_ref(record_count) := v_text_hdr_ref(i);
                  v_text_seq_new_ref(record_count) := seq_nbr;
                  v_lce_text_new_ref(record_count) := SUBSTR(v_lce_text_ref(i), return_position + 1);
               ELSE
                  v_text_hdr_new_ref(record_count) := v_text_hdr_ref(i);
                  v_text_seq_new_ref(record_count) := seq_nbr;
                  v_lce_text_new_ref(record_count) := v_lce_text_ref(i);
               END IF;
            END LOOP;
         END IF;

         IF (v_text_hdr_new_ref.COUNT > 0)
         THEN
            FOR i IN v_text_hdr_new_ref.FIRST .. v_text_hdr_new_ref.LAST
            LOOP
               BEGIN
                  EXECUTE IMMEDIATE    'INSERT INTO cz_lce_texts'
                                    || cz_pb_mgr.v_db_link
                                    || '( LCE_HEADER_ID'
                                    || ' '
                                    || ',SEQ_NBR'
                                    || ' '
                                    || ',LCE_TEXT'
                                    || ' '
                                    || ')'
                                    || ' '
                                    || 'VALUES (:1,:2,:3)'
                              USING v_text_hdr_new_ref(i), v_text_seq_new_ref(i), v_lce_text_new_ref(i);

                  COMMIT;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     ROLLBACK;
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_lce_texts', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LCETEXTS', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               END;
            END LOOP;

            COMMIT;
         END IF;

         v_text_hdr_ref.DELETE;
         v_text_seq_ref.DELETE;
         v_lce_text_ref.DELETE;
         v_text_hdr_tbl.DELETE;
         v_text_seq_tbl.DELETE;
         v_lce_text_tbl.DELETE;
      END IF;                                                                             /* end if of cz_pb_mgr.v_status_code <> PUBLICATION_ERROR */
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_lce_texts', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.COPYLCETEXTS', SQLCODE);
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
---------the installed or base languages on the source and the target instance
---------must be the same.
   PROCEDURE pb_language_check
   IS
      lang_cv ref_cursor;
      lang_index NUMBER := 0.0;
   BEGIN
      cz_pb_mgr.v_src_lang_code_tbl.DELETE;

      BEGIN
         SELECT   UPPER(language_code)
         BULK COLLECT INTO cz_pb_mgr.v_src_lang_code_tbl
             FROM fnd_languages
            WHERE fnd_languages.installed_flag IN('B', 'I')
         ORDER BY UPPER(language_code);
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_LANG');
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SRCLANG', SQLCODE);
            cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            cz_pb_mgr.global_export_retcode := 2;
      END;

      cz_pb_mgr.v_tgt_lang_code_tbl.DELETE;

      BEGIN
         OPEN lang_cv FOR    'SELECT UPPER(language_code)'
                          || ' '
                          || 'FROM 	 fnd_languages'
                          || cz_pb_mgr.v_db_link
                          || ' '
                          || 'WHERE  fnd_languages.installed_flag IN (''B'', ''I'')'
                          || ' '
                          || 'ORDER  BY UPPER(language_code)';

         lang_index := 1;

         LOOP
            FETCH lang_cv
             INTO cz_pb_mgr.v_tgt_lang_code_tbl(lang_index);

            EXIT WHEN lang_cv%NOTFOUND;
            lang_index := lang_index + 1;
         END LOOP;
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_LANG');
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SRCLANG', SQLCODE);
            cz_pb_mgr.v_status_code := 'ERR';
            cz_pb_mgr.global_export_retcode := 2;
      END;

      IF (    (cz_pb_mgr.v_src_lang_code_tbl.COUNT > 0)
          AND (cz_pb_mgr.v_tgt_lang_code_tbl.COUNT > 0)
          AND (cz_pb_mgr.v_src_lang_code_tbl.COUNT = cz_pb_mgr.v_tgt_lang_code_tbl.COUNT)
         )
      THEN
         FOR l IN cz_pb_mgr.v_src_lang_code_tbl.FIRST .. cz_pb_mgr.v_src_lang_code_tbl.LAST
         LOOP
            IF (cz_pb_mgr.v_src_lang_code_tbl(l) <> cz_pb_mgr.v_tgt_lang_code_tbl(l))
            THEN
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_SRC_TGT_LANG', 'LANGUAGE', cz_pb_mgr.v_tgt_lang_code_tbl(l));
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SRCLANG', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               cz_pb_mgr.global_export_retcode := 2;
            END IF;
         END LOOP;
      ELSE
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_LANG');
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SRCLANG', SQLCODE);
         cz_pb_mgr.v_status_code := 'ERR';
         cz_pb_mgr.global_export_retcode := 2;
      END IF;

      cz_pb_mgr.v_src_lang_code_tbl.DELETE;
      cz_pb_mgr.v_tgt_lang_code_tbl.DELETE;
   END pb_language_check;
-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure to fix bug# 2759486  When copies of models exist
-----there could be many projects with the same persistent_node_id
-----So we need persistent_node_id and its associated project for resolving child_model_expl_id
-----of model ref expls.
   PROCEDURE get_pers_prj_id(
      p_ref_node IN cz_ps_nodes.ps_node_id%TYPE
     ,x_pers_node_id OUT NOCOPY cz_ps_nodes.ps_node_id%TYPE
     ,x_prj_id OUT NOCOPY cz_ps_nodes.devl_project_id%TYPE
   )
   IS
   BEGIN
      SELECT persistent_node_id, devl_project_id
        INTO x_pers_node_id, x_prj_id
        FROM cz_ps_nodes t
       WHERE t.ps_node_id = p_ref_node AND t.deleted_flag = '0';
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving persistent_node_id from cz ps nodes for ps node id: ' || p_ref_node;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.get_pers_prj_id', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure retrieves the project id of a ps node
   PROCEDURE get_devl_project_id(
      p_ps_node_id IN cz_ps_nodes.ps_node_id%TYPE
     ,x_devl_project_id IN OUT NOCOPY cz_ps_nodes.devl_project_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         SELECT devl_project_id
           INTO x_devl_project_id
           FROM cz_ps_nodes
          WHERE cz_ps_nodes.ps_node_id = p_ps_node_id AND cz_ps_nodes.deleted_flag = '0';
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving devl proj id from cz ps nodes for ps node id: ' || p_ps_node_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETDEVLPROJID', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure that retrieves persistent node id
   PROCEDURE get_persistent_node_id(
      p_ps_node_id IN cz_ps_nodes.ps_node_id%TYPE
     ,x_persistent_id IN OUT NOCOPY cz_ps_nodes.persistent_node_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         SELECT persistent_node_id
           INTO x_persistent_id
           FROM cz_ps_nodes t
          WHERE t.ps_node_id = p_ps_node_id AND t.deleted_flag = '0';
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving persistent_node_id from cz ps nodes for ps node id: ' || p_ps_node_id;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETDEVLPROJID', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure retrieves the component id
   PROCEDURE remote_component_id(
      p_resolved_key_value IN OUT NOCOPY NUMBER
     ,p_model_not_exported_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_server_id IN cz_servers.server_local_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (p_model_not_exported_array.COUNT > 0)
         THEN
            FOR j IN p_model_not_exported_array.FIRST .. p_model_not_exported_array.LAST
            LOOP
               IF (p_resolved_key_value = p_model_not_exported_array(j)) THEN
                 get_remote_model_id(p_server_id, p_resolved_key_value, x_status, p_resolved_key_value);
                 EXIT;
               END IF;
            END LOOP;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving remote component from pb model exports: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETDEVLPROJID', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure that resolves remote reference nodes
   PROCEDURE resolve_ref_ids_not_found(
      p_master_keys_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_resolving_key_old_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_resolving_key_new_idx_array IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2
     ,p_resolved_key_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_column_name IN VARCHAR2
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      ref_node_found BOOLEAN := FALSE;
      v_node_id NUMBER := 0.0;
      child_ref_id_cv ref_cursor;
      v_ref_project cz_devl_projects.devl_project_id%TYPE;
      v_ref_remote_model cz_devl_projects.devl_project_id%TYPE;
      v_child_expl_id cz_model_ref_expls.model_ref_expl_id%TYPE;
      v_persistent_node_id cz_ps_nodes.persistent_node_id%TYPE;
      v_source_child_model cz_model_ref_expls.model_id%TYPE;
      v_child_ref_node cz_ps_nodes.ps_node_id%TYPE;
      v_ref_model_id cz_model_ref_expls.model_id%TYPE;
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (p_master_keys_array.COUNT > 0)
         THEN
            FOR i IN p_master_keys_array.FIRST .. p_master_keys_array.LAST
            LOOP
               ref_node_found := FALSE;

               IF (p_resolved_key_array(i) IS NOT NULL)
               THEN
                  BEGIN
                     p_resolved_key_array(i) := p_resolving_key_new_idx_array(p_resolved_key_array(i));
                     ref_node_found := TRUE;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        ref_node_found := FALSE;
                     WHEN OTHERS
                     THEN
                        RAISE;
                  END;

                  v_node_id := p_resolved_key_array(i);
                  v_ref_project := 0;
                  v_source_child_model := 0;
                  v_child_ref_node := 0;
                  v_persistent_node_id := 0;
                  v_ref_model_id := 0;

                  IF (NOT ref_node_found)
                  THEN
                     IF (p_column_name = 'cz_model_ref_expl.referring_node_id')
                     THEN
                        get_devl_project_id(p_resolved_key_array(i), v_ref_project, cz_pb_mgr.v_status_code);
                        get_remote_model_id(cz_pb_mgr.v_server_id, v_ref_project, cz_pb_mgr.v_status_code, v_ref_remote_model);

                        IF ((v_ref_project IS NOT NULL) AND(cz_pb_mgr.v_status_code <> PUBLICATION_ERROR))
                        THEN
                           OPEN child_ref_id_cv FOR    'SELECT model_ref_expl_id FROM cz_model_ref_expls'
                                                    || cz_pb_mgr.v_db_link
                                                    || '  t'
                                                    || ' '
                                                    || 'WHERE  t.model_id = '
                                                    || TO_CHAR(v_ref_remote_model)
                                                    || ' '
                                                    || 'AND    node_depth = 0 ';

                           LOOP
                              FETCH child_ref_id_cv
                               INTO v_child_expl_id;

                              EXIT WHEN child_ref_id_cv%NOTFOUND;
                           END LOOP;

                           CLOSE child_ref_id_cv;

                           OPEN child_ref_id_cv FOR    'SELECT model_id'
                                                    || ' '
                                                    || 'FROM   cz_model_ref_expls'
                                                    || cz_pb_mgr.v_db_link
                                                    || '  t'
                                                    || ' '
                                                    || 'WHERE  t.model_ref_expl_id = '
                                                    || TO_CHAR(v_child_expl_id)
                                                    || ' '
                                                    || 'AND   t.deleted_flag = ''0'' ';

                           LOOP
                              FETCH child_ref_id_cv
                               INTO v_ref_model_id;

                              EXIT WHEN child_ref_id_cv%NOTFOUND;
                           END LOOP;

                           CLOSE child_ref_id_cv;

                           get_persistent_node_id(p_resolved_key_array(i), v_persistent_node_id, cz_pb_mgr.v_status_code);

                           OPEN child_ref_id_cv FOR    'SELECT ps_node_id FROM cz_ps_nodes'
                                                    || cz_pb_mgr.v_db_link
                                                    || '  t'
                                                    || ' '
                                                    || 'WHERE  t.persistent_node_id = '
                                                    || TO_CHAR(v_persistent_node_id)
                                                    || ' '
                                                    || 'AND   t.devl_project_id = '
                                                    || TO_CHAR(v_ref_model_id)
                                                    || ' '
                                                    || 'AND   t.deleted_flag = ''0'' ';

                           LOOP
                              FETCH child_ref_id_cv
                               INTO p_resolved_key_array(i);

                              EXIT WHEN child_ref_id_cv%NOTFOUND;
                           END LOOP;

                           CLOSE child_ref_id_cv;
                        END IF;
                     ELSIF(p_column_name = 'cz_model_ref_expl.child_expl_id')
                     THEN
                      IF cz_pb_mgr.v_session_parameter<>model_copy THEN
                        BEGIN
                           SELECT model_id, referring_node_id
                             INTO v_source_child_model, v_child_ref_node
                             FROM cz_model_ref_expls
                            WHERE cz_model_ref_expls.model_ref_expl_id = p_resolved_key_array(i) AND cz_model_ref_expls.deleted_flag = '0';
                        EXCEPTION
                           WHEN OTHERS
                           THEN
                              v_child_ref_node := NULL;
                        END;

                        IF (v_child_ref_node IS NOT NULL)
                        THEN
                           get_pers_prj_id(v_child_ref_node, v_persistent_node_id, v_source_child_model);
                           get_remote_model_id(cz_pb_mgr.v_server_id, v_source_child_model, cz_pb_mgr.v_status_code, v_ref_remote_model);

                           BEGIN
                              OPEN child_ref_id_cv FOR    'SELECT ps_node_id'
                                                       || ' '
                                                       || 'FROM   cz_ps_nodes'
                                                       || cz_pb_mgr.v_db_link
                                                       || '  t'
                                                       || ' '
                                                       || 'WHERE  t.persistent_node_id = '
                                                       || TO_CHAR(v_persistent_node_id)
                                                       || ' '
                                                       || 'AND   t.devl_project_id = '
                                                       || TO_CHAR(v_ref_remote_model)
                                                       || ' '
                                                       || 'AND   t.deleted_flag = ''0'' ';

                              LOOP
                                 FETCH child_ref_id_cv
                                  INTO v_child_ref_node;

                                 EXIT WHEN child_ref_id_cv%NOTFOUND;
                              END LOOP;

                              CLOSE child_ref_id_cv;
                           EXCEPTION
                              WHEN NO_DATA_FOUND
                              THEN
                                 cz_pb_mgr.v_err_message :=
                                    'NO remote referring node id found for model :' || v_ref_remote_model || ' on server : ' || cz_pb_mgr.v_server_id;
                                 cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODREF', SQLCODE);

                                 CLOSE child_ref_id_cv;
                              WHEN OTHERS
                              THEN
                                 CLOSE child_ref_id_cv;
                           END;
                        ELSE
                           get_remote_model_id(cz_pb_mgr.v_server_id, v_source_child_model, cz_pb_mgr.v_status_code, v_ref_remote_model);
                        END IF;

                        IF ((v_child_ref_node > 0) AND(v_source_child_model > 0) AND(cz_pb_mgr.v_status_code <> PUBLICATION_ERROR))
                        THEN
                           BEGIN
                              OPEN child_ref_id_cv FOR    'SELECT model_ref_expl_id'
                                                       || ' '
                                                       || 'FROM  cz_model_ref_expls'
                                                       || cz_pb_mgr.v_db_link
                                                       || ' t'
                                                       || ' '
                                                       || 'WHERE  t.model_id = '
                                                       || TO_CHAR(v_ref_remote_model)
                                                       || ' '
                                                       || 'AND    t.referring_node_id = '
                                                       || TO_CHAR(v_child_ref_node);

                              LOOP
                                 FETCH child_ref_id_cv
                                  INTO p_resolved_key_array(i);

                                 EXIT WHEN child_ref_id_cv%NOTFOUND;
                              END LOOP;

                              CLOSE child_ref_id_cv;
                           EXCEPTION
                              WHEN OTHERS
                              THEN
                                 CLOSE child_ref_id_cv;
                           END;
                        ELSE
                           BEGIN
                              OPEN child_ref_id_cv FOR    'SELECT model_ref_expl_id'
                                                       || ' '
                                                       || 'FROM  cz_model_ref_expls'
                                                       || cz_pb_mgr.v_db_link
                                                       || ' t'
                                                       || ' '
                                                       || 'WHERE  t.model_id = '
                                                       || TO_CHAR(v_ref_remote_model)
                                                       || ' '
                                                       || 'AND    t.node_depth = 0';

                              LOOP
                                 FETCH child_ref_id_cv
                                  INTO p_resolved_key_array(i);

                                 EXIT WHEN child_ref_id_cv%NOTFOUND;
                              END LOOP;

                              CLOSE child_ref_id_cv;
                           EXCEPTION
                              WHEN OTHERS
                              THEN
                                 CLOSE child_ref_id_cv;
                           END;
                        END IF;
                      END IF;
                     ELSIF(p_column_name = 'cz_model_ref_expl.component_id')
                     THEN
                        remote_component_id(p_resolved_key_array(i)
                                           ,cz_pb_mgr.v_models_not_to_be_exported
                                           ,cz_pb_mgr.v_server_id
                                           ,cz_pb_mgr.v_status_code
                                           );
                     ELSIF(p_column_name IN
                              ('cz_ui_nodes.ui_def_ref_id'
                              ,'cz_ui_refs.ref_ui_def_id'
                              ,'cz_ui_page_refs.target_ui_def_id'
                              ,'cz_ui_page_elements.target_page_ui_def_id'
                              ,'cz_ui_ref_templates.ref_template_ui_def_id'
                              ,'cz_ui_actions.target_ui_def_id'
                              )
                          )
                     THEN
                        BEGIN
                           IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
                           THEN
                              OPEN child_ref_id_cv FOR    'SELECT ui_def_id FROM cz_ui_defs'
                                                       || cz_pb_mgr.v_db_link
                                                       || ' '
                                                       || 'WHERE name = (SELECT name FROM cz_ui_defs t'
                                                       || ' '
                                                       || 'WHERE t.ui_def_id = '
                                                       || p_resolved_key_array(i)
                                                       || ')'
                                                       || ' '
                                                       || 'AND devl_project_id = :1'
                              USING v_ref_remote_model;
                              LOOP
                                 FETCH child_ref_id_cv
                                  INTO p_resolved_key_array(i);

                                 EXIT WHEN child_ref_id_cv%NOTFOUND;
                              END LOOP;

                              CLOSE child_ref_id_cv;
                           ELSE
                              OPEN child_ref_id_cv FOR    'SELECT	ui_def_id FROM cz_ui_defs'
                                                       || cz_pb_mgr.v_db_link
                                                       || ' '
                                                       || 'WHERE		name	= ( SELECT name FROM	  cz_ui_defs t'
                                                       || ' '
                                                       || 'WHERE  t.ui_def_id = '
                                                       || p_resolved_key_array(i)
                                                       || ' )'
                                                       || ' '
                                                       || 'AND devl_project_id = :1'
                              USING v_ref_remote_model;
                              LOOP
                                 FETCH child_ref_id_cv
                                  INTO p_resolved_key_array(i);

                                 EXIT WHEN child_ref_id_cv%NOTFOUND;
                              END LOOP;

                              CLOSE child_ref_id_cv;
                           END IF;
                        EXCEPTION
                           WHEN OTHERS
                           THEN
                              CLOSE child_ref_id_cv;

                              RAISE;
                        END;
                     END IF;                                                                                             /* end if of p_column name */
                  END IF;                                                                                                /* end if of ref_not_found */
               END IF;                                                                                            /* end if of p_resolved_key_array */
            END LOOP;                                                                                            /* end loop of p_master_keys_array */
         END IF;                                                                                                    /*end if of p_master_keys_array */
      END IF;                                                                                                                 /* end if of x_status */
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in resolving : ' || p_column_name || ' for id ' || v_node_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEREFIDS', SQLCODE);
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------update reference ids of cz ps nodes of the remote model
------@p_models_exported -- root model and all its children
------@x_status --- publication status
------@p_server_id --- server local is of the target instance
------@p_new_ps_node_array --- ps node array that contains new values
-- Note: do get_rem_nodes_of_models early, then we can remove this ugly method as well as some other bad ones
   PROCEDURE update_remote_reference_ids(
      p_models_not_exported IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_new_ps_node_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_server_id IN cz_servers.server_local_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      l_sql_string VARCHAR2(32000);
      l_remote_mode_id NUMBER;
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (p_models_not_exported.COUNT > 0)
         THEN
            FOR i IN p_models_not_exported.FIRST .. p_models_not_exported.LAST
            LOOP
	       IF (p_new_ps_node_array.COUNT > 0) THEN
               FOR j IN p_new_ps_node_array.FIRST .. p_new_ps_node_array.LAST
               LOOP
                  IF (cz_pb_mgr.v_ps_refid_old_tbl(j) IS NOT NULL)
                  THEN
                    get_remote_model_id(p_server_id, p_models_not_exported(i), x_status, l_remote_mode_id);
                    l_sql_string := 'UPDATE cz_ps_nodes'
                           ||   cz_pb_mgr.v_db_link
                           || ' SET reference_id=:1,component_id=:2'
                           || ' WHERE deleted_flag=:3 AND ps_node_id=:4 AND reference_id=:5';
                    EXECUTE IMMEDIATE l_sql_string
                      USING l_remote_mode_id,l_remote_mode_id,record_not_deleted,p_new_ps_node_array(j),p_models_not_exported(i);
                  END IF;
               END LOOP;
	       END IF;
            END LOOP;

            COMMIT WORK;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_REF_ID_ERR', 'TABLENAME', 'cz_ps_nodes', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------procedure that resolves the virtual components of explosion records
--------@p_model_ref_expls_ref :explosion array
--------@p_models_not_exported :source models that are not exported
--------@p_server_id           :server local id of cz servers of the target instance
--------@x_status              :publication_status
   PROCEDURE resolve_virtual_components(
      p_model_ref_expls_ref IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_models_not_exported IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_server_id IN OUT NOCOPY cz_servers.server_local_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      rec_count PLS_INTEGER := 0;
      v_vrt_comp_id_tbl cz_pb_mgr.t_ref;
      v_vrt_comp_id_ref cz_pb_mgr.t_ref;
      virt_ref_id_cv ref_cursor;
      virt_model_id_cv ref_cursor;
      v_vir_remote_model_id NUMBER := 0.0;
      v_vir_devl_id NUMBER := 0.0;
      v_remote_comp_id NUMBER := 0.0;
      v_child_expl_id NUMBER := 0.0;
      v_vir_persistent_id cz_ps_nodes.persistent_node_id%TYPE;
      v_errored_model_id cz_devl_projects.devl_project_id%TYPE;
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (p_models_not_exported.COUNT > 0)
         THEN
            v_vrt_comp_id_tbl.DELETE;

            FOR i IN p_models_not_exported.FIRST .. p_models_not_exported.LAST
            LOOP
               v_errored_model_id := p_models_not_exported(i);

               BEGIN
                  SELECT component_id
                  BULK COLLECT INTO v_vrt_comp_id_tbl
                    FROM cz_model_ref_expls
                   WHERE cz_model_ref_expls.model_id = p_models_not_exported(i)
                     AND cz_model_ref_expls.virtual_flag = 0
                     AND (cz_model_ref_expls.ps_node_type = non_virtual_component OR cz_model_ref_expls.ps_node_type = model_connector)
                     AND cz_model_ref_expls.deleted_flag = record_not_deleted;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := 'No virtual components in the model : ' || TO_CHAR(p_models_not_exported(i));
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VIRCOMPL', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message :=
                                'Error in bulk collect of virtual components in the model : ' || TO_CHAR(p_models_not_exported(i)) || ' : '
                                || SQLERRM;
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.VIRCOMPL', SQLCODE);
                     RAISE;
               END;

               IF (v_vrt_comp_id_tbl.COUNT > 0)
               THEN
                  rec_count := v_vrt_comp_id_ref.COUNT;

                  FOR j IN v_vrt_comp_id_tbl.FIRST .. v_vrt_comp_id_tbl.LAST
                  LOOP
                     rec_count := rec_count + 1;
                     v_vrt_comp_id_ref(rec_count) := v_vrt_comp_id_tbl(j);
                  END LOOP;
               END IF;
            END LOOP;
         END IF;

         v_vir_persistent_id := 0;
         v_vir_devl_id := 0;

         IF (v_vrt_comp_id_ref.COUNT > 0)
         THEN
            FOR i IN v_vrt_comp_id_ref.FIRST .. v_vrt_comp_id_ref.LAST
            LOOP
               BEGIN
                  SELECT devl_project_id, persistent_node_id
                    INTO v_vir_devl_id, v_vir_persistent_id
                    FROM cz_ps_nodes
                   WHERE ps_node_id = v_vrt_comp_id_ref(i);
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     v_vir_devl_id := 0;
                     v_vir_persistent_id := 0;
               END;

               v_vir_remote_model_id := 0;

               IF (v_vir_devl_id > 0)
               THEN
                  get_remote_model_id(cz_pb_mgr.v_server_id, v_vir_devl_id, cz_pb_mgr.v_status_code, v_vir_remote_model_id);
               END IF;

               cz_pb_mgr.v_remote_comp_id := 0;

               IF (v_vir_remote_model_id > 0)
               THEN
                  BEGIN
                     OPEN virt_ref_id_cv FOR    'SELECT ps_node_id FROM cz_ps_nodes'
                                             || cz_pb_mgr.v_db_link
                                             || '  t'
                                             || ' '
                                             || 'WHERE  t.devl_project_id = '
                                             || v_vir_remote_model_id
                                             || ' '
                                             || 'AND    t.persistent_node_id  = '
                                             || v_vir_persistent_id
                                             || ' '
                                             || 'AND   t.deleted_flag = ''0'' ';

                     LOOP
                        FETCH virt_ref_id_cv
                         INTO v_remote_comp_id;

                        EXIT WHEN virt_ref_id_cv%NOTFOUND;
                     END LOOP;

                     CLOSE virt_ref_id_cv;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        CLOSE virt_ref_id_cv;

                        RAISE;
                  END;

                  cz_pb_mgr.v_child_expl_id := NULL;

                  IF (v_remote_comp_id > 0)
                  THEN
                     BEGIN
                        OPEN virt_model_id_cv FOR    'SELECT model_ref_expl_id'
                                                  || ' '
                                                  || 'FROM  cz_model_ref_expls'
                                                  || cz_pb_mgr.v_db_link
                                                  || '  t'
                                                  || ' '
                                                  || 'WHERE t.model_id = '
                                                  || v_vir_remote_model_id
                                                  || ' '
                                                  || 'AND  t.component_id = '
                                                  || v_remote_comp_id
                                                  || ' '
                                                  || 'AND  t.deleted_flag = ''0'' ';

                        LOOP
                           FETCH virt_model_id_cv
                            INTO v_child_expl_id;

                           EXIT WHEN virt_model_id_cv%NOTFOUND;
                        END LOOP;

                        CLOSE virt_model_id_cv;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           CLOSE virt_model_id_cv;

                           RAISE;
                     END;

		     IF (p_model_ref_expls_ref.COUNT > 0) THEN
                     FOR z IN p_model_ref_expls_ref.FIRST .. p_model_ref_expls_ref.LAST
                     LOOP
                        EXECUTE IMMEDIATE    'BEGIN '
                                          || ' '
                                          || 'UPDATE cz_model_ref_expls'
                                          || cz_pb_mgr.v_db_link
                                          || '  t'
                                          || ' '
                                          || 'SET    t.component_id = '
                                          || v_remote_comp_id
                                          || ' ,'
                                          || ' '
                                          || 't.child_model_expl_id = '
                                          || v_child_expl_id
                                          || ''
                                          || ' '
                                          || 'WHERE  t.model_ref_expl_id = '
                                          || p_model_ref_expls_ref(z)
                                          || ''
                                          || ' '
                                          || 'AND    t.component_id = '
                                          || v_vrt_comp_id_ref(i)
                                          || ''
                                          || ' '
                                          || 'AND    t.deleted_flag = ''0'';'
                                          || ' '
                                          || 'COMMIT;'
                                          || ' '
                                          || 'END;';
                     END LOOP;
		     END IF;
                  END IF;                                                                               /* end if of cz_pb_mgr.v_remote_comp_id > 0 */
               END IF;                                                                                       /* end if of v_vir_remote_model_id > 0 */
            END LOOP;

            v_vrt_comp_id_tbl.DELETE;
            v_vrt_comp_id_ref.DELETE;
         END IF;                                                                                           /* end if of v_vrt_comp_id_ref.COUNT > 0 */
      END IF;                                                                                            /* end if of x_status <> PUBLICATION_ERROR */
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error during resolution of non virtual component of source model : ' || v_errored_model_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEVIRTCOMP', SQLCODE);
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END;


-- Models with no change since the last successful export are not exported. Therefore their UIs
-- are not exported as well. In such a case if a referring UI is exported, then the ids of referred UIs
-- need to be resolved in these referring UIs. For that we need to map all referred UI Id from the
-- source to corresponding remote Ids. This is exactly what this procedure does i.e. tt maps the
-- source ui_def_ids to remote ui_def_ids in the table x_cz_ui_defs_idx_ref
PROCEDURE get_uis_of_mdls_not_exported(p_models_not_exported IN OUT NOCOPY cz_pb_mgr.t_ref,
                                       x_cz_ui_defs_idx_ref IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2,
                                       p_server_id  IN OUT NOCOPY cz_servers.server_local_id%TYPE,
                                       x_status IN OUT NOCOPY VARCHAR2)
AS

v_ui_defs_tbl               cz_pb_mgr.t_ref;

ui_ref_id_cv               REF_CURSOR;
v_devl_project_id          cz_devl_projects.devl_project_id%TYPE;
v_remote_devl_project_id   cz_devl_projects.devl_project_id%TYPE;
v_remote_ui_def_id         cz_ui_defs.ui_def_id%TYPE;
v_name                     cz_ui_defs.name%TYPE;
CANNOT_FIND_REMOTE_UI      EXCEPTION;

BEGIN

  IF (x_status <> PUBLICATION_ERROR) THEN
    IF (p_models_not_exported.COUNT > 0) THEN
      -- loop through all model that are not exported during this publishing session
      FOR I IN p_models_not_exported.FIRST..p_models_not_exported.LAST
      LOOP
        v_ui_defs_tbl.DELETE;
        v_devl_project_id := p_models_not_exported(i);
        get_remote_model_id(p_server_id,v_devl_project_id,x_status,v_remote_devl_project_id);

        -- For each of these source models, get all the UIs
       IF (cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id=0) THEN
         SELECT ui_def_id BULK COLLECT INTO v_ui_defs_tbl
         FROM cz_ui_defs
         WHERE deleted_flag='0' AND devl_project_id=v_devl_project_id AND ui_style=g_ui_style_jrad;
       ELSE
        BEGIN
          SELECT ui_def_id
          BULK
          COLLECT
          INTO   v_ui_defs_tbl
          FROM   cz_ui_defs
          WHERE  cz_ui_defs.devl_project_id = v_devl_project_id
          AND    cz_ui_defs.deleted_flag = RECORD_NOT_DELETED
          AND    cz_ui_defs.ui_style <> '-1';

        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          cz_pb_mgr.v_err_message := 'No ui_def_ids found for : '||to_char(v_devl_project_id);
          cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_pb_mgr.GETUISOFMDLSNOTEXPORTED', SQLCODE);
        WHEN OTHERS THEN
          RAISE;
        END;
       END IF;

        IF (v_ui_defs_tbl.COUNT > 0) THEN
          -- For each source UI, find the corresponding remote UI. We find the corresponding remote
          -- UI using the remote devl_project_id and name of the UI
          FOR K IN v_ui_defs_tbl.FIRST..v_ui_defs_tbl.LAST
          LOOP
            BEGIN
              SELECT name into v_name
              from cz_ui_defs
              where ui_def_Id = v_ui_defs_tbl(k)
              AND deleted_flag = RECORD_NOT_DELETED;

              v_remote_ui_def_id := NULL;
              OPEN ui_ref_id_cv FOR 'SELECT ui_def_id FROM cz_ui_defs'||CZ_PB_MGR.v_db_link ||
                                    ' WHERE name = :1 AND devl_project_id = :2' ||
                                    ' AND deleted_flag = :3'
                   USING v_name, v_remote_devl_project_id, RECORD_NOT_DELETED;
              LOOP
                -- There is one problem here. If there is an extra UI on the source model
                -- then we wont find it on the remote model. This issue needs to be addressed.
                -- For now we just raise a CANNOT_FIND_REMOTE_UI exception in such a case
                FETCH  ui_ref_id_cv INTO v_remote_ui_def_id;
                EXIT WHEN ui_ref_id_cv%NOTFOUND;
              END LOOP;

              IF ( v_remote_ui_def_id IS NULL ) THEN
                cz_pb_mgr.v_err_message := 'Cannot find UI ' || v_name || ' for remote model ' || to_char(v_devl_project_id);
                log_pb_errors(cz_pb_mgr.v_err_message,0,'cz_pb_mgr.GETUISOFMDLSNOTEXPORTED',SQLCODE);
                RAISE CANNOT_FIND_REMOTE_UI;
              END IF;

              CLOSE  ui_ref_id_cv;

              x_cz_ui_defs_idx_ref(v_ui_defs_tbl(k)) := v_remote_ui_def_id;

            EXCEPTION
              WHEN OTHERS THEN
                CLOSE  ui_ref_id_cv;
                RAISE;
            END;
          END LOOP;
        END IF;
      END LOOP; /* end loop of p_models_not_exported */
    END IF; /* end if of p_models_not_exported */
  END IF;
END get_uis_of_mdls_not_exported;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------Procedure to resolve remote ui nodes of cz_ui_nodes
-- Note for model conversion, v_cz_ui_nodes_new_ref should be empty, otherwise there would be a problem here
   PROCEDURE resolve_remote_ui_nodes(
      p_master_keys_array IN OUT NOCOPY cz_pb_mgr.t_ref    -- v_cz_ui_nodes_new_ref
     ,p_models_not_exported IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_resolved_array IN OUT NOCOPY cz_pb_mgr.t_ref       -- v_cz_ui_nodes_ui_ref_id_ref
     ,p_server_id IN OUT NOCOPY cz_servers.server_local_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      v_remote_ui_defs_ref cz_pb_mgr.t_ref;
      v_remote_ui_defs_tbl cz_pb_mgr.t_ref;
      v_remote_ui_nodes_ref cz_pb_mgr.t_ref;
      v_remote_ui_nod_ui_def_ref cz_pb_mgr.t_ref;
      v_remote_ui_nodes_tbl cz_pb_mgr.t_ref;
      v_remote_ui_nod_ui_def_tbl cz_pb_mgr.t_ref;
      v_remote_pers_ui_node_tbl cz_pb_mgr.t_ref;
      v_remote_pers_ui_node_ref cz_pb_mgr.t_ref;
      ui_def_ref_id_cv ref_cursor;
      v_node_ref_proj_id cz_devl_projects.devl_project_id%TYPE;
      v_node_ref_export_id cz_pb_model_exports.export_id%TYPE;
      v_node_ref_remote_model cz_pb_model_exports.remote_model_id%TYPE;
      rec_count NUMBER;

      CURSOR l_ui_def_cur (p_ui_def_id NUMBER) IS SELECT name FROM  cz_ui_defs b WHERE  b.ui_def_id = p_ui_def_id;
      l_ui_def_name cz_ui_defs.name%TYPE;

   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (p_master_keys_array.COUNT > 0)
         THEN
            -- same thing already done in get_uis_of_mdls_not_exported!
            IF (p_models_not_exported.COUNT > 0)
            THEN
               v_remote_ui_defs_ref.DELETE;

               FOR i IN p_models_not_exported.FIRST .. p_models_not_exported.LAST
               LOOP
                  v_remote_ui_defs_tbl.DELETE;

                  BEGIN
                     SELECT ui_def_id
                     BULK COLLECT INTO v_remote_ui_defs_tbl
                       FROM cz_ui_defs
                      WHERE cz_ui_defs.devl_project_id = p_models_not_exported(i) AND cz_ui_defs.deleted_flag = record_not_deleted
                      AND ui_style IN (g_ui_style_dhtml,g_ui_style_applet);
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        cz_pb_mgr.v_err_message := 'No ui_def_ref_ids found for : ' || TO_CHAR(cz_pb_mgr.v_models_not_to_be_exported(i));
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEREMOTEUINODES', SQLCODE);
                     WHEN OTHERS
                     THEN
                        RAISE;
                  END;

                  rec_count := v_remote_ui_defs_ref.COUNT;

                  IF (v_remote_ui_defs_tbl.COUNT > 0)
                  THEN
                     FOR k IN v_remote_ui_defs_tbl.FIRST .. v_remote_ui_defs_tbl.LAST
                     LOOP
                        rec_count := rec_count + 1;
                        v_remote_ui_defs_ref(rec_count) := v_remote_ui_defs_tbl(k);
                     END LOOP;
                  END IF;
               END LOOP;                                                                       /* end loop of cz_pb_mgr.v_models_not_to_be_exported */
            END IF;                                                                                              /* end if of p_models_not_exported */

            IF (v_remote_ui_defs_ref.COUNT > 0)
            THEN
               v_remote_ui_defs_tbl.DELETE;
               v_remote_ui_nodes_ref.DELETE;
               v_remote_ui_nod_ui_def_ref.DELETE;

               FOR i IN v_remote_ui_defs_ref.FIRST .. v_remote_ui_defs_ref.LAST
               LOOP
                  v_remote_ui_nodes_tbl.DELETE;
                  v_remote_ui_nod_ui_def_tbl.DELETE;

                  BEGIN
                     SELECT   ui_node_id, ui_def_id, persistent_ui_node_id
                     BULK COLLECT INTO v_remote_ui_nodes_tbl, v_remote_ui_nod_ui_def_tbl, v_remote_pers_ui_node_tbl
                         FROM cz_ui_nodes
                        WHERE cz_ui_nodes.ui_def_id = v_remote_ui_defs_ref(i) AND cz_ui_nodes.deleted_flag = '0'
                     ORDER BY cz_ui_nodes.ui_node_id;
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        cz_pb_mgr.v_err_message := 'No ui_node_ids found ';
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UINODREF', SQLCODE);
                     WHEN OTHERS
                     THEN
                        cz_pb_mgr.v_err_message := 'Error in retrieving ui_node_ids for remote ui_node_refs ';
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UINODREF', SQLCODE);
                        cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  END;

                  IF (v_remote_ui_nodes_tbl.COUNT > 0)
                  THEN
                     FOR j IN v_remote_ui_nodes_tbl.FIRST .. v_remote_ui_nodes_tbl.LAST
                     LOOP
                        rec_count := v_remote_ui_nodes_ref.COUNT + 1;
                        v_remote_ui_nodes_ref(rec_count) := v_remote_ui_nodes_tbl(j);
                        v_remote_ui_nod_ui_def_ref(rec_count) := v_remote_ui_nod_ui_def_tbl(j);
                        v_remote_pers_ui_node_ref(rec_count) := v_remote_pers_ui_node_tbl(j);
                     END LOOP;
                  END IF;                                                                                        /* end if of v_remote_ui_nodes_tbl */
               END LOOP;                                                                                        /* end loop of v_remote_ui_defs_ref */
            END IF;                                                                                               /* end if of v_remote_ui_defs_ref */

            IF (v_remote_ui_nodes_ref.COUNT > 0)
            THEN
	       IF (p_master_keys_array.COUNT > 0) THEN
               FOR j IN p_master_keys_array.FIRST .. p_master_keys_array.LAST
               LOOP
                  IF (p_resolved_array(j) IS NOT NULL)
                  THEN
                     FOR i IN v_remote_ui_nodes_ref.FIRST .. v_remote_ui_nodes_ref.LAST
                     LOOP
                        IF (p_resolved_array(j) = v_remote_ui_nodes_ref(i))
                        THEN
                           ---------get devl_project_id
                           SELECT devl_project_id
                             INTO v_node_ref_proj_id
                             FROM cz_ui_defs
                            WHERE ui_def_id = v_remote_ui_nod_ui_def_ref(i) AND cz_ui_defs.deleted_flag = '0';

                           get_remote_model_id(p_server_id,v_node_ref_proj_id,x_status,v_node_ref_remote_model);

                           OPEN l_ui_def_cur(v_remote_ui_nod_ui_def_ref(i));
                           FETCH l_ui_def_cur INTO l_ui_def_name;
                           CLOSE l_ui_def_cur;

                           OPEN ui_def_ref_id_cv FOR    'SELECT ui_node_id'
                                                     || ' '
                                                     || 'FROM	 cz_ui_nodes'
                                                     || cz_pb_mgr.v_db_link
                                                     || '  t'
                                                     || ' '
                                                     || 'WHERE  t.persistent_ui_node_id = :pers_ui_node_id'
                                                     || ' '
                                                     || 'AND    t.ui_def_id  = (SELECT ui_def_id'
                                                     || ' '
                                                     || 'FROM   cz_ui_defs'
                                                     || cz_pb_mgr.v_db_link
                                                     || ' a'
                                                     || ' '
                                                     || 'WHERE  a.name = :ui_def_name'
                                                     || ' '
                                                     || 'AND   a.devl_project_id = :devl_project_id)'
                                                     || ' '
                                                     || 'AND 	t.deleted_flag = ''0'''
                                                     || ' '
                                                     || 'AND  	ROWNUM < 2 '
                                                     USING v_remote_pers_ui_node_ref(i), l_ui_def_name, v_node_ref_remote_model;
                           LOOP
                              FETCH ui_def_ref_id_cv
                               INTO p_resolved_array(j);

                              EXIT WHEN ui_def_ref_id_cv%NOTFOUND;
                           END LOOP;

                           CLOSE ui_def_ref_id_cv;
                        END IF;                                                         /* end if of p_resolved_array(j) = v_remote_ui_nodes_ref(i) */
                     END LOOP;                                                                       /* end loop of FOR  I IN v_remote_ui_nodes_ref */
                  END IF;                                                                              /* end if of p_resolved_array(j) IS NOT NULL */
               END LOOP;                                                                                /* end loop of FOR J IN p_master_keys_array */
	       END IF;
            END IF;                                                                                    /* end if of v_remote_ui_nodes_ref.COUNT > 0 */
         END IF;                                                                                       /* end if of (p_master_keys_array.COUNT > 0) */
      END IF;                                                                                            /* end if of x_status <> PUBLICATION_ERROR */
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cz_pb_mgr.v_err_message := 'No ui_node_ref_ids found ';
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UINODREF', SQLCODE);

         CLOSE ui_def_ref_id_cv;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving ui_nod_ref_ids ';
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UINODREF', SQLCODE);

         CLOSE ui_def_ref_id_cv;

         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END resolve_remote_ui_nodes;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------------populate ps nodes pl/sql table with ps node ids from remote server
--------------@p_model_not_exported_array: source models not exported
--------------@p_ps_nodes_single_array   : ps nodes single index array
--------------@x_status            : publication status parameter
   PROCEDURE get_rem_nodes_of_models(
      p_model_not_exported_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_ps_nodes_single_array IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      remote_ps_count NUMBER;
      v_remote_models_tbl cz_pb_mgr.t_ref;
      v_rem_ps_nodes_ref cz_pb_mgr.t_ref;
      v_rem_pers_nodes_ref cz_pb_mgr.t_ref;
      v_src_ps_nodes_ref cz_pb_mgr.t_ref;
      remote_node_cv ref_cursor;
      v_remote_ps_node_id cz_ps_nodes.ps_node_id%TYPE;
      v_remote_pers_node_id cz_ps_nodes.persistent_node_id%TYPE;
      l_remote_model_id  NUMBER;
   BEGIN
      IF (x_status <> PUBLICATION_ERROR) THEN
         IF (p_model_not_exported_array.COUNT > 0) THEN
            FOR k IN p_model_not_exported_array.FIRST .. p_model_not_exported_array.LAST
            LOOP
               BEGIN
                 get_remote_model_id(cz_pb_mgr.v_server_id,p_model_not_exported_array(k),x_status,l_remote_model_id);
                 v_remote_models_tbl(k):=l_remote_model_id;
               EXCEPTION
                  WHEN OTHERS THEN
                     cz_pb_mgr.v_err_message :=
                                     'No remote model found for source model: ' || p_model_not_exported_array(k)
                                     || ' on the remote server';
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REMOTENODES', SQLCODE);
                     x_status := PUBLICATION_ERROR;
                     RAISE;
               END;

               IF (v_remote_models_tbl(k) > 0) THEN
                  OPEN remote_node_cv FOR 'SELECT ps_node_id,persistent_node_id'
                                          || ' '
                                          || 'FROM  cz_ps_nodes'
                                          || cz_pb_mgr.v_db_link
                                          || '  t'
                                          || ' '
                                          || 'WHERE t.devl_project_id = '
                                          || v_remote_models_tbl(k)
                                          || ' '
                                          || 'AND t.deleted_flag = ''0'' ';

                  LOOP
                     FETCH remote_node_cv
                      INTO v_remote_ps_node_id, v_remote_pers_node_id;

                     EXIT WHEN remote_node_cv%NOTFOUND;
                     remote_ps_count := v_rem_ps_nodes_ref.COUNT + 1;
                     v_rem_ps_nodes_ref(remote_ps_count) := v_remote_ps_node_id;
                     v_rem_pers_nodes_ref(remote_ps_count) := v_remote_pers_node_id;

                     SELECT ps_node_id
                       INTO v_src_ps_nodes_ref(remote_ps_count)
                       FROM cz_ps_nodes
                      WHERE cz_ps_nodes.devl_project_id = p_model_not_exported_array(k)
                        AND cz_ps_nodes.persistent_node_id = v_remote_pers_node_id
                        AND cz_ps_nodes.deleted_flag = record_not_deleted;
                  END LOOP;

                  CLOSE remote_node_cv;
               END IF;                               /* end if of (v_remote_models_tbl(k) > 0) */
            END LOOP;                                /* end loop of FOR k IN p_model_not_exported_array */

            IF (v_rem_ps_nodes_ref.COUNT > 0)
            THEN
               FOR m IN v_rem_ps_nodes_ref.FIRST .. v_rem_ps_nodes_ref.LAST
               LOOP
                  cz_pb_mgr.v_cz_ps_nodes_idx_tbl(v_src_ps_nodes_ref(m)):=v_rem_ps_nodes_ref(m);
               END LOOP;
            END IF;                                                                                     /* end if of (v_rem_ps_nodes_ref.COUNT > 0) */
         END IF;                                                                                /* end if of (p_model_not_exported_array.COUNT > 0) */
      END IF;                                                                                            /* end if of x_status <> PUBLICATION_ERROR */
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving remote ps node ids for source models not exported: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETREMNODES', SQLCODE);

         CLOSE remote_node_cv;

         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END get_rem_nodes_of_models;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure inserts data into cz_ps_prop_vals for non-migration session
-----@p_prop_vals_array: table of ps nodes
-----@p_property_array  : table of property ids
-----@p_data_val_array  : table of data values
-----@x_status : publication status parameter
   PROCEDURE insert_into_ps_prop_vals
   AS
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(cz_pb_mgr.v_prop_vals_node_ref.COUNT > 0))
      THEN
         EXECUTE IMMEDIATE    'BEGIN'
                           || ' '
                           || 'cz_pb_mgr.v_expr_count := 0;'
                           || ' '
                           || 'FOR I IN cz_pb_mgr.v_prop_vals_node_ref.FIRST..cz_pb_mgr.v_prop_vals_node_ref.LAST'
                           || ' '
                           || 'LOOP'
                           || ' '
                           || 'cz_pb_mgr.v_propval_node_id    := cz_pb_mgr.v_prop_vals_node_ref(i);'
                           || ' '
                           || 'cz_pb_mgr.v_propval_prop_id    := cz_pb_mgr.v_prop_vals_prop_ref(i);'
                           || ' '
                           || 'cz_pb_mgr.v_propval_data_value := cz_pb_mgr.v_prop_vals_data_ref(i);'
                           || ' '
                           || 'cz_pb_mgr.v_propval_data_num_value := cz_pb_mgr.v_prop_vals_data_num_ref(i);'
                           || ' '
                           || 'INSERT INTO cz_ps_prop_vals'
                           || cz_pb_mgr.v_db_link
                           || '('
                           || ' '
                           || 'ps_node_id,PROPERTY_ID,DATA_VALUE,DELETED_FLAG,data_num_value)'
                           || ' '
                           || 'VALUES (cz_pb_mgr.v_propval_node_id,cz_pb_mgr.v_propval_prop_id,cz_pb_mgr.v_propval_data_value,'
                           || ' '
                           || '''0'',cz_pb_mgr.v_propval_data_num_value);'
                           || ' '
                           || 'IF ( cz_pb_mgr.v_expr_count > cz_pb_mgr.RECORD_COMMIT_SIZE) THEN'
                           || ' '
                           || 'COMMIT; cz_pb_mgr.v_expr_count := 0;'
                           || ' '
                           || 'END IF;'
                           || ' '
                           || 'cz_pb_mgr.v_expr_count := cz_pb_mgr.v_expr_count + 1;'
                           || ' '
                           || 'END LOOP;'
                           || ' '
                           || 'END;';
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_TABLE_POPULATION_ERR', 'TABLENAME', 'cz_ps_prop_vals', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:cz_ps_prop_vals', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END insert_into_ps_prop_vals;

--------------------------------------------------------------------------------
  -- used for model conversion
  -- ps node ids in v_prop_vals_node_ref and translatable text ids in v_prop_vals_data_num_ref
  -- are already resolved in upload_item_schema
  PROCEDURE mc_insert_pspropvals IS
  BEGIN
    IF cz_pb_mgr.v_prop_vals_node_ref.COUNT=0 THEN RETURN; END IF;

    FOR i IN cz_pb_mgr.v_prop_vals_node_ref.FIRST .. cz_pb_mgr.v_prop_vals_node_ref.LAST LOOP
      IF cz_pb_mgr.v_prop_vals_valuesource_ref(i) = 'PsValue' OR cz_pb_mgr.v_prop_vals_valuesource_ref(i) = 'PsDflt' THEN
        INSERT INTO cz_ps_prop_vals(ps_node_id, property_id, data_value, data_num_value, deleted_flag)
        VALUES(cz_pb_mgr.v_prop_vals_node_ref(i), cz_pb_mgr.v_prop_vals_prop_ref(i),
               cz_pb_mgr.v_prop_vals_data_ref(i), cz_pb_mgr.v_prop_vals_data_num_ref(i), '0');
      END IF;
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_TABLE_POPULATION_ERR', 'TABLENAME', 'cz_ps_prop_vals', 'SQLERRM', SQLERRM);
      cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:cz_ps_prop_vals', SQLCODE);
      cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
      cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
      RAISE;
  END mc_insert_pspropvals;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_des_chart_features(x_status IN OUT NOCOPY VARCHAR2)
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (cz_pb_mgr.v_cz_des_feature_id_old_ref.COUNT > 0)
         THEN
            cz_pb_mgr.v_expr_count := 0;

            EXECUTE IMMEDIATE    'BEGIN'
                              || ' '
                              || 'FOR I IN cz_pb_mgr.v_cz_des_feature_id_old_ref.FIRST..cz_pb_mgr.v_cz_des_feature_id_old_ref.LAST'
                              || ' '
                              || 'LOOP'
                              || ' '
                              || 'INSERT INTO cz_des_chart_features'
                              || cz_pb_mgr.v_db_link
                              || '('
                              || ' '
                              || 'RULE_ID'
                              || ' '
                              || ',FEATURE_ID'
                              || ' '
                              || ',FEATURE_TYPE'
                              || ' '
                              || ',DELETED_FLAG'
                              || ' '
                              || ',MODEL_REF_EXPL_ID)'
                              || ' '
                              || 'VALUES (cz_pb_mgr.v_cz_des_feature_rid_new_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_cz_des_feature_id_old_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_cz_des_feature_ft_typ_ref(i)'
                              || ' '
                              || ',''0'''
                              || ' '
                              || ',cz_pb_mgr.v_cz_des_feature_mrefl_id_ref(i)'
                              || ' '
                              || ');'
                              || ' '
                              || 'IF ( cz_pb_mgr.v_expr_count > cz_pb_mgr.RECORD_COMMIT_SIZE) THEN'
                              || ' '
                              || 'COMMIT;'
                              || ' '
                              || 'cz_pb_mgr.v_expr_count := 0;'
                              || ' '
                              || 'END IF;'
                              || ' '
                              || 'cz_pb_mgr.v_expr_count := cz_pb_mgr.v_expr_count + 1;'
                              || ' '
                              || 'END LOOP;'
                              || ' '
                              || 'END;';
         END IF;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_TABLE_POPULATION_ERR', 'TABLENAME', 'cz_des_chart_features', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:CZ_DES_CHART_FEATURES', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------the new ids from v_cz_des_cells_rule_id_new_ref
   PROCEDURE insert_des_chart_cells(x_status IN OUT NOCOPY VARCHAR2)
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (cz_pb_mgr.v_cz_des_cells_rule_id_old_ref.COUNT > 0)
         THEN
            cz_pb_mgr.v_expr_count := 0;

            EXECUTE IMMEDIATE    'BEGIN'
                              || ' '
                              || 'FOR I IN cz_pb_mgr.v_cz_des_cells_rule_id_old_ref.FIRST..cz_pb_mgr.v_cz_des_cells_rule_id_old_ref.LAST'
                              || ' '
                              || 'LOOP'
                              || ' '
                              || 'INSERT INTO cz_des_chart_cells'
                              || cz_pb_mgr.v_db_link
                              || '('
                              || ' '
                              || 'RULE_ID'
                              || ' '
                              || ',PRIMARY_OPT_ID'
                              || ' '
                              || ',SECONDARY_OPT_ID'
                              || ' '
                              || ',MARK_CHAR'
                              || ' '
                              || ',DELETED_FLAG'
                              || ' '
                              || ',SECONDARY_FEAT_EXPL_ID'
                              || ' '
                              || ',SECONDARY_FEATURE_ID'
                              || ' '
                              || ')'
                              || ' '
                              || 'values   (	cz_pb_mgr.v_cz_des_cells_rule_id_new_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_cz_des_cells_popt_id_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_cz_des_cells_sopt_id_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_cz_des_cells_mark_char_ref(i)'
                              || ' '
                              || ',''0'''
                              || ' '
                              || ',cz_pb_mgr.v_cz_des_cells_sexpl_id_ref(i)'
                              || ' '
                              || ',cz_pb_mgr.v_cz_des_cells_sf_id_ref(i)'
                              || ' '
                              || ');'
                              || ' '
                              || 'IF ( cz_pb_mgr.v_expr_count > cz_pb_mgr.RECORD_COMMIT_SIZE) THEN'
                              || ' '
                              || 'COMMIT;'
                              || ' '
                              || 'cz_pb_mgr.v_expr_count := 0;'
                              || ' '
                              || 'END IF;'
                              || ' '
                              || 'cz_pb_mgr.v_expr_count := cz_pb_mgr.v_expr_count + 1;'
                              || ' '
                              || 'END LOOP;'
                              || ' '
                              || 'END;';
         END IF;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_TABLE_POPULATION_ERR', 'TABLENAME', 'cz_des_chart_cells', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:CZ_DES_CHART_CELLS', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE collect_func_comp_specs
   IS
      v_cz_func_devl_old_tbl cz_pb_mgr.t_ref;
      v_cz_func_cid_old_tbl cz_pb_mgr.t_ref;
      v_cz_func_expl_old_tbl cz_pb_mgr.t_ref;
      v_cz_func_fld_old_tbl cz_pb_mgr.t_ref;
      v_object_type_tbl cz_pb_mgr.objtype;
      rec_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start bulk collect of func comp specs');
      END IF;

      clear_tables('cz_func_comp_specs', 'ref', cz_pb_mgr.v_status_code);

      IF (cz_pb_mgr.v_cz_model_ref_expls_old_ref.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.v_cz_model_ref_expls_old_ref.FIRST .. cz_pb_mgr.v_cz_model_ref_expls_old_ref.LAST
         LOOP
            clear_tables('cz_func_comp_specs', 'tbl', cz_pb_mgr.v_status_code);
            v_cz_func_devl_old_tbl.DELETE;
            v_cz_func_cid_old_tbl.DELETE;
            v_cz_func_expl_old_tbl.DELETE;
            v_cz_func_fld_old_tbl.DELETE;
            v_object_type_tbl.DELETE;

            BEGIN
               SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_func_comp_specs_seq
                                                 , 'cz_func_comp_specs_s.nextval' || cz_pb_mgr.v_db_link
                                                 ,cz_pb_mgr.v_oraclesequenceincr
                                                 )
                     ,func_comp_id, devl_project_id, component_id, model_ref_expl_id
                     ,rule_folder_id, 'FNC'
               BULK COLLECT INTO cz_pb_mgr.v_cz_func_comp_new_tbl
                     ,cz_pb_mgr.v_cz_func_comp_old_tbl, v_cz_func_devl_old_tbl, v_cz_func_cid_old_tbl, v_cz_func_expl_old_tbl
                     ,v_cz_func_fld_old_tbl, v_object_type_tbl
                 FROM cz_func_comp_specs t
                WHERE t.model_ref_expl_id = cz_pb_mgr.v_cz_model_ref_expls_old_ref(i) AND t.deleted_flag = '0';
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  cz_pb_mgr.v_err_message := SUBSTR(SQLERRM, 1, 2000);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.FUNCCOMP', SQLCODE);
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_func_comp_specs', 'SQLERRM', SQLERRM);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  RAISE;
            END;

            rec_count := cz_pb_mgr.v_cz_func_comp_new_ref.COUNT;

            IF (cz_pb_mgr.v_cz_func_comp_new_tbl.COUNT > 0)
            THEN
               FOR k IN cz_pb_mgr.v_cz_func_comp_new_tbl.FIRST .. cz_pb_mgr.v_cz_func_comp_new_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.v_cz_func_comp_new_ref(rec_count) := cz_pb_mgr.v_cz_func_comp_new_tbl(k);
                  cz_pb_mgr.v_cz_func_comp_old_ref(rec_count) := cz_pb_mgr.v_cz_func_comp_old_tbl(k);
                  cz_pb_mgr.v_cz_func_comp_idx_ref(cz_pb_mgr.v_cz_func_comp_old_tbl(k)):=cz_pb_mgr.v_cz_func_comp_new_tbl(k);
                  cz_pb_mgr.v_cz_func_devl_old_ref(rec_count) := v_cz_func_devl_old_tbl(k);
                  cz_pb_mgr.v_cz_func_cid_old_ref(rec_count) := v_cz_func_cid_old_tbl(k);
                  cz_pb_mgr.v_cz_func_expl_old_ref(rec_count) := v_cz_func_expl_old_tbl(k);
                  cz_pb_mgr.v_cz_func_fld_old_ref(rec_count) := v_cz_func_fld_old_tbl(k);
                  cz_pb_mgr.v_cz_func_obj_ref(rec_count) := v_object_type_tbl(k);
               END LOOP;
            END IF;
         END LOOP;  /* end loop of FOR  I IN cz_pb_mgr.v_cz_model_ref_expls_old_ref */
      END IF;       /* end if of cz_pb_mgr.v_cz_model_ref_expls_old_ref.COUNT > 0 */

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end bulk collect of func comp specs');
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END collect_func_comp_specs;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that bulk collects rules of projects
----@p_rules_flag : indicates if rules have to be copied while publishing
----@p_model_array : models to be copied
----@p_rules_old_array : tbl containing old rule ids
----@p_rules_new_array : tbl for new rules
----@p_rules_sng_array : table for single index implementation
----@x_status : publication status parameter
PROCEDURE bulk_collect_rules(
      p_rules_flag IN VARCHAR2
     ,p_model_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_rules_old_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_rules_new_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_rules_sng_array IN OUT NOCOPY cz_pb_mgr.t_ref_idx_vc2
     ,x_status IN OUT NOCOPY VARCHAR2
   )
AS
  l_cz_rules_new_id_tbl   cz_pb_mgr.t_ref;
  l_cz_rules_old_id_tbl   cz_pb_mgr.t_ref;
  l_cz_rules_rf_id_tbl    cz_pb_mgr.t_ref;
  l_cz_rules_proj_id_tbl  cz_pb_mgr.t_ref;
  l_cz_rules_comp_id_tbl  cz_pb_mgr.t_ref;
  l_cz_rules_rea_id_tbl   cz_pb_mgr.t_ref;
  l_cz_rules_eff_id_tbl   cz_pb_mgr.t_ref;
  l_cz_rules_unmsg_id_tbl cz_pb_mgr.t_ref;
  l_cz_rules_expl_id_tbl  cz_pb_mgr.t_ref;
  l_cz_rules_sig_tbl      cz_pb_mgr.t_ref;
  l_cz_rules_ui_tbl       cz_pb_mgr.t_ref;
  l_cz_rules_perst_id_tbl cz_pb_mgr.t_ref;
  l_eff_usg_mask_tbl      cz_pb_mgr.t_eff_usage_mask;
  l_object_type           cz_rule_folders.object_type%TYPE;
  l_rule_type_tbl         cz_pb_mgr.t_ref;

  rec_count PLS_INTEGER;

BEGIN
  IF (x_status = PUBLICATION_ERROR OR p_model_array.COUNT = 0) THEN
    RETURN;
  END IF;
  rec_count := cz_pb_mgr.v_cz_rules_rule_id_new_ref.COUNT; -- ? 0

  FOR i IN p_model_array.FIRST .. p_model_array.LAST
  LOOP
    l_cz_rules_new_id_tbl.DELETE;
    l_cz_rules_old_id_tbl.DELETE;
    l_cz_rules_rf_id_tbl.DELETE;
    l_cz_rules_proj_id_tbl.DELETE;
    l_cz_rules_comp_id_tbl.DELETE;
    l_cz_rules_rea_id_tbl.DELETE;
    l_cz_rules_eff_id_tbl.DELETE;
    l_cz_rules_unmsg_id_tbl.DELETE;
    l_cz_rules_expl_id_tbl.DELETE;
    l_cz_rules_sig_tbl.DELETE;
    l_cz_rules_ui_tbl.DELETE;
    l_eff_usg_mask_tbl.DELETE;
    l_cz_rules_perst_id_tbl.DELETE;
    l_rule_type_tbl.DELETE;

    BEGIN
      IF (cz_pb_mgr.v_session_parameter = MODEL_COPY) THEN
        IF (COPY_RULES = 'YES') THEN
          SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_rules_seq
                   ,'cz_rules_s.nextval' || cz_pb_mgr.v_db_link, cz_pb_mgr.v_oraclesequenceincr)
             ,rule_id, rule_folder_id, devl_project_id, component_id
             ,reason_id, unsatisfied_msg_id, effectivity_set_id
             ,model_ref_expl_id, signature_id, ui_def_id, effective_usage_mask
             ,persistent_rule_id, rule_type
          BULK COLLECT INTO l_cz_rules_new_id_tbl, l_cz_rules_old_id_tbl
             ,l_cz_rules_rf_id_tbl, l_cz_rules_proj_id_tbl, l_cz_rules_comp_id_tbl
             ,l_cz_rules_rea_id_tbl, l_cz_rules_unmsg_id_tbl, l_cz_rules_eff_id_tbl
             ,l_cz_rules_expl_id_tbl, l_cz_rules_sig_tbl, l_cz_rules_ui_tbl, l_eff_usg_mask_tbl
             ,l_cz_rules_perst_id_tbl, l_rule_type_tbl
          FROM cz_rules t
          WHERE t.devl_project_id = p_model_array(i) AND t.deleted_flag = '0'
               AND t.seeded_flag <> SEED_DATA
		AND ((CZ_PB_MGR.COPY_UIS='YES')
		       OR
		    (rule_type NOT IN (RULE_TYPE_DISPLAY_CONDITION, RULE_TYPE_ENABLED_CONDITION, RULE_TYPE_CAPTION))
		    )
               AND (
                     (t.ui_def_id IS NULL OR t.ui_def_id IN(0,1)) OR
                     (t.ui_def_id>1 AND
                       EXISTS(SELECT NULL FROM CZ_UI_DEFS u
                               WHERE u.ui_def_id=t.ui_def_id AND u.deleted_flag='0') AND
                       EXISTS(SELECT NULL FROM CZ_UI_PAGES p
                               WHERE p.page_id=t.ui_page_id AND
                                     p.ui_def_id=t.ui_def_id AND p.deleted_flag='0'))
                   );

        END IF;
      ELSE
        IF (p_rules_flag = 'YES') THEN
          SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_rules_seq
                   ,'cz_rules_s.nextval' || cz_pb_mgr.v_db_link, cz_pb_mgr.v_oraclesequenceincr)
             ,rule_id, rule_folder_id, devl_project_id, component_id
             ,reason_id, unsatisfied_msg_id, effectivity_set_id
             ,model_ref_expl_id, signature_id, ui_def_id, effective_usage_mask
             ,persistent_rule_id, rule_type
          BULK COLLECT INTO l_cz_rules_new_id_tbl, l_cz_rules_old_id_tbl
             ,l_cz_rules_rf_id_tbl, l_cz_rules_proj_id_tbl, l_cz_rules_comp_id_tbl
             ,l_cz_rules_rea_id_tbl, l_cz_rules_unmsg_id_tbl, l_cz_rules_eff_id_tbl
             ,l_cz_rules_expl_id_tbl, l_cz_rules_sig_tbl, l_cz_rules_ui_tbl, l_eff_usg_mask_tbl
             ,l_cz_rules_perst_id_tbl, l_rule_type_tbl
          FROM cz_rules t
          WHERE t.devl_project_id = p_model_array(i) AND t.deleted_flag = '0'
                AND t.seeded_flag <> SEED_DATA
                AND (
                     (t.ui_def_id IS NULL OR t.ui_def_id IN(0,1)) OR
                     (t.ui_def_id>1 AND
                       EXISTS(SELECT NULL FROM CZ_UI_DEFS u
                               WHERE u.ui_def_id=t.ui_def_id AND u.deleted_flag='0') AND
                       EXISTS(SELECT NULL FROM CZ_UI_PAGES p
                               WHERE p.page_id=t.ui_page_id AND
                                     p.ui_def_id=t.ui_def_id AND p.deleted_flag='0'))
                    );

        ELSE
          SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_rules_seq
                   ,'cz_rules_s.nextval' || cz_pb_mgr.v_db_link, cz_pb_mgr.v_oraclesequenceincr)
             ,rule_id, rule_folder_id, devl_project_id, component_id
             ,reason_id, unsatisfied_msg_id, effectivity_set_id
             ,model_ref_expl_id, signature_id, ui_def_id, effective_usage_mask
             ,persistent_rule_id, rule_type
          BULK COLLECT INTO l_cz_rules_new_id_tbl, l_cz_rules_old_id_tbl
             ,l_cz_rules_rf_id_tbl, l_cz_rules_proj_id_tbl, l_cz_rules_comp_id_tbl
             ,l_cz_rules_rea_id_tbl, l_cz_rules_unmsg_id_tbl, l_cz_rules_eff_id_tbl
             ,l_cz_rules_expl_id_tbl, l_cz_rules_sig_tbl, l_cz_rules_ui_tbl, l_eff_usg_mask_tbl
             ,l_cz_rules_perst_id_tbl, l_rule_type_tbl
          FROM cz_rules t
          WHERE t.devl_project_id = p_model_array(i)
           AND  t.rule_type IN (RULE_TYPE_CONFIG_EXTENSION, RULE_TYPE_DISPLAY_CONDITION,
                                RULE_TYPE_ENABLED_CONDITION, RULE_TYPE_CAPTION)
           AND  t.deleted_flag = '0'  AND t.seeded_flag <> SEED_DATA
           AND (
                     (t.ui_def_id IS NULL OR t.ui_def_id IN(0,1)) OR
                     (t.ui_def_id>1 AND
                       EXISTS(SELECT NULL FROM CZ_UI_DEFS u
                               WHERE u.ui_def_id=t.ui_def_id AND u.deleted_flag='0') AND
                       EXISTS(SELECT NULL FROM CZ_UI_PAGES p
                               WHERE p.page_id=t.ui_page_id AND
                                     p.ui_def_id=t.ui_def_id AND p.deleted_flag='0'))
                   );

        END IF;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        cz_pb_mgr.v_err_message := 'No rules found for model: ' || p_model_array(i);
        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RULES', SQLCODE);
      WHEN OTHERS THEN
        RAISE;
    END;

    IF l_cz_rules_new_id_tbl.COUNT > 0 THEN
      FOR k IN l_cz_rules_new_id_tbl.FIRST .. l_cz_rules_new_id_tbl.LAST
      LOOP
        rec_count := rec_count + 1;
        cz_pb_mgr.v_cz_rules_rule_id_idx_ref(l_cz_rules_old_id_tbl(k)):=l_cz_rules_new_id_tbl(k);
        cz_pb_mgr.v_cz_rules_proj_id_ref(rec_count) := l_cz_rules_proj_id_tbl(k);
        cz_pb_mgr.v_cz_rules_comp_id_ref(rec_count) := l_cz_rules_comp_id_tbl(k);
        cz_pb_mgr.v_cz_rules_expl_ref(rec_count) := l_cz_rules_expl_id_tbl(k);
        p_rules_new_array(rec_count) := l_cz_rules_new_id_tbl(k);
        p_rules_old_array(rec_count) := l_cz_rules_old_id_tbl(k);
        cz_pb_mgr.v_cz_rules_rea_id_ref(rec_count) := l_cz_rules_rea_id_tbl(k);
        cz_pb_mgr.v_cz_rules_unmsg_id_ref(rec_count) := l_cz_rules_unmsg_id_tbl(k);
        cz_pb_mgr.v_cz_rules_eff_id_ref(rec_count) := l_cz_rules_eff_id_tbl(k);
        cz_pb_mgr.v_cz_rules_sig_ref(rec_count) := l_cz_rules_sig_tbl(k);
        cz_pb_mgr.v_cz_rules_ui_ref(rec_count) := l_cz_rules_ui_tbl(k);
        cz_pb_mgr.v_cz_rule_usage_mask_tbl(rec_count) := l_eff_usg_mask_tbl(k);
        cz_pb_mgr.v_cz_rules_obj_ref(rec_count) := 'RUL';
        cz_pb_mgr.v_cz_rules_persistent_id_ref(rec_count) := l_cz_rules_perst_id_tbl(k);

        IF l_rule_type_tbl(k) IN (RULE_TYPE_DISPLAY_CONDITION, RULE_TYPE_ENABLED_CONDITION,
                                  RULE_TYPE_CAPTION, RULE_TYPE_POPULATOR) THEN
          cz_pb_mgr.v_cz_rules_rf_id_ref(rec_count) := 0;
        ELSE
          cz_pb_mgr.v_cz_rules_rf_id_ref(rec_count) := l_cz_rules_rf_id_tbl(k);
        END IF;
      END LOOP;
    END IF;
  END LOOP;

  IF (rec_count > 0 AND (cz_pb_mgr.v_session_parameter = MODEL_COPY OR
                         cz_pb_mgr.v_session_parameter = CZ_MODEL_MIGRATION_PVT.MIGRATE_MODEL)) THEN
    FOR j IN p_rules_old_array.FIRST .. p_rules_old_array.LAST
    LOOP
      BEGIN
        SELECT object_type  INTO l_object_type
        FROM cz_rule_folders
        WHERE rule_folder_id = p_rules_old_array(j) AND object_type NOT IN ('FNC', 'RFL', 'RSQ');
        cz_pb_mgr.v_cz_rules_obj_ref(j) := l_object_type;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          NULL;
      END;
    END LOOP;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_rules', 'SQLERRM', SQLERRM);
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZ_RULES', SQLCODE);
    x_status := PUBLICATION_ERROR;
    RAISE;
END bulk_collect_rules;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----procedure that clears all global pl/sql tables
   PROCEDURE clear_all_tables(x_status IN OUT NOCOPY VARCHAR2)
   AS
   BEGIN
      clear_tables('cz_ps_nodes', 'tbl', cz_pb_mgr.v_status_code);
      clear_tables('cz_ps_nodes', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_model_ref_expls', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_model_ref_expls', 'tbl', cz_pb_mgr.v_status_code);
      clear_tables('cz_func_comp_specs', 'tbl', cz_pb_mgr.v_status_code);
      clear_tables('cz_func_comp_specs', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_ui_defs', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_ui_defs', 'tbl', cz_pb_mgr.v_status_code);
      clear_tables('cz_ui_nodes', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_ps_prop_vals', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_ps_prop_vals', 'tbl', cz_pb_mgr.v_status_code);
      clear_tables('cz_item_masters', 'tbl', cz_pb_mgr.v_status_code);
      clear_tables('cz_item_masters', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_rule_folders', 'tbl', cz_pb_mgr.v_status_code);
      clear_tables('cz_rule_folders', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_expression_nodes', 'tbl', cz_pb_mgr.v_status_code);
      clear_tables('cz_expression_nodes', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_rules', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_des_chart_features', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_des_chart_cells', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_lce_headers', 'ref', cz_pb_mgr.v_status_code);
      clear_tables('cz_lce_load_specs', 'ref', cz_pb_mgr.v_status_code);
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in clearing all tables : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CLEARALLTABLES', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END clear_all_tables;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure to get the new ui_def_id that would be in the target publication
-----@p_publication_id : source publication_id
-----@p_old_ui_array : array containing old ui_def_ids
-----@p_new_ui_array : array containing new ui_def_ids
-----@x_new_ui_def_id  : new ui_def_id
-----@x_status : publication status parameter
   PROCEDURE get_new_ui_def_id(
      p_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,p_old_ui_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_new_ui_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,x_new_ui_def_id IN OUT NOCOPY cz_model_publications.ui_def_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      v_old_ui_def_id cz_model_publications.model_id%TYPE;
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         SELECT ui_def_id
           INTO v_old_ui_def_id
           FROM cz_model_publications
          WHERE cz_model_publications.publication_id = p_publication_id AND cz_model_publications.deleted_flag = record_not_deleted;

         IF ((v_old_ui_def_id > 0) AND(p_new_ui_array.COUNT > 0))
         THEN
	  IF (p_old_ui_array.COUNT > 0) THEN
            FOR i IN p_old_ui_array.FIRST .. p_old_ui_array.LAST
            LOOP
               IF (v_old_ui_def_id = p_old_ui_array(i))
               THEN
                  x_new_ui_def_id := p_new_ui_array(i);
                  EXIT;
               END IF;
            END LOOP;
	   END IF;
         ELSE
            x_new_ui_def_id := NULL;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_DATA_FOUND', 'TABLENAME', 'cz_model_publications', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:UIDEFID', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_new_ui_def_id;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----procedure gets model id for target publication
   PROCEDURE get_new_model_id(
      p_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,p_new_model_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,x_new_model_id IN OUT NOCOPY cz_model_publications.model_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         IF (p_new_model_array.COUNT > 0)
         THEN
            SELECT remote_model_id
              INTO x_new_model_id
              FROM cz_pb_model_exports
             WHERE cz_pb_model_exports.publication_id = p_publication_id
               AND cz_pb_model_exports.model_id = cz_pb_model_exports.root_model_id
               ---AND     cz_pb_model_exports.export_reverse_seq = 0
               AND cz_pb_model_exports.superseded_flag = 'N';
         END IF;

         ---the above query has been changed to hold good for circular connectors
               ---In circular references the root may not have an export rev seq of 0
         UPDATE cz_pb_model_exports
            SET superseded_flag = 'Y'
          WHERE publication_id = p_publication_id AND superseded_flag = 'N';
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving new model id for publication id: ' || p_publication_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETNEWMODELID', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_new_model_id;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that retrieves the source publication_id, export_status, server_id, remote_publication_id
------from cz_model_publications table
------@p_publication_id : publication id whose info is required
------@p_status : publication_status
------@x_model_id : model that is to be published
------@x_ui_def_id : ui_def_id
------@x_export_status  : prev publication status
------@x_remote_publication_id : prev remote publication id
------@x_status : publication status parameter
   PROCEDURE get_source_pb_info(
      p_publication_id IN cz_model_publications.publication_id%TYPE
     ,x_model_id IN OUT NOCOPY cz_model_publications.model_id%TYPE
     ,x_ui_def_id IN OUT NOCOPY cz_model_publications.ui_def_id%TYPE
     ,x_server_id IN OUT NOCOPY cz_model_publications.server_id%TYPE
     ,x_export_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
     ,x_remote_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_object_type IN OUT NOCOPY cz_model_publications.object_type%TYPE
     ,x_pb_mode IN OUT NOCOPY cz_model_publications.publication_mode%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         SELECT object_id, ui_def_id, server_id, export_status, remote_publication_id, object_type, publication_mode, NVL(config_engine_type, 'L')
           INTO x_model_id, x_ui_def_id, x_server_id, x_export_status, x_remote_publication_id, x_object_type, x_pb_mode, g_engine_type
           FROM cz_model_publications, cz_devl_projects
          WHERE cz_model_publications.publication_id = p_publication_id
            AND cz_model_publications.deleted_flag = record_not_deleted
            AND cz_model_publications.object_id = cz_devl_projects.devl_project_id
            AND cz_devl_projects.deleted_flag = '0';
	    -- Bug 5507300; 06-Sep-2006; kdande; Removed the following condition as user should be able to Republish disabled publications.
            -- AND cz_model_publications.disabled_flag = '0';

         ----if x_ui_def_id is null
         IF (x_ui_def_id IS NULL)
         THEN
            BEGIN
               SELECT ui_def_id
                 INTO x_ui_def_id
                 FROM cz_ui_defs
                WHERE cz_ui_defs.devl_project_id = x_model_id AND cz_ui_defs.deleted_flag = '0' AND cz_ui_defs.NAME NOT LIKE 'MUID' AND ROWNUM < 2;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  x_ui_def_id := NULL;
               WHEN OTHERS
               THEN
                  x_ui_def_id := 0;
            END;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message :=
                                  'Error in retrieving source publication info for publication id : ' || TO_CHAR(p_publication_id) || ' : '
                                  || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETPUBINFO', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_source_pb_info;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that retrieves the prev publication_id, export_status, server_id, remote_publication_id
------from cz_model_publications table
------@p_publication_id : publication id whose info is required
------@p_status : publication_status
------@x_prev publication id : prev publication id
------@x_prev_export_status  : prev publication status
------@x_prev_remote_publication_id : prev remote publication id
------@x_status : publication status parameter
   PROCEDURE get_new_copy_pb_info(
      p_publication_id IN cz_model_publications.publication_id%TYPE
     ,x_prev_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_prev_export_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
     ,x_prev_remote_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (p_publication_id IS NOT NULL)
      THEN
         SELECT publication_id, export_status, remote_publication_id
           INTO x_prev_publication_id, x_prev_export_status, x_prev_remote_publication_id
           FROM cz_model_publications
          WHERE cz_model_publications.publication_id = p_publication_id AND cz_model_publications.deleted_flag = record_not_deleted;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message :=
                               'Error in retrieving publication info (newcopy) for publication id : ' || TO_CHAR(p_publication_id) || ' : '
                               || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETPUBINFO', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_new_copy_pb_info;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that retrieves the prev publication_id, export_status, server_id, remote_publication_id
------from cz_model_publications table
------@p_publication_id : publication id whose info is required
------@p_status : publication_status
------@x_prev publication id : prev publication id
------@x_prev_export_status  : prev publication status
------@x_prev_remote_publication_id : prev remote publication id
------@x_status : publication status parameter
   PROCEDURE get_republish_pb_info(
      p_publication_id IN cz_model_publications.publication_id%TYPE
     ,p_status IN cz_model_publications.export_status%TYPE
     ,x_prev_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_prev_export_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
     ,x_prev_remote_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      SELECT publication_id, export_status, remote_publication_id
        INTO x_prev_publication_id, x_prev_export_status, x_prev_remote_publication_id
        FROM cz_model_publications
       WHERE cz_model_publications.remote_publication_id = p_publication_id
         AND cz_model_publications.export_status = p_status
         AND cz_model_publications.deleted_flag = record_not_deleted;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving publication info (republish) for publication id : ' || p_publication_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETPUBINFO', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_republish_pb_info;

------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----------procedure to get the max publication id for a model
----------@p_model_id  : devl_project_id of the model
----------@p_server_id : server_id of the publication request
----------@x_publication_id : retrieved max publication id
----------@x_status: publication status parameter
   PROCEDURE get_max_pub_id(
      p_model_id IN OUT NOCOPY cz_devl_projects.devl_project_id%TYPE
     ,p_server_id IN OUT NOCOPY cz_model_publications.server_id%TYPE
     ,x_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      SELECT MAX(publication_id)
        INTO x_publication_id
        FROM cz_model_publications t
       WHERE t.model_id = p_model_id
         AND t.server_id = p_server_id
         AND t.model_last_struct_update = (SELECT last_struct_update
                                             FROM cz_devl_projects
                                            WHERE cz_devl_projects.devl_project_id = p_model_id)
         AND t.export_status IN('PUP', 'OK')
         AND t.source_target_flag = g_source_flag
         AND t.publication_id <> cz_pb_mgr.v_publication_id
         AND t.deleted_flag = record_not_deleted;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in retrieving max publication id for model id : ' || p_model_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETPUBINFO', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_max_pub_id;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that retrieves previous publication
-----if an existing publication is re-published.  This is again based on if all UIs are exported
-----or no UI is exported i.e., only a publication request is created and no data is exported
-----@p_ui_str : values are 'UI' or 'x' that indicates if UIs are exported
-----@p_session_parameter : differentiates between a publishing process and deep copy
-----@p_rem_publication_id : remote publication id of the existing publication
-----@x_prev publication id : prev publication id
-----@x_prev_export_status  : prev publication status
-----@x_prev_remote_publication_id : prev remote publication id
-----@x_status : publication status parameter
   PROCEDURE get_prev_publication(
      p_ui_str IN OUT NOCOPY VARCHAR2
     ,p_session_parameter IN OUT NOCOPY VARCHAR2
     ,p_rem_publication_id IN cz_model_publications.publication_id%TYPE
     ,x_prev_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_prev_export_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
     ,x_prev_remote_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      v_pr_pub_id cz_model_publications.publication_id%TYPE;
   BEGIN
      IF ((p_ui_str = 'UI') AND(p_session_parameter <> model_copy))
      THEN
         IF (p_rem_publication_id IS NOT NULL)
         THEN
            get_republish_pb_info(p_rem_publication_id, 'PUP', x_prev_publication_id, x_prev_export_status, x_prev_remote_publication_id, x_status);

            IF (x_prev_publication_id > 0)
            THEN
               cz_pb_mgr.v_err_message := 'Re-publish of publication: ' || TO_CHAR(x_prev_publication_id);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZMODPUB', SQLCODE);
            END IF;
         ELSE
            get_max_pub_id(cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_server_id, v_pr_pub_id, cz_pb_mgr.v_status_code);
            get_new_copy_pb_info(v_pr_pub_id, x_prev_publication_id, x_prev_export_status, x_prev_remote_publication_id, x_status);

            IF (x_prev_publication_id > 0)
            THEN
               cz_pb_mgr.v_err_message := 'New Copy of publication: ' || TO_CHAR(x_prev_publication_id);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZMODPUB', SQLCODE);
            END IF;
         END IF;                                                                                   /* end if of ( p_rem_publication_id IS NOT NULL) */
      ELSIF((cz_pb_mgr.v_ui_str = 'x') AND(cz_pb_mgr.v_session_parameter <> model_copy))
      THEN
         IF (p_rem_publication_id IS NOT NULL)
         THEN
            get_republish_pb_info(p_rem_publication_id, 'PUP', x_prev_publication_id, x_prev_export_status, x_prev_remote_publication_id, x_status);

            IF (x_prev_publication_id > 0)
            THEN
               cz_pb_mgr.v_err_message := 'Re-publish of publication: ' || TO_CHAR(x_prev_publication_id);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZMODPUB', SQLCODE);
            END IF;
         ELSE
            get_max_pub_id(cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_server_id, v_pr_pub_id, cz_pb_mgr.v_status_code);
            get_new_copy_pb_info(v_pr_pub_id, x_prev_publication_id, x_prev_export_status, x_prev_remote_publication_id, x_status);
         END IF;
      END IF;                                                                /* end if of (p_ui_str = 'UI') AND (p_session_parameter <> MODEL_COPY) */
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message :=
                              'Error in retrieving previous publication info for publication id : ' || cz_pb_mgr.v_publication_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETPREVPUB', SQLCODE);
         RAISE;
   END get_prev_publication;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure inserts target publication record
------@p_new_publication_id : new publication id
------@p_old_publication_id : old publication id
------@p_link IN OUT NOCOPY : db link
------@x_status publication status parameter
   PROCEDURE insert_tgt_publication(
      p_new_publication_id IN cz_model_publications.publication_id%TYPE
     ,p_old_publication_id IN cz_model_publications.publication_id%TYPE
     ,p_model_id IN cz_model_publications.model_id%TYPE
     ,p_ui_def_id IN cz_model_publications.ui_def_id%TYPE
     ,p_link IN OUT NOCOPY VARCHAR2
     ,p_insert_flag IN VARCHAR2
     ,x_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
   )
   AS
      v_ui_def VARCHAR2(2000);
      v_inst_str VARCHAR2(8000);
      v_src_ui_def_id VARCHAR2(2000);
   BEGIN
      IF ((p_new_publication_id > 0) AND(x_status <> PUBLICATION_ERROR))
      THEN
         get_synchronized_pb_values(p_old_publication_id);

         IF (p_ui_def_id IS NULL)
         THEN
            v_ui_def := 'NULL';
            v_src_ui_def_id := 'NULL';
         ELSE
            v_ui_def := TO_CHAR(p_ui_def_id);
            v_src_ui_def_id := TO_CHAR(cz_pb_mgr.v_root_ui_def_id);
         END IF;

         v_inst_str :=
               'INSERT INTO cz_model_publications'
            || p_link
            || ''
            || ' '
            || '(PUBLICATION_ID'
            || ' '
            || ',MODEL_ID'
            || ' '
            || ',OBJECT_ID'
            || ' '
            || ',OBJECT_TYPE'
            || ' '
            || ',SERVER_ID'
            || ' '
            || ',ORGANIZATION_ID'
            || ' '
            || ',TOP_ITEM_ID'
            || ' '
            || ',PRODUCT_KEY'
            || ' '
            || ',PUBLICATION_MODE'
            || ' '
            || ',UI_DEF_ID'
            || ' '
            || ',UI_STYLE'
            || ' '
            || ',APPLICABLE_FROM'
            || ' '
            || ',APPLICABLE_UNTIL'
            || ' '
            || ',EXPORT_STATUS'
            || ' '
            || ',MODEL_PERSISTENT_ID'
            || ' '
            || ',DELETED_FLAG'
            || ' '
            || ',MODEL_LAST_STRUCT_UPDATE'
            || ' '
            || ',MODEL_LAST_LOGIC_UPDATE'
            || ' '
            || ',MODEL_LAST_UPDATED'
            || ' '
            || ',SOURCE_TARGET_FLAG'
            || ' '
            || ',REMOTE_PUBLICATION_ID'
            || ' '
            || ',SOURCE_UI_DEF_ID'
            || ' '
            || ',SOURCE_MODEL_ID'
            || ' '
            || ',CONTAINER'
            || ' '
            || ',PAGE_LAYOUT'
            || ' '
            || ',disabled_flag'
            || ' '
            || ')'
            || ' '
            || 'SELECT 	:1'
            || ' '
            || ',:2'
            || ' '
            || ',:3'
            || ' '
            || ',OBJECT_TYPE'
            || ' '
            || ',SERVER_ID'
            || ' '
            || ',:4'
            || ' '
            || ',:5'
            || ' '
            || ',:6'
            || ' '
            || ',PUBLICATION_MODE'
            || ' '
            || ',:7'
            || ' '
            || ',UI_STYLE'
            || ' '
            || ',APPLICABLE_FROM'
            || ' '
            || ',APPLICABLE_UNTIL'
            || ' '
            || ',''OK'''
            || ' '
            || ',MODEL_PERSISTENT_ID'
            || ' '
            || ',DELETED_FLAG'
            || ' '
            || ',MODEL_LAST_STRUCT_UPDATE'
            || ' '
            || ',MODEL_LAST_LOGIC_UPDATE'
            || ' '
            || ',MODEL_LAST_UPDATED'
            || ' '
            || ','''
            || g_target_flag
            || ''''
            || ' '
            || ',:8'
            || ' '
            || ',:9'
            || ' '
            || ',:10'
            || ' '
            || ',CONTAINER'
            || ' '
            || ',PAGE_LAYOUT'
            || ' '
            || ',disabled_flag'
            || ' '
            || 'FROM  cz_model_publications'
            || ' '
            || 'WHERE publication_id = :11 ';

         EXECUTE IMMEDIATE v_inst_str
                     USING p_new_publication_id
                          ,p_model_id
                          ,p_model_id
                          ,cz_pb_mgr.v_bomsynch_org_id
                          ,cz_pb_mgr.v_bomsynch_item_id
                          ,cz_pb_mgr.v_bomsynch_product_key
                          ,p_ui_def_id
                          ,p_old_publication_id
                          ,cz_pb_mgr.v_root_ui_def_id
                          ,cz_pb_mgr.v_root_model_id
                          ,p_old_publication_id;

         ---------update remote_publication on the source
         IF (p_insert_flag = 'REPUBLISH')
         THEN
            UPDATE cz_model_publications
               SET remote_publication_id = p_new_publication_id
             WHERE publication_id = cz_pb_mgr.v_cz_model_pub_old_id;
         ELSIF(p_insert_flag = 'NEW')
         THEN
            UPDATE cz_model_publications
               SET remote_publication_id = p_new_publication_id
             WHERE publication_id = p_old_publication_id;
         END IF;

         ------update for republish_model api
         IF (cz_pb_mgr.v_republish_model = new_copy_mode)
         THEN
            EXECUTE IMMEDIATE    'UPDATE cz_model_publications'
                              || p_link
                              || '   t '
                              || ' '
                              || 'SET    t.applicable_from  = :1,'
                              || ' '
                              || 't.applicable_until = :2'
                              || ' '
                              || 'WHERE   t.publication_id   = :3 '
                        USING v_repub_appl_from, v_repub_appl_until, v_repub_remote_pb_id;
         END IF;

         EXECUTE IMMEDIATE 'UPDATE cz_devl_projects set checkout_user = NULL ' || ' ' || 'WHERE  devl_project_id = ' || NVL(p_model_id, 0);
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in inserting target publication for source publication id: ' || p_old_publication_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTTGTPUB', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END insert_tgt_publication;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that inserts publication applicability parameters on the target instance
   PROCEDURE insert_pb_parameters(
      p_new_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,p_old_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,p_session_parameter IN OUT NOCOPY VARCHAR2
     ,p_db_link IN VARCHAR2
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      IF (x_status <> PUBLICATION_ERROR) AND(p_session_parameter <> model_copy)
      THEN
         ---------------- insert the fields of cz_pb_client_apps
         cz_pb_mgr.v_insert_string :='INSERT INTO cz_pb_client_apps'||p_db_link  || ' ' ||
						'(PUBLICATION_ID,FND_APPLICATION_ID,APPLICATION_SHORT_NAME,NOTES)' || ' ' ||
					  'SELECT '||p_new_publication_id||',t.APPLICATION_ID,t.APPLICATION_SHORT_NAME,NOTES' || ' ' ||
					  'FROM  cz_pb_client_apps,fnd_application' ||p_db_link|| ' ' ||
	 				  't WHERE cz_pb_client_apps.publication_id = :1'  || ' ' ||
	 				  'and cz_pb_client_apps.APPLICATION_SHORT_NAME=t.APPLICATION_SHORT_NAME';
		EXECUTE IMMEDIATE v_insert_string using p_old_publication_id;

         COMMIT;
         ----------insert the fields of cz_publication_usages
         cz_pb_mgr.v_insert_string :=
               'INSERT INTO cz_publication_usages'
            || p_db_link
            || ' '
            || '(PUBLICATION_ID,USAGE_ID)'
            || ' '
            || 'SELECT  '
            || p_new_publication_id
            || ',USAGE_ID'
            || ' '
            || 'FROM  cz_publication_usages'
            || ' '
	    || 'WHERE publication_id = :1';

	 EXECUTE IMMEDIATE v_insert_string using p_old_publication_id;


         COMMIT;
         ---------------- insert the fields of cz_pb_languages
         cz_pb_mgr.v_insert_string :=
               'INSERT INTO cz_pb_languages'
            || p_db_link
            || ' '
            || '(PUBLICATION_ID,LANGUAGE)'
            || ' '
            || 'SELECT '
            || p_new_publication_id
            || ',LANGUAGE'
            || ' '
            || 'FROM  cz_pb_languages'
            || ' '
	    ||	'WHERE cz_pb_languages.publication_id = :1';

	 EXECUTE IMMEDIATE v_insert_string using p_old_publication_id;

         COMMIT;
      END IF;                                                    /* end if of x_status <> PUBLICATION_ERROR) AND (p_session_parameter <> MODEL_COPY */
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message :=
            'Error in inserting publication parameters on the target instance for source publication id: ' || p_old_publication_id || ' : '
            || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.INSERTTGTPUB', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END insert_pb_parameters;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_devl_projects(
      p_new_model_id IN OUT NOCOPY cz_devl_projects.devl_project_id%TYPE
     ,p_old_model_id IN OUT NOCOPY cz_devl_projects.devl_project_id%TYPE
     ,p_orig_sys_ref IN OUT NOCOPY cz_devl_projects.orig_sys_ref%TYPE
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      l_sql_query VARCHAR2(32000);
   BEGIN
      IF (x_status <> PUBLICATION_ERROR)
      THEN
         cz_pb_mgr.v_devl_orig_sys_ref := NULL;
         cz_pb_mgr.l_intl_text_id_tbl.DELETE;
         cz_pb_mgr.l_bom_caption_rule_tbl.DELETE;
         cz_pb_mgr.l_nonbom_caption_rule_tbl.DELETE;
         cz_pb_mgr.l_bom_caption_rule := 0;
         cz_pb_mgr.l_nonbom_capt_rule_id := 0;
         l_devl_proj_inv_id := NULL;
         l_devl_proj_org_id := NULL;
         l_devl_proj_product_key := NULL;
         l_bom_caption_text_id := 0;
         l_nonbom_caption_text_id := 0;

         SELECT DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.devlproject_origsysref(orig_sys_ref), orig_sys_ref), bom_caption_rule_id
               ,nonbom_caption_rule_id, DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.devlproject_invid(inventory_item_id), inventory_item_id)
               ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.devlproject_orgid(organization_id), organization_id)
               ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.devlproject_productkey(product_key), product_key), bom_caption_text_id
               ,nonbom_caption_text_id
           INTO cz_pb_mgr.v_devl_orig_sys_ref, cz_pb_mgr.l_bom_caption_rule
               ,cz_pb_mgr.l_nonbom_capt_rule_id, cz_pb_mgr.l_devl_proj_inv_id
               ,cz_pb_mgr.l_devl_proj_org_id
               ,cz_pb_mgr.l_devl_proj_product_key, cz_pb_mgr.l_bom_caption_text_id
               ,cz_pb_mgr.l_nonbom_caption_text_id
           FROM cz_devl_projects
          WHERE cz_devl_projects.devl_project_id = p_old_model_id;

         IF (cz_pb_mgr.l_bom_caption_text_id <> 0)
         THEN
            cz_pb_mgr.l_intl_text_id_tbl(1) := cz_pb_mgr.l_bom_caption_text_id;
            insert_intl_texts(cz_pb_mgr.l_intl_text_id_tbl, 'bom capt text of cz_devl_projects');
            resolve_intl_texts(cz_pb_mgr.l_intl_text_id_tbl, cz_pb_mgr.v_cz_intl_text_idx_ref, 'bom capt text of cz_devl_projects');
            cz_pb_mgr.l_bom_caption_text_id := cz_pb_mgr.l_intl_text_id_tbl(1);
         ELSE
            cz_pb_mgr.l_bom_caption_text_id := NULL;
         END IF;

         IF (cz_pb_mgr.l_nonbom_caption_text_id <> 0)
         THEN
            cz_pb_mgr.l_intl_text_id_tbl(1) := cz_pb_mgr.l_nonbom_caption_text_id;
            insert_intl_texts(cz_pb_mgr.l_intl_text_id_tbl, 'non bom capt text of cz_devl_projects');
            resolve_intl_texts(cz_pb_mgr.l_intl_text_id_tbl, cz_pb_mgr.v_cz_intl_text_idx_ref, 'non bom capt text of cz_devl_projects');
            cz_pb_mgr.l_nonbom_caption_text_id := cz_pb_mgr.l_intl_text_id_tbl(1);
         ELSE
            cz_pb_mgr.l_nonbom_caption_text_id := NULL;
         END IF;

         IF (cz_pb_mgr.l_bom_caption_rule <> 0)
         THEN
            resolve_ids(cz_pb_mgr.l_bom_caption_rule_tbl, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'bom rule ids of projects', ENTITY_TYPE_RULE);
         ELSE
            cz_pb_mgr.l_bom_caption_rule := NULL;
         END IF;

         IF (cz_pb_mgr.l_nonbom_capt_rule_id <> 0)
         THEN
            resolve_ids(cz_pb_mgr.l_nonbom_caption_rule_tbl, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'non bom rule ids of projects', ENTITY_TYPE_RULE);
         ELSE
            cz_pb_mgr.l_nonbom_capt_rule_id := NULL;
         END IF;

         l_sql_query :=
               'BEGIN  INSERT INTO cz_devl_projects'
            || cz_pb_mgr.v_db_link
            || '(DEVL_PROJECT_ID'
            || ' '
            || ',NAME,VERSION,DESC_TEXT,ORIG_SYS_REF,PUBLISHED,LAST_STRUCT_UPDATE'
            || ' '
            || ',UI_TIMESTAMP_STRUCT_UPDATE'
            || ' '
            || ',LAST_LOGIC_UPDATE,DELETED_FLAG,PERSISTENT_PROJECT_ID'
            || ' '
            || ',MODEL_TYPE,bom_caption_rule_id,nonbom_caption_rule_id'
            || ' '
            || ',organization_id,inventory_item_id,product_key'
            || ' '
            || ',bom_caption_text_id,nonbom_caption_text_id,POST_MIGR_CHANGE_FLAG,config_engine_type)'
            || ' '
            || 'SELECT :1'
            || ' '
            || ',NAME,VERSION,DESC_TEXT,:2,PUBLISHED,LAST_STRUCT_UPDATE'
            || ' '
            || ',UI_TIMESTAMP_STRUCT_UPDATE'
            || ' '
            || ',LAST_LOGIC_UPDATE,DELETED_FLAG,PERSISTENT_PROJECT_ID'
            || ' '
            || ',MODEL_TYPE,:3,:4'
            || ' '
            || ',:5,:6,:7'
            || ' '
            || ',:8,:9,POST_MIGR_CHANGE_FLAG,config_engine_type'
            || ' '
            || 'FROM cz_devl_projects'
            || ' '
            || 'WHERE cz_devl_projects.devl_project_id = '
            || TO_CHAR(p_old_model_id)
            || '; END; ';

         EXECUTE IMMEDIATE l_sql_query
                     USING p_new_model_id
                          ,cz_pb_mgr.v_devl_orig_sys_ref
                          ,cz_pb_mgr.l_bom_caption_rule
                          ,cz_pb_mgr.l_nonbom_capt_rule_id
                          ,cz_pb_mgr.l_devl_proj_org_id
                          ,cz_pb_mgr.l_devl_proj_inv_id
                          ,cz_pb_mgr.l_devl_proj_product_key
                          ,cz_pb_mgr.l_bom_caption_text_id
                          ,cz_pb_mgr.l_nonbom_caption_text_id;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERTION_ERR', 'TABLENAME', 'cz_devl_projects', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END insert_devl_projects;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
---------procedure retrieves the value of sequence incrementor
   PROCEDURE get_seq_incrementor(x_oraclesequenceincr IN OUT NOCOPY cz_db_settings.VALUE%TYPE)
   AS
   BEGIN
      SELECT VALUE
        INTO x_oraclesequenceincr
        FROM cz_db_settings
       WHERE cz_db_settings.setting_id = sequence_incr_str;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_SEQ_INCR');
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.SEQINCR', SQLCODE);
         x_oraclesequenceincr := 20;
   END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure retrieves copy rules flag
   PROCEDURE get_copy_rules_flg(x_copyrules IN OUT NOCOPY VARCHAR2)
   AS
   BEGIN
      IF (cz_pb_mgr.v_session_parameter = pub_model)
      THEN
         SELECT VALUE
           INTO x_copyrules
           FROM cz_db_settings
          WHERE cz_db_settings.setting_id = rule_copy;
      ELSE
         x_copyrules := copy_rules;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_copyrules := 'YES';
   END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedureto to get single Publication Language from cz_db_settings. SUN ER
   PROCEDURE get_single_pb_language
   AS
   BEGIN
      IF (CZ_PB_MGR.v_session_parameter = PUB_MODEL)
      THEN
         SELECT UPPER(value)
           INTO vPubSingleLang
           FROM cz_db_settings
          WHERE UPPER(cz_db_settings.setting_id) = PUB_LANGUAGE;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         vPubSingleLang := NULL;
   END;
------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that uploads publication data
----@p_publication_id : publication request id on the source database
   PROCEDURE upload_publication_data(p_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE)
   AS
      v_new_ui_def_id cz_model_publications.ui_def_id%TYPE;
      v_remote_model cz_model_publications.model_id%TYPE;
      v_prev_publication_id cz_model_publications.publication_id%TYPE;
      v_prev_export_status cz_model_publications.export_status%TYPE;
   BEGIN
      pbdebug := 22036;
      -------------update the status in cz_model_publications and model exports
      update_pb_status(p_publication_id, cz_pb_mgr.v_status_code, cz_pb_mgr.v_models_to_be_exported, cz_pb_mgr.v_status_code);
      ------------get new publication id for the target publication
      get_new_publication_id(p_publication_id
                            ,cz_pb_mgr.v_cz_model_pub_old_id
                            ,cz_pb_mgr.v_cz_model_pub_new_id
                            ,cz_pb_mgr.remote_publication_id
                            ,cz_pb_mgr.v_status_code
                            );
      ------get new ui_def_id for the target publication
      get_new_ui_def_id(p_publication_id, cz_pb_mgr.v_cz_ui_defs_old_ref, cz_pb_mgr.v_cz_ui_defs_new_ref, v_new_ui_def_id, cz_pb_mgr.v_status_code);

      -------get model id for target publication
      IF (g_object_type = MODEL_PUBLICATION) THEN
         get_new_model_id(p_publication_id, v_models_to_be_exported_new, v_remote_model, cz_pb_mgr.v_status_code);
      ELSE -- not supported
        get_new_model_id(p_publication_id, cz_pb_mgr.g_ui_templates_new_temp_id_ref, v_remote_model, cz_pb_mgr.v_status_code);
      END IF;

      -----------get previous publication id and status
      get_prev_publication(cz_pb_mgr.v_ui_str
                          ,cz_pb_mgr.v_session_parameter
                          ,cz_pb_mgr.remote_publication_id
                          ,v_prev_publication_id
                          ,v_prev_export_status
                          ,cz_pb_mgr.v_prev_remote_publication_id
                          ,cz_pb_mgr.v_status_code
                          );
      --------insert the new publication into cz_model_publications table of the target db
      insert_tgt_publication(cz_pb_mgr.v_cz_model_pub_new_id
                            ,cz_pb_mgr.v_cz_model_pub_old_id
                            ,v_remote_model
                            ,v_new_ui_def_id
                            ,cz_pb_mgr.v_db_link
                            ,'NEW'
                            ,cz_pb_mgr.v_status_code
                            );

      ---------------- insert applicability parameters for tgt publication
      IF (g_object_type = MODEL_PUBLICATION)
      THEN
         insert_pb_parameters(cz_pb_mgr.v_cz_model_pub_new_id
                             ,cz_pb_mgr.v_cz_model_pub_old_id
                             ,cz_pb_mgr.v_session_parameter
                             ,cz_pb_mgr.v_db_link
                             ,cz_pb_mgr.v_status_code
                             );
      END IF;

      ------reset status to the original if a re-publish fails
      IF (LTRIM(RTRIM(UPPER(v_prev_export_status))) = 'PUP')
      THEN
         IF (cz_pb_mgr.v_status_code = PUBLICATION_ERROR)
         THEN
            UPDATE cz_model_publications
               SET export_status = 'OK'
             WHERE publication_id = v_prev_publication_id;
         ELSE
            UPDATE cz_model_publications
               SET deleted_flag = '1'
                  ,export_status = 'OK'
             WHERE publication_id = v_prev_publication_id;

            EXECUTE IMMEDIATE    'BEGIN'
                              || ' '
                              || 'UPDATE cz_model_publications'
                              || cz_pb_mgr.v_db_link
                              || ' '
                              || ' '
                              || 'SET deleted_flag = ''1'','
                              || ' '
                              || 'export_status = ''OK'''
                              || ' '
                              || 'WHERE publication_id = cz_pb_mgr.v_prev_remote_publication_id ;'
                              || ' '
                              || 'END;';
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in upload of PUBLICATION schema for publication id : ' || cz_pb_mgr.v_publication_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UPLOADUISCHEMA', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END;                                                                                                      /* end of upload of publication schema */

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--Functions used for resolving effectuve usage mask
   FUNCTION hextodec(hexnum IN CHAR)
      RETURN NUMBER
   IS
      x NUMBER;
      digits NUMBER;
      RESULT NUMBER := 0;
      current_digit CHAR(1);
      current_digit_dec NUMBER;
   BEGIN
      digits := LENGTH(hexnum);

      FOR x IN 1 .. digits
      LOOP
         current_digit := SUBSTR(hexnum, x, 1);

         IF current_digit IN('A', 'B', 'C', 'D', 'E', 'F')
         THEN
            current_digit_dec := ASCII(current_digit) - ASCII('A') + 10;
         ELSE
            current_digit_dec := TO_NUMBER(current_digit);
         END IF;

         RESULT := (RESULT * 16) + current_digit_dec;
      END LOOP;

      RETURN RESULT;
   END hextodec;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   FUNCTION hextobinary(hexnum IN CHAR)
      RETURN VARCHAR2
   IS
      RESULT VARCHAR2(4) := '';
      current_digit_dec NUMBER;
   BEGIN
      IF hexnum IN('A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f')
      THEN
         current_digit_dec := ASCII(UPPER(hexnum)) - ASCII('A') + 10;
      ELSE
         current_digit_dec := TO_NUMBER(hexnum);
      END IF;

      LOOP
         RESULT := TO_CHAR(MOD(current_digit_dec, 2)) || RESULT;
         current_digit_dec := TRUNC(current_digit_dec / 2);
         EXIT WHEN(current_digit_dec < 1);
      END LOOP;

      RESULT := LPAD(RESULT, 4, '0');
      RETURN RESULT;
   END hextobinary;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   FUNCTION power_func(p_power IN NUMBER)
      RETURN NUMBER
   IS
      RESULT NUMBER := 1;
   BEGIN
      FOR x IN 1 .. p_power
      LOOP
         RESULT := RESULT * 2;
      END LOOP;

      RETURN RESULT;
   END;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE getUsgNameArray(usagemap VARCHAR2, p_old_usage_name_to_id_map IN OUT NOCOPY cz_pb_mgr.t_usage_name)
   AS
      l_str VARCHAR2(1) := '';
      l_length NUMBER;
      l_hex VARCHAR2(16) DEFAULT '0123456789ABCDEF';
      l_bits VARCHAR2(64) := '';
      current_digit VARCHAR2(1);
      l_length1 NUMBER;
      l_cnt NUMBER := 0;
      l_name VARCHAR2(2000);
      l_id NUMBER;
   BEGIN
      l_length := LENGTH(usagemap);

      FOR i IN 1 .. l_length
      LOOP
         current_digit := SUBSTR(usagemap, i, 1);
         l_length1 := LENGTH(l_bits);
         l_bits := l_bits || hextobinary(current_digit);
      END LOOP;

      l_length := LENGTH(l_bits);

      FOR i IN 1 .. l_length
      LOOP
         l_str := SUBSTR(l_bits, -i, 1);

         IF (TO_NUMBER(l_str) = 1)
         THEN
            SELECT NAME, model_usage_id
              INTO l_name, l_id
              FROM cz_model_usages
             WHERE model_usage_id = l_cnt;

            p_old_usage_name_to_id_map(l_cnt) := l_name;
         END IF;

         l_cnt := l_cnt + 1;
      END LOOP;
   END getUsgNameArray;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE buildusagemask(usageid IN NUMBER, usagemask IN OUT NOCOPY VARCHAR2)
   AS
      l_str VARCHAR2(255) DEFAULT NULL;
      l_num NUMBER;
      l_hex VARCHAR2(16) DEFAULT '0123456789ABCDEF';
   BEGIN
      l_num := hextodec(usagemask) + power_func(usageid);

      LOOP
         l_str := SUBSTR(l_hex, MOD(l_num, 16) + 1, 1) || l_str;
         l_num := TRUNC(l_num / 16);
         EXIT WHEN(l_num = 0);
      END LOOP;

      usagemask := LPAD(l_str, 16, '0');
   END buildusagemask;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--procedure to resolve effective usage mask for ps nodes and rules.
--Bug #5485126 - p_rules_flag should be 1 when the procedure is called for rules.

   PROCEDURE resolve_effective_usage_mask(p_id_to_eff_usg_msk IN t_ref, p_rules_flag IN PLS_INTEGER)
   AS
      remote_usage ref_cursor;
      avail_usage_cur ref_cursor;
      -- We start with default mask.
      l_previous_mask VARCHAR2(16) := v_default_eff_usg_mask;
      l_avail_usage_id NUMBER;
      l_effective_usage VARCHAR2(2000);
      usageid NUMBER;
      l_usage_id cz_model_usages.model_usage_id%TYPE;
      l_usage_name cz_model_usages.NAME%TYPE;
      l_usage_desc cz_model_usages.description%TYPE;
      l_index_ps_to_eff NUMBER;
      l_index_usage_name_to_id NUMBER;
      l_count NUMBER;
      rec_count NUMBER := 0;
      l_str VARCHAR2(2000);
   BEGIN
      IF(p_rules_flag = 1)THEN
        cz_pb_mgr.v_new_rul_usg_msk_tbl.DELETE;
      ELSE
        cz_pb_mgr.v_new_eff_usg_msk_tbl.DELETE;
      END IF;

      IF (p_id_to_eff_usg_msk.COUNT > 0)
      THEN
         FOR eff IN p_id_to_eff_usg_msk.FIRST .. p_id_to_eff_usg_msk.LAST
         LOOP
            rec_count := rec_count + 1;

            --Bug #5485126 - if the p_rules_flag is set, use the rule usage mask array.

            IF(p_rules_flag = 1)THEN

               l_effective_usage := cz_pb_mgr.v_cz_rule_usage_mask_tbl(eff);
            ELSE

               l_effective_usage := cz_pb_mgr.v_cz_effective_usage_mask_tbl(eff);
            END IF;

            IF (l_effective_usage <> v_default_eff_usg_mask)
            THEN
               getUsgNameArray(l_effective_usage, cz_pb_mgr.v_old_usage_name_to_id_map);
               l_index_usage_name_to_id := cz_pb_mgr.v_old_usage_name_to_id_map.FIRST;

               WHILE(l_index_usage_name_to_id IS NOT NULL)
               LOOP
                  l_usage_name := cz_pb_mgr.v_old_usage_name_to_id_map(l_index_usage_name_to_id);
                  l_usage_id := NULL;
                  l_usage_desc := NULL;
                  -- At this point we will check if the usage is already been processed
				  -- we will maintain two arrays
				  -- 1. having list of all the usage name processed
				  -- 2. usage name to new remote usage id that is commited.
		          IF (cz_pb_mgr.g_usg_name_processed.COUNT = 0 OR (NOT cz_pb_mgr.g_usg_name_processed.EXISTS(l_usage_name))) THEN
                    OPEN remote_usage FOR    'Select model_usage_id, name, description '
                                          || ' '
                                          || 'from cz_model_usages'
                                          || cz_pb_mgr.v_db_link
                                          || ' t'
                                          || ' '
                                          || 'where t.name = :1' USING l_usage_name;

                    FETCH remote_usage
                     INTO l_usage_id, l_usage_name, l_usage_desc;

                    IF (l_usage_id IS NULL)
                    THEN
                       OPEN avail_usage_cur FOR 'select min(model_usage_id) from cz_model_usages' || cz_pb_mgr.v_db_link || 'where in_use=''X''';

                       FETCH avail_usage_cur
                        INTO l_avail_usage_id;

                       IF (l_avail_usage_id is null)
                       THEN
                          --Raise migration failure.
                          --Proposed: Usage Limit maxed out during the migration process.
                          cz_pb_mgr.v_err_message :=
                                                  cz_utils.get_text('CZDEV_MAX_USAGES_CREATED_ERR', 'TABLENAME', 'cz_model_usages', 'SQLERRM', SQLERRM);
                          cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.resolve_effective_usage_mask', SQLCODE);
                          cz_pb_mgr.v_status_code := 0;                                                                             -- MIGRATION_ERROR;
                          cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
                          RAISE NO_DATA_FOUND;
                       ELSE
                          l_usage_id := l_avail_usage_id;
                          --Insert into cz_model_usages, use execute immediate
                          l_str :=
                                'update cz_model_usages'
                             || cz_pb_mgr.v_db_link
                             || ' '
                             || 'set name = :1,'
                             || ' '
                             || 'description = :2,'
                             || ' '
                             || 'in_use = ''1'' '
                             || ' '
                             || 'where model_usage_id = :3';

                          EXECUTE IMMEDIATE l_str
                                      USING l_usage_name, l_usage_desc, l_avail_usage_id;

                          ----------insert into cz_rp_entries
                          l_str :=
                                'BEGIN
                        	insert into cz_rp_entries'
                             || cz_pb_mgr.v_db_link
                             || ' ( OBJECT_TYPE'
                             || ' '
                             || ',OBJECT_ID'
                             || ' '
                             || ',ENCLOSING_FOLDER'
                             || ' '
                             || ',NAME'
                             || ' '
                             || ',DESCRIPTION'
                             || ' '
                             || ',DELETED_FLAG'
                             || ' '
                             || ',SEEDED_FLAG'
                             || ' '
                             || ')'
                             || ' '
                             || 'VALUES ( ''USG'' '
                             || ' '
                             || ',:1'
                             || ' '
                             || ',:2'
                             || ' '
                             || ',:3'
                             || ' '
                             || ',:4'
                             || ' '
                             || ',''0'' '
                             || ' '
                             || ',''0'');'
                             || ' '
                             || 'commit;'
                             || ' '
                             || 'EXCEPTION'
                             || ' '
                             || 'WHEN OTHERS THEN'
                             || ' '
                             || 'update cz_rp_entries set deleted_flag = ''0'' where object_id = :1;'
                             || ' '
                             || 'END;';

                          EXECUTE IMMEDIATE l_str
                                      USING l_avail_usage_id, cz_pb_mgr.g_migration_tgt_folder_id, l_usage_name, l_usage_desc;

                          COMMIT;
                       END IF;
                     END IF;
		     cz_pb_mgr.g_usg_name_processed(l_usage_name) := l_usage_id;
		  END IF;
                  l_usage_id := cz_pb_mgr.g_usg_name_processed(l_usage_name);
                  buildusagemask(l_usage_id, l_previous_mask);
                  l_index_usage_name_to_id := cz_pb_mgr.v_old_usage_name_to_id_map.NEXT(l_index_usage_name_to_id);
               END LOOP;

               IF(p_rules_flag = 1)THEN
                  cz_pb_mgr.v_new_rul_usg_msk_tbl(rec_count) := l_previous_mask;
               ELSE
                  cz_pb_mgr.v_new_eff_usg_msk_tbl(rec_count) := l_previous_mask;
               END IF;

               --Add the new usage mask to the array_of_resolved_mask  against the new ps_node_ids.
               l_previous_mask := v_default_eff_usg_mask;
               cz_pb_mgr.v_old_usage_name_to_id_map.DELETE;
            ELSE
               IF(p_rules_flag = 1)THEN
                 cz_pb_mgr.v_new_rul_usg_msk_tbl(rec_count) := v_default_eff_usg_mask;
               ELSE
                 cz_pb_mgr.v_new_eff_usg_msk_tbl(rec_count) := v_default_eff_usg_mask;
               END IF;
            END IF;
         END LOOP;
      END IF;
   END resolve_effective_usage_mask;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure to upload ps structure tree
   PROCEDURE upload_ps_structure(
      p_models_for_export IN OUT NOCOPY cz_pb_mgr.t_ref
     ,p_export_flag IN OUT NOCOPY VARCHAR2
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      v_project_count PLS_INTEGER := 0;
      rec_count PLS_INTEGER := 0;
      v_cz_model_ref_expls_new_tbl cz_pb_mgr.t_ref;
      v_cz_model_ref_expls_old_tbl cz_pb_mgr.t_ref;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      pbdebug := 22037;

      ----logging process times
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start bulk collect of psnodes');
      END IF;

      -- if model migration, the collection of ps_nodes related stuff has already happened
      -- before, so don't redo this.
      -- IF (p_models_for_export.COUNT > 0) THEN
      --   bulk collect of psnodes moved to mm_loadoldpsnodesforitems() ...
      -- END IF; -- end if of p_models_for_export > 0
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end bulk collect of psnodes');
         log_timing_message('start insert_eff_sets');
      END IF;

      -------------populate effectivity sets table
      insert_eff_sets(cz_pb_mgr.v_ps_eff_set_id_tbl
                     ,cz_pb_mgr.v_cz_eff_sets_old_tbl
                     ,cz_pb_mgr.v_cz_eff_sets_new_tbl
                     ,cz_pb_mgr.v_cz_eff_sets_idx_tbl
                     ,'cz_pb_mgr.v_cz_eff_sets_old_tbl'
                     ,'cz_pb_mgr.v_cz_eff_sets_new_tbl'
                     ,'Eff sets of ps nodes'
                     );
      ------clear_tables('cz_rules','ref',cz_pb_mgr.v_status_code);
      -----bulk collect old and new rule ids
      bulk_collect_rules(p_export_flag
                        ,cz_pb_mgr.v_models_to_be_exported
                        ,cz_pb_mgr.v_cz_rules_rule_id_old_ref
                        ,cz_pb_mgr.v_cz_rules_rule_id_new_ref
                        ,cz_pb_mgr.v_cz_rules_rule_id_idx_ref
                        ,cz_pb_mgr.v_status_code
                        );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end insert_eff_sets');
         log_timing_message('start eff sets of ps nodes');
      END IF;

      -- resolve effective usage mask for rules
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         resolve_effective_usage_mask(cz_pb_mgr.v_cz_rules_rule_id_old_ref, 1);
      END IF;

      ---------resolve eff sets
      resolve_ids(cz_pb_mgr.v_ps_eff_set_id_tbl, cz_pb_mgr.v_cz_eff_sets_idx_tbl, 'eff sets of ps nodes');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end eff sets of ps nodes');
      END IF;

      -------------insert intl texts for cz_ps_nodes
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start insert_intl_texts Intl Text of ps nodes');
      END IF;

      insert_intl_texts(cz_pb_mgr.v_ps_intl_old_tbl, 'Intl Text of ps nodes');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end insert_intl_texts Intl Text of ps nodes');
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start Intl Text of ps nodes');
      END IF;

      resolve_intl_texts(cz_pb_mgr.v_ps_intl_old_tbl, cz_pb_mgr.v_cz_intl_text_idx_ref, 'intl texts of ps nodes');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end Intl Text of ps nodes');
      END IF;

      -----insert violation text ids
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start insert_intl_texts Violation text of ps nodes');
      END IF;

      insert_intl_texts(cz_pb_mgr.v_ps_viol_old_tbl, 'Violation text of ps nodes');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end insert_intl_texts Violation text of ps nodes');
      END IF;

      -------resolve violation text ids
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_intl_texts Violation text of ps nodes');
      END IF;

      resolve_intl_texts(cz_pb_mgr.v_ps_viol_old_tbl, cz_pb_mgr.v_cz_intl_text_idx_ref, 'violation texts of ps nodes');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_intl_texts Violation text of ps nodes');
      END IF;

      -------resolve rule ids
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve caption rule ids in ps nodes');
      END IF;

      resolve_ids(cz_pb_mgr.v_ps_capt_rule_tbl, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'caption rule ids of ps nodes');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve resolve caption rule ids in ps nodes');
      END IF;

      ------------Resolving ps_ref_id of cz ps nodes
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_ids ps_ref_id of cz ps nodes');
      END IF;

      -- non-exported psnodes actually loaded and put into the map too, so it would be better to load them early too
      -- then no special treatment needed for reference_id, component_id, etc
      resolve_ids(cz_pb_mgr.v_ps_refid_old_tbl, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'reference_id of cz ps nodes', FLD_PSN_REFERENCE_ID);

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ids ps_ref_id of cz ps nodes');
      END IF;

      ------------Resolving component -ids of ps_nodes
      resolve_ids(cz_pb_mgr.v_cz_ps_nodes_comp_tbl, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'component id of cz ps nodes', FLD_PSN_REFERENCE_ID);

      -- resolve effective usage mask for ps nodes.
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         resolve_effective_usage_mask(cz_pb_mgr.v_cz_ps_nodes_old_tbl, 0);
      END IF;

      -- to verify: the model referred by reverse connector id would always be reexported regardless of having any
      -- change or not, if the model having the reverse connector is exported?
      -- otherwise, we need to implement resolver_ref_ids_not_found for this column and call that instead
      resolve_ids(cz_pb_mgr.g_ps_reverse_connector_tbl, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'psn reverse_connector_id');

      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'ps_node_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ps_nodes_new_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'devl_project_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_devl_project_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'parent_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_parent_id_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'reference_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_refId_old_tbl';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_eff_set_id_tbl';
      plsql_table_list(rec_count).col_name := 'effectivity_set_id';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_intl_old_tbl';
      plsql_table_list(rec_count).col_name := 'intl_text_id';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_viol_old_tbl';
      plsql_table_list(rec_count).col_name := 'violation_text_id';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_orig_sys_tbl';
      plsql_table_list(rec_count).col_name := 'orig_sys_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_comp_seq_path_tbl';
      plsql_table_list(rec_count).col_name := 'component_sequence_path';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_comp_seq_id_tbl';
      plsql_table_list(rec_count).col_name := 'component_sequence_id';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ps_capt_rule_tbl';
      plsql_table_list(rec_count).col_name := 'displayname_capt_rule_id';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ps_nodes_comp_tbl';
      plsql_table_list(rec_count).col_name := 'component_id';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ps_uits_add_tbl';
      plsql_table_list(rec_count).col_name := 'UI_TIMESTAMP_ADD';

      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'reverse_connector_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_ps_reverse_connector_tbl';

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_new_eff_usg_msk_tbl';
         plsql_table_list(rec_count).col_name := 'effective_usage_mask';
         mm_resync_ps_items;
         mm_resync_ps_item_types; --Bug9180063
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_v_ps_item_id_tbl';
         plsql_table_list(rec_count).col_name := 'item_id';
 --Bug9180063 to include item_type_backptr during insertion of data into cz_ps_nodes
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_v_ps_item_type_id_tbl';
         plsql_table_list(rec_count).col_name := 'item_type_backptr';
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start insert_into_table of cz ps nodes');
      END IF;

      insert_into_table('cz_ps_nodes'
                       ,'ps_node_id'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.v_cz_ps_nodes_old_tbl'
                       ,cz_pb_mgr.v_cz_ps_nodes_old_tbl
                       );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end insert_into_table of cz ps nodes');
      END IF;

      -----------update reference id of cz_ps_nodes of the target server for the models not exported
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start update_remote_reference_ids');
      END IF;

      update_remote_reference_ids(cz_pb_mgr.v_models_not_to_be_exported
                                 ,cz_pb_mgr.v_cz_ps_nodes_new_tbl
                                 ,cz_pb_mgr.v_server_id
                                 ,cz_pb_mgr.v_status_code
                                 );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end update_remote_reference_ids');
      END IF;

      --------------Populating cz_model_ref_expls table of the target database
      clear_tables('cz_model_ref_expls', 'ref', cz_pb_mgr.v_status_code);

      IF (p_models_for_export.COUNT > 0)
      THEN
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start bulk collect of model_ref_expls');
         END IF;

         FOR i IN p_models_for_export.FIRST .. p_models_for_export.LAST
         LOOP
            v_cz_model_ref_expls_new_tbl.DELETE;
            v_cz_model_ref_expls_old_tbl.DELETE;
            clear_tables('cz_model_ref_expls', 'tbl', cz_pb_mgr.v_status_code);

            BEGIN
               SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_model_ref_expls_seq
                                                 , 'cz_model_ref_expls_s.nextval' || cz_pb_mgr.v_db_link
                                                 ,cz_pb_mgr.v_oraclesequenceincr
                                                 )
                     ,model_ref_expl_id, component_id, parent_expl_node_id, child_model_expl_id
                     ,referring_node_id, model_id
               BULK COLLECT INTO v_cz_model_ref_expls_new_tbl
                     ,v_cz_model_ref_expls_old_tbl, cz_pb_mgr.v_component_id_old_tbl, cz_pb_mgr.v_parent_expl_id_tbl, cz_pb_mgr.v_child_expl_id_tbl
                     ,cz_pb_mgr.v_referring_node_id_tbl, cz_pb_mgr.v_ref_model_id_tbl
                 FROM cz_model_ref_expls t
                WHERE t.model_id = p_models_for_export(i) AND t.deleted_flag = '0';
            EXCEPTION
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_model_ref_expls', 'SQLERRM', SQLERRM);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  RAISE;
            END;

            rec_count := cz_pb_mgr.v_cz_model_ref_expls_new_ref.COUNT;

            IF (v_cz_model_ref_expls_new_tbl.COUNT > 0)
            THEN
               FOR k IN v_cz_model_ref_expls_new_tbl.FIRST .. v_cz_model_ref_expls_new_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.v_cz_model_ref_expls_new_ref(rec_count) := v_cz_model_ref_expls_new_tbl(k);
                  cz_pb_mgr.v_cz_model_ref_expls_old_ref(rec_count) := v_cz_model_ref_expls_old_tbl(k);
                  cz_pb_mgr.v_cz_model_ref_expls_idx_ref(v_cz_model_ref_expls_old_tbl(k)):=v_cz_model_ref_expls_new_tbl(k);
                  cz_pb_mgr.v_component_id_old_ref(rec_count) := cz_pb_mgr.v_component_id_old_tbl(k);
                  cz_pb_mgr.v_parent_expl_id_ref(rec_count) := cz_pb_mgr.v_parent_expl_id_tbl(k);
                  cz_pb_mgr.v_child_expl_id_ref(rec_count) := cz_pb_mgr.v_child_expl_id_tbl(k);
                  cz_pb_mgr.v_referring_node_id_ref(rec_count) := cz_pb_mgr.v_referring_node_id_tbl(k);
                  cz_pb_mgr.v_ref_model_id_ref(rec_count) := cz_pb_mgr.v_ref_model_id_tbl(k);
               END LOOP;
            END IF;
         END LOOP;                                     /* end loop of FOR I IN p_models_for_export */
      END IF;                                          /* end if of p_models_for_export.COUNT > 0 */

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end bulk collect of model_ref_expls');
      END IF;

      ------------Resolve parent expl ids of model_ref_expls
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_ids parent ids of cz_model_ref_expls');
      END IF;

      resolve_ids(cz_pb_mgr.v_parent_expl_id_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'parent ids of cz_model_ref_expls');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ids parent ids of cz_model_ref_expls');
      END IF;

      -------------resolve model id of model_ref_expls
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_ids model id of cz_model_ref_expls');
      END IF;

      resolve_ids(cz_pb_mgr.v_ref_model_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'model id of cz_model_ref_expls');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ids model id of cz_model_ref_expls');
      END IF;

      ----------resolving referring node ids of model ref expls
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_ref_ids_not_found cz_model_ref_expl.referring_node_id');
      END IF;

      resolve_ref_ids_not_found(cz_pb_mgr.v_cz_model_ref_expls_new_ref
                               ,cz_pb_mgr.v_cz_ps_nodes_old_tbl
                               ,cz_pb_mgr.v_cz_ps_nodes_idx_tbl
                               ,cz_pb_mgr.v_referring_node_id_ref
                               ,'cz_model_ref_expl.referring_node_id'
                               ,cz_pb_mgr.v_status_code
                               );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ref_ids_not_found cz_model_ref_expl.referring_node_id');
      END IF;

      -----------resolve child expl ids
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_ref_ids_not_found cz_model_ref_expl.child_expl_id');
      END IF;

      resolve_ref_ids_not_found(cz_pb_mgr.v_cz_model_ref_expls_new_ref
                               ,cz_pb_mgr.v_cz_model_ref_expls_old_ref
                               ,cz_pb_mgr.v_cz_model_ref_expls_idx_ref
                               ,cz_pb_mgr.v_child_expl_id_ref
                               ,'cz_model_ref_expl.child_expl_id'
                               ,cz_pb_mgr.v_status_code
                               );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ref_ids_not_found cz_model_ref_expl.child_expl_id');
      END IF;

      ----------resolving component_id of model ref expls
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_ref_ids_not_found cz_model_ref_expl.component_id');
      END IF;

      resolve_ref_ids_not_found(cz_pb_mgr.v_cz_model_ref_expls_new_ref
                               ,cz_pb_mgr.v_cz_ps_nodes_old_tbl
                               ,cz_pb_mgr.v_cz_ps_nodes_idx_tbl
                               ,cz_pb_mgr.v_component_id_old_ref
                               ,'cz_model_ref_expl.component_id'
                               ,cz_pb_mgr.v_status_code
                               );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ref_ids_not_found cz_model_ref_expl.component_id');
      END IF;

      ----------populate target root model id
      IF (p_models_for_export.COUNT > 0)
      THEN
         FOR i IN p_models_for_export.FIRST .. p_models_for_export.LAST
         LOOP
            IF (p_models_for_export(i) = cz_pb_mgr.v_root_model_id)
            THEN
               cz_pb_mgr.target_root_model_id := cz_pb_mgr.v_models_to_be_exported_new(i);
               EXIT;
            END IF;
         END LOOP;
      END IF;

      --------populate plsql_table_list for model_ref_expls
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'model_ref_expl_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_model_ref_expls_new_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'parent_expl_node_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_parent_expl_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'component_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_component_id_old_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'model_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ref_model_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'referring_node_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_referring_node_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'child_model_expl_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_child_expl_id_ref';

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start insert_into_table cz_model_ref_expls');
      END IF;

      insert_into_table('cz_model_ref_expls'
                       ,'model_ref_expl_id'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.v_cz_model_ref_expls_old_ref'
                       ,cz_pb_mgr.v_cz_model_ref_expls_old_ref
                       );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end insert_into_table cz_model_ref_expls');
      END IF;

      -----------------------resolution of non virtual components
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_virtual_components');
      END IF;

      resolve_virtual_components(cz_pb_mgr.v_cz_model_ref_expls_new_ref
                                ,cz_pb_mgr.v_models_not_to_be_exported
                                ,cz_pb_mgr.v_server_id
                                ,cz_pb_mgr.v_status_code
                                );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_virtual_components');
      END IF;

      -------get func comp spec by expl id
      IF (cz_pb_mgr.v_session_parameter IN(pub_model, cz_model_migration_pvt.migrate_model))
      THEN
         collect_func_comp_specs;
      ELSIF(cz_pb_mgr.v_session_parameter = model_copy)
      THEN
         IF (cz_pb_mgr.copy_rules = 'YES')
         THEN
            collect_func_comp_specs;
         END IF;
      END IF;

      ---------release local pl/sql tables
      v_cz_model_ref_expls_new_tbl.DELETE;
      v_cz_model_ref_expls_old_tbl.DELETE;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         x_status := PUBLICATION_ERROR;
         RAISE pb_upload_ps_schema;
   END upload_ps_structure;                                       /* end of export of product structure */

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_ui_node_props(p_ui_def_id_tbl IN cz_pb_mgr.t_ref)
   AS
      l_prop_node_tbl cz_pb_mgr.t_ref;
      l_plsql_table_list cz_pb_mgr.col_plsql_table_list;
      l_rec_count NUMBER := 0;
   BEGIN
      IF p_ui_def_id_tbl.COUNT > 0
      THEN
         cz_pb_mgr.g_ui_node_prop_new_node_tbl.DELETE;
         cz_pb_mgr.g_ui_node_prop_old_node_tbl.DELETE;
         cz_pb_mgr.g_ui_node_prop_new_uidf_tbl.DELETE;
         cz_pb_mgr.g_ui_node_prop_old_uidf_tbl.DELETE;

	 IF (cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0) THEN
         FOR i IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST
         LOOP
            l_prop_node_tbl.DELETE;

            SELECT DISTINCT prop.ui_node_id
            BULK COLLECT INTO l_prop_node_tbl
                       FROM cz_ui_node_props prop, cz_ui_nodes node
                      WHERE prop.ui_def_id = node.ui_def_id
                        AND prop.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_ref(i)
                        AND node.ui_node_id = prop.ui_node_id
                        AND node.deleted_flag = record_not_deleted
                        AND prop.deleted_flag = record_not_deleted;

            IF l_prop_node_tbl.COUNT > 0
            THEN
               l_rec_count := cz_pb_mgr.g_ui_node_prop_new_node_tbl.COUNT;

               FOR j IN l_prop_node_tbl.FIRST .. l_prop_node_tbl.LAST
               LOOP
                  l_rec_count := l_rec_count + 1;
                  cz_pb_mgr.g_ui_node_prop_new_node_tbl(l_rec_count) := l_prop_node_tbl(j);
                  cz_pb_mgr.g_ui_node_prop_old_node_tbl(l_rec_count) := l_prop_node_tbl(j);
                  cz_pb_mgr.g_ui_node_prop_new_uidf_tbl(l_rec_count) := cz_pb_mgr.v_cz_ui_defs_old_ref(i);
                  cz_pb_mgr.g_ui_node_prop_old_uidf_tbl(l_rec_count) := cz_pb_mgr.v_cz_ui_defs_old_ref(i);
               END LOOP;
            END IF;
         END LOOP;
	 END IF;

         IF cz_pb_mgr.g_ui_node_prop_new_node_tbl.COUNT > 0
         THEN
            resolve_ids(cz_pb_mgr.g_ui_node_prop_new_node_tbl, cz_pb_mgr.v_cz_ui_nodes_idx_ref, 'ui node ids of ui node props');
            resolve_ids(cz_pb_mgr.g_ui_node_prop_new_uidf_tbl, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of ui node props');
            l_plsql_table_list(1).col_name := 'ui_node_id';
            l_plsql_table_list(1).table_name := 'cz_pb_mgr.g_ui_node_prop_new_node_tbl';
            l_plsql_table_list(2).col_name := 'ui_def_id';
            l_plsql_table_list(2).table_name := 'cz_pb_mgr.g_ui_node_prop_new_uidf_tbl';
            insert_into_table('cz_ui_node_props'
                             ,'ui_node_id'
                             ,'ui_def_id'
                             ,cz_pb_mgr.v_db_link
                             ,l_plsql_table_list
                             ,'cz_pb_mgr.g_ui_node_prop_old_node_tbl'
                             ,'cz_pb_mgr.g_ui_node_prop_old_uidf_tbl'
                             ,cz_pb_mgr.g_ui_node_prop_old_node_tbl
                             ,cz_pb_mgr.g_ui_node_prop_old_uidf_tbl
                             );
         END IF;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_ui_node_props', 'ERR', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.NODEPROPS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
   END insert_ui_node_props;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE synch_master_template
   AS
      remote_mt ref_cursor;
      rec_count NUMBER;
      l_mt_gen_id t_ref;
      l_mt_old_id t_ref;
      l_mt_name t_mt_name;
      l_mt_id NUMBER;
      mt_idx NUMBER;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      l_rec_count NUMBER;
   BEGIN
      cz_pb_mgr.v_mt_name.DELETE;
      cz_pb_mgr.v_mt_name_ref.DELETE;
      cz_pb_mgr.v_mt_gen_id.DELETE;
      cz_pb_mgr.v_mt_old_id_tbl.DELETE;
      cz_pb_mgr.v_mt_old_only.DELETE;
      cz_pb_mgr.v_new_mt_id_ref.DELETE;
      cz_pb_mgr.v_new_mt_id_tbl.DELETE;
      cz_pb_mgr.g_mt_obj_type.DELETE;

      -- Bug 5510573; 06-Sep-2006; kdande; Added a check to see if cz_pb_mgr.v_cz_ui_defs_old_ref has elements at all and then proceed
      IF (cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0) THEN
      FOR ui IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST
      LOOP
         -- Andrew is going to provide with a query to fetch master template for given ui def id.
         SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_ui_defs_seq, 'cz_ui_defs_s.NEXTVAL' || cz_pb_mgr.v_db_link, cz_pb_mgr.v_oraclesequenceincr)
               ,ui_def_id, NAME
         BULK COLLECT INTO l_mt_gen_id
               ,l_mt_old_id, l_mt_name
           FROM cz_ui_defs mstr
          WHERE mstr.deleted_flag = '0'
            AND mstr.master_template_flag = '1'
            AND mstr.seeded_flag = '0'
            AND EXISTS(SELECT 1
                         FROM cz_ui_defs udf
                        WHERE udf.from_master_template_id = mstr.ui_def_id AND ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_ref(ui));

         -- keep a running array for l_mt_names
         rec_count := v_mt_name.COUNT;

         IF (l_mt_old_id.COUNT > 0)
         THEN
            FOR m IN l_mt_old_id.FIRST .. l_mt_old_id.LAST
            LOOP
               IF (cz_pb_mgr.v_mt_name_ref.COUNT = 0 OR NOT cz_pb_mgr.v_mt_name_ref.EXISTS(l_mt_name(m)))
               THEN
                  rec_count := rec_count + 1;
                  cz_pb_mgr.v_mt_name(rec_count) := l_mt_name(m);
                  cz_pb_mgr.v_mt_name_ref(l_mt_name(m)) := m;
                  cz_pb_mgr.v_mt_old_id_tbl(rec_count) := l_mt_old_id(m);
                  cz_pb_mgr.v_mt_gen_id(rec_count) := l_mt_gen_id(m);
               END IF;
            END LOOP;
         END IF;
      END LOOP;
      END IF;

      -- loop through the array list to check name on the remote server
      IF (cz_pb_mgr.v_mt_name.COUNT > 0)
      THEN
         rec_count := 0;
         cz_pb_mgr.v_mt_old_id_ref.DELETE;

         FOR n IN cz_pb_mgr.v_mt_name.FIRST .. cz_pb_mgr.v_mt_name.LAST
         LOOP
            --IF ((cz_pb_mgr.v_new_mt_name_to_id_map.COUNT = 0) OR (NOT cz_pb_mgr.v_new_mt_name_to_id_map.exists(cz_pb_mgr.v_mt_name(N))) ) THEN
            l_mt_id := NULL;
            rec_count := rec_count + 1;

            OPEN remote_mt FOR    'Select ui_def_id'
                               || ' '
                               || 'from cz_ui_defs'
                               || cz_pb_mgr.v_db_link
                               || 't'
                               || ' '
                               || 'where t.deleted_flag = ''0'' and t.master_template_flag = ''1'' and t.name = :1' USING cz_pb_mgr.v_mt_name(n);

            FETCH remote_mt
             INTO l_mt_id;

            IF (l_mt_id IS NOT NULL)
            THEN
               cz_pb_mgr.v_mt_old_to_new_id(cz_pb_mgr.v_mt_old_id_tbl(n)) := l_mt_id;
               cz_pb_mgr.v_mt_id_ref(rec_count) := l_mt_id;
            ELSE
               cz_pb_mgr.v_mt_old_to_new_id(cz_pb_mgr.v_mt_old_id_tbl(n)) := cz_pb_mgr.v_mt_gen_id(n);
               cz_pb_mgr.v_mt_id_ref(rec_count) := cz_pb_mgr.v_mt_gen_id(n);
               cz_pb_mgr.v_new_mt_id_ref(rec_count) := cz_pb_mgr.v_mt_gen_id(n);
               cz_pb_mgr.v_mt_old_id_ref(rec_count) := cz_pb_mgr.v_mt_old_id_tbl(n);
            END IF;
         --END IF;
         END LOOP;

         rec_count := 0;
         cz_pb_mgr.g_mt_obj_type.DELETE;
         cz_pb_mgr.g_mt_enclosing_fld_rp_entry.DELETE;
         mt_idx := cz_pb_mgr.v_new_mt_id_ref.FIRST;

         WHILE(mt_idx IS NOT NULL)
         LOOP
            rec_count := rec_count + 1;
            cz_pb_mgr.v_new_mt_id_tbl(rec_count) := cz_pb_mgr.v_new_mt_id_ref(mt_idx);
            cz_pb_mgr.g_mt_obj_type(rec_count) := 'UMT';
            cz_pb_mgr.g_mt_enclosing_fld_rp_entry(rec_count) := cz_pb_mgr.g_migration_tgt_folder_id;
            mt_idx := cz_pb_mgr.v_new_mt_id_ref.NEXT(mt_idx);
         END LOOP;

         IF (cz_pb_mgr.v_new_mt_id_tbl.COUNT > 0)
         THEN
              --------populate plsql_table_list for ui_defs
            --null values in arrays will cause insert problems
            --so pack v_mt_old_id_ref into a non empty array
            --it can get into this situation where there are some m
            --master templates that need to migrated, but there are some that
            --don't need to be migrated.
            l_rec_count := 0;

	    IF (cz_pb_mgr.v_mt_old_id_ref.COUNT > 0) THEN
            FOR m IN cz_pb_mgr.v_mt_old_id_ref.FIRST .. cz_pb_mgr.v_mt_old_id_ref.LAST
            LOOP
               IF (cz_pb_mgr.v_mt_old_id_ref(m) IS NOT NULL)
               THEN
                  l_rec_count := l_rec_count + 1;
                  cz_pb_mgr.v_mt_old_only(l_rec_count) := cz_pb_mgr.v_mt_old_id_ref(m);
               END IF;
            END LOOP;
	    END IF;

            plsql_table_list.DELETE;
            rec_count := 1;
            plsql_table_list(rec_count).col_name := 'ui_def_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_new_mt_id_tbl';
            insert_into_table('cz_ui_defs', 'ui_def_id', cz_pb_mgr.v_db_link, plsql_table_list, 'cz_pb_mgr.v_mt_old_only', cz_pb_mgr.v_mt_old_only);
            ----------begin insert into cz_rp_entries----------------
            plsql_table_list.DELETE;
            rec_count := 1;
            plsql_table_list(rec_count).col_name := 'object_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_new_mt_id_tbl';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'object_type';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_mt_obj_type';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'enclosing_folder';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_mt_enclosing_fld_rp_entry';
            insert_into_rp_entries('cz_rp_entries'
                                  ,'object_id'
                                  ,'object_type'
                                  ,cz_pb_mgr.v_db_link
                                  ,plsql_table_list
                                  ,'cz_pb_mgr.v_mt_old_only'
                                  ,'cz_pb_mgr.g_mt_obj_type'
                                  ,cz_pb_mgr.v_mt_old_only
                                  ,cz_pb_mgr.g_mt_obj_type
                                  );
         ----------end insert into cz_rp_entries----------------
         END IF;
      END IF;
   END synch_master_template;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------procedure that uploads UI schema
   PROCEDURE upload_ui_schema(p_models_for_export IN OUT NOCOPY cz_pb_mgr.t_ref, x_status IN OUT NOCOPY VARCHAR2,
                              p_copy_nonjradui IN BOOLEAN DEFAULT TRUE)
   AS
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      rec_count PLS_INTEGER := 0;
      v_ui_node_count PLS_INTEGER := 0;
      v_cz_ui_defs_old_tbl cz_pb_mgr.t_ref;
      v_ui_devl_id_tbl cz_pb_mgr.t_ref;
      v_ui_comp_id_tbl cz_pb_mgr.t_ref;
      v_ui_rf_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_new_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_old_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_ui_def_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_parent_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_ui_ref_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_ps_node_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_component_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_ui_dref_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_expl_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_fcomp_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_capt_id_tbl cz_pb_mgr.t_ref;
      v_cz_ui_nodes_tool_id_tbl cz_pb_mgr.t_ref;
      v_menu_capt_rule_tbl cz_pb_mgr.t_ref;
      v_page_capt_rule_tbl cz_pb_mgr.t_ref;
      l_from_mt_id_tbl cz_pb_mgr.t_ref;
   BEGIN
      pbdebug := 22038;

      IF ((cz_pb_mgr.copy_uis <> 'YES') AND(cz_pb_mgr.v_session_parameter = cz_pb_mgr.model_copy))
      THEN
         cz_pb_mgr.v_root_ui_def_id := -999;
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start bulk collect of ui defs');
      END IF;

      IF ((cz_pb_mgr.v_root_ui_def_id IS NOT NULL) AND(cz_pb_mgr.v_root_ui_def_id <= 0))THEN RETURN; END IF;

         clear_tables('cz_ui_defs', 'ref', cz_pb_mgr.v_status_code);

         IF (p_models_for_export.COUNT > 0) THEN
            -- not copy non-jrad ui in any conversion session or in a copy session flagged by p_copy_nonjradui
            IF NOT (cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id=0 OR
                    cz_pb_mgr.v_session_parameter=model_copy AND NOT p_copy_nonjradui) THEN
              get_source_uis(cz_pb_mgr.v_root_model_id, p_models_for_export, cz_pb_mgr.v_cz_ui_defs_old_ref);
            END IF;
            get_oa_uis(p_models_for_export, cz_pb_mgr.v_cz_ui_defs_old_ref, cz_pb_mgr.v_cz_ui_defs_old_oa_ref);

            --get_oa_tmpls is also called from has_to_be_published.
            --However, for model migration, has_to_be_published
            --is not called.  So make the call  to get_oa_tmpls here.
            IF cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id<>0 THEN
               get_oa_tmpls;
            END IF;

            IF (cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.v_cz_ui_defs_new_ref.COUNT;

               FOR k IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.v_cz_ui_defs_new_ref(rec_count) :=
                     cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_ui_defs_seq
                                                , 'cz_ui_defs_s.NEXTVAL' || cz_pb_mgr.v_db_link
                                                ,cz_pb_mgr.v_oraclesequenceincr
                                                );
               END LOOP;
            END IF;                                                                           /* end if of cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0 */
         END IF;

         IF (cz_pb_mgr.v_cz_ui_defs_new_ref.COUNT > 0)
         THEN
            FOR m IN cz_pb_mgr.v_cz_ui_defs_new_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_new_ref.LAST
            LOOP
               cz_pb_mgr.v_cz_ui_defs_idx_ref(cz_pb_mgr.v_cz_ui_defs_old_ref(m)) := cz_pb_mgr.v_cz_ui_defs_new_ref(m);
            END LOOP;
         END IF;

         get_uis_of_mdls_not_exported(cz_pb_mgr.v_models_not_to_be_exported,
                                      cz_pb_mgr.v_cz_ui_defs_idx_ref,
                                      cz_pb_mgr.v_server_id,
					                            cz_pb_mgr.v_status_code);

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end bulk collect of ui defs');
            log_timing_message('start bulk collect of devl_project_ids and component_ids for ui_defs');
         END IF;

         ---------get devl_project_ids and component_ids for ui_defs
         /* We should really re-architect this portion of the code
            we have already queried cz_ui_defs before for oa_style UIs in
            get_oa_uis and have the menu_caption_rule_id,page_caption_rule_id,
            from_master_template_id.  We need to query it again here because
            we don't have these values for DHTML UIs and insert_into_table for
            cz_ui_defs will fail.  We should consolidate the querying into one place.
         */

         IF (cz_pb_mgr.v_cz_ui_defs_new_ref.COUNT > 0)
         THEN
	   IF (cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0) THEN
            FOR i IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST
            LOOP
               BEGIN
                  v_ui_devl_id_tbl.DELETE;
                  v_ui_comp_id_tbl.DELETE;
                  v_ui_rf_id_tbl.DELETE;

                  SELECT devl_project_id, component_id, menu_caption_rule_id, page_caption_rule_id, cz_ui_defs.from_master_template_id
                  BULK COLLECT INTO v_ui_devl_id_tbl, v_ui_comp_id_tbl, v_menu_capt_rule_tbl, v_page_capt_rule_tbl, l_from_mt_id_tbl
                    FROM cz_ui_defs
                   WHERE cz_ui_defs.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_ref(i) AND cz_ui_defs.deleted_flag = record_not_deleted;

                  rec_count := cz_pb_mgr.v_ui_devl_id_ref.COUNT;

                  IF (v_ui_devl_id_tbl.COUNT > 0)
                  THEN
                     FOR k IN v_ui_devl_id_tbl.FIRST .. v_ui_devl_id_tbl.LAST
                     LOOP
                        rec_count := rec_count + 1;
                        cz_pb_mgr.v_ui_devl_id_ref(rec_count) := v_ui_devl_id_tbl(k);
                        cz_pb_mgr.v_ui_comp_id_ref(rec_count) := v_ui_comp_id_tbl(k);
                        cz_pb_mgr.v_ui_defs_mcpt_rule_ref(rec_count) := v_menu_capt_rule_tbl(k);
                        cz_pb_mgr.v_ui_defs_pcpt_rule_ref(rec_count) := v_page_capt_rule_tbl(k);
                        v_master_template_id_ref(rec_count) := l_from_mt_id_tbl(k);
                     END LOOP;
                  END IF;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_defs', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                     RAISE;
               END;
            END LOOP;                                                                        /* end loop of FOR I IN cz_pb_mgr.v_cz_ui_defs_old_ref */
	   END IF;
         END IF;                                                                              /* end if of cz_pb_mgr.v_cz_ui_defs_new_ref.COUNT > 0 */

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end bulk collect of devl_project_ids and component_ids for ui_defs');
            log_timing_message('start resolve_ids devl project id of cz_ui_defs');
         END IF;

         ----------resolve devl_project_ids
         resolve_ids(cz_pb_mgr.v_ui_devl_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'devl project id of cz_ui_defs');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids devl project id of cz_ui_defs');
         END IF;

         ----------resolve component_ids
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start resolve_ids component id of cz_ui_defs');
         END IF;

         resolve_ids(cz_pb_mgr.v_ui_comp_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'component id of cz_ui_defs');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids component id of cz_ui_defs');
         END IF;

         ----------resolve component_ids of models not to be exported
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start component_ids of models not to be exported');
         END IF;

         IF (cz_pb_mgr.v_ui_comp_id_ref.COUNT > 0)
         THEN
            FOR k IN cz_pb_mgr.v_ui_comp_id_ref.FIRST .. cz_pb_mgr.v_ui_comp_id_ref.LAST
            LOOP
               remote_component_id(cz_pb_mgr.v_ui_comp_id_ref(k)
                                  ,cz_pb_mgr.v_models_not_to_be_exported
                                  ,cz_pb_mgr.v_server_id
                                  ,cz_pb_mgr.v_status_code
                                  );
            END LOOP;
         END IF;            /* end if of cz_pb_mgr.v_ui_comp_id_ref.COUNT > 0 */

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end component_ids of models not to be exported');
         END IF;

         resolve_ids(cz_pb_mgr.v_ui_defs_mcpt_rule_ref, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'menu caption rule ids of ui defs');
         resolve_ids(cz_pb_mgr.v_ui_defs_pcpt_rule_ref, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'page caption rule ids of ui defs');

         IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id <> 0)
         THEN
            synch_master_template;
            resolve_ids(cz_pb_mgr.v_master_template_id_ref, cz_pb_mgr.v_mt_old_to_new_id, 'from_master_template_id of uidef', ENTITY_TYPE_UMT);
         END IF;

         --------populate plsql_table_list for ui_defs
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_defs_new_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'devl_project_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_devl_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'component_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_comp_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'menu_caption_rule_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_defs_mcpt_rule_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'page_caption_rule_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_ui_defs_pcpt_rule_ref';

         ---------insert into cz_ui_defs of target server
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start insert_into_table cz_ui_defs');
         END IF;

         IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id <> 0)
         THEN
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'from_master_template_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_master_template_id_ref';
         END IF;

         insert_into_table('cz_ui_defs'
                          ,'ui_def_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.v_cz_ui_defs_old_ref'
                          ,cz_pb_mgr.v_cz_ui_defs_old_ref
                          );

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end insert_into_table cz_ui_defs');
         END IF;

         ------export oa uis
         IF (cz_pb_mgr.v_cz_ui_defs_old_oa_ref.COUNT > 0) THEN
            export_oa_uis;
         END IF;

         --------populate plsql_table_list for ui_properties
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_defs_new_ref';

         ------------insert into cz_ui_properties  of target server
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start insert_into_table cz_ui_properties');
         END IF;

         insert_into_table('cz_ui_properties'
                          ,'ui_def_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.v_cz_ui_defs_old_ref'
                          ,cz_pb_mgr.v_cz_ui_defs_old_ref
                          );

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end insert_into_table cz_ui_properties');
         END IF;

         ----------insert ids of cz_ui_nodes
         clear_tables('cz_ui_nodes', 'ref', cz_pb_mgr.v_status_code);

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start bulk collect of cz_ui_nodes');
         END IF;

         IF (cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0)
         THEN
            FOR i IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST
            LOOP
               v_cz_ui_nodes_new_tbl.DELETE;
               v_cz_ui_nodes_old_tbl.DELETE;
               v_cz_ui_nodes_ui_def_id_tbl.DELETE;
               v_cz_ui_nodes_parent_id_tbl.DELETE;
               v_cz_ui_nodes_ui_ref_id_tbl.DELETE;
               v_cz_ui_nodes_ps_node_id_tbl.DELETE;
               v_cz_ui_nodes_component_id_tbl.DELETE;
               v_cz_ui_nodes_ui_dref_id_tbl.DELETE;
               v_cz_ui_nodes_expl_id_tbl.DELETE;
               v_cz_ui_nodes_fcomp_id_tbl.DELETE;
               v_cz_ui_nodes_capt_id_tbl.DELETE;
               v_cz_ui_nodes_tool_id_tbl.DELETE;

               BEGIN
                  SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_ui_nodes_seq
                                                    , 'cz_ui_nodes_s.nextval' || cz_pb_mgr.v_db_link
                                                    ,cz_pb_mgr.v_oraclesequenceincr
                                                    )
                        ,ui_node_id, ui_def_id, parent_id, ui_node_ref_id
                        ,ui_def_ref_id, ps_node_id, component_id, model_ref_expl_id
                        ,func_comp_id, caption_id, tool_tip_id
                  BULK COLLECT INTO v_cz_ui_nodes_new_tbl
                        ,v_cz_ui_nodes_old_tbl, v_cz_ui_nodes_ui_def_id_tbl, v_cz_ui_nodes_parent_id_tbl, v_cz_ui_nodes_ui_ref_id_tbl
                        ,v_cz_ui_nodes_ui_dref_id_tbl, v_cz_ui_nodes_ps_node_id_tbl, v_cz_ui_nodes_component_id_tbl, v_cz_ui_nodes_expl_id_tbl
                        ,v_cz_ui_nodes_fcomp_id_tbl, v_cz_ui_nodes_capt_id_tbl, v_cz_ui_nodes_tool_id_tbl
                    FROM cz_ui_nodes
                   WHERE cz_ui_nodes.ui_def_id = cz_pb_mgr.v_cz_ui_defs_old_ref(i) AND cz_ui_nodes.deleted_flag = record_not_deleted;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := 'No ui nodes found for : ' || TO_CHAR(cz_pb_mgr.v_cz_ui_defs_old_ref(i));
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UINODES', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ui_nodes', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                     RAISE;
               END;

               IF (v_cz_ui_nodes_new_tbl.COUNT > 0)
               THEN
                  FOR k IN v_cz_ui_nodes_new_tbl.FIRST .. v_cz_ui_nodes_new_tbl.LAST
                  LOOP
                     v_ui_node_count := cz_pb_mgr.v_cz_ui_nodes_new_ref.COUNT + 1;
                     cz_pb_mgr.v_cz_ui_nodes_new_ref(v_ui_node_count) := v_cz_ui_nodes_new_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_old_ref(v_ui_node_count) := v_cz_ui_nodes_old_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_idx_ref(v_cz_ui_nodes_old_tbl(k)):=v_cz_ui_nodes_new_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_ui_def_id_ref(v_ui_node_count) := v_cz_ui_nodes_ui_def_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_parent_id_ref(v_ui_node_count) := v_cz_ui_nodes_parent_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_ui_ref_id_ref(v_ui_node_count) := v_cz_ui_nodes_ui_ref_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_ps_node_id_ref(v_ui_node_count) := v_cz_ui_nodes_ps_node_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_component_id_ref(v_ui_node_count) := v_cz_ui_nodes_component_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_ui_dref_id_ref(v_ui_node_count) := v_cz_ui_nodes_ui_dref_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_expl_id_ref(v_ui_node_count) := v_cz_ui_nodes_expl_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_fcomp_id_ref(v_ui_node_count) := v_cz_ui_nodes_fcomp_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_capt_id_ref(v_ui_node_count) := v_cz_ui_nodes_capt_id_tbl(k);
                     cz_pb_mgr.v_cz_ui_nodes_tool_id_ref(v_ui_node_count) := v_cz_ui_nodes_tool_id_tbl(k);
                  END LOOP;
               END IF;                                                                                 /* end if of v_cz_ui_nodes_new_tbl.COUNT > 0 */
            END LOOP;
         END IF;                                                                              /* end if of cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0 */

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end bulk collect of cz_ui_nodes');
         END IF;

         ----intl texts of ui nodes
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start insert_intl_texts caption ids of ui nodes');
         END IF;

         insert_intl_texts(cz_pb_mgr.v_cz_ui_nodes_capt_id_ref, 'Caption ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end insert_intl_texts caption ids of ui nodes');
         END IF;

         -----resolve caption ids
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start resolve_intl_texts caption ids of ui nodes');
         END IF;

         resolve_intl_texts(cz_pb_mgr.v_cz_ui_nodes_capt_id_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'caption ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_intl_texts caption ids of ui nodes');
         END IF;

         -----insert tool tip ids
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start insert_intl_texts Tool tip ids of ui nodes');
         END IF;

         insert_intl_texts(cz_pb_mgr.v_cz_ui_nodes_tool_id_ref, 'Tool tip ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end insert_intl_texts Tool tip ids of ui nodes');
         END IF;

         ---------resolve tool tip ids
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start resolve_intl_texts tool tip ids of ui nodes');
         END IF;

         resolve_intl_texts(cz_pb_mgr.v_cz_ui_nodes_tool_id_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'tool tip ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_intl_texts tool tip ids of ui nodes');
         END IF;

         ---------resolve ui def ids of ui nodes
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start resolve_ids ui def ids of ui nodes');
         END IF;

         resolve_ids(cz_pb_mgr.v_cz_ui_nodes_ui_def_id_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids ui def ids of ui nodes');
         END IF;

         ---------resolve parent ids of ui nodes
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start resolve_ids parent ids of ui nodes');
         END IF;

         resolve_ids(cz_pb_mgr.v_cz_ui_nodes_parent_id_ref, cz_pb_mgr.v_cz_ui_nodes_idx_ref, 'parent ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids parent ids of ui nodes');
         END IF;

         ---------resolve ui node ref ids of ui nodes
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start resolve_ids ui node ref ids of ui nodes');
         END IF;

         resolve_ids(cz_pb_mgr.v_cz_ui_nodes_ui_ref_id_ref, cz_pb_mgr.v_cz_ui_nodes_idx_ref, 'ui node ref ids of ui nodes', FLD_IGNORE_NOW);

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids ui node ref ids of ui nodes');
         END IF;

         ---------resolve ps node ref ids of ui nodes
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start resolve_ids ps node ids of ui nodes');
         END IF;

         resolve_ids(cz_pb_mgr.v_cz_ui_nodes_ps_node_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'ps node ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids ps node ids of ui nodes');
         END IF;

         ---------resolve component ids of ui nodes
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start resolve_ids component ids of ui nodes');
         END IF;

         resolve_ids(cz_pb_mgr.v_cz_ui_nodes_component_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'component ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids component ids of ui nodes');
            log_timing_message('start resolve_ids model ref expl id of cz_ui nodes');
         END IF;

         resolve_ids(cz_pb_mgr.v_cz_ui_nodes_expl_id_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'model ref expl id of cz_ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids model ref expl id of cz_ui nodes');
            log_timing_message('start resolve_ids func comp ids of ui nodes');
         END IF;

         ---------resolve func comp ids of ui nodes
         resolve_ids(cz_pb_mgr.v_cz_ui_nodes_fcomp_id_ref, cz_pb_mgr.v_cz_func_comp_idx_ref, 'func comp ids of ui nodes');

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ids func comp ids of ui nodes');
            log_timing_message('start resolve_ref_ids_not_found');
         END IF;

         ---------resolve ui_def_ref_id
         -- should call resolve_ids instead
         resolve_ref_ids_not_found(cz_pb_mgr.v_cz_ui_nodes_new_ref
                                  ,cz_pb_mgr.v_cz_ui_defs_old_ref
                                  ,cz_pb_mgr.v_cz_ui_defs_idx_ref
                                  ,cz_pb_mgr.v_cz_ui_nodes_ui_dref_id_ref
                                  ,'cz_ui_nodes.ui_def_ref_id'
                                  ,cz_pb_mgr.v_status_code
                                  );

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_ref_ids_not_found');
            log_timing_message('start resolve_remote_ui_nodes');
         END IF;

         ----------resolve remote ui_node_ids
         resolve_remote_ui_nodes(cz_pb_mgr.v_cz_ui_nodes_new_ref
                                ,cz_pb_mgr.v_models_not_to_be_exported
                                ,cz_pb_mgr.v_cz_ui_nodes_ui_ref_id_ref
                                ,cz_pb_mgr.v_server_id
                                ,cz_pb_mgr.v_status_code
                                );

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end resolve_remote_ui_nodes');
         END IF;

         --------populate plsql_table_list for ui_nodes
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'ui_node_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_new_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ui_def_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_ui_def_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'parent_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_parent_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'component_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_component_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ps_node_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_ps_node_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ui_node_ref_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_ui_ref_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ui_def_ref_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_ui_dref_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'func_comp_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_fcomp_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'model_ref_expl_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_expl_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'caption_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_capt_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'tool_tip_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_ui_nodes_tool_id_ref';

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start insert_into_table cz_ui_nodes');
         END IF;

         -----------insert into cz_ui_nodes of target server
         insert_into_table('cz_ui_nodes'
                          ,'ui_node_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.v_cz_ui_nodes_old_ref'
                          ,cz_pb_mgr.v_cz_ui_nodes_old_ref
                          );

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end insert_into_table cz_ui_nodes');
         END IF;

         --------populate plsql_table_list for ui_node_props
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start insert_into_table cz_ui_node_props');
         END IF;

         insert_ui_node_props(cz_pb_mgr.v_cz_ui_defs_old_ref);

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end insert_into_table cz_ui_node_props');
         END IF;

         -------------release local pl/sql tables
         v_cz_ui_nodes_new_tbl.DELETE;
         v_cz_ui_nodes_old_tbl.DELETE;
         v_cz_ui_nodes_ui_def_id_tbl.DELETE;
         v_cz_ui_nodes_parent_id_tbl.DELETE;
         v_cz_ui_nodes_ui_ref_id_tbl.DELETE;
         v_cz_ui_nodes_ps_node_id_tbl.DELETE;
         v_cz_ui_nodes_component_id_tbl.DELETE;
         v_cz_ui_nodes_ui_dref_id_tbl.DELETE;
         v_cz_ui_nodes_expl_id_tbl.DELETE;
         v_cz_ui_nodes_fcomp_id_tbl.DELETE;

   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         x_status := PUBLICATION_ERROR;
         RAISE pb_upload_ui_schema;
   END upload_ui_schema;  /* end of upload of UI schema */

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------procedure to upload item sub-schema
   PROCEDURE upload_item_schema(p_ps_nodes_array IN OUT NOCOPY cz_pb_mgr.t_ref, x_status IN OUT NOCOPY VARCHAR2)
   AS
      v_property_count PLS_INTEGER := 0;
      rec_count PLS_INTEGER := 0;
      v_remote_prop_tbl cz_pb_mgr.t_ref;
      l_data_type_tbl cz_pb_mgr.t_ref;
      l_def_num_value_tbl cz_pb_mgr.t_ref;
      l_old_psnode_id NUMBER;
   BEGIN

      ------------------insert data into cz_ps_prop_vals
      clear_tables('cz_ps_prop_vals', 'ref', cz_pb_mgr.v_status_code);
      get_all_properties;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end bulk collect from cz_psnode_propval_v');
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve psnodes of prop vals');
      END IF;

      -----resolve psnodes of prop vals
      resolve_ids(cz_pb_mgr.v_prop_vals_node_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'ps node id of prop vals');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve psnodes of prop vals');
      END IF;

      ----resolve prop num value for translatable text props
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve prop num value');
      END IF;

      IF (cz_pb_mgr.v_prop_vals_data_num_ref.COUNT > 0 AND
         (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model OR cz_pb_mgr.v_server_id = 0)) THEN
         FOR intltext IN cz_pb_mgr.v_prop_vals_data_num_ref.FIRST .. cz_pb_mgr.v_prop_vals_data_num_ref.LAST
         LOOP
            IF  cz_pb_mgr.v_prop_vals_data_typ_ref(intltext) = 8 AND
               (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model OR
                cz_pb_mgr.v_prop_vals_valuesource_ref(intltext) = 'PsValue') THEN
               rec_count := rec_count + 1;
               cz_pb_mgr.v_prop_vals_intl_text_ref(rec_count) := cz_pb_mgr.v_prop_vals_data_num_ref(intltext);
            END IF;
         END LOOP;
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve prop num value');
      END IF;

/*insert tranlateable property related intls for publication or local migration. Remote Migration will be dealt separately*/
      -- v_prop_vals_intl_text_ref not used by remote migration
      IF cz_pb_mgr.v_prop_vals_intl_text_ref.COUNT > 0 THEN

        IF (cz_pb_mgr.g_log_timing = publication_timing)
        THEN
           log_timing_message('start insert texts for prop num value');
        END IF;

        insert_intl_texts(cz_pb_mgr.v_prop_vals_intl_text_ref, 'prop num value of cz prop vals');

        IF (cz_pb_mgr.g_log_timing = publication_timing)
        THEN
           log_timing_message('end insert texts for prop num value');
        END IF;

        IF (cz_pb_mgr.g_log_timing = publication_timing)
        THEN
           log_timing_message('start resolve cz_pb_mgr.v_prop_vals_data_num_ref');
        END IF;

        IF (cz_pb_mgr.v_prop_vals_data_num_ref.COUNT > 0)
        THEN
           FOR intltext IN cz_pb_mgr.v_prop_vals_data_num_ref.FIRST .. cz_pb_mgr.v_prop_vals_data_num_ref.LAST
           LOOP
              IF  cz_pb_mgr.v_prop_vals_data_typ_ref(intltext) = 8 AND
                  cz_pb_mgr.v_prop_vals_data_num_ref(intltext) IS NOT NULL AND
                 (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model OR
                  cz_pb_mgr.v_prop_vals_valuesource_ref(intltext) = 'PsValue') THEN
                 cz_pb_mgr.v_prop_vals_data_num_ref(intltext) := cz_pb_mgr.v_cz_intl_text_idx_ref(cz_pb_mgr.v_prop_vals_data_num_ref(intltext));
              END IF;
           END LOOP;
        END IF;
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve cz_pb_mgr.v_prop_vals_data_num_ref');
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start insert_into_ps_prop_vals');
      END IF;

      -- If this is remote model migration, we need to synchronize the properties before
      -- we insert into the target machine
      -- that will be done as part of insert item schema
      IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model OR cz_pb_mgr.v_server_id = 0) THEN
         ------insert into cz_ps_prop_vals
         IF cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model THEN
           insert_into_ps_prop_vals;
         ELSE
           mc_insert_pspropvals;
         END IF;

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end insert_into_ps_prop_vals');
         END IF;

         ---------release pl/sql tables
         clear_tables('cz_ps_prop_vals', 'ref', cz_pb_mgr.v_status_code);
         clear_tables('cz_ps_prop_vals', 'tbl', cz_pb_mgr.v_status_code);
      END IF;

      ------------ populate item sub schema
      IF (cz_pb_mgr.v_server_id <> 0)
      THEN
         insert_item_schema;

         -- if model migration, the tables were not cleared before,
         -- they are being taken care of at this stage
         IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model)
         THEN
            ---------release pl/sql tables
            clear_tables('cz_ps_prop_vals', 'ref', cz_pb_mgr.v_status_code);
            clear_tables('cz_ps_prop_vals', 'tbl', cz_pb_mgr.v_status_code);
         END IF;

         ----------refresh model usages
         IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model)
         THEN
            load_usages;
         END IF;

         ---------delete pl/sql tables
         clear_tables('cz_item_masters', 'tbl', cz_pb_mgr.v_status_code);
         clear_tables('cz_item_masters', 'ref', cz_pb_mgr.v_status_code);
      END IF;                       /* end if of cz_pb_mgr.v_server_id <> 0 */
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         x_status := PUBLICATION_ERROR;
         RAISE pb_upload_item_schema;
   END upload_item_schema;          /* end of upload of ITEM schema */

--------------------------------------------------------------------------------
PROCEDURE copy_fce_files IS
  l_oldid_tbl  t_ref;
  l_newid_tbl  t_ref;
  l_comid_tbl  t_ref;
  l_count      PLS_INTEGER := 0;
  l_plsql_table_list cz_pb_mgr.col_plsql_table_list;
BEGIN
  FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST LOOP
    l_newid_tbl.DELETE;
    l_oldid_tbl.DELETE;
    l_comid_tbl.DELETE;

    SELECT cz_pb_mgr.sequence_generate(CZ_FCE_FILES_SEQ
                                      ,'CZ_FCE_FILES_S.NEXTVAL' || cz_pb_mgr.v_db_link
                                      ,cz_pb_mgr.v_oraclesequenceincr
                                      ),
           fce_file_id, component_id
    BULK COLLECT INTO l_newid_tbl, l_oldid_tbl, l_comid_tbl
    FROM cz_fce_files
    WHERE deleted_flag = '0' AND component_id = cz_pb_mgr.v_models_to_be_exported(i);

    IF l_newid_tbl.COUNT > 0 THEN
      FOR j IN l_newid_tbl.FIRST .. l_newid_tbl.LAST LOOP
        l_count := l_count + 1;
        cz_pb_mgr.g_fcefile_new_id_tbl(l_count) := l_newid_tbl(j);
        cz_pb_mgr.g_fcefile_old_id_tbl(l_count) := l_oldid_tbl(j);
        cz_pb_mgr.g_fcefile_compid_tbl(l_count) := l_comid_tbl(j);
      END LOOP;
    END IF;
  END LOOP;

  resolve_ids(cz_pb_mgr.g_fcefile_compid_tbl,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,'component id of fce files');

  l_plsql_table_list(1).col_name   := 'FCE_FILE_ID';
  l_plsql_table_list(1).table_name := 'cz_pb_mgr.g_fcefile_new_id_tbl';
  l_plsql_table_list(2).col_name   := 'COMPONENT_ID';
  l_plsql_table_list(2).table_name := 'cz_pb_mgr.g_fcefile_compid_tbl';

  insert_into_table('CZ_FCE_FILES'
                   ,'FCE_FILE_ID'
                   , cz_pb_mgr.v_db_link
                   , l_plsql_table_list
                   ,'cz_pb_mgr.g_fcefile_old_id_tbl'
                   , cz_pb_mgr.g_fcefile_old_id_tbl
                   );
END copy_fce_files;

----->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure to insert rules
   PROCEDURE insert_rules(p_copy_rules_flag IN VARCHAR2, p_model_root_folder_map IN cz_pb_mgr.t_ref_idx_vc2)
   IS
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      rec_count NUMBER := 0;
   BEGIN
      ---------------reason id of cz rules
      insert_intl_texts(cz_pb_mgr.v_cz_rules_rea_id_ref, 'Reason ids of cz rules');
      --------resolve reason ids
      resolve_intl_texts(cz_pb_mgr.v_cz_rules_rea_id_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'reason id of cz rules');

      ---------------unsatisfied message of cz rules
      insert_intl_texts(cz_pb_mgr.v_cz_rules_unmsg_id_ref, 'Unsatisfied message ids of cz rules');
      ---------resolve unsatisfied message ids
      resolve_intl_texts(cz_pb_mgr.v_cz_rules_unmsg_id_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'unmsg id of cz rules');

      ------------populate effectivity set ids for cz rules
      insert_eff_sets(cz_pb_mgr.v_cz_rules_eff_id_ref
                     ,cz_pb_mgr.v_cz_eff_sets_old_tbl
                     ,cz_pb_mgr.v_cz_eff_sets_new_tbl
                     ,cz_pb_mgr.v_cz_eff_sets_idx_tbl
                     ,'cz_pb_mgr.v_cz_eff_sets_old_tbl'
                     ,'cz_pb_mgr.v_cz_eff_sets_new_tbl'
                     ,'Eff sets of cz rules'
                     );

      export_signatures(cz_pb_mgr.v_cz_rules_sig_ref);
      -------------Resolve sig id of cz_rules
      resolve_ids(cz_pb_mgr.v_cz_rules_sig_ref, cz_pb_mgr.v_sig_idx_ref, 'sig id of cz rules', ENTITY_TYPE_SIGNATURE);
      ----------resolve_eff_sets;
      resolve_ids(cz_pb_mgr.v_cz_rules_eff_id_ref, cz_pb_mgr.v_cz_eff_sets_idx_tbl, 'eff sets of cz rules');

      -------------Resolve rule_folder_id of cz_rules
      -- if copy rule db setting is not yes, publishing still copies CXs and FCs but only copies
      -- the root rule folder of a model, so we will put such rules under root folder in tgt model
      -- note we do not want to leave rule folders unresolved because it may cause problem in developer
      IF cz_pb_mgr.v_session_parameter=pub_model AND p_copy_rules_flag<>'YES' THEN
        FOR i IN cz_pb_mgr.v_cz_rules_rf_id_ref.FIRST .. cz_pb_mgr.v_cz_rules_rf_id_ref.LAST LOOP
          IF cz_pb_mgr.v_cz_rules_rf_id_ref(i)<>0 THEN
            cz_pb_mgr.v_cz_rules_rf_id_ref(i):=p_model_root_folder_map(cz_pb_mgr.v_cz_rules_proj_id_ref(i));
          END IF;
        END LOOP;
      END IF;
      resolve_ids(cz_pb_mgr.v_cz_rules_rf_id_ref, cz_pb_mgr.v_cz_folders_id_idx_ref, 'rule folder ids of cz rules');

      -------------Resolve devl_project_id of cz_rules
      resolve_ids(cz_pb_mgr.v_cz_rules_proj_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'devl_project_id of cz rules');
      -------------Resolve component_id of cz_rules
      resolve_ids(cz_pb_mgr.v_cz_rules_comp_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'component_id of cz rules', FLD_RULE_COMPONENT_ID);

      -------------Resolve expl id of cz_rules
      resolve_ids(cz_pb_mgr.v_cz_rules_expl_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'expl id of cz rules');
      resolve_ids(cz_pb_mgr.v_cz_rules_ui_ref, cz_pb_mgr.v_cz_ui_defs_idx_ref, 'ui def id of cz rules');
      -------------populate plsql_table_list for cz rules
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'rule_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_rule_id_new_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'rule_folder_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_rf_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'devl_project_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_proj_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'component_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_comp_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'reason_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_rea_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'unsatisfied_msg_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_unmsg_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'effectivity_set_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_eff_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'model_ref_expl_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_expl_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'signature_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_sig_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'ui_def_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_ui_ref';
      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
        rec_count := rec_count + 1;
        plsql_table_list(rec_count).col_name := 'effective_usage_mask';
        plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_new_rul_usg_msk_tbl';
        rec_count := rec_count + 1;
        plsql_table_list(rec_count).col_name := 'persistent_rule_id';
        plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_persistent_id_ref';
      END IF;

      ------populate cz_rules
      insert_into_table('cz_rules'
			   ,'rule_id'
			   ,cz_pb_mgr.v_db_link
			   ,plsql_table_list
			   ,'cz_pb_mgr.v_cz_rules_rule_id_old_ref'
			   ,cz_pb_mgr.v_cz_rules_rule_id_old_ref
			   );

      -----insert new records into cz_rule_folders
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'rule_folder_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_rule_id_new_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'object_type';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_obj_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'devl_project_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_proj_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'parent_rule_folder_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_rf_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'effectivity_set_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_rules_eff_id_ref';
      ----------insert into cz_func_comp_specs
      insert_into_table('cz_rule_folders'
                       ,'rule_folder_id'
                       ,'object_type'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.v_cz_rules_rule_id_old_ref'
                       ,'cz_pb_mgr.v_cz_rules_obj_ref'
                       ,cz_pb_mgr.v_cz_rules_rule_id_old_ref
                       ,cz_pb_mgr.v_cz_rules_obj_ref
                       );
   END insert_rules;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE bulk_collect_archives
   IS
      l_archive_refs_tbl cz_pb_mgr.t_ref;
      l_archive_id_tbl cz_pb_mgr.t_ref;
      l_devl_proj_tbl cz_pb_mgr.t_ref;
      rec_count NUMBER := 0;
      l_archive_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
      THEN
         cz_pb_mgr.g_archive_id_old_ref.DELETE;
         cz_pb_mgr.g_devl_proj_ref.DELETE;
         cz_pb_mgr.g_devl_proj_old_ref.DELETE;
         cz_pb_mgr.g_archive_id_ref.DELETE;
         cz_pb_mgr.g_archives_idx_ref.DELETE;

         FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
         LOOP
            l_archive_refs_tbl.DELETE;
            l_devl_proj_tbl.DELETE;

            BEGIN
               SELECT archive_id, devl_project_id
               BULK COLLECT INTO l_archive_refs_tbl, l_devl_proj_tbl
                 FROM cz_archive_refs
                WHERE cz_archive_refs.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) AND cz_archive_refs.deleted_flag = record_not_deleted;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
            END;

            IF (l_archive_refs_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.g_archive_id_old_ref.COUNT;

               FOR j IN l_archive_refs_tbl.FIRST .. l_archive_refs_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  --cz_pb_mgr.g_archive_id_ref(rec_count) := l_archive_refs_tbl(j);
                  cz_pb_mgr.g_archive_id_old_ref(rec_count) := l_archive_refs_tbl(j);
                  cz_pb_mgr.g_devl_proj_ref(rec_count) := l_devl_proj_tbl(j);
                  cz_pb_mgr.g_devl_proj_old_ref(rec_count) := l_devl_proj_tbl(j);
               END LOOP;
            END IF;
         END LOOP;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_archive_refs', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.ARCHIVES', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END bulk_collect_archives;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE export_archives
   IS
      l_archives_tbl t_ref;
      l_old_archives_tbl t_ref;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      rec_count NUMBER := 0;
   BEGIN
      bulk_collect_archives;
      cz_pb_mgr.g_archives_old_ref.DELETE;
      cz_pb_mgr.g_archives_new_ref.DELETE;
      cz_pb_mgr.g_archives_idx_ref.DELETE;

      IF (cz_pb_mgr.g_archive_id_old_ref.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.g_archive_id_old_ref.FIRST .. cz_pb_mgr.g_archive_id_old_ref.LAST
         LOOP
            l_old_archives_tbl.DELETE;
            l_archives_tbl.DELETE;

            SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_archives_seq
                                              , 'cz_archives_s.nextval' || cz_pb_mgr.v_db_link
                                              ,cz_pb_mgr.v_oraclesequenceincr
                                              )
                  ,archive_id
            BULK COLLECT INTO l_archives_tbl
                  ,l_old_archives_tbl
              FROM cz_archives
             WHERE cz_archives.archive_id = cz_pb_mgr.g_archive_id_old_ref(i) AND cz_archives.deleted_flag = record_not_deleted;

            IF (l_archives_tbl.COUNT > 0)
            THEN
               FOR j IN l_archives_tbl.FIRST .. l_archives_tbl.LAST
               LOOP
                  rec_count := cz_pb_mgr.g_archives_new_ref.COUNT + 1;
                  cz_pb_mgr.g_archives_new_ref(rec_count) := l_archives_tbl(j);
                  cz_pb_mgr.g_archives_idx_ref(cz_pb_mgr.g_archive_id_old_ref(i)) := l_archives_tbl(j);
                  cz_pb_mgr.g_archives_old_ref(rec_count) := l_old_archives_tbl(j);
               END LOOP;
            END IF;
         END LOOP;

         IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
         THEN
            mm_sync_archives;
         -- resolve the array to only those that need to be inserted
         END IF;

         IF (cz_pb_mgr.v_session_parameter <> model_copy AND cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model)
         THEN
            resolve_ids(cz_pb_mgr.g_archive_id_old_ref,cz_pb_mgr.g_archive_id_ref, cz_pb_mgr.g_archives_idx_ref, 'resolve archive id of archives');

	 ELSE
    	   rec_count:=0;
    	    FOR I IN cz_pb_mgr.g_archive_id_old_ref.FIRST..cz_pb_mgr.g_archive_id_old_ref.LAST
    	     LOOP
    	      rec_count:=rec_count+1;
              cz_pb_mgr.g_archive_id_ref(rec_count):=cz_pb_mgr.g_archive_id_old_ref(i);
    	     END LOOP;
         END IF;

         IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
         THEN
            mm_insert_archives;
         ELSE
            mm_insert_archives_for_pb;
         END IF;

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end insert_into_table cz_archives');
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END export_archives;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE export_populators
   IS
      l_filter_sets_id_tbl cz_pb_mgr.t_ref;
      l_filter_sets_devl_tbl cz_pb_mgr.t_ref;
      l_filter_sets_rule_tbl cz_pb_mgr.t_ref;
      l_filter_sets_new_id_tbl cz_pb_mgr.t_ref;
      l_populators_new_id_tbl cz_pb_mgr.t_ref;
      l_populators_id_tbl cz_pb_mgr.t_ref;
      l_populators_node_tbl cz_pb_mgr.t_ref;
      l_populators_set_id_tbl cz_pb_mgr.t_ref;
      rec_flt_count NUMBER := 0;
      rec_pop_count NUMBER := 0;
      rec_count PLS_INTEGER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      IF ((cz_pb_mgr.v_session_parameter IN(model_copy, cz_model_migration_pvt.migrate_model)) AND(cz_pb_mgr.v_models_to_be_exported.COUNT > 0))
      THEN
         cz_pb_mgr.v_filter_sets_new_id_ref.DELETE;
         cz_pb_mgr.v_filter_sets_id_ref.DELETE;
         cz_pb_mgr.v_filter_sets_devl_ref.DELETE;
         cz_pb_mgr.v_filter_sets_rule_ref.DELETE;
         cz_pb_mgr.v_filter_sets_idx_ref.DELETE;

         FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
         LOOP
            l_filter_sets_new_id_tbl.DELETE;
            l_filter_sets_id_tbl.DELETE;
            l_filter_sets_devl_tbl.DELETE;
            l_filter_sets_rule_tbl.DELETE;

            BEGIN
               SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_filter_sets_seq
                                                 , 'cz_filter_sets_s.nextval' || cz_pb_mgr.v_db_link
                                                 ,cz_pb_mgr.v_oraclesequenceincr
                                                 )
                     ,filter_set_id, devl_project_id, rule_id
               BULK COLLECT INTO l_filter_sets_new_id_tbl
                     ,l_filter_sets_id_tbl, l_filter_sets_devl_tbl, l_filter_sets_rule_tbl
                 FROM cz_filter_sets
                WHERE cz_filter_sets.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) AND cz_filter_sets.deleted_flag = '0'
                AND EXISTS (SELECT NULL FROM cz_populators pop, cz_ps_nodes psn
                            WHERE pop.deleted_flag = '0' AND pop.filter_set_id = cz_filter_sets.filter_set_id
                            AND pop.owned_by_node_id = psn.ps_node_id AND psn.deleted_flag = '0');

            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_filter_sets', 'SQLERRM', SQLERRM);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.FILTERSETS', SQLCODE);
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  RAISE;
            END;

            IF (l_filter_sets_id_tbl.COUNT > 0)
            THEN
               rec_flt_count := cz_pb_mgr.v_filter_sets_id_ref.COUNT;

               FOR j IN l_filter_sets_id_tbl.FIRST .. l_filter_sets_id_tbl.LAST
               LOOP
                  rec_flt_count := rec_flt_count + 1;
                  cz_pb_mgr.v_filter_sets_new_id_ref(rec_flt_count) := l_filter_sets_new_id_tbl(j);
                  cz_pb_mgr.v_filter_sets_id_ref(rec_flt_count) := l_filter_sets_id_tbl(j);
                  cz_pb_mgr.v_filter_sets_idx_ref(l_filter_sets_id_tbl(j)) := l_filter_sets_new_id_tbl(j);
                  cz_pb_mgr.v_filter_sets_devl_ref(rec_flt_count) := l_filter_sets_devl_tbl(j);
                  cz_pb_mgr.v_filter_sets_rule_ref(rec_flt_count) := l_filter_sets_rule_tbl(j);
               END LOOP;
            END IF;
         END LOOP;

         IF (cz_pb_mgr.v_filter_sets_id_ref.COUNT > 0)
         THEN
            cz_pb_mgr.v_populators_new_id_ref.DELETE;
            cz_pb_mgr.v_populators_id_ref.DELETE;
            cz_pb_mgr.v_populators_node_ref.DELETE;
            cz_pb_mgr.v_populators_set_id_ref.DELETE;

            FOR i IN cz_pb_mgr.v_filter_sets_id_ref.FIRST .. cz_pb_mgr.v_filter_sets_id_ref.LAST
            LOOP
               l_populators_id_tbl.DELETE;
               l_populators_node_tbl.DELETE;
               l_populators_set_id_tbl.DELETE;
               l_populators_new_id_tbl.DELETE;

               BEGIN
                  SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_populators_seq
                                                    , 'cz_populators_s.nextval' || cz_pb_mgr.v_db_link
                                                    ,cz_pb_mgr.v_oraclesequenceincr
                                                    )
                        ,populator_id, owned_by_node_id, filter_set_id
                  BULK COLLECT INTO l_populators_new_id_tbl
                        ,l_populators_id_tbl, l_populators_node_tbl, l_populators_set_id_tbl
                    FROM cz_populators
                   WHERE cz_populators.filter_set_id = cz_pb_mgr.v_filter_sets_id_ref(i) AND cz_populators.deleted_flag = '0';
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     NULL;
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_populators', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.POPULATORS', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                     RAISE;
               END;

               IF (l_populators_id_tbl.COUNT > 0)
               THEN
                  rec_pop_count := cz_pb_mgr.v_populators_id_ref.COUNT;

                  FOR j IN l_populators_id_tbl.FIRST .. l_populators_id_tbl.LAST
                  LOOP
                     rec_pop_count := rec_pop_count + 1;
                     cz_pb_mgr.v_populators_new_id_ref(rec_pop_count) := l_populators_new_id_tbl(j);
                     cz_pb_mgr.v_populators_id_ref(rec_pop_count) := l_populators_id_tbl(j);
                     cz_pb_mgr.v_populators_node_ref(rec_pop_count) := l_populators_node_tbl(j);
                     cz_pb_mgr.v_populators_set_id_ref(rec_pop_count) := l_populators_set_id_tbl(j);
                  END LOOP;
               END IF;
            END LOOP;

            ------resolve devl id and rule id
            resolve_ids(cz_pb_mgr.v_filter_sets_devl_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'dev proj id of cz filter sets');
            ------resolve devl id
            resolve_ids(cz_pb_mgr.v_filter_sets_rule_ref, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'rule id of cz filter sets');
            -----resolve ps node id
            resolve_ids(cz_pb_mgr.v_populators_node_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'owned by node id of cz populators');
            -----resolve filter set id
            resolve_ids(cz_pb_mgr.v_populators_set_id_ref, cz_pb_mgr.v_filter_sets_idx_ref, 'filter set id of cz populators');
            plsql_table_list.DELETE;
            rec_count := 1;
            plsql_table_list(rec_count).col_name := 'filter_set_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_filter_sets_new_id_ref';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'devl_project_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_filter_sets_devl_ref';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'rule_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_filter_sets_rule_ref';
            insert_into_table('cz_filter_sets'
                             ,'filter_set_id'
                             ,cz_pb_mgr.v_db_link
                             ,plsql_table_list
                             ,'cz_pb_mgr.v_filter_sets_id_ref'
                             ,cz_pb_mgr.v_filter_sets_id_ref
                             );
            plsql_table_list.DELETE;
            rec_count := 1;
            plsql_table_list(rec_count).col_name := 'populator_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_populators_new_id_ref';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'owned_by_node_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_populators_node_ref';
            rec_count := rec_count + 1;
            plsql_table_list(rec_count).col_name := 'filter_set_id';
            plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_populators_set_id_ref';
            insert_into_table('cz_populators'
                             ,'populator_id'
                             ,cz_pb_mgr.v_db_link
                             ,plsql_table_list
                             ,'cz_pb_mgr.v_populators_id_ref'
                             ,cz_pb_mgr.v_populators_id_ref
                             );

            IF (cz_pb_mgr.v_populators_node_ref.COUNT > 0)
            THEN
               EXECUTE IMMEDIATE
                'BEGIN' || ' ' ||
                   'FOR i IN cz_pb_mgr.v_populators_node_ref.FIRST..cz_pb_mgr.v_populators_node_ref.LAST' || ' ' ||
                     'LOOP' || ' ' ||
                       'UPDATE cz_ps_nodes' ||  cz_pb_mgr.v_db_link  || ' ' || 't' || ' ' ||
                          'SET   t.from_populator_id = cz_pb_mgr.v_populators_new_id_ref(i) ' || ' ' ||
                          'WHERE  t.devl_project_id = cz_pb_mgr.v_filter_sets_devl_ref(i) AND' || ' ' ||
                           't.from_populator_id=cz_pb_mgr.v_populators_id_ref(i) AND' ||  ' ' ||
                           't.deleted_flag=''0''; ' || ' ' ||
                    'END LOOP;' || ' ' ||
                'END;';

               COMMIT;
            END IF;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_INSERT_ERR', 'TABLENAME', 'cz_populators', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.POPULATORS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END export_populators;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that uploads rule schema
   PROCEDURE upload_rule_schema(p_models_for_export IN OUT NOCOPY cz_pb_mgr.t_ref, p_copy_rules_flag IN VARCHAR2, x_status IN OUT NOCOPY VARCHAR2)
   AS
      rec_count PLS_INTEGER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      v_cz_folders_pf_id_tbl cz_pb_mgr.t_ref;
      v_cz_folders_pj_id_tbl cz_pb_mgr.t_ref;
      v_cz_express_proj_id_tbl cz_pb_mgr.t_ref;
      v_cz_enodes_expr_id_tbl cz_pb_mgr.t_ref;
      v_cz_des_feature_id_old_tbl cz_pb_mgr.t_ref;
      v_cz_des_feature_rule_id_tbl cz_pb_mgr.t_ref;
      v_cz_des_feature_mrefl_id_tbl cz_pb_mgr.t_ref;
      v_cz_des_feature_ft_typ_tbl cz_pb_mgr.t_ref;
      v_cz_des_cells_rule_id_tbl cz_pb_mgr.t_ref;
      v_cz_des_cells_sf_id_tbl cz_pb_mgr.t_ref;
      v_cz_des_cells_sopt_id_tbl cz_pb_mgr.t_ref;
      v_cz_des_cells_popt_id_tbl cz_pb_mgr.t_ref;
      v_cz_des_cells_sexpl_id_tbl cz_pb_mgr.t_ref;
      v_cz_des_cells_mark_char_tbl cz_pb_mgr.exprflgtype;
      v_cz_rule_folders_orig_tbl cz_pb_mgr.orig_sys_ref_type;
      v_cz_rule_folders_eff_tbl cz_pb_mgr.t_ref;
      v_sig_count NUMBER := 0;
      v_object_type_tbl cz_pb_mgr.objtype;
      rec_count_rsq NUMBER := 0;
      v_rule_type_tbl cz_pb_mgr.t_ref;
      v_model_root_folder_map  cz_pb_mgr.t_ref_idx_vc2;

PROCEDURE mm_resolve_rule_fks(px_fk_tbl IN OUT NOCOPY t_ref, p_id_map t_ref_idx_vc2, p_ruleid_tbl IN t_ref, p_colname IN VARCHAR2)
IS
BEGIN
  IF px_fk_tbl.COUNT=0 THEN RETURN; END IF;

  FOR i IN px_fk_tbl.FIRST .. px_fk_tbl.LAST LOOP
    IF px_fk_tbl(i) IS NOT NULL THEN
      BEGIN
        px_fk_tbl(i) := p_id_map(px_fk_tbl(i));
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
          FOR j IN (SELECT rule.name rulename, prj.name prjname
                    FROM cz_rules rule, cz_devl_projects prj
                    WHERE rule.rule_id=p_ruleid_tbl(i) AND rule.devl_project_id=prj.devl_project_id) LOOP
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_MIGR_RULE_ERR', 'FK_COL', p_colname, 'RULE_NAME', j.rulename, 'MODEL_NAME', j.prjname);
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'upload_rule_schema.mm_resolve_rule_fks', SQLCODE);
          END LOOP;
          RAISE;
      END;
    END IF;
  END LOOP;
END mm_resolve_rule_fks;

   BEGIN
      --------------populate ps nodes pl/sql table with ps node ids from remote server
      get_rem_nodes_of_models(cz_pb_mgr.v_models_not_to_be_exported
                             ,cz_pb_mgr.v_cz_ps_nodes_idx_tbl
                             ,cz_pb_mgr.v_status_code
                             );
      -------insert into cz_rule_folders
      clear_tables('cz_rule_folders', 'ref', cz_pb_mgr.v_status_code);
      mm_v_tbl_rule_seq.DELETE;

      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
         LOOP
            clear_tables('cz_rule_folders', 'tbl', cz_pb_mgr.v_status_code);
            v_cz_folders_pf_id_tbl.DELETE;
            v_cz_folders_pj_id_tbl.DELETE;
            v_cz_rule_folders_orig_tbl.DELETE;
            v_cz_rule_folders_eff_tbl.DELETE;
            v_object_type_tbl.DELETE;

            BEGIN
               IF (cz_pb_mgr.v_session_parameter = model_copy)
               THEN
		 IF (p_copy_rules_flag = 'YES') THEN
                  SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_rule_folders_seq
                                                    , 'cz_rule_folders_s.nextval' || cz_pb_mgr.v_db_link
                                                    ,cz_pb_mgr.v_oraclesequenceincr
                                                    )
                        ,rule_folder_id, parent_rule_folder_id, devl_project_id, effectivity_set_id
                        ,orig_sys_ref, object_type
                  BULK COLLECT INTO cz_pb_mgr.v_cz_folders_id_new_tbl
                        ,cz_pb_mgr.v_cz_folders_id_old_tbl, v_cz_folders_pf_id_tbl, v_cz_folders_pj_id_tbl, v_cz_rule_folders_orig_tbl
                        ,v_cz_rule_folders_eff_tbl, v_object_type_tbl
                    FROM cz_rule_folders t
                   WHERE t.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) AND t.deleted_flag = '0' AND t.object_type IN('RFL', 'RSQ');
                  ELSE -- Just create the Model Rule Folder if not copying rules
                    SELECT cz_pb_mgr.sequence_generate(
                             cz_pb_mgr.cz_rule_folders_seq,
                             'cz_rule_folders_s.nextval' || cz_pb_mgr.v_db_link,
                             cz_pb_mgr.v_oraclesequenceincr
                           ),
                           rule_folder_id, parent_rule_folder_id, devl_project_id, effectivity_set_id,orig_sys_ref, object_type
                    BULK COLLECT INTO cz_pb_mgr.v_cz_folders_id_new_tbl, cz_pb_mgr.v_cz_folders_id_old_tbl, v_cz_folders_pf_id_tbl,
                           v_cz_folders_pj_id_tbl, v_cz_rule_folders_orig_tbl, v_cz_rule_folders_eff_tbl, v_object_type_tbl
                    FROM   cz_rule_folders t
                    WHERE  t.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i)
                    AND    t.deleted_flag = '0'
                    AND    t.parent_rule_folder_id IS NULL
                    AND    t.object_type = 'RFL';
		  END IF;
               ELSE
                  IF (p_copy_rules_flag = 'YES')
                  THEN
                     SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_rule_folders_seq
                                                       , 'cz_rule_folders_s.nextval' || cz_pb_mgr.v_db_link
                                                       ,cz_pb_mgr.v_oraclesequenceincr
                                                       )
                           ,rule_folder_id, parent_rule_folder_id, devl_project_id, effectivity_set_id
                           ,orig_sys_ref, object_type
                     BULK COLLECT INTO cz_pb_mgr.v_cz_folders_id_new_tbl
                           ,cz_pb_mgr.v_cz_folders_id_old_tbl, v_cz_folders_pf_id_tbl, v_cz_folders_pj_id_tbl, v_cz_rule_folders_eff_tbl
                           ,v_cz_rule_folders_orig_tbl, v_object_type_tbl
                       FROM cz_rule_folders t
                      WHERE t.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i)
                        AND t.deleted_flag = '0'
                        AND t.object_type IN('RFL', 'RSQ');
                  ELSE -- Just create the Model Rule Folder if not copying rules
                    SELECT cz_pb_mgr.sequence_generate(
                             cz_pb_mgr.cz_rule_folders_seq,
                             'cz_rule_folders_s.nextval' || cz_pb_mgr.v_db_link,
                             cz_pb_mgr.v_oraclesequenceincr
                           ), rule_folder_id, parent_rule_folder_id, devl_project_id, effectivity_set_id, orig_sys_ref, object_type
                    BULK COLLECT INTO cz_pb_mgr.v_cz_folders_id_new_tbl, cz_pb_mgr.v_cz_folders_id_old_tbl, v_cz_folders_pf_id_tbl,
                           v_cz_folders_pj_id_tbl, v_cz_rule_folders_eff_tbl, v_cz_rule_folders_orig_tbl, v_object_type_tbl
                    FROM   cz_rule_folders t
                    WHERE  t.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i)
                    AND    t.deleted_flag = '0'
                    AND    t.parent_rule_folder_id IS NULL
                    AND    t.object_type = 'RFL';
                  END IF;
               END IF;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  cz_pb_mgr.v_err_message := SUBSTR(SQLERRM, 1, 2000);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RULEFOLDERS', SQLCODE);
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_rule_folders', 'SQLERRM', SQLERRM);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RULEFOLDERS', SQLCODE);
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  RAISE;
            END;

            rec_count := cz_pb_mgr.v_cz_folders_id_new_ref.COUNT;
            rec_count_rsq := mm_v_tbl_rule_seq.COUNT;

            IF (cz_pb_mgr.v_cz_folders_id_new_tbl.COUNT > 0)
            THEN
               FOR k IN cz_pb_mgr.v_cz_folders_id_new_tbl.FIRST .. cz_pb_mgr.v_cz_folders_id_new_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.v_cz_folders_id_new_ref(rec_count) := cz_pb_mgr.v_cz_folders_id_new_tbl(k);
                  cz_pb_mgr.v_cz_folders_id_old_ref(rec_count) := cz_pb_mgr.v_cz_folders_id_old_tbl(k);
                  cz_pb_mgr.v_cz_folders_id_idx_ref(cz_pb_mgr.v_cz_folders_id_old_tbl(k)):=cz_pb_mgr.v_cz_folders_id_new_tbl(k);
                  cz_pb_mgr.v_cz_folders_pf_id_ref(rec_count) := v_cz_folders_pf_id_tbl(k);
                  cz_pb_mgr.v_cz_folders_pj_id_ref(rec_count) := v_cz_folders_pj_id_tbl(k);
                  cz_pb_mgr.v_cz_folders_eff_ref(rec_count) := v_cz_rule_folders_eff_tbl(k);
                  cz_pb_mgr.v_cz_folders_orig_ref(rec_count) := v_cz_rule_folders_orig_tbl(k);
                  cz_pb_mgr.v_cz_folders_obj_ref(rec_count) := v_object_type_tbl(k);

                  IF cz_pb_mgr.v_session_parameter=pub_model AND p_copy_rules_flag<>'YES' THEN
                    v_model_root_folder_map(cz_pb_mgr.v_models_to_be_exported(i)):=v_cz_folders_id_old_tbl(k);
                  END IF;

                  IF (v_object_type_tbl(k) = 'RSQ')
                  THEN
                     rec_count_rsq := rec_count_rsq + 1;
                     mm_v_tbl_rule_seq(rec_count_rsq) := v_cz_folders_id_old_tbl(k);
                  END IF;
               END LOOP;
            END IF;
         END LOOP;      /* end loop of FOR I IN cz_pb_mgr.v_models_to_be_exported */
      END IF;           /* end if of cz_pb_mgr.v_models_to_be_exported.COUNT > 0 */

      -----resolve parent rule folder id and devl proj id
      resolve_ids(cz_pb_mgr.v_cz_folders_pf_id_ref, cz_pb_mgr.v_cz_folders_id_idx_ref, 'parent folder id of rule folders');
      resolve_ids(cz_pb_mgr.v_cz_folders_pj_id_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'devl proj id of rule folders');
      insert_eff_sets(cz_pb_mgr.v_cz_folders_eff_ref
                     ,cz_pb_mgr.v_cz_eff_sets_old_tbl
                     ,cz_pb_mgr.v_cz_eff_sets_new_tbl
                     ,cz_pb_mgr.v_cz_eff_sets_idx_tbl
                     ,'cz_pb_mgr.v_cz_eff_sets_old_tbl'
                     ,'cz_pb_mgr.v_cz_eff_sets_new_tbl'
                     ,'Eff sets of rule folders'
                     );
      resolve_ids(cz_pb_mgr.v_cz_folders_eff_ref, cz_pb_mgr.v_cz_eff_sets_idx_tbl, 'eff id of rule folders');
      -----insert new records into cz_rule_folders
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'rule_folder_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_folders_id_new_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'object_type';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_folders_obj_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'devl_project_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_folders_pj_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'parent_rule_folder_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_folders_pf_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'effectivity_set_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_folders_eff_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'orig_sys_ref';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_folders_orig_ref';
      insert_into_table('cz_rule_folders'
                       ,'rule_folder_id'
                       ,'object_type'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.v_cz_folders_id_old_ref'
                       ,'cz_pb_mgr.v_cz_folders_obj_ref'
                       ,cz_pb_mgr.v_cz_folders_id_old_ref
                       ,cz_pb_mgr.v_cz_folders_obj_ref
                       );

      --------release local pl/sql tables of rule folders
      v_cz_folders_pf_id_tbl.DELETE;
      v_cz_folders_pj_id_tbl.DELETE;
      v_cz_rule_folders_eff_tbl.DELETE;
      v_cz_rule_folders_orig_tbl.DELETE;
      clear_tables('cz_rule_folders', 'tbl', cz_pb_mgr.v_status_code);

      -------------insert into func comp specs
     IF cz_pb_mgr.v_cz_func_comp_old_ref.COUNT > 0 THEN
      IF cz_pb_mgr.v_session_parameter=pub_model AND p_copy_rules_flag<>'YES' THEN
        FOR i IN cz_pb_mgr.v_cz_func_fld_old_ref.FIRST .. cz_pb_mgr.v_cz_func_fld_old_ref.LAST LOOP
          IF cz_pb_mgr.v_cz_func_fld_old_ref(i) IS NOT NULL THEN
            cz_pb_mgr.v_cz_func_fld_old_ref(i):=v_model_root_folder_map(cz_pb_mgr.v_cz_func_devl_old_ref(i));
          END IF;
        END LOOP;
      END IF;
      resolve_ids(cz_pb_mgr.v_cz_func_fld_old_ref, cz_pb_mgr.v_cz_folders_id_idx_ref, 'rule folder id of cz_func_comp_specs');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start resolve_ids devl project id of cz_func_comp_specs');
      END IF;

      resolve_ids(cz_pb_mgr.v_cz_func_devl_old_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'devl project id of cz_func_comp_specs');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ids devl project id of cz_func_comp_specs');
         log_timing_message('start resolve_ids component id of cz_func_comp_specs');
      END IF;

      resolve_ids(cz_pb_mgr.v_cz_func_cid_old_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'component id of cz_func_comp_specs', FLD_RULE_COMPONENT_ID);

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ids component id of cz_func_comp_specs');
         log_timing_message('start resolve_ids model ref expl id of cz_funce_comp_specs');
      END IF;

      resolve_ids(cz_pb_mgr.v_cz_func_expl_old_ref, cz_pb_mgr.v_cz_model_ref_expls_idx_ref, 'model ref expl id of cz_func_comp_specs');

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end resolve_ids model ref expl id of cz_funce_comp_specs');
      END IF;

      --------populate plsql_table_list for cz func comp specs
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'func_comp_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_comp_new_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'devl_project_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_devl_old_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'component_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_cid_old_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'model_ref_expl_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_expl_old_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'rule_folder_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_fld_old_ref';

      ----------insert into cz_func_comp_specs
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start insert_into_table cz_func_comp_specs');
      END IF;

      insert_into_table('cz_func_comp_specs'
                       ,'func_comp_id'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.v_cz_func_comp_old_ref'
                       ,cz_pb_mgr.v_cz_func_comp_old_ref
                       );

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end insert_into_table cz_func_comp_specs');
      END IF;

      -----insert new records into cz_rule_folders
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'rule_folder_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_comp_new_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'object_type';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_obj_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'devl_project_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_devl_old_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'parent_rule_folder_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_func_fld_old_ref';
      ----------insert into cz_func_comp_specs
      insert_into_table('cz_rule_folders'
                       ,'rule_folder_id'
                       ,'object_type'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.v_cz_func_comp_old_ref'
                       ,'cz_pb_mgr.v_cz_func_obj_ref'
                       ,cz_pb_mgr.v_cz_func_comp_old_ref
                       ,cz_pb_mgr.v_cz_func_obj_ref
                       );
     END IF;

      -----export archives
      export_archives;
      export_populators;

      IF cz_pb_mgr.v_cz_rules_rule_id_old_ref.COUNT > 0 THEN
        insert_rules(p_copy_rules_flag, v_model_root_folder_map);
      END IF;

      IF cz_pb_mgr.v_session_parameter = pub_model THEN
        IF g_engine_type = ENGINE_TYPE_FCE THEN
          copy_fce_files;
        ELSE
          copy_lce_headers;
          copy_lce_texts(p_copy_rules_flag);
        END IF;
      END IF;

         ---------------local pl/sql tables of cz rules released after populating rule sub schema
         -------------insert expressions
         IF (cz_pb_mgr.v_cz_rules_rule_id_old_ref.COUNT > 0)
         THEN
            FOR m IN cz_pb_mgr.v_cz_rules_rule_id_old_ref.FIRST .. cz_pb_mgr.v_cz_rules_rule_id_old_ref.LAST
            LOOP
               clear_tables('cz_expression_nodes', 'tbl', cz_pb_mgr.v_status_code);

               BEGIN
                  IF (cz_pb_mgr.v_session_parameter IN(model_copy, cz_model_migration_pvt.migrate_model))
                  THEN
                     SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_expression_nodes_seq
                                                       , 'cz_expression_nodes_s.nextval' || cz_pb_mgr.v_db_link
                                                       ,cz_pb_mgr.v_oraclesequenceincr
                                                       )
                           ,expr_node_id, ps_node_id, expr_parent_id
                           ,decode(model_ref_expl_id,-1,null,model_ref_expl_id), rule_id, argument_signature_id
                           ,param_signature_id,property_id
                     BULK COLLECT INTO cz_pb_mgr.v_cz_enodes_enode_id_new_tbl
                           ,cz_pb_mgr.v_cz_enodes_enode_id_old_tbl, cz_pb_mgr.v_cz_enodes_psnode_id_tbl, cz_pb_mgr.v_cz_enodes_pexpr_id_tbl
                           ,cz_pb_mgr.v_cz_enodes_mrefl_id_tbl, cz_pb_mgr.v_cz_enodes_rule_id_tbl, cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl
                           ,cz_pb_mgr.v_cz_enodes_par_sig_id_tbl
                           ,cz_pb_mgr.v_cz_enodes_prop_id_tbl
                       FROM cz_expression_nodes t
                      WHERE t.rule_id = cz_pb_mgr.v_cz_rules_rule_id_old_ref(m) AND t.deleted_flag = '0';
                  ELSE
                     SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_expression_nodes_seq
                                                       , 'cz_expression_nodes_s.nextval' || cz_pb_mgr.v_db_link
                                                       ,cz_pb_mgr.v_oraclesequenceincr
                                                       )
                           ,expr_node_id, ps_node_id, expr_parent_id
                           ,decode(model_ref_expl_id,-1,null,model_ref_expl_id), rule_id, argument_signature_id
                           ,param_signature_id
                     BULK COLLECT INTO cz_pb_mgr.v_cz_enodes_enode_id_new_tbl
                           ,cz_pb_mgr.v_cz_enodes_enode_id_old_tbl, cz_pb_mgr.v_cz_enodes_psnode_id_tbl, cz_pb_mgr.v_cz_enodes_pexpr_id_tbl
                           ,cz_pb_mgr.v_cz_enodes_mrefl_id_tbl, cz_pb_mgr.v_cz_enodes_rule_id_tbl, cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl
                           ,cz_pb_mgr.v_cz_enodes_par_sig_id_tbl
                       FROM cz_expression_nodes t
                      WHERE t.rule_id = cz_pb_mgr.v_cz_rules_rule_id_old_ref(m) AND t.deleted_flag = '0' AND t.expr_type <> 208;
                  END IF;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := SUBSTR(SQLERRM, 1, 2000);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.EXPRNODES', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_expression_nodes', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.EXPRNODES', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                     RAISE;
               END;

               rec_count := cz_pb_mgr.v_cz_enodes_enode_id_new_ref.COUNT;

               IF (cz_pb_mgr.v_cz_enodes_enode_id_new_tbl.COUNT > 0)
               THEN
                  FOR i IN cz_pb_mgr.v_cz_enodes_enode_id_new_tbl.FIRST .. cz_pb_mgr.v_cz_enodes_enode_id_new_tbl.LAST
                  LOOP
                     rec_count := rec_count + 1;
                     cz_pb_mgr.v_cz_enodes_enode_id_new_ref(rec_count) := cz_pb_mgr.v_cz_enodes_enode_id_new_tbl(i);
                     cz_pb_mgr.v_cz_enodes_enode_id_old_ref(rec_count) := cz_pb_mgr.v_cz_enodes_enode_id_old_tbl(i);
                     cz_pb_mgr.v_cz_enodes_enode_id_idx_ref(cz_pb_mgr.v_cz_enodes_enode_id_old_tbl(i)):=cz_pb_mgr.v_cz_enodes_enode_id_new_tbl(i);
                     cz_pb_mgr.v_cz_enodes_psnode_id_ref(rec_count) := cz_pb_mgr.v_cz_enodes_psnode_id_tbl(i);
                     cz_pb_mgr.v_cz_enodes_pexpr_id_ref(rec_count) := cz_pb_mgr.v_cz_enodes_pexpr_id_tbl(i);
                     cz_pb_mgr.v_cz_enodes_mrefl_id_ref(rec_count) := cz_pb_mgr.v_cz_enodes_mrefl_id_tbl(i);
                     cz_pb_mgr.v_cz_enodes_rule_id_ref(rec_count) := cz_pb_mgr.v_cz_enodes_rule_id_tbl(i);
                     cz_pb_mgr.v_cz_enodes_arg_sig_id_ref(rec_count) := cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl(i);
                     cz_pb_mgr.v_cz_enodes_par_sig_id_ref(rec_count) := cz_pb_mgr.v_cz_enodes_par_sig_id_tbl(i);

                     IF (cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model)
                     THEN
                      cz_pb_mgr.v_cz_enodes_prop_id_ref(rec_count):=cz_pb_mgr.v_cz_enodes_prop_id_tbl(i);
                     END IF;

                     IF (cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl(i) IS NOT NULL)
                     THEN
                        IF (NOT cz_pb_mgr.v_cz_expr_sig_ref.EXISTS(cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl(i)))
                        THEN
                           v_sig_count := cz_pb_mgr.v_cz_expr_sig_ref.COUNT + 1;
                           cz_pb_mgr.v_cz_expr_sig_ref(v_sig_count) := cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl(i);
                           cz_pb_mgr.v_cz_expr_sig_idx_ref(cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl(i)) := cz_pb_mgr.v_cz_enodes_arg_sig_id_tbl(i);
                        END IF;
                     END IF;

                     IF (cz_pb_mgr.v_cz_enodes_par_sig_id_tbl(i) IS NOT NULL)
                     THEN
                        IF (NOT cz_pb_mgr.v_cz_expr_sig_ref.EXISTS(cz_pb_mgr.v_cz_enodes_par_sig_id_tbl(i)))
                        THEN
                           v_sig_count := cz_pb_mgr.v_cz_expr_sig_ref.COUNT + 1;
                           cz_pb_mgr.v_cz_expr_sig_ref(v_sig_count) := cz_pb_mgr.v_cz_enodes_par_sig_id_tbl(i);
                           cz_pb_mgr.v_cz_expr_sig_idx_ref(cz_pb_mgr.v_cz_enodes_par_sig_id_tbl(i)) := cz_pb_mgr.v_cz_enodes_par_sig_id_tbl(i);
                        END IF;
                     END IF;
                  END LOOP;
               END IF;
            END LOOP;                                                           /* end loop of */
         END IF;  -- end cz_pb_mgr.v_cz_rules_rule_id_old_ref.COUNT > 0                                                                                                                     /* (COUNT > 0) */

         --------export_signatures
         export_signatures(cz_pb_mgr.v_cz_expr_sig_ref);
         -----------resolve parent expr node id
         resolve_ids(cz_pb_mgr.v_cz_enodes_pexpr_id_ref, cz_pb_mgr.v_cz_enodes_enode_id_idx_ref, 'parent expr ids of expression nodes', FLD_IGNORE_NOW);
         -------resolve sig ids
         resolve_ids(cz_pb_mgr.v_cz_enodes_arg_sig_id_ref, cz_pb_mgr.v_sig_idx_ref, 'arg sig ids cz expr nodes', ENTITY_TYPE_SIGNATURE);
         resolve_ids(cz_pb_mgr.v_cz_enodes_par_sig_id_ref, cz_pb_mgr.v_sig_idx_ref, 'param sig ids cz expr nodes', ENTITY_TYPE_SIGNATURE);

         IF (cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id<>0) THEN
           mm_resolve_rule_fks(cz_pb_mgr.v_cz_enodes_psnode_id_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,cz_pb_mgr.v_cz_enodes_rule_id_ref,'cz_expression_nodes.ps_node_id');
           mm_resolve_rule_fks(cz_pb_mgr.v_cz_enodes_mrefl_id_ref,cz_pb_mgr.v_cz_model_ref_expls_idx_ref,cz_pb_mgr.v_cz_enodes_rule_id_ref,'cz_expression_nodes.model_ref_expl_id');
           resolve_ids(cz_pb_mgr.v_cz_enodes_prop_id_ref, cz_pb_mgr.mm_v_ht_sync_all_prop, 'property id of cz expr nodes', ENTITY_TYPE_PROPERTY);
         ELSE
           resolve_ids(cz_pb_mgr.v_cz_enodes_mrefl_id_ref,cz_pb_mgr.v_cz_model_ref_expls_idx_ref,'model ref expl id of expression nodes',FLD_IGNORE_NOW);
           resolve_ids(cz_pb_mgr.v_cz_enodes_psnode_id_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,'ps node ids of expression nodes',FLD_IGNORE_NOW);
         END IF;

         resolve_ids(cz_pb_mgr.v_cz_enodes_rule_id_ref, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'rule id of expression nodes');

         --------populate plsql_table_list for cz_expression_nodes
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'expr_node_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_enodes_enode_id_new_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'rule_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_enodes_rule_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'ps_node_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_enodes_psnode_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'expr_parent_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_enodes_pexpr_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'model_ref_expl_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_enodes_mrefl_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'argument_signature_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_enodes_arg_sig_id_ref';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'param_signature_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_enodes_par_sig_id_ref';

         IF (cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model)
         THEN
          rec_count := rec_count + 1;
          plsql_table_list(rec_count).col_name := 'property_id';
          plsql_table_list(rec_count).table_name := 'cz_pb_mgr.v_cz_enodes_prop_id_ref';
	 END IF;

         ------insert new records into cz_expression_nodes
         insert_into_table('cz_expression_nodes'
                          ,'expr_node_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.v_cz_enodes_enode_id_old_ref'
                          ,cz_pb_mgr.v_cz_enodes_enode_id_old_ref
                          );
         --------release tbl pl/sql tables of cz expression nodes
         clear_tables('cz_expression_nodes', 'tbl', cz_pb_mgr.v_status_code);

      IF (p_copy_rules_flag = 'YES') THEN

         -------------insert into cz_des_chart_features
         clear_tables('cz_des_chart_features', 'ref', cz_pb_mgr.v_status_code);

         IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
         THEN
            FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
            LOOP
               v_cz_des_feature_id_old_tbl.DELETE;
               v_cz_des_feature_rule_id_tbl.DELETE;
               v_cz_des_feature_mrefl_id_tbl.DELETE;
               v_cz_des_feature_ft_typ_tbl.DELETE;

               BEGIN
                 SELECT feature_id, rule_id, model_ref_expl_id, feature_type
                 BULK COLLECT INTO v_cz_des_feature_id_old_tbl, v_cz_des_feature_rule_id_tbl, v_cz_des_feature_mrefl_id_tbl, v_cz_des_feature_ft_typ_tbl
                 FROM cz_des_chart_features t
                 WHERE t.rule_id IN(
                               SELECT rule_id
                                 FROM cz_rules
                                WHERE cz_rules.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i)
                                  AND cz_rules.deleted_flag = '0')
                        AND t.deleted_flag = '0';
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := SUBSTR(SQLERRM, 1, 2000);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.DESCHARTFEAT', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_des_chart_features', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.DESCHARTFEAT', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                     RAISE;
               END;

               rec_count := cz_pb_mgr.v_cz_des_feature_id_old_ref.COUNT;

               IF (v_cz_des_feature_id_old_tbl.COUNT > 0)
               THEN
                  FOR k IN v_cz_des_feature_id_old_tbl.FIRST .. v_cz_des_feature_id_old_tbl.LAST
                  LOOP
                     rec_count := rec_count + 1;
                     cz_pb_mgr.v_cz_des_feature_id_old_ref(rec_count) := v_cz_des_feature_id_old_tbl(k);
                     cz_pb_mgr.v_cz_des_feature_rule_id_ref(rec_count) := v_cz_des_feature_rule_id_tbl(k);
                     cz_pb_mgr.v_cz_des_feature_rid_new_ref(rec_count) := v_cz_des_feature_rule_id_tbl(k);
                     cz_pb_mgr.v_cz_des_feature_mrefl_id_ref(rec_count) := v_cz_des_feature_mrefl_id_tbl(k);
                     cz_pb_mgr.v_cz_des_feature_ft_typ_ref(rec_count) := v_cz_des_feature_ft_typ_tbl(k);
                  END LOOP;
               END IF;
            END LOOP;                                     /* end loop of FOR I IN cz_pb_mgr.v_models_to_be_exported */
         END IF;                                          /* cz_pb_mgr.v_models_to_be_exported.COUNT > 0 */

         IF (cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id<>0) THEN
           mm_resolve_rule_fks(cz_pb_mgr.v_cz_des_feature_id_old_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,cz_pb_mgr.v_cz_des_feature_rid_new_ref,'cz_des_chart_features.feature_id');
           mm_resolve_rule_fks(cz_pb_mgr.v_cz_des_feature_mrefl_id_ref,cz_pb_mgr.v_cz_model_ref_expls_idx_ref,cz_pb_mgr.v_cz_des_feature_rid_new_ref,'cz_des_chart_features.model_ref_expl_id');
         ELSE
           resolve_ids(cz_pb_mgr.v_cz_des_feature_id_old_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,'feature id of cz_des_features',FLD_IGNORE_NOW);
           resolve_ids(cz_pb_mgr.v_cz_des_feature_mrefl_id_ref,cz_pb_mgr.v_cz_model_ref_expls_idx_ref,'model ref expl id of cz_des_features',FLD_IGNORE_NOW);
         END IF;

         resolve_ids(cz_pb_mgr.v_cz_des_feature_rid_new_ref, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'rule id of des chart features');

         ------insert new records into cz_des_chart_features
         insert_des_chart_features(cz_pb_mgr.v_status_code);
         -------------release local pl/sql tables of des chart features
         v_cz_des_feature_id_old_tbl.DELETE;
         v_cz_des_feature_rule_id_tbl.DELETE;
         v_cz_des_feature_mrefl_id_tbl.DELETE;
         v_cz_des_feature_ft_typ_tbl.DELETE;
         ------------insert into cz_des_chart_cells
         clear_tables('cz_des_chart_cells', 'ref', cz_pb_mgr.v_status_code);

         IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
         THEN
            FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
            LOOP
               v_cz_des_cells_rule_id_tbl.DELETE;
               v_cz_des_cells_sf_id_tbl.DELETE;
               v_cz_des_cells_sopt_id_tbl.DELETE;
               v_cz_des_cells_popt_id_tbl.DELETE;
               v_cz_des_cells_sexpl_id_tbl.DELETE;
               v_rule_type_tbl.DELETE;

               BEGIN
                 SELECT rul.rule_id, secondary_feature_id, primary_opt_id, secondary_opt_id
                      , secondary_feat_expl_id, mark_char, rule_type
                 BULK COLLECT INTO v_cz_des_cells_rule_id_tbl, v_cz_des_cells_sf_id_tbl, v_cz_des_cells_popt_id_tbl, v_cz_des_cells_sopt_id_tbl
                                  ,v_cz_des_cells_sexpl_id_tbl, v_cz_des_cells_mark_char_tbl, v_rule_type_tbl
                 FROM cz_rules rul, cz_des_chart_cells dcc
                 WHERE rul.deleted_flag = '0' AND rul.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i)
                 AND rul.rule_id = dcc.rule_id AND dcc.deleted_flag = '0';
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     cz_pb_mgr.v_err_message := SUBSTR(SQLERRM, 1, 2000);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.DESCELLS', SQLCODE);
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_des_chart_cells', 'SQLERRM', SQLERRM);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.DESCELLS', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                     RAISE;
               END;

               rec_count := cz_pb_mgr.v_cz_des_cells_sexpl_id_ref.COUNT;

               IF (v_cz_des_cells_rule_id_tbl.COUNT > 0)
               THEN
                  FOR k IN v_cz_des_cells_rule_id_tbl.FIRST .. v_cz_des_cells_rule_id_tbl.LAST
                  LOOP
                     rec_count := rec_count + 1;
                     cz_pb_mgr.v_cz_des_cells_rule_id_old_ref(rec_count) := v_cz_des_cells_rule_id_tbl(k);
                     cz_pb_mgr.v_cz_des_cells_rule_id_new_ref(rec_count) := v_cz_des_cells_rule_id_tbl(k);
                     cz_pb_mgr.v_cz_des_cells_sf_id_ref(rec_count) := v_cz_des_cells_sf_id_tbl(k);
                     cz_pb_mgr.v_cz_des_cells_sopt_id_ref(rec_count) := v_cz_des_cells_sopt_id_tbl(k);
                     cz_pb_mgr.v_cz_des_cells_popt_id_ref(rec_count) := v_cz_des_cells_popt_id_tbl(k);
                     cz_pb_mgr.v_cz_des_cells_sexpl_id_ref(rec_count) := v_cz_des_cells_sexpl_id_tbl(k);
                     cz_pb_mgr.v_cz_des_cells_mark_char_ref(rec_count) := v_cz_des_cells_mark_char_tbl(k);
                  END LOOP;
               END IF;
            END LOOP;                       /* end loop of FOR I IN cz_pb_mgr.v_models_to_be_exported */
         END IF;                            /* end if of cz_pb_mgr.v_models_to_be_exported.COUNT > 0 */

         resolve_ids(cz_pb_mgr.v_cz_des_cells_rule_id_new_ref, cz_pb_mgr.v_cz_rules_rule_id_idx_ref, 'rule id of des chart cells');
         resolve_ids(cz_pb_mgr.v_cz_des_cells_popt_id_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,'cz_des_chart_cells.primary_opt_id',FLD_IGNORE_NOW);

         IF (cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id<>0) THEN
           mm_resolve_rule_fks(cz_pb_mgr.v_cz_des_cells_sf_id_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,cz_pb_mgr.v_cz_des_cells_rule_id_old_ref,'cz_des_chart_cells.secondary_feature_id');
           mm_resolve_rule_fks(cz_pb_mgr.v_cz_des_cells_sopt_id_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,cz_pb_mgr.v_cz_des_cells_rule_id_old_ref,'cz_des_chart_cells.secondary_opt_id');
           mm_resolve_rule_fks(cz_pb_mgr.v_cz_des_cells_sexpl_id_ref,cz_pb_mgr.v_cz_model_ref_expls_idx_ref,cz_pb_mgr.v_cz_des_cells_rule_id_old_ref,'cz_des_chart_cells.secondary_feat_expl_id');
         ELSE
           resolve_ids(cz_pb_mgr.v_cz_des_cells_sf_id_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,'secondary feature id of cz_des_cells',FLD_IGNORE_NOW);
           resolve_ids(cz_pb_mgr.v_cz_des_cells_sopt_id_ref,cz_pb_mgr.v_cz_ps_nodes_idx_tbl,'secondary opt id of cz_des_cells',FLD_IGNORE_NOW);
           resolve_ids(cz_pb_mgr.v_cz_des_cells_sexpl_id_ref,cz_pb_mgr.v_cz_model_ref_expls_idx_ref,'secondary feat expl id of cz_des_cells',FLD_IGNORE_NOW);
         END IF;

         ------insert new records into cz_des_chart_cells
         insert_des_chart_cells(cz_pb_mgr.v_status_code);

         --during model migration, if a rule_seq has a rule whose effectivity_set_id already
         --exists on the target, then set the rule effectivity to be
         --never effective for all the rules in that rule sequence
         --do this only if there is something to resolve(mm_v_ht_eff_set_tbl_t.COUNT >0)
         IF (    (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
             AND (mm_v_tbl_rule_seq.COUNT > 0)
             AND (mm_v_ht_eff_set_tbl_t.COUNT > 0)
            )
         THEN
            mm_resolve_rule_seq_effsetid;
         END IF;

         -------------release local pl/sql tables of cz des chart cells
         v_cz_des_cells_rule_id_tbl.DELETE;
         v_cz_des_cells_sf_id_tbl.DELETE;
         v_cz_des_cells_sopt_id_tbl.DELETE;
         v_cz_des_cells_popt_id_tbl.DELETE;
         v_cz_des_cells_sexpl_id_tbl.DELETE;

      ELSE
         clear_tables('cz_lce_headers', 'ref', cz_pb_mgr.v_status_code);
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_sql_err_msg, 'cz_pb_mgr.RULESCHEMA', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE pb_upload_rule_schema;
   END upload_rule_schema;
-----------------------------------------------------------------------------------------------------
   PROCEDURE mm_raiseallpossiblesyncerrors
   AS
      v_prop_id cz_properties.property_id%TYPE;
      v_error_flag PLS_INTEGER := 0;
      v_null PLS_INTEGER;
      j PLS_INTEGER;
      v_target_item_type_name cz_item_types.name%TYPE;

      v_null_table  number_type_tbl;

   BEGIN
-- PROPERTY: check if there is atleast one property where the names match, but datatype does not
-- ITEM_TYPES: check if there are more source item properties than target item properties
-- ITEM TYPES: heck if there is atleast one item where the item_type is different
-- UI CONTENT TEMPLATES: UI Content template failure - exact match on TEMPLATE_TYPE, MESSAGE_TYPE, but mismatch
--         on either of ROOT_ELEMENT_TYPE, MAIN_MESSAGE_ID, PARENT_CONTAINER_TYPE,
--         ROOT ELEMENT SIGNATURE_ID or ROOT_REGION_CODE
-- USAGE: Name does not match, but there are already 64 Usages
      FOR i IN 1 .. v_remote_prop_ref.COUNT
      LOOP
         BEGIN
            EXECUTE IMMEDIATE    'SELECT data_type FROM cz_properties'
                              || cz_pb_mgr.v_db_link
                              || ' WHERE deleted_flag = ''0'' AND name = :1 AND NVL(src_application_id, 0) = :2'
                         INTO v_null
                        USING v_property_record_ref(v_remote_prop_ref(i)).NAME, v_property_record_ref(v_remote_prop_ref(i)).src_application_id;

            IF (v_null <> v_property_record_ref(v_remote_prop_ref(i)).data_type)
            THEN
--~> 'Property ''%PROPERTYNAME'' has a different data type on the target instance.'
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_MM_UPVAL_PROPERTY', 'PROPERTYNAME', v_property_record_ref(v_remote_prop_ref(i)).NAME);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'Upfront Validation', 70000);
               v_error_flag := 1;
            END IF;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
         END;
      END LOOP;

      FOR i IN 1 .. v_item_types_new_ref.COUNT
      LOOP
         BEGIN
            EXECUTE IMMEDIATE    'SELECT NULL FROM cz_item_types'
                              || cz_pb_mgr.v_db_link
                              || 'it '
                              || ' WHERE it.deleted_flag = ''0'''
                              || '   AND it.name = :1'
                              || '   AND NVL(it.src_application_id, 0) = :2'
                         INTO v_null
                        USING v_type_record_ref(v_item_types_new_ref(i)).NAME, v_type_record_ref(v_item_types_new_ref(i)).src_application_id;

            j := v_type_property_record_ref(v_item_types_new_ref(i)).FIRST;

            WHILE(j IS NOT NULL)
            LOOP
               BEGIN
                  EXECUTE IMMEDIATE    'SELECT NULL FROM cz_item_types'
                                    || cz_pb_mgr.v_db_link
                                    || 'it, '
                                    || '                 cz_item_type_properties'
                                    || cz_pb_mgr.v_db_link
                                    || 'tp, '
                                    || '                 cz_properties'
                                    || cz_pb_mgr.v_db_link
                                    || ' pr '
                                    || ' WHERE it.deleted_flag = ''0'''
                                    || '   AND pr.deleted_flag = ''0'''
                                    || '   AND tp.deleted_flag = ''0'''
                                    || '   AND it.item_type_id = tp.item_type_id'
                                    || '   AND pr.property_id = tp.property_id'
                                    || '   AND it.name = :1'
                                    || '   AND NVL(it.src_application_id, 0) = :2'
                                    || '   AND pr.name = :3'
                                    || '   AND NVL(pr.src_application_id, 0) = :4'
                               INTO v_null
                              USING v_type_record_ref(v_item_types_new_ref(i)).NAME
                                   ,v_type_record_ref(v_item_types_new_ref(i)).src_application_id
                                   ,v_type_property_record_ref(v_item_types_new_ref(i))(j).NAME
                                   ,v_type_property_record_ref(v_item_types_new_ref(i))(j).src_application_id;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     v_error_flag := 1;
                     --~> 'Item type ''%ITEMTYPENAME'' has a different combination of properties on the target instance.'
                     cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_MM_UPVAL_ITEMTYPE', 'ITEMTYPENAME', v_type_record_ref(v_item_types_new_ref(i)).NAME);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'Upfront Validation', 70000);
               END;

               j := v_type_property_record_ref(v_item_types_new_ref(i)).NEXT(j);
            END LOOP;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
         END;
      END LOOP;

      FOR i IN 1 .. v_item_masters_tbl.COUNT
      LOOP

         --Bug #6972667. This query can return several items with the same ref_part_nbr in different item types.
         --Judging from the SELECT NULL and empty exception block for no_data_found, the only purpose of this
         --query is to skip the second verification for items that don't exist on the target, so we can just
         --use BULK COLLECT.

         EXECUTE IMMEDIATE    'SELECT NULL FROM cz_item_masters'
                           || cz_pb_mgr.v_db_link
                           || ' it '
                           || ' WHERE it.deleted_flag = ''0'''
                           || '   AND it.ref_part_nbr = :1'
                           || '   AND NVL(it.src_application_id, 0) = :2'
                           || '   AND NVL(it.orig_sys_ref, ''0'') = :3'
                      BULK COLLECT INTO v_null_table
                     USING mm_v_itmst_ref_part_nbr_ref(i)
                         , mm_v_itmst_src_app_id_ref(i)
                         --IMPORTANT: this is bom-synchronized (if necessary) orig_sys_ref, hashed by
                         --source item_id
                         , NVL(mm_v_ht_items_orig_ref(v_item_masters_tbl(i)), '0');

         IF ( v_null_table.COUNT > 0 ) THEN

            BEGIN
               EXECUTE IMMEDIATE    'SELECT NULL FROM cz_item_masters'
                                 || cz_pb_mgr.v_db_link
                                 || ' it, '
                                 || '                 cz_item_types'
                                 || cz_pb_mgr.v_db_link
                                 || ' ip '
                                 || ' WHERE it.deleted_flag = ''0'''
                                 || '   AND ip.deleted_flag = ''0'''
                                 || '   AND it.ref_part_nbr = :1'
                                 || '   AND NVL(it.src_application_id, 0) = :2'
                                 || '   AND ip.name = :3'
                                 || '   AND NVL(ip.src_application_id, 0) = :4'
                                 || '   AND NVL(it.orig_sys_ref, ''0'') = :5'

                                  --Bug #6972667. Missing join condition.

                                 || '   AND ip.item_type_id = it.item_type_id'
                            INTO v_null
                           USING mm_v_itmst_ref_part_nbr_ref(i)
                               , mm_v_itmst_src_app_id_ref(i)
                               , v_type_record_ref(v_item_types_tbl(i)).NAME
                               , v_type_record_ref(v_item_types_tbl(i)).src_application_id
                               --IMPORTANT: this is bom-synchronized (if necessary) orig_sys_ref, hashed by
                               --source item_id
                               , NVL(mm_v_ht_items_orig_ref(v_item_masters_tbl(i)), '0');
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  v_error_flag := 1;
                  --~> 'Item ''%ITEMNAME'' has a different item type on the target instance.'
		  -- Bug 5219852; 06-Sep-2006; kdande; Modified the message to show the source and target item type names
                  EXECUTE IMMEDIATE    'SELECT ip.name FROM cz_item_masters'
                                   || cz_pb_mgr.v_db_link
                                   || ' it, cz_item_types'
                                   || cz_pb_mgr.v_db_link
                                   || ' ip '
                                   || ' WHERE it.deleted_flag = ''0'''
                                   || '   AND ip.deleted_flag = ''0'''
                                   || '   AND it.ref_part_nbr = :1'
                                   || '   AND ip.item_type_id = it.item_type_id'
                                   || '   AND NVL(it.src_application_id, 0) = :2'
                                   || '   AND NVL(it.orig_sys_ref, ''0'') = :3'
                              INTO v_target_item_type_name
                             USING mm_v_itmst_ref_part_nbr_ref(i)
                                 , mm_v_itmst_src_app_id_ref(i)
                                 --IMPORTANT: this is bom-synchronized (if necessary) orig_sys_ref, hashed by
                                 --source item_id
                                 , NVL(mm_v_ht_items_orig_ref(v_item_masters_tbl(i)), '0');
                  cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_MM_UPVAL_ITEM', 'ITEMNAME', mm_v_itmst_ref_part_nbr_ref(i),
                                             'SRCNAME', v_type_record_ref(v_item_types_tbl(i)).NAME,
					     'TGTNAME', v_target_item_type_name);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'Upfront Validation', 70000);
            END;
         END IF; --v_null_table.COUNT > 0
      END LOOP;

      IF (v_error_flag = 1)
      THEN
         RAISE cz_pb_global_synch;
      END IF;
   EXCEPTION
      WHEN cz_pb_global_synch
      THEN
         RAISE;
      WHEN OTHERS
      THEN
--~>'Unexpected error during upfront validation: %ERRORTEXT'
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_MM_UPVAL_UNEXPECTED', 'ERRORTEXT', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'Upfront Validation', 70000);
         RAISE;
   END mm_raiseallpossiblesyncerrors;
------------------------------------------------------------------------------------------------
--Bug #5186307. The bug is deferred.
/*
PROCEDURE split_item_origsysref( p_origsysref IN VARCHAR2
                               , x_item_id OUT NOCOPY NUMBER
                               , x_org_id  OUT NOCOPY NUMBER) IS
BEGIN

  --The values can only be not null valid numbers, otherwise TO_NUMBER will fail.

  x_item_id := TO_NUMBER(NVL(SUBSTR(p_origsysref, 1, INSTR(p_origsysref, ':') - 1), 'NULL'));
  x_org_id := TO_NUMBER(NVL(SUBSTR(p_origsysref, INSTR(p_origsysref, ':') + 1), 'NULL'));
END;
*/
------------------------------------------------------------------------------------------------
--Bug #5186307. The bug is deferred, the function just returns the parameter.
/*
FUNCTION synch_item_origsysref(p_origsysref IN VARCHAR2) RETURN VARCHAR2 IS

  l_item_id   NUMBER;
  l_org_id    NUMBER;
BEGIN

  IF(p_origsysref IS NULL)THEN

    --This is an item with source application INV and null orig_sys_ref. Don't do anything for now,
    --but this may be a problem. Not sure if this can happen here, may be caught earlier.

    RETURN NULL;
  END IF;

  IF(v_item_synched_osr.EXISTS(p_origsysref))THEN RETURN v_item_synched_osr(p_origsysref); END IF;

  --Just return the parameter.

  --split_item_origsysref(p_origsysref, l_item_id, l_org_id);

  v_item_synched_osr(p_origsysref) := p_origsysref;
  RETURN v_item_synched_osr(p_origsysref);
END;
*/
------------------------------------------------------------------------------------------------
--Bug #5186307. The bug is deferred, the function just returns the parameter.
/*
FUNCTION synch_itemtype_origsysref(p_origsysref IN VARCHAR2) RETURN VARCHAR2 IS

  l_catalog_id   NUMBER;
BEGIN

  IF(p_origsysref IS NULL)THEN

    --This is an item type with source application INV and null orig_sys_ref. Don't do anything for
    --now, but this may be a problem. Not sure if this can happen here, may be caught earlier.

    RETURN NULL;
  END IF;

  IF(v_itemtype_synched_osr.EXISTS(p_origsysref))THEN RETURN v_itemtype_synched_osr(p_origsysref); END IF;

  --The value can only be a valid not null number.

  l_catalog_id := TO_NUMBER(p_origsysref);

  --Just return the parameter.

  v_itemtype_synched_osr(p_origsysref) := p_origsysref;
  RETURN v_itemtype_synched_osr(p_origsysref);
END;
*/
------------------------------------------------------------------------------------------------
--This procedure reads the item/property data into the arrays, previously done by insert_item_schema,
--and performs the upfron validations for model migration.
   PROCEDURE read_item_schema
   IS
      v_cz_items_old_ref_idx_ref cz_pb_mgr.t_ref_idx_vc2;
      v_cz_types_old_ref_idx_ref cz_pb_mgr.t_ref_idx_vc2;
      v_item_types_orig_tbl cz_pb_mgr.orig_sys_ref_type;
      v_remote_prop_tbl cz_pb_mgr.t_ref;
      v_prop_type_tbl cz_pb_mgr.t_ref;
      v_prop_src_app_tbl cz_pb_mgr.t_ref;
      v_prop_name_tbl cz_pb_mgr.varchar_type_4000_tbl;
      v_type_name_tbl cz_pb_mgr.varchar_type_4000_tbl;
      v_type_src_app_tbl cz_pb_mgr.t_ref;
      v_bom_flg_tbl cz_pb_mgr.t_ref;
      v_bom_flg_ref cz_pb_mgr.t_ref;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      rec_count NUMBER;
      mm_v_itmst_ref_part_nbr_tbl varchar_type_4000_tbl;
      mm_v_itmst_src_app_id_tbl t_ref;
   BEGIN
---COLLECT ALL THE SOURCE ITEM MASTER RECORDS
      IF (cz_pb_mgr.v_ps_item_id_tbl.COUNT > 0)
      THEN
         cz_pb_mgr.v_item_masters_tbl.DELETE;
         cz_pb_mgr.v_item_types_tbl.DELETE;
         cz_pb_mgr.v_items_orig_ref.DELETE;

         FOR i IN cz_pb_mgr.v_ps_item_id_tbl.FIRST .. cz_pb_mgr.v_ps_item_id_tbl.LAST
         LOOP
            cz_pb_mgr.v_item_masters_ref.DELETE;
            cz_pb_mgr.v_item_types_ref.DELETE;
            v_bom_flg_tbl.DELETE;
            v_item_types_orig_tbl.DELETE;

-- Bug9619157. As a part of the investigation this was one new issue found where
-- item for the reference BOM node was not resolved. Hence subsequence code has been added
-- to take care of item of ps_node_type=263 with src_application not null

            BEGIN
               IF ((cz_pb_mgr.v_ps_type_old_tbl(i) = PS_NODE_TYPE_BOM_MODEL)
                   OR(cz_pb_mgr.v_ps_type_old_tbl(i) = PS_NODE_TYPE_BOM_OPTIONCLASS) OR(cz_pb_mgr.v_ps_type_old_tbl(i) = PS_NODE_TYPE_BOM_STANDARD)
                   OR(cz_pb_mgr.v_ps_type_old_tbl(i) = PS_NODE_TYPE_REFERENCE AND cz_pb_mgr.v_ps_src_appl_id_old_tbl(i) = SRC_APPL_ID_BOM))
               THEN
                  SELECT item_id, item_type_id
                        ,DECODE(cz_pb_mgr.bomsynch_flag
                               ,'Y', NVL(cz_bom_synch.itemmaster_origsysref(orig_sys_ref), cz_pb_mgr.null_string)
                               ,NVL(orig_sys_ref, cz_pb_mgr.null_string)
                               )
                        ,bom_item, ref_part_nbr, NVL(src_application_id, 0)
                  BULK COLLECT INTO cz_pb_mgr.v_item_masters_ref, cz_pb_mgr.v_item_types_ref
                        ,v_item_types_orig_tbl
                        ,v_bom_flg_tbl, mm_v_itmst_ref_part_nbr_tbl, mm_v_itmst_src_app_id_tbl
                    FROM cz_item_masters
                   WHERE cz_item_masters.item_id = cz_pb_mgr.v_ps_item_id_tbl(i)
                     AND cz_item_masters.item_id IS NOT NULL
                     AND cz_item_masters.deleted_flag = '0';
               ELSE
                  SELECT item_id, item_type_id, orig_sys_ref, nonbom_item
                        ,ref_part_nbr, NVL(src_application_id, 0)
                  BULK COLLECT INTO cz_pb_mgr.v_item_masters_ref, cz_pb_mgr.v_item_types_ref, v_item_types_orig_tbl, v_bom_flg_tbl
                        ,mm_v_itmst_ref_part_nbr_tbl, mm_v_itmst_src_app_id_tbl
                    FROM cz_item_masters
                   WHERE cz_item_masters.item_id = cz_pb_mgr.v_ps_item_id_tbl(i)
                     AND cz_item_masters.item_id IS NOT NULL
                     AND cz_item_masters.deleted_flag = '0';
               END IF;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  -----if no items exist, logging a message is not required
                  NULL;
               WHEN OTHERS
               THEN
                  RAISE;
            END;

            rec_count := cz_pb_mgr.v_item_masters_tbl.COUNT;

            IF (cz_pb_mgr.v_item_masters_ref.COUNT > 0)
            THEN
               FOR k IN cz_pb_mgr.v_item_masters_ref.FIRST .. cz_pb_mgr.v_item_masters_ref.LAST
               LOOP
                  IF (cz_pb_mgr.v_item_masters_ref(k) IS NOT NULL)
                  THEN
                     IF (NOT v_cz_items_old_ref_idx_ref.EXISTS(cz_pb_mgr.v_item_masters_ref(k)))
                     THEN
                        rec_count := rec_count + 1;
                        cz_pb_mgr.v_item_masters_tbl(rec_count) := cz_pb_mgr.v_item_masters_ref(k);
                        cz_pb_mgr.mm_v_itmst_ref_part_nbr_ref(rec_count) := mm_v_itmst_ref_part_nbr_tbl(k);
                        cz_pb_mgr.mm_v_itmst_src_app_id_ref(rec_count) := mm_v_itmst_src_app_id_tbl(k);
                        cz_pb_mgr.v_item_types_tbl(rec_count) := cz_pb_mgr.v_item_types_ref(k);
                        cz_pb_mgr.v_items_orig_ref(rec_count) := v_item_types_orig_tbl(k);
                        --for model migration, maintain a sync table to get the
                        --orig_sys_ref from a given item
                        mm_v_ht_items_orig_ref(cz_pb_mgr.v_item_masters_ref(k)) := v_item_types_orig_tbl(k);
                        v_cz_items_old_ref_idx_ref(cz_pb_mgr.v_item_masters_ref(k)) := cz_pb_mgr.v_item_masters_ref(k);
                        v_bom_flg_ref(rec_count) := v_bom_flg_tbl(k);
                     END IF;
                  END IF;
               END LOOP;
            END IF;                                                                             /* end if of cz_pb_mgr.v_item_masters_ref.COUNT > 0 */
         END LOOP;                                                                          /* end loop of FOR I IN cz_pb_mgr.v_cz_ps_nodes_old_tbl */
      END IF;                                                                                /* end if of cz_pb_mgr.v_cz_ps_nodes_old_tbl.COUNT > 0 */

      IF (cz_pb_mgr.v_item_types_tbl.COUNT > 0)
      THEN
         cz_pb_mgr.v_item_types_new_ref.DELETE;
         cz_pb_mgr.v_item_types_orig_ref.DELETE;
         v_cz_types_old_ref_idx_ref.DELETE;

         FOR i IN cz_pb_mgr.v_item_types_tbl.FIRST .. cz_pb_mgr.v_item_types_tbl.LAST
         LOOP
            v_item_types_orig_tbl.DELETE;
            cz_pb_mgr.v_item_types_ref.DELETE;

            BEGIN
               IF ((cz_pb_mgr.v_item_types_tbl(i) IS NOT NULL) AND(v_bom_flg_ref(i) = bom_item))
               THEN
                  SELECT item_type_id, NAME, NVL(src_application_id, 0)
                        ,DECODE(cz_pb_mgr.bomsynch_flag
                               ,'Y', NVL(cz_bom_synch.itemtype_origsysref(orig_sys_ref), cz_pb_mgr.null_string)
                               ,NVL(orig_sys_ref, cz_pb_mgr.null_string)
                               )
                  BULK COLLECT INTO cz_pb_mgr.v_item_types_ref, v_type_name_tbl, v_type_src_app_tbl
                        ,v_item_types_orig_tbl
                    FROM cz_item_types
                   WHERE cz_item_types.item_type_id = cz_pb_mgr.v_item_types_tbl(i) AND cz_item_types.deleted_flag = '0';
               ELSIF((cz_pb_mgr.v_item_types_tbl(i) IS NOT NULL) AND(v_bom_flg_ref(i) = nonbom_item))
               THEN
                  SELECT item_type_id, NAME, NVL(src_application_id, 0), orig_sys_ref
                  BULK COLLECT INTO cz_pb_mgr.v_item_types_ref, v_type_name_tbl, v_type_src_app_tbl, v_item_types_orig_tbl
                    FROM cz_item_types
                   WHERE cz_item_types.item_type_id = cz_pb_mgr.v_item_types_tbl(i) AND cz_item_types.deleted_flag = '0';
               END IF;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
               WHEN OTHERS
               THEN
                  RAISE;
            END;

            IF (cz_pb_mgr.v_item_types_ref.COUNT > 0)
            THEN
               FOR k IN cz_pb_mgr.v_item_types_ref.FIRST .. cz_pb_mgr.v_item_types_ref.LAST
               LOOP
                  IF (cz_pb_mgr.v_item_types_ref(k) IS NOT NULL)
                  THEN
                     IF (NOT v_cz_types_old_ref_idx_ref.EXISTS(cz_pb_mgr.v_item_types_ref(k)))
                     THEN
                        rec_count := cz_pb_mgr.v_item_types_new_ref.COUNT + 1;
                        cz_pb_mgr.v_item_types_new_ref(rec_count) := cz_pb_mgr.v_item_types_ref(k);
                        cz_pb_mgr.v_item_types_orig_ref(rec_count) := v_item_types_orig_tbl(k);
                        --for model migration, maintain a sync table to get the
                        --orig_sys_ref from a given item type
                        mm_v_ht_item_types_orig_ref(cz_pb_mgr.v_item_types_ref(k)) := v_item_types_orig_tbl(k);
                        v_cz_types_old_ref_idx_ref(cz_pb_mgr.v_item_types_ref(k)) := cz_pb_mgr.v_item_types_ref(k);
                        v_type_record_ref(v_item_types_ref(k)).NAME := v_type_name_tbl(k);
                        v_type_record_ref(v_item_types_ref(k)).src_application_id := v_type_src_app_tbl(k);
                     END IF;
                  END IF;
               END LOOP;
            END IF;
         END LOOP;
      END IF;

--~> Properties
      cz_pb_mgr.v_remote_prop_ref.DELETE;
      v_property_record_ref.DELETE;

      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
         LOOP
            v_remote_prop_tbl.DELETE;
            BEGIN
              SELECT property_id, data_type, name, src_application_id
                BULK COLLECT INTO v_remote_prop_tbl, v_prop_type_tbl, v_prop_name_tbl, v_prop_src_app_tbl
                FROM (SELECT itp.property_id, p.data_type, p.name, nvl(p.src_application_id, 0) AS src_application_id
                      from cz_item_masters im, cz_item_type_properties itp, cz_ps_nodes psn, cz_properties p
                      where psn.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) and psn.deleted_flag = '0'
                      and psn.item_id = im.item_id AND im.deleted_flag = '0' and im.item_type_id = itp.item_type_id
                      AND itp.deleted_flag = '0' and itp.property_id = p.property_id and p.deleted_flag = '0'
                      UNION
                      SELECT psp.property_id, p.data_type, p.name, nvl(p.src_application_id, 0) AS src_application_id
                      from cz_ps_prop_vals psp, cz_ps_nodes psn, cz_properties p
                      where psn.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) and psn.ps_node_id = psp.ps_node_id
                      and psn.deleted_flag = '0' AND psp.deleted_Flag = '0' and psp.property_id = p.property_id
                      and p.deleted_flag = '0'
                      UNION
                      SELECT ipv.property_id, p.data_type, p.name, nvl(p.src_application_id, 0) AS src_application_id
                      from cz_ps_nodes psn, cz_item_property_values ipv, cz_properties p
                      where psn.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) and psn.item_id = ipv.item_id
                      and psn.deleted_flag = '0' and ipv.deleted_flag = '0' and ipv.property_id = p.property_id
                      and p.deleted_flag = '0');

            EXCEPTION
               WHEN no_data_found THEN
                  NULL;
               WHEN OTHERS THEN
                  log_pb_errors(SQLERRM,1,'cz_pb_mgr PROP SELECT',SQLCODE);
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  RAISE;
            END;

            IF (v_remote_prop_tbl.COUNT > 0)
            THEN
               FOR j IN v_remote_prop_tbl.FIRST .. v_remote_prop_tbl.LAST
               LOOP
                  IF (v_remote_prop_tbl(j) IS NOT NULL)
                  THEN
                     rec_count := cz_pb_mgr.v_remote_prop_ref.COUNT + 1;
                     cz_pb_mgr.v_remote_prop_ref(rec_count) := v_remote_prop_tbl(j);

                     IF (NOT v_property_record_ref.EXISTS(v_remote_prop_tbl(j)))
                     THEN
                        v_property_record_ref(v_remote_prop_tbl(j)).NAME := v_prop_name_tbl(j);
                        v_property_record_ref(v_remote_prop_tbl(j)).data_type := v_prop_type_tbl(j);
                        v_property_record_ref(v_remote_prop_tbl(j)).src_application_id := v_prop_src_app_tbl(j);
                     END IF;
                  END IF;
               END LOOP;
            END IF;
         END LOOP;
      END IF;

    -- The copy of item type props and item prop values is uncessary for publication (4861805)
    IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
--~> Item type properties
      IF (cz_pb_mgr.v_item_types_new_ref.COUNT > 0)
      THEN
         cz_pb_mgr.v_item_prop_id_tbl.DELETE;
         cz_pb_mgr.v_item_prop_type_tbl.DELETE;
         cz_pb_mgr.v_item_prop_num_val_tbl.DELETE;
         cz_pb_mgr.v_item_prop_data_typ_tbl.DELETE;

         FOR i IN cz_pb_mgr.v_item_types_new_ref.FIRST .. cz_pb_mgr.v_item_types_new_ref.LAST
         LOOP
            cz_pb_mgr.v_item_prop_id_ref.DELETE;
            cz_pb_mgr.v_item_prop_type_ref.DELETE;
            cz_pb_mgr.v_item_prop_num_val_ref.DELETE;
            cz_pb_mgr.v_item_prop_data_typ_ref.DELETE;
            cz_pb_mgr.v_tgt_item_type_prop_orig_ref.DELETE;    --Bug9031588
            cz_pb_mgr.v_src_item_type_prop_orig_ref.DELETE;    --Bug9031588
            BEGIN
               SELECT itp.property_id, itp.item_type_id,p.def_num_value, p.data_type
                     ,DECODE (cz_pb_mgr.bomsynch_flag
                            ,'Y', NVL(cz_bom_synch.itemtypeprop_origsysref(itp.orig_sys_ref), cz_pb_mgr.null_string)
                            ,NVL(itp.orig_sys_ref, cz_pb_mgr.null_string)),NVL(itp.orig_sys_ref, cz_pb_mgr.null_string)
               BULK COLLECT INTO cz_pb_mgr.v_item_prop_id_ref, cz_pb_mgr.v_item_prop_type_ref
                      ,cz_pb_mgr.v_item_prop_num_val_ref, cz_pb_mgr.v_item_prop_data_typ_ref
                      ,v_tgt_item_type_prop_orig_ref, v_src_item_type_prop_orig_ref
                 FROM cz_item_type_properties itp, cz_properties p
                WHERE itp.item_type_id = cz_pb_mgr.v_item_types_new_ref(i)
                      AND p.deleted_flag = '0'
                      AND itp.property_id =p.property_id
                      AND itp.deleted_flag = '0';
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_item_type_properties', 'SQLERRM', SQLERRM);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.ITEMTYPE', SQLCODE);
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            END;

            rec_count := cz_pb_mgr.v_item_prop_id_tbl.COUNT;

            IF (cz_pb_mgr.v_item_prop_id_ref.COUNT > 0)
            THEN
               FOR k IN cz_pb_mgr.v_item_prop_id_ref.FIRST .. cz_pb_mgr.v_item_prop_id_ref.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.v_item_prop_id_tbl(rec_count) := cz_pb_mgr.v_item_prop_id_ref(k);
                  cz_pb_mgr.v_item_prop_type_tbl(rec_count) := cz_pb_mgr.v_item_prop_type_ref(k);
                  cz_pb_mgr.v_item_prop_num_val_tbl(rec_count):=cz_pb_mgr.v_item_prop_num_val_ref(k);
                  cz_pb_mgr.v_item_prop_data_typ_tbl(rec_count):=cz_pb_mgr.v_item_prop_data_typ_ref(k);
                  cz_pb_mgr.v_tgt_type_prop_orig_tbl(rec_count):=cz_pb_mgr.v_tgt_item_type_prop_orig_ref(k);   --Bug9031588
                  cz_pb_mgr.v_src_type_prop_orig_tbl(rec_count):=cz_pb_mgr.v_src_item_type_prop_orig_ref(k);   --Bug9031588
                  v_type_property_record_ref(v_item_prop_type_ref(k))(v_item_prop_id_ref(k)) := v_property_record_ref(v_item_prop_id_ref(k));
                  mm_v_ht_item_typ_prop_orig_ref(v_src_item_type_prop_orig_ref(k)) := v_tgt_item_type_prop_orig_ref(k);  --Bug9031588
               END LOOP;
            END IF;
         END LOOP;  --  end loop of FOR I IN cz_pb_mgr.v_item_types_tbl
      END IF;       --  cz_pb_mgr.v_item_types_new_ref.COUNT > 0

      IF (cz_pb_mgr.v_item_masters_tbl.COUNT > 0)
      THEN
         cz_pb_mgr.v_it_prop_vals_id_tbl.DELETE;
         cz_pb_mgr.v_it_prop_vals_item_tbl.DELETE;

         FOR i IN cz_pb_mgr.v_item_masters_tbl.FIRST .. cz_pb_mgr.v_item_masters_tbl.LAST
         LOOP
            cz_pb_mgr.v_it_prop_vals_id_ref.DELETE;
            cz_pb_mgr.v_it_prop_vals_item_ref.DELETE;
            cz_pb_mgr.v_it_prop_value_ref.DELETE;
            cz_pb_mgr.v_tgt_item_prop_val_orig_ref.DELETE;    --Bug9031588
            cz_pb_mgr.v_src_item_prop_val_orig_ref.DELETE;    --Bug9031588

            BEGIN
               SELECT property_id, item_id
                      ,DECODE(cz_pb_mgr.bomsynch_flag
                            ,'Y', NVL(cz_bom_synch.itempropvalues_origsysref(orig_sys_ref), cz_pb_mgr.null_string)
                            , NVL(orig_sys_ref, cz_pb_mgr.null_string)
                            ),NVL(orig_sys_ref, cz_pb_mgr.null_string)
               BULK COLLECT INTO cz_pb_mgr.v_it_prop_vals_id_ref, cz_pb_mgr.v_it_prop_vals_item_ref
                      ,v_tgt_item_prop_val_orig_ref,v_src_item_prop_val_orig_ref
                 FROM cz_item_property_values
                WHERE item_id = cz_pb_mgr.v_item_masters_tbl(i) AND deleted_flag = '0';
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  cz_pb_mgr.v_err_message := 'No item property value found for item id: ' || TO_CHAR(cz_pb_mgr.v_item_masters_tbl(i));
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.ITEMTYPES', SQLCODE);
               WHEN OTHERS
               THEN
                  RAISE;
            END;

            rec_count := cz_pb_mgr.v_it_prop_vals_id_tbl.COUNT;

            IF (cz_pb_mgr.v_it_prop_vals_id_ref.COUNT > 0)
            THEN
               FOR k IN cz_pb_mgr.v_it_prop_vals_id_ref.FIRST .. cz_pb_mgr.v_it_prop_vals_id_ref.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.v_it_prop_vals_id_tbl(rec_count) := cz_pb_mgr.v_it_prop_vals_id_ref(k);
                  cz_pb_mgr.v_it_prop_vals_item_tbl(rec_count) := cz_pb_mgr.v_it_prop_vals_item_ref(k);
                  cz_pb_mgr.v_tgt_prop_val_orig_tbl(rec_count) := cz_pb_mgr.v_tgt_item_prop_val_orig_ref(k);   --Bug9031588
                  cz_pb_mgr.v_src_prop_val_orig_tbl(rec_count) := cz_pb_mgr.v_src_item_prop_val_orig_ref(k);   --Bug9031588
                  mm_v_ht_item_prop_val_orig_ref(v_src_item_prop_val_orig_ref(k)) := v_tgt_item_prop_val_orig_ref(k);  --Bug9031588
               END LOOP;
            END IF;
         END LOOP;  --  end loop of FOR I IN cz_pb_mgr.v_item_masters_tbl
      END IF;       --  end if of cz_pb_mgr.v_item_masters_tbl.COUNT > 0
    END IF;

    --Bug #5186307. Some of the item and item types can be bom, although corresponding ps nodes and the whole
    --model can be non-bom (item-based ps nodes and populators). For a non-bom model bom synchronization will
    --not be called, and it is just impossible to call it. However, the orig_sys_refs of the bom items and
    --item types still need to be synchronized. The following code implements this synchronization for a non-
    --bom model.

    --The bug is deferred.
/*
    IF(cz_pb_mgr.bomsynch_flag = 'N' AND cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)THEN

      FOR i IN 1..v_item_masters_tbl.COUNT LOOP

        IF(mm_v_itmst_src_app_id_ref(i) = 401)THEN

           v_items_orig_ref(i) := synch_item_origsysref(v_items_orig_ref(i));
        END IF;
      END LOOP;

      FOR i IN 1..v_item_types_new_ref.COUNT LOOP

        IF(v_type_record_ref(v_item_types_new_ref(i)).src_application_id = 702)THEN

           v_item_types_orig_ref(i) := synch_itemtype_origsysref(v_item_types_orig_ref(i));
        END IF;
      END LOOP;
    END IF;
*/
    --Now run the upfront validations for model migration.
    IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
    THEN
       mm_raiseallpossiblesyncerrors;
    END IF;
   END;
-----------------------------------------------------------------------------------------------------
-------------- Load data : procedure used to export data
   PROCEDURE load_data(
      v_publication_id IN cz_model_publications.publication_id%TYPE
     ,v_root_model_id IN cz_model_publications.model_id%TYPE
     ,v_server_id IN cz_model_publications.server_id%TYPE
     ,x_status_code IN OUT NOCOPY cz_model_publications.export_status%TYPE
     ,p_copy_nonjradui IN BOOLEAN DEFAULT TRUE
   )
   AS
      v_db_link VARCHAR2(128);
      seq_cv ref_cursor;
      rec_count PLS_INTEGER := 0;
      resolution_status VARCHAR2(200);
      v_copy_rules_flag VARCHAR2(3) := '';
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      -------select value of setting id CopyRules from cz_db_settings
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start get_copy_rules_flg');
      END IF;

      get_copy_rules_flg(v_copy_rules_flag);

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end get_copy_rules_flg: copy_rules_flag='||v_copy_rules_flag);
      END IF;

      IF (copy_rules = 'NO')
      THEN
         v_copy_rules_flag := 'NO';
      END IF;

      ---------check languages on source and target instances
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start pb_language_check');
      END IF;

      pb_language_check;

  --- To get the single language from cz_db_settins -- SKM
      get_single_pb_language;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end pb_language_check');
      END IF;

      -- load the ps nodes needed for ps_prop_vals and items
      -- this process of getting all the ps node information used to happen in upload_ps_structure, but
      -- model migration needed this to happen much before that
      mm_v_ht_item_types_orig_ref.DELETE;
      mm_v_ht_items_orig_ref.DELETE;
      mm_loadoldpsnodesforitems;
      IF (cz_pb_mgr.v_server_id <> 0 ) THEN
        read_item_schema;
      END IF;

      --------upload item sub-schema
      IF (g_object_type = MODEL_PUBLICATION OR cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start upload_item_schema');
         END IF;

         --upload_item_schema used to to happen after upload_ps_structure, upload_ui_schema
         --but model migration required this to happen earlier.  Moving this did not seem to affect
         --publication.
         upload_item_schema(cz_pb_mgr.v_cz_ps_nodes_old_tbl, cz_pb_mgr.v_status_code);

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end upload_item_schema');
         END IF;
      END IF;

      ------export product structure
      IF (g_object_type = MODEL_PUBLICATION OR cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start upload_ps_structure');
         END IF;

         upload_ps_structure(cz_pb_mgr.v_models_to_be_exported, v_copy_rules_flag, cz_pb_mgr.v_status_code);

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end upload_ps_structure');
         END IF;
      END IF;

      --------------upload UI Schema
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start upload_ui_schema');
      END IF;

      upload_ui_schema(cz_pb_mgr.v_models_to_be_exported, cz_pb_mgr.v_status_code, p_copy_nonjradui);

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end upload_ui_schema');
      END IF;

      ------upload rule schema
      IF (g_object_type = MODEL_PUBLICATION OR cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start upload_rule_schema');
         END IF;

         upload_rule_schema(cz_pb_mgr.v_models_to_be_exported, v_copy_rules_flag, cz_pb_mgr.v_status_code);

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end upload_rule_schema');
         END IF;
      END IF;

      x_status_code := cz_pb_mgr.v_status_code;
   EXCEPTION
      WHEN cz_pb_global_synch
      THEN
--~>  'Errors in upfront validation, unable to continue.'
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_UPVAL_ERRORS');
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'Upfront Validation', 70000);
         x_status_code := PUBLICATION_ERROR;
      WHEN pb_upload_ps_schema
      THEN
         cz_pb_mgr.v_err_message := 'Error in export of product structure for publication id : ' || cz_pb_mgr.v_publication_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PRODSTRUCTURE', SQLCODE);
         x_status_code := PUBLICATION_ERROR;
      WHEN pb_upload_ui_schema
      THEN
         cz_pb_mgr.v_err_message := 'Error in upload of UI schema for publication id : ' || cz_pb_mgr.v_publication_id;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UPLOADUISCHEMA', SQLCODE);
         x_status_code := PUBLICATION_ERROR;
      WHEN pb_upload_rule_schema
      THEN
         cz_pb_mgr.v_err_message := 'Error in upload of RULE schema for publication id : ' || cz_pb_mgr.v_publication_id || ':' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UPLOADRULESCHEMA', SQLCODE);
         x_status_code := PUBLICATION_ERROR;
      WHEN pb_upload_item_schema
      THEN
         cz_pb_mgr.v_err_message := 'Error in upload of ITEM schema for publication id : ' || cz_pb_mgr.v_publication_id;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.UPLOADITEMSCHEMA', SQLCODE);
         x_status_code := PUBLICATION_ERROR;
      WHEN OTHERS
      THEN
         x_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := 'Fatal error occured during data upload ';
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:ENDLOADDATA', SQLCODE);
   END load_data;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_tmp_pub(p_temp_id IN NUMBER)
   IS
      l_old_publication_id NUMBER;
      l_remote_publication_id NUMBER;
      l_new_publication_id NUMBER;
      v_inst_str VARCHAR2(2000);
   BEGIN
      v_inst_str :=
            'UPDATE cz_model_publications set deleted_flag = ''1'' WHERE object_id := :1 '
         || ' '
         || 'and object_type = :2 and server_id = :3 and source_target_flag = :4';

      EXECUTE IMMEDIATE v_inst_str
                  USING p_temp_id, 'UIT', cz_pb_mgr.v_db_link, g_source_flag;

      COMMIT;
      v_inst_str :=
            'UPDATE cz_model_publications'
         || cz_pb_mgr.v_db_link
         || ' set deleted_flag = ''1'' WHERE object_id := :1'
         || ' '
         || 'and object_type = :2 and server_id = :3 and source_target_flag = :4';

      EXECUTE IMMEDIATE v_inst_str
                  USING p_temp_id, 'UIT', cz_pb_mgr.v_db_link, g_source_flag;

      COMMIT;

      SELECT cz_model_publications_s.NEXTVAL
        INTO l_old_publication_id
        FROM DUAL;

      l_remote_publication_id :=
         cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_model_publications_seq
                                    , 'cz_model_publications_s.nextval' || cz_pb_mgr.v_db_link
                                    ,cz_pb_mgr.v_oraclesequenceincr
                                    );
      v_inst_str :=
            'INSERT INTO cz_model_publications'
         || ' '
         || '(PUBLICATION_ID,MODEL_ID,OBJECT_ID,OBJECT_TYPE,SERVER_ID,ORGANIZATION_ID,TOP_ITEM_ID,PRODUCT_KEY'
         || ' '
         || ',PUBLICATION_MODE,UI_DEF_ID,UI_STYLE,APPLICABLE_FROM,APPLICABLE_UNTIL,EXPORT_STATUS,MODEL_PERSISTENT_ID'
         || ' '
         || ',DELETED_FLAG,MODEL_LAST_STRUCT_UPDATE,MODEL_LAST_LOGIC_UPDATE,MODEL_LAST_UPDATED,SOURCE_TARGET_FLAG'
         || ' '
         || ',REMOTE_PUBLICATION_ID,SOURCE_UI_DEF_ID,SOURCE_MODEL_ID,CONTAINER,PAGE_LAYOUT,disabled_flag )'
         || ' '
         || 'SELECT :1,:2,:3,OBJECT_TYPE,SERVER_ID,ORGANIZATION_ID,TOP_ITEM_ID,PRODUCT_KEY,PUBLICATION_MODE,'
         || ' '
         || 'UI_DEF_ID,UI_STYLE,APPLICABLE_FROM,APPLICABLE_UNTIL,''OK'',MODEL_PERSISTENT_ID,DELETED_FLAG,'
         || ' '
         || 'MODEL_LAST_STRUCT_UPDATE,MODEL_LAST_LOGIC_UPDATE,MODEL_LAST_UPDATED,'''
         || g_source_flag
         || ''',:4,SOURCE_UI_DEF_ID,'
         || ' '
         || 'SOURCE_MODEL_ID,CONTAINER,PAGE_LAYOUT,disabled_flag  FROM  DUAL ';

      EXECUTE IMMEDIATE v_inst_str
                  USING l_old_publication_id, p_temp_id, p_temp_id, l_remote_publication_id;

      v_inst_str :=
            'INSERT INTO cz_model_publications'
         || cz_pb_mgr.v_db_link
         || ''
         || ' '
         || '(PUBLICATION_ID,MODEL_ID,OBJECT_ID,OBJECT_TYPE,SERVER_ID,ORGANIZATION_ID,TOP_ITEM_ID,PRODUCT_KEY'
         || ' '
         || ',PUBLICATION_MODE,UI_DEF_ID,UI_STYLE,APPLICABLE_FROM,APPLICABLE_UNTIL,EXPORT_STATUS,MODEL_PERSISTENT_ID'
         || ' '
         || ',DELETED_FLAG,MODEL_LAST_STRUCT_UPDATE,MODEL_LAST_LOGIC_UPDATE,MODEL_LAST_UPDATED,SOURCE_TARGET_FLAG'
         || ' '
         || ',REMOTE_PUBLICATION_ID,SOURCE_UI_DEF_ID,SOURCE_MODEL_ID,CONTAINER,PAGE_LAYOUT,disabled_flag )'
         || ' '
         || 'SELECT :1,:2,:3,OBJECT_TYPE,SERVER_ID,ORGANIZATION_ID,TOP_ITEM_ID,PRODUCT_KEY,PUBLICATION_MODE,'
         || ' '
         || 'UI_DEF_ID,UI_STYLE,APPLICABLE_FROM,APPLICABLE_UNTIL,''OK'',MODEL_PERSISTENT_ID,DELETED_FLAG,'
         || ' '
         || 'MODEL_LAST_STRUCT_UPDATE,MODEL_LAST_LOGIC_UPDATE,MODEL_LAST_UPDATED,'''
         || g_target_flag
         || ''',:4,SOURCE_UI_DEF_ID,'
         || ' '
         || 'SOURCE_MODEL_ID,CONTAINER,PAGE_LAYOUT,disabled_flag  FROM  DUAL ';

      EXECUTE IMMEDIATE v_inst_str
                  USING l_remote_publication_id, p_temp_id, p_temp_id, l_old_publication_id;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         NULL;
   END;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----will global template have a button_bar_template
----may be not

   PROCEDURE export_global_template(p_template_id IN NUMBER, p_publication_id IN NUMBER)
   IS
      rec_count NUMBER := 0;
      l_new_document VARCHAR2(255);
      l_document_id NUMBER;
      l_str VARCHAR2(2000);
   BEGIN
      -----bulk collect from templates
      cz_pb_mgr.g_ui_templates_old_temp_id_ref.DELETE;
      cz_pb_mgr.g_ui_templates_new_temp_id_ref.DELETE;
      cz_pb_mgr.g_ui_templates_idx_temp_ref.DELETE;
      cz_pb_mgr.g_ui_templates_msg_id_ref.DELETE;
      cz_pb_mgr.g_ui_templates_title_ref.DELETE;
      cz_pb_mgr.g_ui_templates_jrad_new_ref.DELETE;
      cz_pb_mgr.v_intl_text_ui_tbl.DELETE;
      cz_pb_mgr.v_intl_text_model_tbl.DELETE;
      cz_pb_mgr.g_ui_templates_button_tbl.DELETE;

      IF (cz_pb_mgr.v_server_id = 0)
      THEN
         SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_ui_templates
                                           , 'cz_ui_templates_s.nextval' || cz_pb_mgr.v_db_link
                                           ,cz_pb_mgr.v_oraclesequenceincr
                                           )
               ,template_id, main_message_id, title_id
               ,jrad_doc, -1, 0
               ,0
         BULK COLLECT INTO cz_pb_mgr.g_ui_templates_new_temp_id_ref
               ,cz_pb_mgr.g_ui_templates_old_temp_id_ref, cz_pb_mgr.g_ui_templates_msg_id_ref, cz_pb_mgr.g_ui_templates_title_ref
               ,cz_pb_mgr.g_ui_templates_jrad_new_ref, cz_pb_mgr.v_intl_text_model_tbl, cz_pb_mgr.v_intl_text_ui_tbl
               ,cz_pb_mgr.g_ui_templates_ui_def_old_ref
           FROM cz_ui_templates
          WHERE cz_ui_templates.template_id = p_template_id AND cz_ui_templates.ui_def_id = 0 AND cz_ui_templates.deleted_flag = record_not_deleted;
      ELSE
         SELECT template_id, template_id, main_message_id
               ,title_id, jrad_doc, -1
               ,0, 0
         BULK COLLECT INTO cz_pb_mgr.g_ui_templates_new_temp_id_ref, cz_pb_mgr.g_ui_templates_old_temp_id_ref, cz_pb_mgr.g_ui_templates_msg_id_ref
               ,cz_pb_mgr.g_ui_templates_title_ref, cz_pb_mgr.g_ui_templates_jrad_new_ref, cz_pb_mgr.v_intl_text_model_tbl
               ,cz_pb_mgr.v_intl_text_ui_tbl, cz_pb_mgr.g_ui_templates_ui_def_old_ref
           FROM cz_ui_templates
          WHERE cz_ui_templates.template_id = p_template_id AND cz_ui_templates.ui_def_id = 0 AND cz_ui_templates.deleted_flag = record_not_deleted;
      END IF;

      ------main msg
      insert_intl_texts(cz_pb_mgr.g_ui_templates_msg_id_ref, 'main message ids of cz ui templates', TRUE);
      resolve_intl_texts(cz_pb_mgr.g_ui_templates_msg_id_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'main message ids of cz ui templates');
      ----title id
      insert_intl_texts(cz_pb_mgr.g_ui_templates_title_ref, 'main message ids of cz ui templates', TRUE);
      resolve_intl_texts(cz_pb_mgr.g_ui_templates_title_ref, cz_pb_mgr.v_cz_intl_text_idx_ref, 'main message ids of cz ui templates');

      IF (cz_pb_mgr.g_ui_templates_jrad_new_ref.COUNT > 0)
      THEN
         FOR doc IN cz_pb_mgr.g_ui_templates_jrad_new_ref.FIRST .. cz_pb_mgr.g_ui_templates_jrad_new_ref.LAST
         LOOP
            IF (cz_pb_mgr.g_ui_templates_jrad_new_ref(doc) IS NOT NULL)
            THEN
               insert_into_repository(cz_pb_mgr.g_ui_templates_jrad_new_ref(doc), cz_pb_mgr.g_ui_templates_jrad_new_ref(doc), cz_pb_mgr.v_db_link);
            END IF;
         END LOOP;
      END IF;

      insert_ui_templates;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := 'Fatal error occured during export of global template: ' || p_template_id || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.EXPORTGLOBALTMP', SQLCODE);
         RAISE;
   END export_global_template;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE export_global_template
   IS
      rec_count NUMBER := 0;
      l_new_document VARCHAR2(255);
      l_document_id NUMBER;
      l_str VARCHAR2(2000);
      l_global_temp_tbl cz_pb_mgr.t_ref;
   BEGIN
      -----bulk collect from templates
      cz_pb_mgr.g_ui_templates_old_temp_id_ref.DELETE;
      cz_pb_mgr.g_ui_templates_new_temp_id_ref.DELETE;
      cz_pb_mgr.g_ui_templates_idx_temp_ref.DELETE;
      cz_pb_mgr.g_ui_templates_msg_id_ref.DELETE;
      cz_pb_mgr.g_ui_templates_title_ref.DELETE;
      cz_pb_mgr.g_ui_templates_jrad_new_ref.DELETE;
      cz_pb_mgr.v_intl_text_ui_tbl.DELETE;
      cz_pb_mgr.v_intl_text_model_tbl.DELETE;
      cz_pb_mgr.g_ui_templates_button_tbl.DELETE;

      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
         LOOP
            l_global_temp_tbl.DELETE;

            SELECT template_id
            BULK COLLECT INTO l_global_temp_tbl
              FROM cz_ui_collect_tmpls_v
             WHERE cz_ui_collect_tmpls_v.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) AND cz_ui_collect_tmpls_v.ui_def_id = 0;

            IF (l_global_temp_tbl.COUNT > 0)
            THEN
               rec_count := cz_pb_mgr.g_ui_templates_old_temp_id_ref.COUNT;

               FOR j IN l_global_temp_tbl.FIRST .. l_global_temp_tbl.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.g_ui_templates_old_temp_id_ref(rec_count) := l_global_temp_tbl(j);
               END LOOP;
            END IF;
         END LOOP;
      END IF;

      IF (cz_pb_mgr.g_ui_templates_old_temp_id_ref.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.g_ui_templates_old_temp_id_ref.FIRST .. cz_pb_mgr.g_ui_templates_old_temp_id_ref.LAST
         LOOP
            export_global_template(cz_pb_mgr.g_ui_templates_old_temp_id_ref(i), cz_pb_mgr.v_publication_id);
            insert_tmp_pub(cz_pb_mgr.g_ui_templates_old_temp_id_ref(i));
         END LOOP;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := 'Fatal error occured during export of global template: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.EXPORTGLOBALTMP', SQLCODE);
         RAISE;
   END export_global_template;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------- procedure to export the configuration models
---------from the development to the production server
   PROCEDURE proc_export(
      publicationid IN NUMBER
     ,modelid IN NUMBER
     ,serverid IN NUMBER
     ,x_status_code IN OUT NOCOPY cz_model_publications.export_status%TYPE
     ,p_copy_nonjradui IN BOOLEAN DEFAULT TRUE
   )
   IS
      CURSOR model_cur(rootmodelid NUMBER, serverid NUMBER, pubid NUMBER)
      IS
         SELECT   model_id
             FROM cz_pb_model_exports
            WHERE root_model_id = rootmodelid AND server_id = serverid AND publication_id = pubid AND superseded_flag = 'N'
         ORDER BY export_reverse_seq DESC;

      v_cursor NUMBER;
      v_model_id_table_exported model_id_table;
      v_model_id_table_not_exported model_id_table;
      v_model_count NUMBER := 1;
      v_validate_count NUMBER;
      mm_models_to_be_migrated cz_pb_mgr.t_ref;

      l_expl_check_flag   cz_db_settings.value%TYPE;
      l_run_id            NUMBER := cz_pb_mgr.v_pb_run_id;
      l_msg_count         NUMBER;
      l_msg_data          VARCHAR2(32000);
      l_return_status     VARCHAR2(16);

   BEGIN
      v_next_sequence_gen.DELETE;
      v_sequence_count.DELETE;

      ------retrieve seq incrementor from cz_db_settings
      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start get_seq_incrementor');
      END IF;

      get_seq_incrementor(cz_pb_mgr.v_oraclesequenceincr);

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end get_seq_incrementor');
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start get_models_tobe_exported');
      END IF;

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         mm_models_to_be_migrated := get_rootmodel_and_mig_tgt_fldr(publicationid);
         mm_get_models_tobe_exported(mm_models_to_be_migrated);
      ELSIF(g_object_type = MODEL_PUBLICATION)
      THEN
         get_models_tobe_exported(modelid);
      ELSIF(g_object_type = template_publication)
      THEN
         cz_pb_mgr.v_models_to_be_exported.DELETE;
         cz_pb_mgr.v_models_to_be_exported(1) := modelid;
      END IF;

      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0) THEN
      FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
      LOOP
         mm_v_rootmodels_tobe_exported(i) := modelid;
      END LOOP;
      END IF;

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('end get_models_tobe_exported');
         log_timing_message('start create_export_request');
      END IF;

      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
         LOOP
            create_export_request(cz_pb_mgr.mm_v_rootmodels_tobe_exported(i), cz_pb_mgr.v_models_to_be_exported(i), publicationid, serverid);
         END LOOP;
      ELSE
         cz_pb_mgr.v_err_message := 'No model / template data exported ';
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:EXPREQ', SQLCODE);
      END IF;

      -----create_copy_requests;
      IF (g_object_type = MODEL_PUBLICATION OR cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         cz_pb_mgr.v_models_to_be_exported.DELETE;

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end create_export_request');
            log_timing_message('start model_cur ');
         END IF;

         OPEN model_cur(modelid, serverid, publicationid);

         LOOP
            FETCH model_cur
             INTO v_cursor;

            EXIT WHEN model_cur%NOTFOUND;
            cz_pb_mgr.v_models_to_be_exported(v_model_count) := v_cursor;
            v_model_count := v_model_count + 1;
         END LOOP;

         CLOSE model_cur;

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end model_cur ');
            log_timing_message('start validate_schema');
         END IF;

         v_validate_count := validate_schema(serverid);

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('end validate_schema');
         END IF;

         IF ((v_validate_count = 1) AND(cz_pb_mgr.v_status_code <> PUBLICATION_ERROR))
         THEN
            IF (cz_pb_mgr.g_log_timing = publication_timing)
            THEN
               log_timing_message('start load_data');
            END IF;

            load_data(publicationid, modelid, serverid, x_status_code, p_copy_nonjradui);

            IF (cz_pb_mgr.g_log_timing = publication_timing)
            THEN
               log_timing_message('end load_data');
            END IF;
         ELSE
            IF (v_validate_count <> 1)
            THEN
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_SCHEMA_COMPAT_ERR');
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:VALSCH', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            ELSE
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               cz_pb_mgr.v_err_message := 'Process terminated for publication_id: ' || TO_CHAR(cz_pb_mgr.v_publication_id);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:PROCEXP', SQLCODE);
            END IF;
         END IF;
      ELSIF(g_object_type = template_publication)
      THEN
         export_global_template(modelid, publicationid);
      END IF;

      -----upload publication data
      IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model)
      THEN
         upload_publication_data(cz_pb_mgr.v_publication_id);
      END IF;

      --Verify if the exported product structure and explosion data are in synch.

      IF(cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)THEN

        BEGIN
          SELECT DECODE(UPPER(value), 'Y', 'Y', 'YES', 'Y', '1', 'Y', 'ON', 'Y', 'N')
            INTO l_expl_check_flag FROM cz_db_settings
           WHERE UPPER(section_name) = 'PUBLICATION'
             AND UPPER(setting_id) = 'CheckExplosionStructure';
        EXCEPTION
          WHEN OTHERS THEN
            l_expl_check_flag := 'N';
        END;

        IF(l_expl_check_flag = 'Y')THEN

          EXECUTE IMMEDIATE 'BEGIN cz_diagnostics_pvt.verify_structure' || cz_pb_mgr.v_db_link || '(1.0, :1, ''0'', :2, :3, :4, :5); END;'
            USING cz_pb_mgr.target_root_model_id, IN OUT l_run_id, IN OUT l_return_status, IN OUT l_msg_count, IN OUT l_msg_data;
        END IF;

        IF(l_return_status = FND_API.G_RET_STS_ERROR)THEN

          cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
          cz_pb_mgr.v_err_message :=  l_msg_data;
          cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message ,'cz_diagnostics_pvt', -1);
        END IF;
      END IF;

      -----set status for concurrent manager
      IF (cz_pb_mgr.v_status_code = PUBLICATION_ERROR)
      THEN
         cz_pb_mgr.global_export_retcode := 2;
         rollback_data(cz_pb_mgr.v_db_link);
      END IF;

      -----clear tables
      clear_all_tables(cz_pb_mgr.v_status_code);
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_EXPORT_FAILURE', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.EXPORT_FAILURE', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         RAISE;
   END proc_export;

--------------------------------------------------------------------------------
-- private: ret status: 0 yes, 2 no (msg_data - ui or err info, model_name - model info)
PROCEDURE is_ui_upto_date(p_ui_def_id IN NUMBER
                         ,p_report_model_info IN NUMBER
                         ,x_return_status OUT NOCOPY NUMBER
                         ,x_msg_data OUT NOCOPY VARCHAR2
                         ,x_model_name OUT NOCOPY VARCHAR2
                         ,p_check_root_ui_only IN BOOLEAN DEFAULT FALSE
                         )
IS
  l_ui_style cz_ui_defs.ui_style%TYPE;
  l_ui_status cz_ui_defs.ui_status%TYPE;
  l_ui_tbl t_ref;
  l_ui_name cz_ui_defs.NAME%TYPE;
  l_root_model_id NUMBER;
  l_root_ui_last_update_date DATE;
  l_model_id NUMBER;
  l_model_name cz_devl_projects.NAME%TYPE;
  l_last_update_date DATE;
  l_last_struct_update DATE;
  l_suppress_refresh_flag cz_ui_defs.suppress_refresh_flag%TYPE;
BEGIN
  x_return_status := 0;
  x_msg_data := '';

  SELECT ui_style, ui_status, NAME, NVL(suppress_refresh_flag, '0'), devl_project_id, NVL(ui_timestamp_refresh, last_update_date)
    INTO l_ui_style, l_ui_status, l_ui_name, l_suppress_refresh_flag, l_root_model_id, l_root_ui_last_update_date
  FROM cz_ui_defs
  WHERE ui_def_id = p_ui_def_id;

  IF l_ui_status = 'NEED_REFRESH' THEN
    x_return_status := 2;
    x_msg_data := l_ui_name;

    IF p_report_model_info = 1 THEN
      SELECT NAME INTO x_model_name
      FROM cz_devl_projects
      WHERE devl_project_id = l_root_model_id;
    END IF;

    RETURN;
  END IF;

  IF p_check_root_ui_only THEN
    IF l_suppress_refresh_flag='0' THEN
      l_ui_tbl(1) := p_ui_def_id;
    END IF;
  ELSE
    IF (l_ui_style IN(g_ui_style_dhtml, g_ui_style_applet)) THEN
      SELECT DISTINCT ui_def_id BULK COLLECT INTO l_ui_tbl
      FROM cz_ui_nodes
      WHERE deleted_flag = '0'
      START WITH ui_def_id = p_ui_def_id
      CONNECT BY PRIOR ui_def_ref_id = ui_def_id AND PRIOR deleted_flag = '0';
    ELSIF (l_ui_style = g_ui_style_jrad) THEN
      SELECT ref_ui_def_id BULK COLLECT INTO l_ui_tbl
      FROM (SELECT DISTINCT ref_ui_def_id
            FROM cz_ui_refs
            START WITH ui_def_id = p_ui_def_id AND deleted_flag = '0'
            CONNECT BY PRIOR ref_ui_def_id = ui_def_id AND deleted_flag = '0' AND PRIOR deleted_flag = '0') uis
      WHERE EXISTS (SELECT NULL
                    FROM cz_ui_defs
                    WHERE ui_def_id = uis.ref_ui_def_id AND deleted_flag = '0' AND NVL(suppress_refresh_flag, '0') = '0');

      IF l_suppress_refresh_flag = '0' THEN
        l_ui_tbl(l_ui_tbl.COUNT + 1) := p_ui_def_id;
      END IF;
    ELSIF l_ui_style = g_ui_style_custom THEN
      RETURN;
    ELSE
      x_return_status := 2;
      x_msg_data := cz_utils.get_text('CZ_UI_STYLE_ERR');
      RETURN;
    END IF;
  END IF;

  IF (l_ui_tbl.COUNT > 0) THEN
    FOR i IN l_ui_tbl.FIRST .. l_ui_tbl.LAST
    LOOP
      IF l_ui_tbl(i) = p_ui_def_id THEN
        l_model_id := l_root_model_id;
        l_last_update_date := l_root_ui_last_update_date;
      ELSE
        BEGIN
          SELECT NVL(ui_timestamp_refresh, last_update_date), devl_project_id, NAME, ui_status
            INTO l_last_update_date, l_model_id, l_ui_name, l_ui_status
          FROM cz_ui_defs
          WHERE cz_ui_defs.ui_def_id = l_ui_tbl(i);
        EXCEPTION
          WHEN OTHERS THEN
            l_last_update_date := NULL;
        END;

        IF l_last_update_date IS NULL OR l_ui_status = 'NEED_REFRESH' THEN
          x_return_status := 2;
          x_msg_data := l_ui_name;

          IF p_report_model_info = 1 THEN
            SELECT NAME INTO x_model_name
            FROM cz_devl_projects
            WHERE devl_project_id = l_model_id;
          END IF;

          EXIT;
        END IF;
      END IF;

      BEGIN
        SELECT DECODE(l_ui_style, g_ui_style_jrad, NVL(ui_timestamp_struct_update, last_struct_update), last_struct_update), NAME
          INTO l_last_struct_update, l_model_name
        FROM cz_devl_projects
        WHERE cz_devl_projects.devl_project_id = l_model_id;
      EXCEPTION
        WHEN OTHERS THEN
          l_last_struct_update := NULL;
          l_model_name := NULL;
      END;

      IF l_last_struct_update IS NULL OR l_last_update_date < l_last_struct_update THEN
        x_return_status := 2;
        x_msg_data := l_ui_name;
        x_model_name := l_model_name;
        EXIT;
      END IF;
    END LOOP;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    x_return_status := 2;
    x_msg_data := SQLERRM;
END is_ui_upto_date;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----------deep model copy
-----------p_model_id : devl_project_id of the model for which a copy is to be made.
-----------p_server_id: server_id from cz_servers that contains db info
-----------p_folder: folder to which the copy is made
-----------p_copy_rules: flag 1 implies copy rules else 0
-----------p_copy_uis: flag 1 implies copy uis
-----------p_copy_root: flag 1 implies that only root model would be copied
-----------x_model_id : devl_project_id of the copied model
   PROCEDURE deep_model_copy(
      p_model_id IN NUMBER
     ,p_server_id IN NUMBER
     ,p_folder IN NUMBER
     ,p_copy_rules IN NUMBER
     ,p_copy_uis IN NUMBER
     ,p_copy_root IN NUMBER
     ,x_model_id OUT NOCOPY NUMBER
     ,x_run_id OUT NOCOPY NUMBER
     ,x_status OUT NOCOPY VARCHAR2
   )
   AS
      v_count PLS_INTEGER := 0;
      v_model_chk_count PLS_INTEGER := 0;
      v_ui_chk_count PLS_INTEGER := 0;
      v_folder_chk PLS_INTEGER := 0;
      v_rp_entries_name cz_rp_entries.NAME%TYPE;
      v_rp_entries_desc cz_rp_entries.description%TYPE;
      v_object_id cz_rp_entries.object_id%TYPE;
      v_copy_number NUMBER := 0.0;
      v_rp_orig_sys_ref VARCHAR2(255);
      v_imp_ps_node_count PLS_INTEGER := 0;
      v_pub_id cz_model_publications.publication_id%TYPE;
      l_msg_index NUMBER;
      failed_to_lock_model EXCEPTION;
      l_msg_data VARCHAR2(2000);
      l_msg_count NUMBER := 0;
      l_return_status VARCHAR2(1);
      l_lock_status VARCHAR2(1);
      l_locked_models cz_security_pvt.number_type_tbl;
      l_checkout_user cz_security_pvt.varchar_type_tbl;
      l_model_upto_date_status NUMBER;
      l_ui_upto_date_status NUMBER;
      l_model_upto_date_msg VARCHAR2(2000);
      logic_gen_required CONSTANT NUMBER := 1;
      ui_refresh_required CONSTANT NUMBER := 2;
      l_ui_tbl     t_ref;
      l_ui_name    VARCHAR2(1000);
      l_model_name VARCHAR2(1000);
      l_copy_nonjradui BOOLEAN;
      ui_not_uptodate EXCEPTION;

      TYPE ui_style_tbl_type IS TABLE OF cz_ui_defs.ui_style%TYPE INDEX BY PLS_INTEGER;
      l_ui_style_tbl  ui_style_tbl_type;
   BEGIN
      ----------delete session specific parameters
      BEGIN
         delete_session_parameters;
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_err_message := 'ERROR :deletion of session parameters ' || SQLERRM;
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
      END;

      cz_pb_mgr.v_status_code := publication_ok;

      ---------select run_id and user from dual
      ---------
      BEGIN
         SELECT USER, cz_xfr_run_infos_s.NEXTVAL
           INTO cz_pb_mgr.loguser, cz_pb_mgr.v_pb_run_id
           FROM DUAL;
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_SEQ_XFR');
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.XFRINFO', SQLCODE);
      END;

      cz_security_pvt.lock_model(1.0, p_model_id, fnd_api.g_true, fnd_api.g_true, l_locked_models, l_lock_status, l_msg_count, l_msg_data);

      IF (l_lock_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         l_msg_index := 1;

         WHILE l_msg_count > 0
         LOOP
            l_msg_data := fnd_msg_pub.get(l_msg_index, fnd_api.g_false);
            cz_pb_mgr.error_msg_populate(l_msg_data, 'cz_pb_mgr.LOCKMODEL', SQLCODE);
            l_msg_index := l_msg_index + 1;
            l_msg_count := l_msg_count - 1;
         END LOOP;

         RAISE failed_to_lock_model;
      END IF;

      --------initialize session parameters
      cz_pb_mgr.sequence_const := 0;
      cz_pb_mgr.v_status_code := 'OK';
      cz_pb_mgr.global_export_retcode := 0;
      cz_pb_mgr.g_object_type := 'PRJ';

      IF (p_copy_rules = 1)
      THEN
         cz_pb_mgr.copy_rules := 'YES';
      ELSE
         cz_pb_mgr.copy_rules := 'NO';
      END IF;

      IF (p_copy_uis = 1)
      THEN
         cz_pb_mgr.copy_uis := 'YES';
      ELSE
         cz_pb_mgr.copy_uis := 'NO';
      END IF;

      IF (p_copy_root = 0)
      THEN
         cz_pb_mgr.copy_root_only := 'NO';
      ELSE
         cz_pb_mgr.copy_root_only := 'YES';
      END IF;

      --------initialize model, ui and server values
      cz_pb_mgr.v_root_model_id := p_model_id;

      --------get the ui_def_id for the above model
      IF (cz_pb_mgr.copy_uis = 'YES')
      THEN
         BEGIN
            SELECT MAX(ui_def_id)
              INTO cz_pb_mgr.v_root_ui_def_id
              FROM cz_ui_defs
             WHERE cz_ui_defs.devl_project_id = cz_pb_mgr.v_root_model_id AND cz_ui_defs.deleted_flag = '0';
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               cz_pb_mgr.v_root_ui_def_id := -999;
            WHEN OTHERS
            THEN
               cz_pb_mgr.v_root_ui_def_id := -999;
         END;
      ELSE
         cz_pb_mgr.v_root_ui_def_id := -999;
      END IF;

      cz_pb_mgr.v_server_id := p_server_id;
      -------set session level parameter that differentiates from publishing
      cz_pb_mgr.v_session_parameter := model_copy;
      cz_pb_mgr.g_source_flag := cz_model_migration_pvt.pub_source_flag;
      cz_pb_mgr.g_target_flag := cz_model_migration_pvt.pub_target_flag;
      ---------check if model exists
      v_model_chk_count := 0;

      BEGIN
         SELECT 1, NVL(config_engine_type, 'L')
           INTO v_model_chk_count, g_engine_type
           FROM cz_devl_projects
          WHERE cz_devl_projects.devl_project_id = cz_pb_mgr.v_root_model_id AND cz_devl_projects.deleted_flag = '0';
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_MODEL');
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISHMODEL', SQLCODE);
            cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
      END;

      ---------verify that ui exists
      v_ui_chk_count := -1;

      IF (cz_pb_mgr.v_root_ui_def_id > 0)
      THEN
         BEGIN
            SELECT 1
              INTO v_ui_chk_count
              FROM cz_ui_defs
             WHERE cz_ui_defs.ui_def_id = cz_pb_mgr.v_root_ui_def_id AND cz_ui_defs.deleted_flag = '0';
         EXCEPTION
            WHEN OTHERS
            THEN
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_UI');
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         END;
      END IF;

      -------check if UI is upto date
      IF cz_pb_mgr.copy_uis = 'YES' THEN
        l_copy_nonjradui := TRUE;
        IF cz_pb_mgr.copy_root_only = 'YES' THEN
          SELECT ui_def_id, ui_style BULK COLLECT INTO l_ui_tbl, l_ui_style_tbl
          FROM cz_ui_defs
          WHERE deleted_flag='0' AND ui_style<>-1 AND devl_project_id=p_model_id;
        ELSE
          SELECT ui_def_id, ui_style BULK COLLECT INTO l_ui_tbl, l_ui_style_tbl
          FROM cz_ui_defs
          WHERE deleted_flag='0' AND ui_style<>-1 AND devl_project_id IN
          (SELECT component_id FROM cz_model_ref_expls
           WHERE deleted_flag='0' AND model_id=p_model_id);
        END IF;

        IF l_ui_tbl.COUNT>0 THEN
          FOR i IN l_ui_tbl.FIRST .. l_ui_tbl.LAST LOOP
            -- all jrad uis have to be up to date
            -- all nonjrad uis will be not copied if any such ui is not up to date
            IF l_ui_style_tbl(i) = oa_ui_style OR l_copy_nonjradui THEN
              is_ui_upto_date(p_ui_def_id         => l_ui_tbl(i)
                             ,p_report_model_info => 1
                             ,x_return_status     => l_ui_upto_date_status
                             ,x_msg_data          => l_ui_name
                             ,x_model_name        => l_model_name
                             ,p_check_root_ui_only=> TRUE
                             );
              IF l_ui_upto_date_status IS NOT NULL AND l_ui_upto_date_status <> 0 THEN
                cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_MODEL_NOT_UP_TO_DATE', 'STRING', 'UI' ||
                                        ' ''' || l_ui_name || '''', 'MODELID', '''' || l_model_name || '''');
                cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', -20001);
                IF l_ui_style_tbl(i) = oa_ui_style THEN
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  RAISE ui_not_uptodate;
                ELSE
                  l_copy_nonjradui := FALSE;
                END IF;
              END IF;
            END IF;
          END LOOP;
        END IF;
      END IF;

      -- if no ui to copy or not to copy ui
      IF l_ui_upto_date_status IS NULL THEN
        l_ui_upto_date_status := 0;
      END IF;

      --------check if folder exists
      IF (p_folder IS NOT NULL)
      THEN
         BEGIN
            SELECT 1
              INTO v_folder_chk
              FROM cz_rp_entries
             WHERE object_type = 'FLD' AND object_id = p_folder AND deleted_flag = '0';
         EXCEPTION
            WHEN OTHERS
            THEN
               cz_pb_mgr.v_err_message := 'Error in retrieving folder id : ' || p_folder || ' : ' || SQLERRM;
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         END;
      END IF;

      IF (v_model_chk_count = 0)
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_MODEL');
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
      ELSIF(v_ui_chk_count = 0)
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_UI');
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
      ELSE
         -----------create a dummy publication
         BEGIN
            SELECT cz_model_publications_s.NEXTVAL
              INTO cz_pb_mgr.v_publication_id
              FROM DUAL;

            v_pub_id := cz_pb_mgr.v_publication_id;
         EXCEPTION
            WHEN OTHERS
            THEN
               cz_pb_mgr.v_err_message := 'Error in generation of dummy publication id';
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         END;

         BEGIN
            INSERT INTO cz_model_publications
                        (publication_id, model_id, server_id, product_key, publication_mode
                        ,ui_def_id, ui_style, applicable_from, applicable_until, deleted_flag, model_last_struct_update, model_last_logic_update
                        ,model_last_updated, source_target_flag, object_id, object_type, disabled_flag
                        )
                 VALUES (cz_pb_mgr.v_publication_id, cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_server_id, 'copy model', 'T'
                        ,cz_pb_mgr.v_root_ui_def_id, '0', SYSDATE, SYSDATE, '0', SYSDATE, SYSDATE
                        ,SYSDATE, g_target_flag, cz_pb_mgr.v_root_model_id, 'PRJ', '0'
                        );

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               cz_pb_mgr.v_err_message := 'Error in creation of dummy publication record: ' || SQLERRM;
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         END;

         BEGIN
            proc_export(cz_pb_mgr.v_publication_id, cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_server_id, cz_pb_mgr.v_status_code,
                        (cz_pb_mgr.copy_uis='YES' AND l_copy_nonjradui));

            IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
            THEN
               cz_pb_mgr.v_err_message := 'MODEL: ' || cz_pb_mgr.v_root_model_id || '  successfully copied';
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
            ELSE
               cz_pb_mgr.v_err_message := 'MODEL: ' || cz_pb_mgr.v_root_model_id || '  copy failed';
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
            END IF;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_EXPORT_FAILURE', 'SQLERRM', SQLERRM);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
               cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         END;

         ----------insert into cz_rp_entries
         IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
         THEN
            v_imp_ps_node_count := 0;

            FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
            LOOP
               v_imp_ps_node_count := cz_pb_mgr.v_imported_ps_ref.COUNT + 1;
               cz_pb_mgr.v_imported_ps_node := cz_pb_mgr.v_models_to_be_exported(i);
               cz_pb_mgr.v_imported_ps_ref(v_imp_ps_node_count) := cz_pb_mgr.v_models_to_be_exported(i);

               BEGIN
                  SELECT remote_model_id
                    INTO v_object_id
                    FROM cz_pb_model_exports
                   WHERE cz_pb_model_exports.model_id = cz_pb_mgr.v_models_to_be_exported(i)
                     AND cz_pb_model_exports.publication_id = cz_pb_mgr.v_publication_id;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     cz_pb_mgr.v_err_message := 'Error in retrieving remote model id : ' || SQLERRM;
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
               END;

               BEGIN
                  SELECT desc_text, orig_sys_ref
                    INTO v_rp_entries_desc, v_rp_orig_sys_ref
                    FROM cz_devl_projects
                   WHERE cz_devl_projects.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) AND cz_devl_projects.deleted_flag = '0';
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     v_rp_orig_sys_ref := NULL;
                     cz_pb_mgr.v_err_message := 'No desc exists for devl_project_id : ' || SQLERRM;
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
                  WHEN OTHERS
                  THEN
                     v_rp_orig_sys_ref := NULL;
                     cz_pb_mgr.v_err_message := 'Error in retrieving desc from cz_devl_projects for devl_project_id: ' || SQLERRM;
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
                     cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               END;

               v_rp_entries_name := copy_name(cz_pb_mgr.v_models_to_be_exported(i));

               IF (v_rp_entries_name = 'ERROR')
               THEN
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
               END IF;

               IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
               THEN
                  cz_pb_mgr.v_new_object_id := v_object_id;

                  BEGIN
                     cz_pb_mgr.v_rp_folder_id := p_folder;
                     cz_pb_mgr.v_rp_name := v_rp_entries_name;
                     cz_pb_mgr.v_rp_desc := v_rp_entries_desc;

                     EXECUTE IMMEDIATE    'BEGIN'
                                       || ' '
                                       || 'insert into cz_rp_entries'
                                       || cz_pb_mgr.v_db_link
                                       || ' ( OBJECT_TYPE'
                                       || ' '
                                       || ',OBJECT_ID'
                                       || ' '
                                       || ',ENCLOSING_FOLDER'
                                       || ' '
                                       || ',NAME'
                                       || ' '
                                       || ',DESCRIPTION'
                                       || ' '
                                       || ',DELETED_FLAG'
                                       || ' '
                                       || ',SEEDED_FLAG'
                                       || ' '
                                       || ')'
                                       || ' '
                                       || 'VALUES ( ''PRJ'''
                                       || ' '
                                       || ',cz_pb_mgr.v_new_object_id'
                                       || ' '
                                       || ',cz_pb_mgr.v_rp_folder_id'
                                       || ' '
                                       || ',cz_pb_mgr.v_rp_name'
                                       || ' '
                                       || ',cz_pb_mgr.v_rp_desc'
                                       || ' '
                                       || ',''0'''
                                       || ' '
                                       || ',''0'');'
                                       || ' '
                                       || 'commit;'
                                       || ' '
                                       || 'END;';
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        cz_pb_mgr.v_err_message := 'Error in inserting into cz_rp_entries: ' || SQLERRM;
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
                        cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  END;

                  --------update proj name in devl projects with the new name
                  ----------check if source model is upto date
                  l_model_upto_date_msg := NULL;
                  l_model_upto_date_status := 0;
                  is_model_upto_date(cz_pb_mgr.v_models_to_be_exported(i), l_model_upto_date_status, l_model_upto_date_msg);

                  BEGIN
                     IF (cz_pb_mgr.v_rp_name IS NOT NULL)
                     THEN
                        IF ((l_model_upto_date_status = 0) AND(l_ui_upto_date_status = 0))
                        THEN
                           EXECUTE IMMEDIATE    'BEGIN'
                                             || ' '
                                             || 'UPDATE cz_devl_projects'
                                             || cz_pb_mgr.v_db_link
                                             || '  t'
                                             || ' '
                                             || 'SET  t.name = cz_pb_mgr.v_rp_name'
                                             || ' '
                                             || 'WHERE  t.devl_project_id = '
                                             || cz_pb_mgr.v_new_object_id
                                             || ';'
                                             || ' '
                                             || 'END;';
                        ELSIF((l_model_upto_date_status = logic_gen_required) AND(l_ui_upto_date_status = ui_refresh_required))
                        THEN
                           EXECUTE IMMEDIATE    'BEGIN'
                                             || ' '
                                             || 'UPDATE cz_devl_projects'
                                             || cz_pb_mgr.v_db_link
                                             || '  t'
                                             || ' '
                                             || 'SET  t.name = cz_pb_mgr.v_rp_name,'
                                             || ' '
                                             || 't.last_logic_update = sysdate,'
                                             || ' '
                                             || 't.last_struct_update =  sysdate'
                                             || ' '
                                             || 'WHERE  t.devl_project_id = '
                                             || cz_pb_mgr.v_new_object_id
                                             || ';'
                                             || ' '
                                             || 'END;';
                        ELSIF((l_model_upto_date_status = logic_gen_required) AND(l_ui_upto_date_status = 0))
                        THEN
                           EXECUTE IMMEDIATE    'BEGIN'
                                             || ' '
                                             || 'UPDATE cz_devl_projects'
                                             || cz_pb_mgr.v_db_link
                                             || '  t'
                                             || ' '
                                             || 'SET  t.name = cz_pb_mgr.v_rp_name,'
                                             || ' '
                                             || 't.last_logic_update = sysdate'
                                             || ' '
                                             || 'WHERE  t.devl_project_id = '
                                             || cz_pb_mgr.v_new_object_id
                                             || ';'
                                             || ' '
                                             || 'END;';
                        ELSE
                           EXECUTE IMMEDIATE    'BEGIN'
                                             || ' '
                                             || 'UPDATE cz_devl_projects'
                                             || cz_pb_mgr.v_db_link
                                             || '  t'
                                             || ' '
                                             || 'SET  t.name = cz_pb_mgr.v_rp_name,'
                                             || ' '
                                             || 't.last_struct_update = sysdate'
                                             || ' '
                                             || 'WHERE  t.devl_project_id = '
                                             || cz_pb_mgr.v_new_object_id
                                             || ';'
                                             || ' '
                                             || 'END;';
                        END IF;
                     END IF;

                     COMMIT;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        cz_pb_mgr.v_err_message := 'Error in updating cz_devl_projects with the new project name: ' || SQLERRM;
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
                        cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  END;

                 BEGIN

	             EXECUTE IMMEDIATE ' INSERT INTO CZ_PERSISTENT_REC_IDS'
	                               ||' (devl_project_id,MAX_PERSISTENT_REC_ID,'
                                       ||' deleted_flag) '
		                       ||'  SELECT :1,m.max_persistent_rec_id,0 from '
                                       ||'  cz_devl_projects p,'
		                       ||'  CZ_PERSISTENT_REC_IDS m '
                                       ||'  where p.devl_project_id=:2'
	                               ||'  and m.devl_project_id=p.devl_project_id  '
		                       ||'  and p.deleted_flag=0 '
                                       ||'  and p.POST_MIGR_CHANGE_FLAG is not null and p.POST_MIGR_CHANGE_FLAG<>''L'''
		     USING  cz_pb_mgr.v_new_object_id, cz_pb_mgr.v_models_to_be_exported(i);

                 EXCEPTION
                     WHEN OTHERS
                     THEN
                        cz_pb_mgr.v_err_message := 'Error in inserting records into CZ_PERSISTENT_REC_IDS: ' || SQLERRM;
                        cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
                        cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  END;

                  ------insert into cz_xfr_project_bills
                  IF (v_rp_orig_sys_ref IS NOT NULL)
                  THEN
                     BEGIN
                        EXECUTE IMMEDIATE    'BEGIN'
                                          || ' '
                                          || 'insert into cz_xfr_project_bills'
                                          || cz_pb_mgr.v_db_link
                                          || ' ('
                                          || ' '
                                          || 'MODEL_PS_NODE_ID'
                                          || ' '
                                          || ',ORGANIZATION_ID'
                                          || ' '
                                          || ',COMPONENT_ITEM_ID'
                                          || ' '
                                          || ',DESCRIPTION'
                                          || ' '
                                          || ',LAST_IMPORT_RUN_ID'
                                          || ' '
                                          || ',LAST_IMPORT_DATE'
                                          || ' '
                                          || ',SOURCE_BILL_DELETED'
                                          || ' '
                                          || ',TOP_ITEM_ID'
                                          || ' '
                                          || ',DELETED_FLAG'
                                          || ' '
                                          || ',EXPLOSION_TYPE'
                                          || ' '
                                          || ',BILL_REVISION_DATE'
                                          || ' '
                                          || ',EFF_FROM'
                                          || ' '
                                          || ',EFF_TO'
                                          || ' '
                                          || ',SOURCE_SERVER'
                                          || ' '
                                          || ',COPY_ADDL_CHILD_MODELS'
                                          || ' '
                                          || ')'
                                          || ' '
                                          || 'SELECT  cz_pb_mgr.v_new_object_id'
                                          || ' '
                                          || ',ORGANIZATION_ID'
                                          || ' '
                                          || ',COMPONENT_ITEM_ID'
                                          || ' '
                                          || ',DESCRIPTION'
                                          || ' '
                                          || ',LAST_IMPORT_RUN_ID'
                                          || ' '
                                          || ',LAST_IMPORT_DATE'
                                          || ' '
                                          || ',SOURCE_BILL_DELETED'
                                          || ' '
                                          || ',TOP_ITEM_ID'
                                          || ' '
                                          || ',DELETED_FLAG'
                                          || ' '
                                          || ',EXPLOSION_TYPE'
                                          || ' '
                                          || ',BILL_REVISION_DATE'
                                          || ' '
                                          || ',EFF_FROM'
                                          || ' '
                                          || ',EFF_TO'
                                          || ' '
                                          || ',SOURCE_SERVER'
                                          || ' '
                                          || ',COPY_ADDL_CHILD_MODELS'
                                          || ' '
                                          || 'FROM   cz_xfr_project_bills'
                                          || ' '
                                          || 'WHERE  cz_xfr_project_bills.MODEL_PS_NODE_ID = cz_pb_mgr.v_imported_ps_node'
                                          || ' '
                                          || 'AND   cz_xfr_project_bills.deleted_flag = ''0'';'
                                          || ' '
                                          || 'commit;'
                                          || ' '
                                          || 'END;';
                     EXCEPTION
                        WHEN NO_DATA_FOUND
                        THEN
                           cz_pb_mgr.v_err_message := 'Error in inserting into cz_xfr_projects : ' || SQLERRM;
                           cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
                        WHEN OTHERS
                        THEN
                           cz_pb_mgr.v_err_message := 'Error in inserting into cz_xfr_projects : ' || SQLERRM;
                           cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
                           cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                     END;
                  END IF;
               END IF;
            END LOOP;
         END IF;

         x_run_id := cz_pb_mgr.v_pb_run_id;
         x_status := cz_pb_mgr.v_status_code;
         log_pb_trace;
         delete_session_parameters;

         IF (cz_pb_mgr.v_status_code = PUBLICATION_ERROR)
         THEN
            rollback_data(cz_pb_mgr.v_db_link);
            x_model_id := -999;

            IF (cz_pb_mgr.v_imported_ps_ref.COUNT > 0)
            THEN
               EXECUTE IMMEDIATE    'BEGIN'
                                 || ' '
                                 || 'FOR I IN cz_pb_mgr.v_imported_ps_ref.FISRT..cz_pb_mgr.v_imported_ps_ref.LAST'
                                 || ' '
                                 || 'LOOP'
                                 || ' '
                                 || 'DELETE FROM cz_rp_entries'
                                 || cz_pb_mgr.v_db_link
                                 || ' t'
                                 || ' '
                                 || 'WHERE  t.object_id = cz_pb_mgr.v_imported_ps_ref(i)'
                                 || ' '
                                 || 'AND    t.object_type = ''PRJ'';'
                                 || ' '
                                 || 'END;';
            END IF;
         ELSE
            x_model_id := v_object_id;
         END IF;

         ----------delete dummy publication record
         DELETE FROM cz_model_publications
               WHERE publication_id = v_pub_id;

         DELETE FROM cz_model_publications
               WHERE remote_publication_id = v_pub_id;

         DELETE FROM cz_pb_model_exports
               WHERE publication_id = v_pub_id;
      END IF;

      cz_security_pvt.unlock_model(1.0, fnd_api.g_true, l_locked_models, l_lock_status, l_msg_count, l_msg_data);

      IF (l_lock_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         l_msg_index := 1;

         WHILE l_msg_count > 0
         LOOP
            cz_pb_mgr.error_msg_populate(fnd_msg_pub.get(l_msg_index, fnd_api.g_false), 'cz_pb_mgr.LOCKMODEL', SQLCODE);
            l_msg_index := l_msg_index + 1;
            l_msg_count := l_msg_count - 1;
         END LOOP;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN failed_to_lock_model
      THEN
         x_run_id := cz_pb_mgr.v_pb_run_id;
         x_status := PUBLICATION_ERROR;
         cz_security_pvt.unlock_model(1.0, fnd_api.g_true, l_locked_models, l_lock_status, l_msg_count, l_msg_data);
         log_pb_trace;
      WHEN ui_not_uptodate THEN
         x_run_id := cz_pb_mgr.v_pb_run_id;
         x_status := PUBLICATION_ERROR;
         cz_security_pvt.unlock_model(1.0, fnd_api.g_true, l_locked_models, l_lock_status, l_msg_count, l_msg_data);
         log_pb_trace;
      WHEN OTHERS
      THEN
         cz_security_pvt.unlock_model(1.0, fnd_api.g_true, l_locked_models, l_lock_status, l_msg_count, l_msg_data);
         cz_pb_mgr.v_err_message := 'Fatal error during deep model copy of model: ' || cz_pb_mgr.v_root_model_id;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODELCOPY', SQLCODE);
   END;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----signature of deep model copy that developer would call
----
   PROCEDURE deep_model_copy(
      p_model_id IN NUMBER
     ,p_server_id IN NUMBER
     ,p_folder IN NUMBER
     ,p_copy_rules IN NUMBER
     ,p_copy_uis IN NUMBER
     ,p_copy_root IN NUMBER
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
     ,p_init_msg_list IN VARCHAR2 DEFAULT FND_API.G_TRUE
   )
   IS
      TYPE message_tbl_type IS TABLE OF VARCHAR2(2000)
         INDEX BY BINARY_INTEGER;

      l_model_id cz_devl_projects.devl_project_id%TYPE;
      l_run_id NUMBER;
      l_status VARCHAR2(2000);
      l_message_tbl message_tbl_type;
      l_instr NUMBER := 0;
   BEGIN

      --initialize the message stack depending on the input parameter
      IF (p_init_msg_list = FND_API.G_TRUE) THEN
         fnd_msg_pub.initialize;
      END IF;

      x_return_status := FND_API.G_RET_STS_SUCCESS;
      x_msg_count := 0;
      x_msg_data := '';
      deep_model_copy(p_model_id, p_server_id, p_folder, p_copy_rules, p_copy_uis, p_copy_root, l_model_id, l_run_id, l_status);

      IF (l_status = PUBLICATION_ERROR)
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      END IF;
   END deep_model_copy;

------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------------procedure to publish all models
   PROCEDURE publish_all_models
   AS

      CURSOR tobepublished_cur
      IS
         SELECT   publication_id
             FROM cz_model_publications
            WHERE cz_model_publications.deleted_flag = record_not_deleted
              AND cz_model_publications.export_status = publication_pending
              AND UPPER(object_type) = model_publication
         ORDER BY publication_id;

      v_tobepublished cz_model_publications.publication_id%TYPE;
      v_run_id cz_db_logs.run_id%TYPE;
      v_pb_status cz_model_publications.export_status%TYPE;
   BEGIN

      OPEN tobepublished_cur;

      LOOP
         FETCH tobepublished_cur
          INTO v_tobepublished;

         EXIT WHEN tobepublished_cur%NOTFOUND;
         publish_model(v_tobepublished, v_run_id, v_pb_status);
      END LOOP;

      CLOSE tobepublished_cur;
   EXCEPTION
      WHEN OTHERS
      THEN
         CLOSE tobepublished_cur;

         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_GEN_ERROR', 'TOBEPUBLISHED', v_tobepublished, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISH_ALL_MODELS', SQLCODE);
   END publish_all_models;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----initialize pb parameters
   PROCEDURE initialize_pb_parameters(p_publication_id IN cz_model_publications.publication_id%TYPE)
   AS
      l_log_pb_time cz_db_settings.VALUE%TYPE;
      l_pub_mode cz_model_publications.publication_mode%TYPE;
   BEGIN
      fnd_msg_pub.initialize;
      cz_pb_mgr.v_publication_id := p_publication_id;
      cz_pb_mgr.sequence_const := 0;
      cz_pb_mgr.v_ui_str := 'x';
      cz_pb_mgr.global_export_retcode := 0;
      cz_pb_mgr.v_pb_run_id := 0.0;
      cz_pb_mgr.bomsynch_flag := 'N';
      cz_pb_mgr.v_status_code := publication_ok;
      cz_pb_mgr.v_session_parameter := pub_model;
      cz_pb_mgr.g_source_flag := cz_model_migration_pvt.pub_source_flag;
      cz_pb_mgr.g_target_flag := cz_model_migration_pvt.pub_target_flag;
      cz_pb_mgr.v_cz_model_pub_old_id := p_publication_id;
      cz_pb_mgr.v_cz_model_pub_new_id := NULL;
      cz_pb_mgr.v_ui_name := NULL;
      cz_pb_mgr.v_sql_err_msg := 'Fatal error reported';
      v_refresh_rules := 'NO';

      SELECT publication_mode
        INTO l_pub_mode
        FROM cz_model_publications
       WHERE publication_id = p_publication_id AND deleted_flag = record_not_deleted;

      IF (UPPER(l_pub_mode) = cz_model_migration_pvt.mode_migration)
      THEN
         cz_pb_mgr.v_session_parameter := cz_model_migration_pvt.migrate_model;
         cz_pb_mgr.g_source_flag := cz_model_migration_pvt.mig_source_flag;
         cz_pb_mgr.g_target_flag := cz_model_migration_pvt.mig_target_flag;
      END IF;

      ---------select run_id and user from dual
      BEGIN
         SELECT USER, cz_xfr_run_infos_s.NEXTVAL
           INTO cz_pb_mgr.loguser, cz_pb_mgr.v_pb_run_id
           FROM DUAL;
      EXCEPTION
         WHEN OTHERS
         THEN
            RAISE run_id_error;
      END;

      -------select setting for logging
      BEGIN
         SELECT VALUE
           INTO cz_pb_mgr.v_pb_log_flag
           FROM cz_db_settings
          WHERE cz_db_settings.setting_id = publication_log;
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.v_pb_log_flag := 'NO';
      END;

      -------select setting for logging publication times
      BEGIN
         SELECT VALUE
           INTO l_log_pb_time
           FROM cz_db_settings
          WHERE cz_db_settings.setting_id = pb_timing_log;

         IF (l_log_pb_time = 'YES')
         THEN
            cz_pb_mgr.g_log_timing := publication_timing;
         END IF;
      EXCEPTION
         WHEN OTHERS
         THEN
            cz_pb_mgr.g_log_timing := 1;
      END;
   EXCEPTION
      WHEN run_id_error
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_SEQ_XFR');
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.XFRINFO', SQLCODE);
      WHEN OTHERS
      THEN
         RAISE;
   END initialize_pb_parameters;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE check_ui_template_exist(p_template_id IN NUMBER, x_status IN OUT NOCOPY cz_model_publications.export_status%TYPE)
   IS
      l_count NUMBER := 0;
   BEGIN
      SELECT 1
        INTO l_count
        FROM cz_ui_templates
       WHERE cz_ui_templates.template_id = p_template_id
         AND cz_ui_templates.ui_def_id = 0
         AND cz_ui_templates.deleted_flag = record_not_deleted
         AND ROWNUM < 2;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_GLOBAL_TMPL', 'PUBID', cz_pb_mgr.v_publication_id);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISHMODEL', SQLCODE);
         x_status := PUBLICATION_ERROR;
   END check_ui_template_exist;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
--------procedure that checks if model and ui specified in the request exist
--------@p_publication_id : publication id of the request
--------@p_model_id : model id of the pb request
--------@p_ui_def_id : ui_def_id of the request
--------@x_status : publication status parameter
   PROCEDURE check_model_ui_exist(
      p_publication_id IN cz_model_publications.publication_id%TYPE
     ,p_model_id IN cz_model_publications.model_id%TYPE
     ,p_ui_def_id IN cz_model_publications.ui_def_id%TYPE
     ,x_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
   )
   AS
      v_model_chk_count NUMBER := 0.0;
      v_ui_chk_count NUMBER := 0.0;
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         SELECT COUNT(*)
           INTO v_model_chk_count
           FROM cz_devl_projects
          WHERE cz_devl_projects.devl_project_id = p_model_id AND cz_devl_projects.deleted_flag = record_not_deleted;

         IF (v_model_chk_count = 0)
         THEN
            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_MODEL', 'PUBID', p_publication_id);
            cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISHMODEL', SQLCODE);
            x_status := PUBLICATION_ERROR;
         END IF;

         v_ui_chk_count := -1;

         IF ((p_ui_def_id IS NOT NULL) AND(p_ui_def_id > 0))
         THEN
            SELECT COUNT(*)
              INTO v_ui_chk_count
              FROM cz_ui_defs
             WHERE cz_ui_defs.ui_def_id = p_ui_def_id AND cz_ui_defs.deleted_flag = record_not_deleted;

            IF (v_ui_chk_count = 0)
            THEN
               cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_NO_UI', 'PUBID', p_publication_id);
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISHMODEL', SQLCODE);
               x_status := PUBLICATION_ERROR;
            END IF;
         END IF;

         IF ((v_model_chk_count = 0) OR(v_ui_chk_count = 0))
         THEN
            update_publication_status(p_publication_id, PUBLICATION_ERROR, empty_string);
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_status := PUBLICATION_ERROR;
         RAISE;
   END check_model_ui_exist;

------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------procedure that gets the target ui def id in case no new copy is made
   PROCEDURE get_tgt_ui_def(
      p_ui_def_id IN cz_model_publications.ui_def_id%TYPE
     ,p_prev_rem_publication_id IN cz_model_publications.publication_id%TYPE
     ,x_rem_model_id IN OUT NOCOPY cz_model_publications.model_id%TYPE
     ,x_rem_ui_def_id IN OUT NOCOPY cz_model_publications.ui_def_id%TYPE
     ,x_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
   )
   AS
      v_ui_name cz_ui_defs.NAME%TYPE;
      v_old_remote_model cz_model_publications.model_id%TYPE;
      ui_cv ref_cursor;
   BEGIN
      BEGIN
         SELECT NAME
           INTO v_ui_name
           FROM cz_ui_defs
          WHERE ui_def_id = p_ui_def_id;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_ui_name := NULL;
      END;

      BEGIN
        get_remote_model_id(cz_pb_mgr.v_server_id,cz_pb_mgr.v_root_model_id,x_status,v_old_remote_model);
      EXCEPTION
         WHEN OTHERS
         THEN
            RAISE;
      END;

      x_rem_model_id := v_old_remote_model;

      IF (v_ui_name IS NOT NULL)
      THEN
         OPEN ui_cv FOR    'SELECT ui_def_id FROM cz_ui_defs'
                        || cz_pb_mgr.v_db_link
                        || ' '
                        || 'WHERE name = :1'
                        || ' '
                        || 'AND deleted_flag = ''0'' AND devl_project_id = :2' USING v_ui_name, v_old_remote_model;

         LOOP
            FETCH ui_cv
             INTO x_rem_ui_def_id;

            EXIT WHEN ui_cv%NOTFOUND;
         END LOOP;

         CLOSE ui_cv;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         CLOSE ui_cv;

         cz_pb_mgr.v_err_message := 'Error in retrieving remote ui def id for source ui_def_id: ' || TO_CHAR(p_ui_def_id) || ' : ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.GETTGTUIDEF', SQLCODE);
         x_status := PUBLICATION_ERROR;
         RAISE;
   END get_tgt_ui_def;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that checks the export status of the existing request
-----Only requests with a status of PEN can be published
   PROCEDURE check_export_status(
      p_export_status IN cz_model_publications.export_status%TYPE
     ,p_pb_flag IN VARCHAR2
     ,x_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
   )
   AS
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF (p_pb_flag = cz_publish)
         THEN
            IF ((p_export_status = 'PUP') OR(p_export_status = 'ERR') OR(p_export_status = 'PRC') OR(p_export_status = 'OK'))
            THEN
               cz_pb_mgr.v_err_message :=
                                   cz_utils.get_text('CZ_PB_FATAL_ERR', 'PUBID', cz_pb_mgr.v_publication_id, 'SQLERRM', 'Export status check failed');
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISHMODEL', SQLCODE);
               cz_pb_mgr.v_err_message := 'Publication with a status PRC/PUP/ERR may not be published';
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISHMODEL', SQLCODE);
               x_status := PUBLICATION_ERROR;
            END IF;
         ELSIF(p_pb_flag = cz_republish)
         THEN
            IF (p_export_status <> 'OK')
            THEN
               x_status := PUBLICATION_ERROR;
               cz_pb_mgr.v_err_message :=
                               cz_utils.get_text('CZ_REPUB_STATUS_CHK', 'PUBID', cz_pb_mgr.v_publication_id, 'SQLERRM', 'Export status check failed');
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISHMODEL', SQLCODE);
            END IF;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := 'Error in check pb status: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISHMODEL', SQLCODE);
         x_status := PUBLICATION_ERROR;
   END check_export_status;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE is_ui_upto_date(p_ui_def_id IN NUMBER, x_return_status OUT NOCOPY NUMBER, x_msg_data OUT NOCOPY VARCHAR2)
   IS
      l_model_name cz_devl_projects.NAME%TYPE;
   BEGIN
      IF p_ui_def_id IS NOT NULL
      THEN
         is_ui_upto_date(p_ui_def_id, 0, x_return_status, x_msg_data, l_model_name);
      END IF;
   END is_ui_upto_date;

   FUNCTION is_ui_upto_date(p_ui_def_id IN NUMBER)
      RETURN VARCHAR2
   IS
      l_return_status VARCHAR2(255);
      l_msg_data VARCHAR2(32000);
   BEGIN
      is_ui_upto_date(p_ui_def_id, l_return_status, l_msg_data);

      IF l_return_status = 2
      THEN
         RETURN '1';
      ELSE
         RETURN '0';
      END IF;
   END is_ui_upto_date;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-- return status: 0 yes, 1 no
-- directly called by developer
PROCEDURE is_model_upto_date(p_model_id IN NUMBER, x_return_status IN OUT NOCOPY NUMBER, x_msg_data IN OUT NOCOPY VARCHAR2)
IS
  l_component_id                cz_model_ref_expls.component_id%TYPE;
  l_model_name                  cz_devl_projects.NAME%TYPE;
  l_root_model_name             cz_devl_projects.NAME%TYPE;
  l_prj_last_logic_update       cz_devl_projects.last_logic_update%TYPE;
  l_prj_last_struct_update      cz_devl_projects.last_struct_update%TYPE;
  l_logic_last_update_date      cz_lce_headers.last_update_date%TYPE;
  l_root_logic_last_update_date cz_lce_headers.last_update_date%TYPE;
  l_engine_type                 cz_devl_projects.config_engine_type%TYPE;
  l_is_solver_model             BOOLEAN;

  CURSOR model_cur(in_root_model NUMBER) IS
         SELECT DISTINCT component_id
         FROM cz_model_ref_expls
         WHERE deleted_flag = '0' AND model_id = in_root_model AND ps_node_type = 263;
BEGIN
  fnd_msg_pub.initialize;

  IF p_model_id IS NOT NULL THEN
    x_return_status := 0;
    x_msg_data := '';

    BEGIN
      SELECT last_logic_update, config_engine_type, NAME
        INTO l_prj_last_logic_update, l_engine_type, l_root_model_name
      FROM cz_devl_projects
      WHERE devl_project_id = p_model_id AND deleted_flag = '0';
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE;
    END;

    l_is_solver_model := (l_engine_type IS NOT NULL AND l_engine_type = ENGINE_TYPE_FCE);

    IF l_is_solver_model THEN
      SELECT MAX(last_update_date) INTO l_root_logic_last_update_date
      FROM cz_fce_files
      WHERE component_id = p_model_id AND deleted_flag = '0';
    ELSE
      SELECT MAX(last_update_date) INTO l_root_logic_last_update_date
      FROM cz_lce_headers
      WHERE cz_lce_headers.component_id = p_model_id AND cz_lce_headers.deleted_flag = '0';
    END IF;

    IF l_root_logic_last_update_date IS NULL OR l_root_logic_last_update_date < l_prj_last_logic_update THEN
      x_return_status := 1;
      x_msg_data := l_root_model_name;
      RETURN;
    END IF;

    OPEN model_cur(p_model_id);
    LOOP
      FETCH model_cur INTO l_component_id;
      EXIT WHEN model_cur%NOTFOUND;
      --vsingava 30th Sep '08
      --bug6348111
      BEGIN
        SELECT last_logic_update, NAME, last_struct_update
	INTO l_prj_last_logic_update, l_model_name, l_prj_last_struct_update
        FROM cz_devl_projects
        WHERE cz_devl_projects.devl_project_id = l_component_id AND deleted_flag = '0';
      EXCEPTION
        WHEN OTHERS THEN
          l_prj_last_logic_update := NULL;
      END;

      IF l_prj_last_logic_update IS NOT NULL THEN
        IF l_is_solver_model THEN
          SELECT MAX(last_update_date) INTO l_logic_last_update_date
          FROM cz_fce_files
          WHERE component_id = l_component_id AND deleted_flag = '0';
        ELSE
          SELECT MAX(last_update_date) INTO l_logic_last_update_date
          FROM cz_lce_headers
          WHERE cz_lce_headers.component_id = l_component_id AND cz_lce_headers.deleted_flag = '0';
        END IF;
      END IF;

      IF l_prj_last_logic_update IS NULL OR l_logic_last_update_date IS NULL OR
         l_logic_last_update_date < l_prj_last_logic_update THEN
        x_return_status := 1;
        x_msg_data := l_model_name;
        EXIT;
      ELSIF l_root_logic_last_update_date < l_prj_last_struct_update THEN
        x_return_status := 1;
        x_msg_data := l_root_model_name;
        EXIT;
      END IF;
    END LOOP;

    CLOSE model_cur;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    x_return_status := 1;
    x_msg_data := SQLERRM;
END is_model_upto_date;
--------------------------------------------------------------------------------
-- private, check all uis if input uidefid null, check the given ui tree otherwise
   PROCEDURE model_upto_date(modelid IN NUMBER, status IN OUT NOCOPY VARCHAR2, uidefid IN NUMBER DEFAULT NULL)
   AS
      l_model_name VARCHAR2(4000);
      l_ui_name cz_ui_defs.NAME%TYPE;
      l_ui_model_name VARCHAR2(4000);
      l_model_status NUMBER;
      l_ui_status NUMBER;
      l_folder_id NUMBER;
      l_folder_path VARCHAR2(4000);
      l_model_upto_date BOOLEAN;
      l_ui_upto_date BOOLEAN;
      l_uidef_tbl  t_ref;
   BEGIN
      l_model_upto_date := TRUE;
      is_model_upto_date(modelid, l_model_status, l_model_name);

      IF l_model_status IS NOT NULL AND l_model_status <> 0 THEN
         l_model_upto_date := FALSE;
      END IF;

      l_ui_upto_date := TRUE;

      IF uidefid IS NULL THEN
        IF cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id=0 THEN
          SELECT ui_def_id BULK COLLECT INTO l_uidef_tbl
	  FROM cz_ui_defs
	  WHERE deleted_flag='0' AND ui_style=g_ui_style_jrad AND devl_project_id IN
	  (SELECT component_id FROM cz_model_ref_expls
           WHERE deleted_flag='0' AND model_id=modelid);
        ELSE
          SELECT ui_def_id BULK COLLECT INTO l_uidef_tbl
          FROM cz_ui_defs
          WHERE deleted_flag='0' AND ui_style<>-1 AND devl_project_id IN
          (SELECT component_id FROM cz_model_ref_expls
           WHERE deleted_flag='0' AND model_id=modelid);
        END IF;

        IF l_uidef_tbl.COUNT > 0 THEN
          FOR i IN l_uidef_tbl.FIRST .. l_uidef_tbl.LAST LOOP
            is_ui_upto_date(p_ui_def_id         => l_uidef_tbl(i)
                           ,p_report_model_info => 1
                           ,x_return_status     => l_ui_status
                           ,x_msg_data          => l_ui_name
                           ,x_model_name        => l_ui_model_name
                           ,p_check_root_ui_only=> TRUE
                           );
            IF l_ui_status IS NOT NULL AND l_ui_status <> 0 THEN
              l_ui_upto_date := FALSE;
              EXIT;
            END IF;
          END LOOP;
        END IF;
      ELSE
        is_ui_upto_date(uidefid, 1, l_ui_status, l_ui_name, l_ui_model_name);
        IF l_ui_status IS NOT NULL AND l_ui_status <> 0 THEN
          l_ui_upto_date := FALSE;
        END IF;
      END IF;

      -- l_status := NVL(l_model_status,0) + NVL(l_ui_status,0);
      -- 0 ok, 1 model not up to date, 2 ui node up to date, 3 both model and ui not up to date
      IF NOT l_ui_upto_date OR NOT l_model_upto_date THEN
         BEGIN
            SELECT enclosing_folder
              INTO l_folder_id
              FROM cz_rp_entries
             WHERE object_id = modelid AND enclosing_folder <> 0 AND object_type = 'PRJ' AND deleted_flag = '0';

            FOR rp_rec IN (SELECT NAME
                           FROM cz_rp_entries
                           START WITH object_type = 'FLD' AND object_id = l_folder_id
                           CONNECT BY PRIOR enclosing_folder = object_id AND object_type = 'FLD' AND object_id <> 0 AND deleted_flag = '0')
            LOOP
               l_folder_path := rp_rec.NAME || '/' || l_folder_path;
            END LOOP;
         EXCEPTION
            WHEN OTHERS THEN
               l_folder_path := NULL;
         END;
      END IF;

      IF l_folder_path IS NOT NULL AND NOT l_model_upto_date THEN
         l_model_name := l_folder_path || l_model_name;
      END IF;

      IF l_folder_path IS NOT NULL AND NOT l_ui_upto_date THEN
         l_ui_model_name := l_folder_path || l_ui_model_name;
      END IF;

      IF NOT l_ui_upto_date AND l_model_upto_date THEN                                                     -- l_status = 2
         status :=
            cz_utils.get_text('CZ_PB_MODEL_NOT_UP_TO_DATE', 'STRING', CZ_UTILS.GET_TEXT('CZ_UI_TEXT') || ' ''' || l_ui_name || '''', 'MODELID', '''' || l_ui_model_name || '''');
      ELSIF l_ui_upto_date AND NOT l_model_upto_date THEN                                                  -- l_status = 1
         status := cz_utils.get_text('CZ_PB_MODEL_NOT_UP_TO_DATE', 'STRING', CZ_UTILS.GET_TEXT('CZ_LOGIC_TEXT') , 'MODELID', '''' || l_model_name || '''');
      ELSIF NOT l_ui_upto_date AND NOT l_model_upto_date THEN                                              -- l_status = 3
         status :=
                  cz_utils.get_text('CZ_PB_UI_LOGIC_NOT_UP_TO_DATE', 'STRING', '''' || l_ui_name || '''', 'MODELID', '''' || l_ui_model_name || '''');
      ELSE
         status := '0';
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
         log_pb_errors(SQLERRM, 1, 'cz_pb_mgr.MODEL_UPTO_DATE', SQLCODE);
         raise_application_error(-20010, SQLERRM);
   END model_upto_date;
-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-- public
PROCEDURE model_upto_date(modelid IN NUMBER, uidefid IN NUMBER, status IN OUT NOCOPY VARCHAR2)
AS
BEGIN
  model_upto_date(modelid, status, uidefid);
END model_upto_date;
----------------------------------------------------------------------------------
   FUNCTION migrate_name(p_devl_project_id IN NUMBER)
      RETURN VARCHAR2
   IS
      original_name cz_devl_projects.NAME%TYPE;
      v_name cz_devl_projects.NAME%TYPE;
      v_instance_name cz_servers.instance_name%TYPE;
      v_null PLS_INTEGER;
      l_endBr varchar2(3):=NULL;
   BEGIN
      BEGIN
         SELECT instance_name
           INTO v_instance_name
           FROM cz_servers
          WHERE server_local_id = 0;

         SELECT NAME
           INTO original_name
           FROM cz_rp_entries
          WHERE object_id = p_devl_project_id AND object_type = 'PRJ' AND deleted_flag = '0';
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            original_name := NULL;
            RAISE;
         WHEN OTHERS
         THEN
            original_name := NULL;
            RAISE;
      END;

      IF (original_name IS NOT NULL)
      THEN
         IF cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id=0 THEN
         v_name := SUBSTR (original_name|| '-[FCE]', 1, 235);

	 ELSE
         v_name :=
               SUBSTR (original_name
            || ' (Migrated from '
            || v_instance_name
            || ':'
            || REPLACE(cz_developer_utils_pvt.get_repository_path(p_devl_project_id, 'PRJ'), '/', '.'), 1, 235);
            -- Bug 5514199; 12-Sep-2006; kdande; Taking 235 chars only as other characters would be appended at runtime like copy x, rules etc
         END IF;

	 IF cz_pb_mgr.v_session_parameter=cz_model_migration_pvt.migrate_model AND cz_pb_mgr.v_server_id=0 THEN
	         l_endBr:='';
	 ELSE
		 l_endBr:=')';
	 END IF;
         BEGIN
            EXECUTE IMMEDIATE    'SELECT NULL FROM cz_rp_entries'
                              || cz_pb_mgr.v_db_link
                              || ' WHERE deleted_flag = ''0'' AND object_type = ''PRJ'' AND '
                              || '       name = :1'
                         INTO v_null
                        USING v_name || l_endBr;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN v_name || l_endBr;
         END;

         BEGIN
            EXECUTE IMMEDIATE    'SELECT COUNT(*) FROM cz_rp_entries'
                              || cz_pb_mgr.v_db_link
                              || ' WHERE deleted_flag = ''0'' AND object_type = ''PRJ'' AND '
                              || '       name LIKE :1'
                         INTO v_null
                        USING v_name || ' copy _%'||l_endBr;

            --This is copy v_null + 1.
            RETURN v_name || ' copy ' || TO_CHAR(v_null + 1) || l_endBr;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN v_name || ' copy 1'||l_endBr;
         END;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         log_report('cz_utils', 'migrate_name', 1, SQLERRM, fnd_log.level_unexpected);
         v_name := 'ERROR';
         RETURN v_name;
   END;

----------------------------------------------------------------------------------
--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
---------procedure to publish a single model
PROCEDURE publish_model(publicationid IN NUMBER, x_run_id IN OUT NOCOPY NUMBER, x_pb_status IN OUT NOCOPY VARCHAR2)
AS
  l_publication_proc  CONSTANT  VARCHAR2(10) := 'CZ_PB_MGR';
  l_migration_proc    CONSTANT  VARCHAR2(20) := 'CZ_MODEL_MIGRATION';
  l_proc_name  v$session.module%TYPE;
  v_check_publication BOOLEAN;
  v_new_copy_pb_id cz_model_publications.publication_id%TYPE;
  v_new_model_id cz_model_publications.model_id%TYPE;
  v_prev_publication_id cz_model_publications.publication_id%TYPE;
  v_prev_export_status cz_model_publications.export_status%TYPE;
  v_cur_export_status cz_model_publications.export_status%TYPE;
  v_pb_mode cz_model_publications.publication_mode%TYPE;
  l_tgt_status VARCHAR2(1);
  l_tgt_msg VARCHAR2(2000);
  l_msg_data VARCHAR2(2000);
  l_msg_count NUMBER;
  l_lock_status VARCHAR2(1);
  v_rp_entries_name cz_rp_entries.NAME%TYPE;
  v_rp_entries_desc cz_rp_entries.description%TYPE;
  v_object_id cz_rp_entries.object_id%TYPE;
  v_rp_orig_sys_ref VARCHAR2(255);
  v_imp_ps_node_count PLS_INTEGER;
  l_locked_models cz_security_pvt.number_type_tbl;
  l_upto_date_status VARCHAR2(2000);
  l_msg_index NUMBER;
  v_max_rec_id NUMBER;
  l_message VARCHAR2(32000);
  l_srcroot VARCHAR2(32000);
  l_targrootpath VARCHAR2(32000);
  l_srcmodel VARCHAR2(32000);
  l_tgt_fld_path VARCHAR2(32000);
  v_org_id cz_xfr_project_bills.organization_id%TYPE;                            -- Bug9031588
  v_component_item_id cz_xfr_project_bills.component_item_id%TYPE;                -- Bug9031588
  v_top_item_id cz_xfr_project_bills.top_item_id%TYPE;                           -- Bug9031588

  v_import_server_on_remote cz_servers.server_local_id%TYPE;
  l_target_imp_server_on_local  cz_servers.server_local_id%TYPE;

  has_no_priv_to_publish EXCEPTION;
  failed_to_lock_model EXCEPTION;
  priv_check_err EXCEPTION;
  not_global_template EXCEPTION;
  model_not_upto_date EXCEPTION;
  invalid_object_type EXCEPTION;
  user_not_initialized EXCEPTION;
  cz_pb_link_problem EXCEPTION;

BEGIN
  pbdebug := 22001;
  delete_session_parameters;
  clear_all_tables(cz_pb_mgr.v_status_code);
  initialize_pb_parameters(publicationid);

  IF (fnd_global.user_name IS NULL) THEN
    cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_FATAL_ERR', 'PUBID', publicationid, 'SQLERRM', 'User is not initialized on session');
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CHECKUSER', 21002);
    RAISE user_not_initialized;
  END IF;

  get_source_pb_info(publicationid
                    ,cz_pb_mgr.v_root_model_id
                    ,cz_pb_mgr.v_root_ui_def_id
                    ,cz_pb_mgr.v_server_id
                    ,v_cur_export_status
                    ,cz_pb_mgr.remote_publication_id
                    ,g_object_type
                    ,v_pb_mode
                    ,cz_pb_mgr.v_status_code
                    );

  -- check if there is another publishing or a pub sync or a migration process running
  IF g_object_type = cz_pb_mgr.MODEL_PUBLICATION THEN
    l_proc_name := cz_pb_sync_util.check_process;
  ELSE -- must be migration because no stand alone UIT publication
    BEGIN
      SELECT module INTO l_proc_name FROM V$SESSION WHERE module = l_migration_proc;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        NULL;
    END;
  END IF;

  IF l_proc_name IS NOT NULL THEN
    IF l_proc_name = l_publication_proc THEN
      cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT('CZ_PB_PROCESS_EXISTS', 'PROC_TYPE', 'publication');
    ELSIF l_proc_name = l_migration_proc THEN
      cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT('CZ_PB_PROCESS_EXISTS', 'PROC_TYPE', 'model migration');
    ELSE
      cz_pb_mgr.v_err_message := CZ_UTILS.GET_TEXT('CZ_PB_SYNC_PROCESS_EXISTS');
    END IF;
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message,'cz_pb_mgr.CHKPROCESS',21001);
    cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
    x_pb_status := PUBLICATION_ERROR;
    cz_pb_mgr.GLOBAL_EXPORT_RETCODE := 2;
    log_pb_errors(cz_pb_mgr.v_err_message,0,'cz_pb_mgr.PUBLISH_MODEL',-1);
    RETURN;
  END IF;

  -- register application
  IF g_object_type = cz_pb_mgr.MODEL_PUBLICATION THEN
    dbms_application_info.set_module(l_publication_proc, '');
  ELSE
    dbms_application_info.set_module(l_migration_proc, '');
  END IF;

  BEGIN
    IF (cz_pb_mgr.g_log_timing = publication_timing) THEN
      log_timing_message('start publish model');
    END IF;

      ----check if model is up to date
    --  IF (g_object_type = MODEL_PUBLICATION) THEN
         model_upto_date(cz_pb_mgr.v_root_model_id, l_upto_date_status);

         IF (l_upto_date_status <> '0') THEN
            cz_pb_mgr.v_err_message := l_upto_date_status;
            RAISE model_not_upto_date;
         END IF;
    --  END IF;

      IF (g_object_type = template_publication) THEN
         check_ui_template_exist(cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_status_code);

         IF (cz_pb_mgr.v_status_code = PUBLICATION_ERROR) THEN
            RAISE not_global_template;
         END IF;
      ELSIF(g_object_type = MODEL_PUBLICATION) THEN
         check_model_ui_exist(publicationid, cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_root_ui_def_id, cz_pb_mgr.v_status_code);
      ELSIF(cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model) THEN
         RAISE invalid_object_type;
      END IF;

      check_export_status(v_cur_export_status, cz_publish, cz_pb_mgr.v_status_code);

      IF (cz_pb_mgr.v_status_code = PUBLICATION_ERROR) THEN
         RAISE invalid_object_type;
      END IF;

      ------ retrieve_db_link
      cz_pb_mgr.v_db_link := retrieve_db_link(cz_pb_mgr.v_server_id);

      -----check for source server flag on the target instance
      IF (cz_pb_mgr.v_server_id <> 0) THEN
         IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
            cz_pb_sync_util.verify_mig_tgt_server(cz_pb_mgr.v_db_link, l_tgt_status, l_tgt_msg);
         ELSE
            cz_pb_sync_util.verify_tgt_server(cz_pb_mgr.v_db_link, l_tgt_status, l_tgt_msg);
         END IF;

         IF (l_tgt_status <> '0') THEN

            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_FATAL_ERR', 'PUBID', publicationid, 'SQLERRM', l_tgt_msg);
            RAISE cz_pb_link_problem;
         END IF;
      END IF;

      l_target_imp_server_on_local := cz_pb_mgr.v_server_id;

      IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model) THEN

         ----check for remote publication id on the target instance

         remote_pb_check(cz_pb_mgr.remote_publication_id);

      ELSE

         /*
          * Bug 5516478
          * On migrating a model to a remote server, if there are BOM models involved,
          * CZ_XFR_PROJECT_BILLS are also migrated.  However, the column SOURCE_SERVER
          * in CZ_XFR_PROJECT_BILLS needs to be resolved to the import server on the
          * migration target.  Currently it was being copied from the source to the
          * target.  In order to do this we need to query CZ_SERVERS in the migration
          * target to get the SERVER_LOCAL_ID.
          */

          v_import_server_on_remote := getRemoteImportServer(l_target_imp_server_on_local);

      END IF;

      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) THEN
         IF (cz_pb_mgr.g_log_timing = publication_timing) THEN
            log_timing_message('start has_tobe_published');
         END IF;

         ----check if the publication has to be published
         IF (cz_pb_mgr.v_session_parameter <> cz_model_migration_pvt.migrate_model) THEN
            v_check_publication := has_tobe_published(publicationid);
         ELSE
            v_check_publication := TRUE;
            ---for publishing, rules related tables are cleared in get_oa_tmpls
            ---which is called from has_to_be_published.
            ---for model migration, get_oa_tmpls is called from upload_ui_schema
            ---at which point, tables cannot be cleared because rules of the model have
            ---already been collected in these tables from bulk_collect_rules.
            ---so, if model migration, the rules related tables will NOT be cleared
            ---get_oa_tmpls.
            clear_tables('cz_rules', 'ref', cz_pb_mgr.v_status_code);
         END IF;

         IF (cz_pb_mgr.g_log_timing = publication_timing) THEN
            log_timing_message('end has_tobe_published');
         END IF;

         cz_security_pvt.lock_model(1.0
                                   ,cz_pb_mgr.v_root_model_id
                                   ,fnd_api.g_true
                                   ,fnd_api.g_true
                                   ,l_locked_models
                                   ,l_lock_status
                                   ,l_msg_count
                                   ,l_msg_data
                                   );

         IF (l_lock_status <> 'S') THEN
            l_msg_index := 1;

            WHILE l_msg_count > 0
            LOOP
               cz_pb_mgr.v_err_message :=
                               cz_utils.get_text('CZ_PB_FATAL_ERR', 'PUBID', publicationid, 'SQLERRM', fnd_msg_pub.get(l_msg_index, fnd_api.g_false));
               cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOCKMODEL', SQLCODE);
               l_msg_index := l_msg_index + 1;
               l_msg_count := l_msg_count - 1;
            END LOOP;

            RAISE failed_to_lock_model;
         END IF;

         UPDATE cz_model_publications
            SET export_status = publication_processing
          WHERE publication_id = cz_pb_mgr.v_publication_id;

         IF (v_check_publication) THEN
            IF (cz_pb_mgr.g_log_timing = publication_timing) THEN
               log_timing_message('start verify_model_for_sync');
            END IF;

            IF (g_object_type = MODEL_PUBLICATION OR cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
               verify_model_for_sync(l_target_imp_server_on_local, cz_pb_mgr.v_root_model_id);
            END IF;

            IF (cz_pb_mgr.g_log_timing = publication_timing) THEN
               log_timing_message('end verify_model_for_sync');
               log_timing_message('start proc_export');
            END IF;

            BEGIN
               proc_export(cz_pb_mgr.v_publication_id, cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_server_id, cz_pb_mgr.v_status_code);

               IF ((cz_pb_mgr.v_root_model_id > 0) AND(cz_pb_mgr.v_session_parameter <> model_copy) AND(cz_pb_mgr.v_models_to_be_exported.COUNT = 0)) THEN
                  cz_pb_mgr.v_err_message := 'model data up to date, no fresh data export required';
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.publish_model', SQLCODE);
               END IF;

               insert_template_elements;

--------------------------------------------------------------------------------------------
--If this is Model Migration, insert into cz_rp_entries, calculate max_persistent_rec_id and
--and insert into CZ_PERSISTENT_REC_IDS with its value, report the migrated and not migrated models.
--------------------------------------------------------------------------------------------

             IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) THEN
               IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model) THEN
                  EXECUTE IMMEDIATE    'SELECT REPLACE(cz_developer_utils_pvt.get_repository_path'
                                    || cz_pb_mgr.v_db_link
                                    || '(:1, ''FLD''), ''/'', ''.'') FROM DUAL'
                               INTO l_tgt_fld_path
                              USING cz_pb_mgr.g_migration_tgt_folder_id;

                  IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0) THEN
                     v_imp_ps_node_count := 0;

                     FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
                     LOOP
                        v_imp_ps_node_count := cz_pb_mgr.v_imported_ps_ref.COUNT + 1;
                        cz_pb_mgr.v_imported_ps_node := cz_pb_mgr.v_models_to_be_exported(i);
                        cz_pb_mgr.v_imported_ps_ref(v_imp_ps_node_count) := cz_pb_mgr.v_models_to_be_exported(i);

                        BEGIN
                           SELECT remote_model_id
                             INTO v_object_id
                             FROM cz_pb_model_exports
                            WHERE cz_pb_model_exports.model_id = cz_pb_mgr.v_models_to_be_exported(i)
                              AND cz_pb_model_exports.publication_id = cz_pb_mgr.v_publication_id;
                        EXCEPTION
                           WHEN OTHERS THEN
                              cz_pb_mgr.v_err_message := 'Error in retrieving remote model id : ' || SQLERRM;
                              cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MIGRATEMODEL', SQLCODE);
                        END;

                        BEGIN
                           SELECT desc_text, orig_sys_ref
                             INTO v_rp_entries_desc, v_rp_orig_sys_ref
                             FROM cz_devl_projects
                            WHERE cz_devl_projects.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) AND cz_devl_projects.deleted_flag = '0';
                        EXCEPTION
                           WHEN NO_DATA_FOUND THEN
                              v_rp_orig_sys_ref := NULL;
                              cz_pb_mgr.v_err_message := 'No desc exists for devl_project_id : ' || SQLERRM;
                              cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MIGRATEMODEL', SQLCODE);
                           WHEN OTHERS THEN
                              v_rp_orig_sys_ref := NULL;
                              cz_pb_mgr.v_err_message := 'Error in retrieving desc from cz_devl_projects for devl_project_id: ' || SQLERRM;
                              cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MIGRATEMODEL', SQLCODE);
                              cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                        END;

                        v_rp_entries_name := migrate_name(cz_pb_mgr.v_models_to_be_exported(i));

                        IF (v_rp_entries_name = 'ERROR') THEN
                           cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                        END IF;

                        IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) THEN
                           cz_pb_mgr.v_new_object_id := v_object_id;

                           BEGIN
                              cz_pb_mgr.v_rp_folder_id := cz_pb_mgr.g_migration_tgt_folder_id;
                              cz_pb_mgr.v_rp_name := v_rp_entries_name;
                              cz_pb_mgr.v_rp_desc := v_rp_entries_desc;

                              EXECUTE IMMEDIATE    'BEGIN'
                                                || ' '
                                                || 'insert into cz_rp_entries'
                                                || cz_pb_mgr.v_db_link
                                                || ' ( OBJECT_TYPE'
                                                || ' '
                                                || ',OBJECT_ID'
                                                || ' '
                                                || ',ENCLOSING_FOLDER'
                                                || ' '
                                                || ',NAME'
                                                || ' '
                                                || ',DESCRIPTION'
                                                || ' '
                                                || ',DELETED_FLAG'
                                                || ' '
                                                || ',SEEDED_FLAG'
                                                || ' '
                                                || ')'
                                                || ' '
                                                || 'VALUES ( ''PRJ'''
                                                || ' '
                                                || ',cz_pb_mgr.v_new_object_id'
                                                || ' '
                                                || ',cz_pb_mgr.v_rp_folder_id'
                                                || ' '
                                                || ',cz_pb_mgr.v_rp_name'
                                                || ' '
                                                || ',cz_pb_mgr.v_rp_desc'
                                                || ' '
                                                || ',''0'''
                                                || ' '
                                                || ',''0'');'
                                                || ' '
                                                || 'commit;'
                                                || ' '
                                                || 'END;';
                           EXCEPTION
                              WHEN OTHERS THEN
                                 cz_pb_mgr.v_err_message := 'Error in inserting into cz_rp_entries: ' || SQLERRM;
                                 cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MIGRATEMODEL', SQLCODE);
                                 cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                           END;

                           BEGIN
                              IF (cz_pb_mgr.v_rp_name IS NOT NULL) THEN

				 EXECUTE IMMEDIATE    'BEGIN'
                                                   || ' '
                                                   || 'UPDATE cz_devl_projects'
                                                   || cz_pb_mgr.v_db_link
                                                   || '  t'
                                                   || ' '
                                                   || 'SET t.name = cz_pb_mgr.v_rp_name'
                                                   || ', post_migr_change_flag = '''
                                                   || cz_model_migration_pvt.change_flag_unchanged
                                                   || ''' '
                                                   || 'WHERE  t.devl_project_id = '
                                                   || cz_pb_mgr.v_new_object_id
                                                   || ';'
                                                   || ' '
                                                   || 'END;';

                              END IF;

                              COMMIT;
                           EXCEPTION
                              WHEN OTHERS THEN
                                 cz_pb_mgr.v_err_message := 'Error in updating cz_devl_projects with the new project name: ' || SQLERRM;
                                 cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MIGRATEMODEL', SQLCODE);
                                 cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                           END;

                           --Calculate the max_persistent_rec_id for the model and insert into CZ_PERSISTENT_REC_IDS.
                           EXECUTE IMMEDIATE    'SELECT GREATEST(NVL((SELECT MAX(persistent_node_id) FROM cz_ps_nodes'
                                             || cz_pb_mgr.v_db_link
                                             || '                      WHERE deleted_flag = ''0'' AND devl_project_id = :1), 0),'
                                             || '                NVL((SELECT MAX(persistent_rule_id) FROM cz_rules'
                                             || cz_pb_mgr.v_db_link
                                             || '                      WHERE deleted_flag = ''0'' AND devl_project_id = :2), 0),'
                                             || '                NVL((SELECT MAX(persistent_intl_text_id) FROM cz_localized_texts'
                                             || cz_pb_mgr.v_db_link
                                             || '                      WHERE deleted_flag = ''0'' AND model_id = :3), 0)) FROM DUAL'
                                        INTO v_max_rec_id
                                       USING v_object_id, v_object_id, v_object_id;


                           BEGIN

			      EXECUTE IMMEDIATE    'BEGIN'
                                                   || ' '
                                                   || 'INSERT INTO CZ_PERSISTENT_REC_IDS'
                                                   || cz_pb_mgr.v_db_link
                                                   || '(devl_project_id,max_persistent_rec_id,deleted_flag)'
                                                   || ' '
                                                   || 'values(:1,:2,0) '
                                                   || ';'
                                                   || ' '
                                                   || 'END;' USING cz_pb_mgr.v_new_object_id,v_max_rec_id;


                              COMMIT;
                           EXCEPTION
                              WHEN OTHERS THEN
                                 cz_pb_mgr.v_err_message := 'Error in inserting into CZ_PERSISTENT_REC_IDS' || SQLERRM;
                                 cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MIGRATEMODEL', SQLCODE);
                                 cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                           END;

                           ------insert into cz_xfr_project_bills
                           IF (v_rp_orig_sys_ref IS NOT NULL) THEN
                              BEGIN
-- Bug9031588
                           SELECT DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.projectBill_orgId(organization_id), organization_id)
                                 ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.projectBill_compItemId(component_item_id),component_item_id)
                                 ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.projectBill_topItemId(top_item_id),top_item_id)
                             INTO v_org_id, v_component_item_id, v_top_item_id
                             FROM cz_xfr_project_bills
                            WHERE cz_xfr_project_bills.MODEL_PS_NODE_ID = cz_pb_mgr.v_imported_ps_node
                              AND cz_xfr_project_bills.deleted_flag = '0';

                                 EXECUTE IMMEDIATE    'BEGIN'
                                                   || ' '
                                                   || 'insert into cz_xfr_project_bills'
                                                   || cz_pb_mgr.v_db_link
                                                   || ' ('
                                                   || ' '
                                                   || 'MODEL_PS_NODE_ID'
                                                   || ' '
                                                   || ',ORGANIZATION_ID'
                                                   || ' '
                                                   || ',COMPONENT_ITEM_ID'
                                                   || ' '
                                                   || ',DESCRIPTION'
                                                   || ' '
                                                   || ',LAST_IMPORT_RUN_ID'
                                                   || ' '
                                                   || ',LAST_IMPORT_DATE'
                                                   || ' '
                                                   || ',SOURCE_BILL_DELETED'
                                                   || ' '
                                                   || ',TOP_ITEM_ID'
                                                   || ' '
                                                   || ',DELETED_FLAG'
                                                   || ' '
                                                   || ',EXPLOSION_TYPE'
                                                   || ' '
                                                   || ',BILL_REVISION_DATE'
                                                   || ' '
                                                   || ',EFF_FROM'
                                                   || ' '
                                                   || ',EFF_TO'
                                                   || ' '
                                                   || ',SOURCE_SERVER'
                                                   || ' '
                                                   || ',COPY_ADDL_CHILD_MODELS'
                                                   || ' '
                                                   || ')'
                                                   || ' '
                                                   || 'SELECT  cz_pb_mgr.v_new_object_id'
                                                   || ' '
                                                   || ',:1'
                                                   || ' '
                                                   || ',:2'
                                                   || ' '
                                                   || ',DESCRIPTION'
                                                   || ' '
                                                   || ',LAST_IMPORT_RUN_ID'
                                                   || ' '
                                                   || ',LAST_IMPORT_DATE'
                                                   || ' '
                                                   || ',SOURCE_BILL_DELETED'
                                                   || ' '
                                                   || ',:3'
                                                   || ' '
                                                   || ',DELETED_FLAG'
                                                   || ' '
                                                   || ',EXPLOSION_TYPE'
                                                   || ' '
                                                   || ',BILL_REVISION_DATE'
                                                   || ' '
                                                   || ',EFF_FROM'
                                                   || ' '
                                                   || ',EFF_TO'
                                                   || ' '
                                                   || ',:4'
                                                   || ' '
                                                   || ',COPY_ADDL_CHILD_MODELS'
                                                   || ' '
                                                   || 'FROM   cz_xfr_project_bills'
                                                   || ' '
                                                   || 'WHERE  cz_xfr_project_bills.MODEL_PS_NODE_ID = cz_pb_mgr.v_imported_ps_node'
                                                   || ' '
                                                   || 'AND   cz_xfr_project_bills.deleted_flag = ''0'';'
                                                   || ' '
                                                   || 'commit;'
                                                   || ' '
                                                   || 'END;'
                                                   USING v_org_id, v_component_item_id, v_top_item_id, v_import_server_on_remote;   -- Bug9031588
                              EXCEPTION
                                 WHEN NO_DATA_FOUND THEN
                                    cz_pb_mgr.v_err_message := 'Error in inserting into cz_xfr_projects : ' || SQLERRM;
                                    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MIGRATEMODEL', SQLCODE);
                                 WHEN OTHERS THEN
                                    cz_pb_mgr.v_err_message := 'Error in inserting into cz_xfr_projects : ' || SQLERRM;
                                    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MIGRATEMODEL', SQLCODE);
                                    cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                              END;
                           END IF;
                        END IF;

                        IF (cz_pb_mgr.v_models_to_be_exported(i) = cz_pb_mgr.v_root_model_id) THEN
                           l_srcroot := REPLACE(cz_developer_utils_pvt.get_repository_path(cz_pb_mgr.v_root_model_id, 'PRJ'), '/', '.');
                           l_targrootpath := l_tgt_fld_path || '.' || v_rp_entries_name;
                        END IF;

                        v_remote_names_exported(i) := v_rp_entries_name;
                     END LOOP;

                     IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) THEN
                        FOR i IN 1 .. v_models_to_be_exported.COUNT
                        LOOP
                           IF (cz_pb_mgr.v_models_to_be_exported(i) = cz_pb_mgr.v_root_model_id) THEN
--Root Model %SRCROOT was migrated to instance %TARGET as %TARGROOTPATH.
                              l_message :=
                                 cz_utils.get_text('CZ_MM_ROOT_EXPORTED'
                                                  ,'SRCROOT'
                                                  ,l_srcroot
                                                  ,'TARGET'
                                                  ,cz_pb_mgr.v_server_local_name
                                                  ,'TARGROOTPATH'
                                                  ,l_targrootpath
                                                  );
                              log_pb_errors(l_message, 0, 'cz_pb_mgr.MIGRATEMODEL', -1);
                           ELSE
--Referenced Model %SRCMODEL was migrated to instance %TARGET as %TARGREPOSPATH when migrating %SRCROOT to %TARGROOTPATH.
                              l_srcmodel := REPLACE(cz_developer_utils_pvt.get_repository_path(v_models_to_be_exported(i), 'PRJ'), '/', '.');
                              l_message :=
                                 cz_utils.get_text('CZ_MM_MODEL_EXPORTED'
                                                  ,'SRCMODEL'
                                                  ,l_srcmodel
                                                  ,'TARGET'
                                                  ,cz_pb_mgr.v_server_local_name
                                                  ,'TARGREPOSPATH'
                                                  , l_tgt_fld_path || '.' || v_remote_names_exported(i)
                                                  ,'SRCROOT'
                                                  ,l_srcroot
                                                  ,'TARGROOTPATH'
                                                  ,l_targrootpath
                                                  );
                              log_pb_errors(l_message, 0, 'cz_pb_mgr.MIGRATEMODEL', -1);
                           END IF;
                        END LOOP;
                     END IF;
                  END IF;

                  IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) THEN
                     FOR i IN 1 .. v_models_not_to_be_exported.COUNT
                     LOOP
--Referenced Model %SRCMODEL is unchanged locally and on instance %TARGET since its prior migration as %TARGREPOSPATH.
--It has been reused in migrating root Model %SRCROOT to %TARGROOTPATH.
                        l_srcmodel := REPLACE(cz_developer_utils_pvt.get_repository_path(v_models_not_to_be_exported(i), 'PRJ'), '/', '.');
                        l_message :=
                           cz_utils.get_text('CZ_MM_MODEL_NOT_EXPORTED'
                                            ,'SRCMODEL'
                                            ,l_srcmodel
                                            ,'TARGET'
                                            ,cz_pb_mgr.v_server_local_name
                                            ,'TARGREPOSPATH'
                                            ,v_remote_names_not_exported(v_models_not_to_be_exported(i))
                                            ,'SRCROOT'
                                            ,l_srcroot
                                            ,'TARGROOTPATH'
                                            ,l_targrootpath
                                            );
                        log_pb_errors(l_message, 0, 'cz_pb_mgr.MIGRATEMODEL', -1);
                     END LOOP;
                  END IF;
               END IF;
            END IF;

--------------------------------------------------------------------------------------------
--End of Model Migration section.
--------------------------------------------------------------------------------------------

               -------update source pb record
               update_pb_status(cz_pb_mgr.v_publication_id, cz_pb_mgr.v_status_code, cz_pb_mgr.v_models_to_be_exported, cz_pb_mgr.v_status_code);

               IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) THEN
                  cz_pb_mgr.v_err_message :=
                                          cz_utils.get_text('CZ_PB_SUCCESS', 'MODELID', cz_pb_mgr.v_root_model_id, 'SERVERID', cz_pb_mgr.v_server_id);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PUBLISH_MODEL', SQLCODE);
               ELSE
                  cz_pb_mgr.global_export_retcode := 2;
                  rollback_data(cz_pb_mgr.v_db_link);
               END IF;

               COMMIT;
            EXCEPTION
               WHEN OTHERS THEN
                  -----message already logged
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  update_publication_status(cz_pb_mgr.v_publication_id, PUBLICATION_ERROR, empty_string);
            END;

            IF (cz_pb_mgr.g_log_timing = publication_timing) THEN
               log_timing_message('end proc_export');
            END IF;
         ELSE                                                                                              /* else of IF (v_check_publication) THEN */
            BEGIN
               IF (cz_pb_mgr.remote_publication_id IS NOT NULL) THEN
                  get_republish_pb_info(cz_pb_mgr.remote_publication_id
                                       ,'PUP'
                                       ,v_prev_publication_id
                                       ,v_prev_export_status
                                       ,cz_pb_mgr.v_prev_remote_publication_id
                                       ,cz_pb_mgr.v_status_code
                                       );

                  IF (v_prev_publication_id > 0) THEN
                     cz_pb_mgr.v_err_message := 'Re-publish of publication: ' || TO_CHAR(publicationid);
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZREPUB', SQLCODE);
                  END IF;
               ELSIF(cz_pb_mgr.remote_publication_id IS NULL) THEN
                  get_max_pub_id(cz_pb_mgr.v_root_model_id, cz_pb_mgr.v_server_id, v_new_copy_pb_id, cz_pb_mgr.v_status_code);
                  get_new_copy_pb_info(v_new_copy_pb_id
                                      ,v_prev_publication_id
                                      ,v_prev_export_status
                                      ,cz_pb_mgr.v_prev_remote_publication_id
                                      ,cz_pb_mgr.v_status_code
                                      );

                  IF (v_prev_publication_id > 0) THEN
                     cz_pb_mgr.v_err_message := 'New Copy of publication: ' || TO_CHAR(NVL(publicationid, 0));
                     cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.CZNCOPY', SQLCODE);
                  END IF;
               END IF;                                                                /* end if of IF (cz_pb_mgr.remote_publication_id IS NOT NULL) */

               -------------get new sequence_no for the target publication_id
               get_new_publication_id(cz_pb_mgr.v_publication_id
                                     ,cz_pb_mgr.v_cz_model_pub_old_id
                                     ,cz_pb_mgr.v_cz_model_pub_new_id
                                     ,cz_pb_mgr.remote_publication_id
                                     ,cz_pb_mgr.v_status_code
                                     );
               ------get new ui def id and model id
               get_tgt_ui_def(cz_pb_mgr.v_root_ui_def_id
                             ,cz_pb_mgr.v_prev_remote_publication_id
                             ,v_new_model_id
                             ,cz_pb_mgr.new_ui_def_id
                             ,cz_pb_mgr.v_status_code
                             );
               ------insert new target publication record
               insert_tgt_publication(cz_pb_mgr.v_cz_model_pub_new_id
                                     ,cz_pb_mgr.v_cz_model_pub_old_id
                                     ,v_new_model_id
                                     ,cz_pb_mgr.new_ui_def_id
                                     ,cz_pb_mgr.v_db_link
                                     ,'REPUBLISH'
                                     ,cz_pb_mgr.v_status_code
                                     );
               ---------------insert applicability parameters for tgt publication
               insert_pb_parameters(cz_pb_mgr.v_cz_model_pub_new_id
                                   ,cz_pb_mgr.v_cz_model_pub_old_id
                                   ,cz_pb_mgr.v_session_parameter
                                   ,cz_pb_mgr.v_db_link
                                   ,cz_pb_mgr.v_status_code
                                   );
            EXCEPTION
               WHEN OTHERS THEN
                  -----message already logged
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
            END;

            ------reset status to the original if a re-publish fails
            IF (LTRIM(RTRIM(UPPER(v_prev_export_status))) = 'PUP') THEN
               IF (cz_pb_mgr.v_status_code = PUBLICATION_ERROR) THEN
                  UPDATE cz_model_publications
                     SET export_status = 'OK'
                   WHERE publication_id = v_prev_publication_id;
               ELSE
                  UPDATE cz_model_publications
                     SET deleted_flag = '1'
                   WHERE publication_id = v_prev_publication_id;

                  EXECUTE IMMEDIATE    'BEGIN'
                                    || ' '
                                    || 'UPDATE cz_model_publications'
                                    || cz_pb_mgr.v_db_link
                                    || ''
                                    || ' '
                                    || 'SET deleted_flag = ''1'''
                                    || ' '
                                    || 'WHERE publication_id = cz_pb_mgr.v_prev_remote_publication_id ;'
                                    || ' '
                                    || 'END;';
               END IF;
            END IF;

            -------update source pb record
            update_pb_status(cz_pb_mgr.v_publication_id, cz_pb_mgr.v_status_code, cz_pb_mgr.v_models_to_be_exported, cz_pb_mgr.v_status_code);

            IF (cz_pb_mgr.v_status_code = PUBLICATION_ERROR) THEN
               -----set status for concurrent manager
               cz_pb_mgr.global_export_retcode := 2;
               rollback_data(cz_pb_mgr.v_db_link);
            END IF;
         END IF;                                                                                         /* end if of IF (v_check_publication) THEN */
      END IF;                                                                           /* end if of (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) */

      l_msg_count := 0;
      l_msg_index := 0;
      cz_security_pvt.unlock_model(1.0, fnd_api.g_true, l_locked_models, l_lock_status, l_msg_count, l_msg_data);

      IF (l_lock_status <> 'S') THEN
         l_msg_index := 1;

         WHILE l_msg_count > 0
         LOOP
            cz_pb_mgr.error_msg_populate(fnd_msg_pub.get(l_msg_index, fnd_api.g_false), 'cz_pb_mgr.LOCKMODEL', SQLCODE);
            l_msg_index := l_msg_index + 1;
            l_msg_count := l_msg_count - 1;
         END LOOP;
      END IF;

      -----insert_template_elements;
      -----------log trace
      IF ((cz_pb_mgr.v_pb_log_flag = 'YES') OR(cz_pb_mgr.v_status_code = PUBLICATION_ERROR)) THEN
         log_pb_trace;
      END IF;

      x_run_id := cz_pb_mgr.v_pb_run_id;
      x_pb_status := cz_pb_mgr.v_status_code;
      /* cz_security_pvt.unlock_entity  (cz_pb_mgr.v_root_model_id,
              cz_security_pvt.PUBLISH_MODEL_FUNCTION,
              l_locked_models,
              l_lock_status,
              l_msg_count,
              l_msg_data); */
      delete_session_parameters;
      -----unregister application
      cz_pb_sync_util.reset_dbms_info;
      COMMIT;

      IF (cz_pb_mgr.g_log_timing = publication_timing) THEN
         log_timing_message('end publish model');
      END IF;

      COMMIT;
   EXCEPTION
      WHEN user_not_initialized THEN
         x_pb_status := PUBLICATION_ERROR;
         x_run_id := cz_pb_mgr.v_pb_run_id;
         cz_pb_mgr.global_export_retcode := 2;
         update_publication_status(publicationid, PUBLICATION_ERROR, empty_string);
         update_pup_status(publicationid);
         log_pb_trace;
         delete_session_parameters;
      WHEN priv_check_err THEN
         cz_pb_mgr.v_err_message := l_msg_data;
         x_pb_status := PUBLICATION_ERROR;
         x_run_id := cz_pb_mgr.v_pb_run_id;
         cz_pb_mgr.global_export_retcode := 2;
         log_pb_errors(cz_pb_mgr.v_err_message, 0, 'CZPBMGRPRIVCHK', -1);
         delete_session_parameters;
      WHEN has_no_priv_to_publish THEN
         cz_pb_mgr.v_err_message := l_msg_data;
         x_pb_status := PUBLICATION_ERROR;
         x_run_id := cz_pb_mgr.v_pb_run_id;
         cz_pb_mgr.global_export_retcode := 2;
         log_pb_errors(cz_pb_mgr.v_err_message, 0, 'CZPBMGRPRIVCHK', -1);
         delete_session_parameters;
      WHEN failed_to_lock_model THEN
         x_pb_status := PUBLICATION_ERROR;
         x_run_id := cz_pb_mgr.v_pb_run_id;
         cz_pb_mgr.global_export_retcode := 2;
         update_publication_status(publicationid, PUBLICATION_ERROR, empty_string);
         update_pup_status(publicationid);
         cz_security_pvt.unlock_model(1.0, fnd_api.g_true, l_locked_models, l_lock_status, l_msg_count, l_msg_data);
         log_pb_trace;
         delete_session_parameters;
      WHEN not_global_template THEN
         x_pb_status := PUBLICATION_ERROR;
         x_run_id := cz_pb_mgr.v_pb_run_id;
         cz_pb_mgr.global_export_retcode := 2;
         update_publication_status(publicationid, PUBLICATION_ERROR, empty_string);
         log_pb_errors(cz_pb_mgr.v_err_message, 0, 'CZPBMGRPRIVCHK', -1);
         delete_session_parameters;
      WHEN model_not_upto_date THEN
         x_pb_status := PUBLICATION_ERROR;
         x_run_id := cz_pb_mgr.v_pb_run_id;
         cz_pb_mgr.global_export_retcode := 2;
         update_publication_status(publicationid, PUBLICATION_ERROR, empty_string);
         update_pup_status(publicationid);
         log_pb_errors(cz_pb_mgr.v_err_message, 0, 'CZPBMGRUPTODATE', -1);
         delete_session_parameters;
      WHEN invalid_object_type THEN
         x_pb_status := PUBLICATION_ERROR;
         x_run_id := cz_pb_mgr.v_pb_run_id;
         cz_pb_mgr.global_export_retcode := 2;
         log_pb_errors(cz_pb_mgr.v_err_message, 0, 'CZPBMGROBJTYP', -1);
         delete_session_parameters;
      WHEN cz_pb_link_problem THEN
         x_pb_status := PUBLICATION_ERROR;
         x_run_id := cz_pb_mgr.v_pb_run_id;
         cz_pb_mgr.global_export_retcode := 2;
         update_publication_status(publicationid, PUBLICATION_ERROR, empty_string);
         update_pup_status(publicationid);
         log_pb_errors(cz_pb_mgr.v_err_message, 0, 'CZPBMGRLNKPRBLM', -1);
         delete_session_parameters;
  END;

  -- unregister application
  dbms_application_info.set_module('', '');

EXCEPTION
  WHEN OTHERS THEN
    x_run_id := cz_pb_mgr.v_pb_run_id ;
    x_pb_status := PUBLICATION_ERROR;
    cz_pb_mgr.GLOBAL_EXPORT_RETCODE := 2;
    log_pb_errors(SQLERRM,0,'cz_pb_mgr.PUBLISH_MODEL',-1);
    dbms_application_info.set_module('', '');
    RAISE;
END publish_model;

----------------------------------------------
------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------------wrappers used by concurrent manager to publish models
   PROCEDURE publish_models_cp(errbuf IN OUT NOCOPY VARCHAR2, retcode IN OUT NOCOPY PLS_INTEGER)
   AS
   BEGIN
      retcode := 0;
      publish_all_models;
      errbuf := NULL;

      IF (cz_pb_mgr.global_export_retcode = 1)
      THEN
         errbuf := cz_utils.get_text('CZ_PB_WARNING');
      END IF;

      IF (cz_pb_mgr.global_export_retcode = 2)
      THEN
         errbuf := cz_utils.get_text('CZ_PB_FAILURE');
      END IF;

      retcode := cz_pb_mgr.global_export_retcode;
   EXCEPTION
      WHEN OTHERS
      THEN
         retcode := 2;
         errbuf := cz_utils.get_text('CZ_PB_OTHERS');
   END;

   PROCEDURE publish_single_model_cp(errbuf IN OUT NOCOPY VARCHAR2, retcode IN OUT NOCOPY PLS_INTEGER, p_publication_id NUMBER)
   AS
      v_run_id NUMBER := 0.0;
      v_pb_status VARCHAR2(3);
   BEGIN
      retcode := 0;
      cz_pb_mgr.global_export_retcode := 0;
      publish_model(p_publication_id, v_run_id, v_pb_status);
      errbuf := NULL;

      IF (cz_pb_mgr.global_export_retcode = 1)
      THEN
         errbuf := cz_utils.get_text('CZ_PB_WARNING');
      END IF;

      IF (cz_pb_mgr.global_export_retcode = 2)
      THEN
         errbuf := cz_utils.get_text('CZ_PB_FAILURE');
      END IF;

      retcode := cz_pb_mgr.global_export_retcode;
   EXCEPTION
      WHEN OTHERS
      THEN
         retcode := 2;
         errbuf := cz_utils.get_text('CZ_PB_OTHERS');
   END;

--------------------------------------
   PROCEDURE seed_fnd_application_cp(errbuf IN OUT NOCOPY VARCHAR2, retcode IN OUT NOCOPY PLS_INTEGER, p_application_name VARCHAR2)
   AS
      v_run_id NUMBER := 0.0;
      v_pb_status VARCHAR2(3);
      l_application_id NUMBER;
   BEGIN
      retcode := 0;

      SELECT application_id
        INTO l_application_id
        FROM fnd_application_tl
       WHERE fnd_application_tl.application_name = p_application_name AND fnd_application_tl.language = USERENV('LANG');

      INSERT INTO cz_ext_applications
                  (application_id, preferred_ui_style, seeded_flag, deleted_flag
                  )
           VALUES (l_application_id, 3, '1', '0'
                  );

      errbuf := NULL;
      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         retcode := 2;
         errbuf := cz_utils.get_text('CZ_APP_OTHERS', 'SQLERRM', SQLERRM);
   END;

----------------------------------------
---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----------proc to delete a publication
----------
    PROCEDURE delete_publication(
      publicationid IN NUMBER
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   AS
      v_server_id cz_model_publications.server_id%TYPE;
      v_cz_link_name cz_servers.cz_link_name%TYPE;
      v_remote_publication_id cz_model_publications.remote_publication_id%TYPE;
      v_export_status cz_model_publications.export_status%TYPE;
      l_tmp_publication NUMBER;
      l_object_type cz_model_publications.object_type%TYPE;
      l_reset_publication cz_model_publications.remote_publication_id%TYPE := 0;
      no_link_name EXCEPTION;
      invalid_object_type EXCEPTION;
      template_in_use EXCEPTION;
      cannot_del_pup EXCEPTION;
      l_pub_mode cz_model_publications.publication_mode%TYPE := cz_model_migration_pvt.mode_publication;
   BEGIN
      fnd_msg_pub.initialize;
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      x_msg_count := 0;
      x_msg_data := '';
      fnd_msg_pub.initialize;

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         l_pub_mode := cz_model_migration_pvt.mode_migration;
      ELSIF(cz_pb_mgr.v_session_parameter = cz_pb_mgr.model_copy)
      THEN
         l_pub_mode := cz_model_migration_pvt.mode_copy;
      END IF;

      SELECT server_id, export_status, remote_publication_id, object_type
        INTO v_server_id, v_export_status, v_remote_publication_id, l_object_type
        FROM cz_model_publications
       WHERE cz_model_publications.publication_id = publicationid AND cz_model_publications.deleted_flag = record_not_deleted;


      --execute the procedure that obsoletes the records
      --if the target has been converted into a development instance

      IF (v_export_status <> model_publication_obselete) THEN

         cz_model_migration_pvt.obsolete_nonpublishable('T', x_return_status, x_msg_count, x_msg_data);
         --it is possible that the obsoleting process changed value of the publication record.
         --so requery
         SELECT server_id, export_status, remote_publication_id, object_type
           INTO v_server_id, v_export_status, v_remote_publication_id, l_object_type
           FROM cz_model_publications
         WHERE cz_model_publications.publication_id = publicationid AND cz_model_publications.deleted_flag = record_not_deleted;
      END IF;

      IF (v_export_status = 'PUP')
      THEN
         RAISE cannot_del_pup;
      END IF;

      ----check for reset cases
      BEGIN
         SELECT publication_id
           INTO l_reset_publication
           FROM cz_model_publications
          WHERE cz_model_publications.remote_publication_id = v_remote_publication_id
            AND cz_model_publications.server_id = v_server_id
            AND cz_model_publications.deleted_flag = record_not_deleted
            AND cz_model_publications.export_status = 'PUP';
             --SPUPPALA bug#7116052 7-AUG-2009.
 	     --AND cz_model_publications.publication_mode = l_pub_mode;
      EXCEPTION
         WHEN OTHERS
         THEN
            l_reset_publication := 0;
      END;

      -- if publications are obsolete, their target should not be deleted
      IF ((v_server_id = 0) OR(v_export_status = model_publication_obselete))
      THEN
         v_cz_link_name := ' ';
      ELSE
         BEGIN
            SELECT fndnam_link_name
              INTO v_cz_link_name
              FROM cz_servers
             WHERE cz_servers.server_local_id = v_server_id;
         EXCEPTION
            WHEN OTHERS
            THEN
               v_cz_link_name := NULL;
         END;

         IF (v_cz_link_name IS NULL)
         THEN
            RAISE no_link_name;
         END IF;

         v_cz_link_name := '@' || LTRIM(RTRIM(v_cz_link_name));
      END IF;

      IF (l_object_type = template_publication)
      THEN
         ----query to check if template is used
         l_tmp_publication := 1;

         IF (l_tmp_publication = 1)
         THEN
            RAISE template_in_use;
         END IF;
      END IF;

      UPDATE cz_model_publications
         SET deleted_flag = '1'
       WHERE publication_id = publicationid;

      DELETE FROM cz_pb_client_apps
            WHERE publication_id = publicationid;

      DELETE FROM cz_publication_usages
            WHERE publication_id = publicationid;

      IF (l_reset_publication > 0)
      THEN
         UPDATE cz_model_publications
            SET export_status = 'OK'
          WHERE publication_id = l_reset_publication;
      END IF;

      IF ((v_export_status <> 'PEN') AND(v_remote_publication_id IS NOT NULL))
      THEN
         EXECUTE IMMEDIATE    'BEGIN'
                           || ' '
                           || 'UPDATE cz_model_publications'
                           || v_cz_link_name
                           || ''
                           || ' '
                           || 'SET deleted_flag = ''1'''
                           || ' '
                           || 'WHERE publication_id = '
                           || v_remote_publication_id
                           || ';'
                           || ' '
                           || 'END;';

         EXECUTE IMMEDIATE    'BEGIN'
                           || ' '
                           || 'DELETE FROM cz_pb_client_apps'
                           || v_cz_link_name
                           || ''
                           || ' '
                           || 'WHERE publication_id = '
                           || v_remote_publication_id
                           || ';'
                           || ' '
                           || 'END;';

         EXECUTE IMMEDIATE    'BEGIN'
                           || ' '
                           || 'DELETE FROM cz_publication_usages'
                           || v_cz_link_name
                           || ''
                           || ' '
                           || 'WHERE  publication_id = '
                           || v_remote_publication_id
                           || ';'
                           || ' '
                           || 'END;';
      END IF;
   EXCEPTION
      WHEN no_link_name
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_NO_LINK_NAME');
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN cannot_del_pup
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PB_CANNOT_DELETE_PUP');
         fnd_message.set_token('PUBID', publicationid);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN invalid_object_type
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_INVALID_PUB_TYPE');
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN template_in_use
      THEN
         x_msg_data := cz_utils.get_text('CZ_TEMPLATE_IN_USE');
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_TEMPLATE_IN_USE');
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := SQLERRM;
   END delete_publication;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----------disable publication
   PROCEDURE disable_publication(
      publicationid IN NUMBER
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   AS
      v_server_id cz_model_publications.server_id%TYPE;
      v_cz_link_name cz_servers.cz_link_name%TYPE;
      v_remote_publication_id cz_model_publications.remote_publication_id%TYPE;
      v_object_type cz_model_publications.object_type%TYPE;
      v_export_status cz_model_publications.export_status%TYPE;
      cannot_disable_template EXCEPTION;
      cannot_disable_publication EXCEPTION;
   BEGIN
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      fnd_msg_pub.initialize;
      --execute the procedure that obsoletes the records
      --if the target has been converted into a development
      --instance
      cz_model_migration_pvt.obsolete_nonpublishable('T', x_return_status, x_msg_count, x_msg_data);

      IF (x_return_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         RAISE pub_maybe_obsoleted;
      END IF;

      SELECT object_type, server_id, remote_publication_id, export_status
        INTO v_object_type, v_server_id, v_remote_publication_id, v_export_status
        FROM cz_model_publications
       WHERE cz_model_publications.publication_id = publicationid;

      BEGIN
         SELECT fndnam_link_name
           INTO v_cz_link_name
           FROM cz_servers
          WHERE cz_servers.server_local_id = v_server_id;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_cz_link_name := NULL;
      END;

      IF (v_export_status NOT IN('OK', 'PEN'))
      THEN
         RAISE cannot_disable_publication;
      END IF;

      IF (v_object_type = template_publication)
      THEN
         RAISE cannot_disable_template;
      END IF;

      IF (v_server_id = 0)
      THEN
         v_cz_link_name := '';
      ELSE
         v_cz_link_name := '@' || LTRIM(RTRIM(v_cz_link_name));
      END IF;

      cz_pb_mgr.remote_publication_id := v_remote_publication_id;

      UPDATE cz_model_publications
         SET disabled_flag = '1'
       WHERE publication_id = publicationid;

      EXECUTE IMMEDIATE    'BEGIN'
                        || ' '
                        || 'UPDATE cz_model_publications'
                        || v_cz_link_name
                        || ''
                        || ' '
                        || 'SET   disabled_flag   = ''1'''
                        || ' '
                        || 'WHERE  publication_id =  cz_pb_mgr.remote_publication_id ;'
                        || ' '
                        || 'END;';

      COMMIT;
   EXCEPTION
      WHEN cannot_disable_publication
      THEN
         ----x_msg_data := CZ_UTILS.GET_TEXT('CZ_CANT_DISABLE_PUB', 'STATUS', v_export_status, 'PUBID', publicationId);
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_CANT_DISABLE_PUB');
         fnd_message.set_token('STATUS', v_export_status);
         fnd_message.set_token('PUBID', publicationid);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN pub_maybe_obsoleted
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
      WHEN cannot_disable_template
      THEN
         x_msg_data := cz_utils.get_text('CZ_CANT_DISABLE_TEMPL', 'PUBID', publicationid);
         x_return_status := FND_API.G_RET_STS_ERROR;
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := SQLERRM;
   END disable_publication;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE get_edit_info(
      publicationid IN cz_model_publications.publication_id%TYPE
     ,x_product_key IN OUT NOCOPY cz_model_publications.product_key%TYPE
     ,x_publication_mode IN OUT NOCOPY VARCHAR2
     ,x_server_id IN OUT NOCOPY cz_servers.server_local_id%TYPE
     ,x_export_status IN OUT NOCOPY cz_model_publications.export_status%TYPE
     ,x_source_target_flag IN OUT NOCOPY cz_model_publications.source_target_flag%TYPE
     ,x_remote_publication_id IN OUT NOCOPY cz_model_publications.remote_publication_id%TYPE
   )
   AS
   BEGIN
      SELECT product_key, publication_mode, server_id, export_status, source_target_flag, remote_publication_id
        INTO x_product_key, x_publication_mode, x_server_id, x_export_status, x_source_target_flag, x_remote_publication_id
        FROM cz_model_publications
       WHERE cz_model_publications.publication_id = publicationid;
   EXCEPTION
      WHEN OTHERS
      THEN
         NULL;
   END;

-------->>>>>>>>>>>>>>
   PROCEDURE populate_app_tbl(p_application_id IN OUT NOCOPY VARCHAR2, x_app_tbl IN OUT NOCOPY cz_pb_mgr.t_ref)
   AS
      x NUMBER := 1;
      i NUMBER := 0;
      y NUMBER := 0;
      v_str VARCHAR2(200);
   BEGIN
      WHILE(x > 0)
      LOOP
         x := INSTR(p_application_id, ';');

         IF (x = 0)
         THEN
            i := i + 1;
            x_app_tbl(i) := p_application_id;
         ELSE
            x := x - 1;
            v_str := SUBSTR(p_application_id, 1, x);
            i := i + 1;
            x_app_tbl(i) := v_str;
            y := LENGTH(p_application_id) -(x + 1);
            x := x + 2;
            p_application_id := SUBSTR(p_application_id, x, y);
         END IF;
      END LOOP;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;

------->>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE populate_lang_tbl(p_lang_id IN OUT NOCOPY VARCHAR2, x_app_tbl IN OUT NOCOPY cz_pb_mgr.t_lang_code)
   AS
      x NUMBER := 1;
      i NUMBER := 0;
      y NUMBER := 0;
      v_str VARCHAR2(200);
   BEGIN
      WHILE(x > 0)
      LOOP
         x := INSTR(p_lang_id, ';');

         IF (x = 0)
         THEN
            i := i + 1;
            x_app_tbl(i) := p_lang_id;
         ELSE
            x := x - 1;
            v_str := SUBSTR(p_lang_id, 1, x);
            i := i + 1;
            x_app_tbl(i) := v_str;
            y := LENGTH(p_lang_id) -(x + 1);
            x := x + 2;
            p_lang_id := SUBSTR(p_lang_id, x, y);
         END IF;
      END LOOP;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;

-------->>>>>>>>>>>>>>>>>>
   PROCEDURE delete_src_pb_data(publicationid IN cz_model_publications.publication_id%TYPE)
   AS
   BEGIN
      DELETE FROM cz_publication_usages
            WHERE cz_publication_usages.publication_id = publicationid;

      DELETE FROM cz_pb_client_apps
            WHERE cz_pb_client_apps.publication_id = publicationid;

      DELETE FROM cz_pb_languages
            WHERE cz_pb_languages.publication_id = publicationid;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;

------->>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_src_pb_data(
      publicationid IN cz_model_publications.publication_id%TYPE
     ,p_application_id_tbl IN cz_pb_mgr.t_ref
     ,p_language_id_tbl IN cz_pb_mgr.t_lang_code
     ,p_usage_id_tbl IN cz_pb_mgr.t_ref
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      v_application_short_name VARCHAR2(50);
   BEGIN
      FOR i IN p_application_id_tbl.FIRST .. p_application_id_tbl.LAST
      LOOP
         SELECT application_short_name
           INTO v_application_short_name
           FROM fnd_application
          WHERE application_id = p_application_id_tbl(i);

         INSERT INTO cz_pb_client_apps
                     (publication_id, fnd_application_id, application_short_name, notes
                     )
              VALUES (publicationid, p_application_id_tbl(i), v_application_short_name, NULL
                     );
      END LOOP;

      FOR i IN p_language_id_tbl.FIRST .. p_language_id_tbl.LAST
      LOOP
         INSERT INTO cz_pb_languages
                     (publication_id, LANGUAGE
                     )
              VALUES (publicationid, p_language_id_tbl(i)
                     );
      END LOOP;

      FOR i IN p_usage_id_tbl.FIRST .. p_usage_id_tbl.LAST
      LOOP
         INSERT INTO cz_publication_usages
                     (publication_id, usage_id
                     )
              VALUES (publicationid, p_usage_id_tbl(i)
                     );
      END LOOP;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_status := '-1';
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_EDIT_SRC_FAILURE', 'PUBID', publicationid, 'SQLERRM', SQLERRM);
         log_pb_errors(v_err_message, 1, 'cz_pb_mgr.EDITPB', SQLCODE);
         RAISE;
   END;

-------->>>>>>>>>>>>>>>>>>>>>
   PROCEDURE insert_tgt_pb_data(
      p_status_str IN OUT NOCOPY VARCHAR2
     ,p_export_status IN cz_model_publications.export_status%TYPE
     ,p_tgt_link IN cz_servers.fndnam_link_name%TYPE
     ,p_publication_mode IN VARCHAR2
     ,p_start_date IN DATE
     ,p_disable_date IN DATE
     ,p_remote_publication_id IN cz_model_publications.remote_publication_id%TYPE
     ,p_application_id_tbl IN cz_pb_mgr.t_ref
     ,p_language_id_tbl IN cz_pb_mgr.t_lang_code
     ,p_usage_id_tbl IN cz_pb_mgr.t_ref
   )
   AS
      v_application_short_name VARCHAR2(50);
      v_edit_str VARCHAR2(2000);
      tgt_appl_id number;
   BEGIN
      IF ((p_status_str <> '-1') AND(p_export_status <> 'PEN'))
      THEN
         v_edit_str :=
               'UPDATE  cz_model_publications'
            || p_tgt_link
            || ' '
            || 'SET   publication_mode = :1,'
            || ' '
            || 'applicable_from  = :2,'
            || ' '
            || 'applicable_until = :3'
            || ' '
            || 'WHERE publication_id  = '
            || p_remote_publication_id;

         EXECUTE IMMEDIATE v_edit_str
                     USING p_publication_mode, p_start_date, p_disable_date;

         v_edit_str :='DELETE FROM cz_publication_usages'||p_tgt_link||' ' ||
				   'WHERE cz_publication_usages.publication_id = :1';

	 EXECUTE IMMEDIATE v_edit_str using p_remote_publication_id;


         v_edit_str := 'DELETE FROM cz_pb_client_apps'||p_tgt_link||' ' ||
				   'WHERE  cz_pb_client_apps.publication_id = :1';

	 EXECUTE IMMEDIATE v_edit_str using p_remote_publication_id;

         v_edit_str := 'DELETE FROM cz_pb_languages'||p_tgt_link||' ' ||
				   'WHERE  cz_pb_languages.publication_id = :1';

	 EXECUTE IMMEDIATE v_edit_str using p_remote_publication_id;

	 IF (p_application_id_tbl.COUNT > 0) THEN
         FOR i IN p_application_id_tbl.FIRST .. p_application_id_tbl.LAST
         LOOP

            EXECUTE IMMEDIATE 'SELECT t.application_short_name,t.application_id'
		||' FROM fnd_application s,fnd_application'||p_tgt_link
		||' t WHERE  s.application_id =:1 and '
		||' s.APPLICATION_SHORT_NAME=t.APPLICATION_SHORT_NAME'
		into v_application_short_name,tgt_appl_id using p_application_id_tbl(i);

            v_edit_str :='INSERT INTO cz_pb_client_apps'||p_tgt_link||' (publication_id,fnd_application_id,application_short_name)'
	       || ' ' || ' values (:1,:2,:3)';

	    EXECUTE IMMEDIATE v_edit_str USING p_remote_publication_id,tgt_appl_id,v_application_short_name;

         END LOOP;
	 END IF;

	 IF (p_language_id_tbl.COUNT > 0) THEN
         FOR i IN p_language_id_tbl.FIRST .. p_language_id_tbl.LAST
         LOOP
            v_edit_str :='INSERT INTO cz_pb_languages'||p_tgt_link||' (publication_id,language)' || ' ' ||
								'values(:1,:2)';
	    EXECUTE IMMEDIATE v_edit_str using p_remote_publication_id,p_language_id_tbl(i);

         END LOOP;
	 END IF;

	 IF (p_usage_id_tbl.COUNT > 0) THEN
         FOR i IN p_usage_id_tbl.FIRST .. p_usage_id_tbl.LAST
         LOOP
            v_edit_str :='INSERT INTO cz_publication_usages'||p_tgt_link||' (publication_id,usage_id)' || ' ' ||
							'VALUES(:1,:2)';

	    EXECUTE IMMEDIATE v_edit_str using p_remote_publication_id,p_usage_id_tbl(i);
         END LOOP;
	 END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_status_str := '-1';
   END;

--------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
---------edit publication
   PROCEDURE edit_publication(
      publicationid IN NUMBER
     ,applicationid IN OUT NOCOPY VARCHAR2
     ,languageid IN OUT NOCOPY VARCHAR2
     ,usageid IN OUT NOCOPY VARCHAR2
     ,startdate IN DATE
     ,disabledate IN DATE
     ,publicationmode IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   AS
      v_product_key cz_model_publications.product_key%TYPE;
      v_publication_mode cz_model_publications.publication_mode%TYPE;
      v_server_id cz_model_publications.server_id%TYPE;
      v_source_target_flag cz_model_publications.source_target_flag%TYPE;
      v_remote_publication_id cz_model_publications.remote_publication_id%TYPE;
      v_export_status cz_model_publications.export_status%TYPE;
      v_count NUMBER;
      v_application_id VARCHAR2(2000);
      v_language_id VARCHAR2(2000);
      v_usage_id VARCHAR2(2000);
      v_tgt_link VARCHAR2(128);
      x NUMBER := 1;
      i NUMBER := 0;
      y NUMBER := 0;
      v_msg VARCHAR2(2000);
      status_str VARCHAR2(200) := '0';
      no_pub_found EXCEPTION;
      l_publication_id NUMBER;
   BEGIN
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      fnd_msg_pub.initialize;
      v_application_id_tbl.DELETE;
      v_usage_id_tbl.DELETE;
      v_language_id_tbl.DELETE;
      --execute the procedure that obsoletes the records
      --if the target has been converted into a development
      --instance
      cz_model_migration_pvt.obsolete_nonpublishable('T', x_return_status, x_msg_count, x_msg_data);

      IF (x_return_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         RAISE pub_maybe_obsoleted;
      END IF;

      BEGIN
         SELECT publication_id
           INTO l_publication_id
           FROM cz_model_publications
          WHERE cz_model_publications.publication_id = publicationid;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RAISE no_pub_found;
      END;

      SELECT COUNT(*)
        INTO v_count
        FROM cz_model_publications
       WHERE cz_model_publications.publication_id = publicationid
         AND cz_model_publications.export_status NOT IN('PRC', 'PUP', 'ERR', model_publication_obselete);

      IF (v_count = 0)
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := 'PUBLICATION HAS STATUS /PRC/PUP/' || model_publication_obselete;
      ELSE
         get_edit_info(publicationid, v_product_key, v_publication_mode, v_server_id, v_export_status, v_source_target_flag, v_remote_publication_id);

         IF (v_server_id = 0)
         THEN
            v_tgt_link := '';
         ELSE
            v_tgt_link := retrieve_db_link(v_server_id);
         END IF;

         UPDATE cz_model_publications
            SET publication_mode = publicationmode
               ,applicable_from = startdate
               ,applicable_until = disabledate
          WHERE publication_id = publicationid;

         populate_app_tbl(applicationid, v_application_id_tbl);
         populate_app_tbl(usageid, v_usage_id_tbl);
         populate_lang_tbl(languageid, v_language_id_tbl);
         delete_src_pb_data(publicationid);
         insert_src_pb_data(publicationid, v_application_id_tbl, v_language_id_tbl, v_usage_id_tbl, status_str);
         insert_tgt_pb_data(status_str
                           ,v_export_status
                           ,v_tgt_link
                           ,publicationmode
                           ,startdate
                           ,disabledate
                           ,v_remote_publication_id
                           ,v_application_id_tbl
                           ,v_language_id_tbl
                           ,v_usage_id_tbl
                           );

         IF (status_str = '-1')
         THEN
            x_return_status := FND_API.G_RET_STS_ERROR;
            x_msg_count := 1;
            x_msg_data := cz_utils.get_text('CZ_PB_EDIT_FAILURE', 'PUBID', publicationid, 'SQLERRM', SQLERRM);
         ELSE
            COMMIT;
         END IF;
      END IF;
   EXCEPTION
      WHEN pub_maybe_obsoleted
      THEN
         x_return_status := FND_API.G_RET_STS_SUCCESS;
      WHEN no_pub_found
      THEN
         x_return_status := FND_API.G_RET_STS_SUCCESS;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := cz_utils.get_text('CZ_PB_EDIT_FAILURE_DETAILS', 'PUBID', publicationid, 'SQLERRM', SQLERRM);
   END edit_publication;

--------------------------------------------------------
   PROCEDURE edit_publication(
      publicationid IN NUMBER
     ,applicationid IN OUT NOCOPY cz_pb_mgr.t_ref
     ,languageid IN OUT NOCOPY cz_pb_mgr.t_lang_code
     ,usageid IN OUT NOCOPY cz_pb_mgr.t_ref
     ,startdate IN DATE
     ,disabledate IN DATE
     ,publicationmode IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   AS
      v_product_key cz_model_publications.product_key%TYPE;
      v_publication_mode cz_model_publications.publication_mode%TYPE;
      v_server_id cz_model_publications.server_id%TYPE;
      v_source_target_flag cz_model_publications.source_target_flag%TYPE;
      v_remote_publication_id cz_model_publications.remote_publication_id%TYPE;
      v_export_status cz_model_publications.export_status%TYPE;
      v_count NUMBER;
      v_application_id VARCHAR2(2000);
      v_language_id VARCHAR2(2000);
      v_usage_id VARCHAR2(2000);
      v_tgt_link VARCHAR2(128);
      x NUMBER := 1;
      i NUMBER := 0;
      y NUMBER := 0;
      v_msg VARCHAR2(2000);
      status_str VARCHAR2(200) := '0';
      no_pub_found EXCEPTION;
      l_publication_id NUMBER;
   BEGIN
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      fnd_msg_pub.initialize;
      --execute the procedure that obsoletes the records
      --if the target has been converted into a development
      --instance
      cz_model_migration_pvt.obsolete_nonpublishable('T', x_return_status, x_msg_count, x_msg_data);

      IF (x_return_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         RAISE pub_maybe_obsoleted;
      END IF;

      BEGIN
         SELECT publication_id
           INTO l_publication_id
           FROM cz_model_publications
          WHERE cz_model_publications.publication_id = publicationid;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RAISE no_pub_found;
      END;

      SELECT COUNT(*)
        INTO v_count
        FROM cz_model_publications
       WHERE cz_model_publications.publication_id = publicationid AND cz_model_publications.export_status NOT IN('PRC', 'PUP', 'ERR');

      IF (v_count = 0)
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := 'PUBLICATION HAS STATUS /PRC/PUP';
      ELSE
         get_edit_info(publicationid, v_product_key, v_publication_mode, v_server_id, v_export_status, v_source_target_flag, v_remote_publication_id);

         IF (v_server_id = 0)
         THEN
            v_tgt_link := '';
         ELSE
            v_tgt_link := retrieve_db_link(v_server_id);
         END IF;

         UPDATE cz_model_publications
            SET publication_mode = publicationmode
               ,applicable_from = startdate
               ,applicable_until = disabledate
          WHERE publication_id = publicationid;

         delete_src_pb_data(publicationid);
         insert_src_pb_data(publicationid, applicationid, languageid, usageid, status_str);
         insert_tgt_pb_data(status_str
                           ,v_export_status
                           ,v_tgt_link
                           ,publicationmode
                           ,startdate
                           ,disabledate
                           ,v_remote_publication_id
                           ,applicationid
                           ,languageid
                           ,usageid
                           );

         IF (status_str = '-1')
         THEN
            x_return_status := FND_API.G_RET_STS_ERROR;
            x_msg_count := 1;
            x_msg_data := cz_utils.get_text('CZ_PB_EDIT_FAILURE', 'PUBID', publicationid, 'SQLERRM', SQLERRM);
         END IF;
      END IF;
   EXCEPTION
      WHEN pub_maybe_obsoleted
      THEN
         x_return_status := FND_API.G_RET_STS_SUCCESS;
      WHEN no_pub_found
      THEN
         x_return_status := FND_API.G_RET_STS_SUCCESS;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := cz_utils.get_text('CZ_PB_EDIT_FAILURE_DETAILS', 'PUBID', publicationid, 'SQLERRM', SQLERRM);
   END edit_publication;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
---------edit publication
   PROCEDURE edit_tgt_pub(
      publicationid IN NUMBER
     ,applicationid IN OUT NOCOPY VARCHAR2
     ,languageid IN OUT NOCOPY VARCHAR2
     ,usageid IN OUT NOCOPY VARCHAR2
     ,startdate IN DATE
     ,disabledate IN DATE
     ,publicationmode IN VARCHAR2
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   AS
      v_product_key cz_model_publications.product_key%TYPE;
      v_publication_mode cz_model_publications.publication_mode%TYPE;
      v_server_id cz_model_publications.server_id%TYPE;
      v_source_target_flag cz_model_publications.source_target_flag%TYPE;
      v_remote_publication_id cz_model_publications.remote_publication_id%TYPE;
      v_export_status cz_model_publications.export_status%TYPE;
      v_count NUMBER;
      v_application_id VARCHAR2(2000);
      v_language_id VARCHAR2(2000);
      v_usage_id VARCHAR2(2000);
      v_tgt_link VARCHAR2(128);
      x NUMBER := 1;
      i NUMBER := 0;
      y NUMBER := 0;
      v_msg VARCHAR2(2000);
      status_str VARCHAR2(200) := '0';
      no_pub_found EXCEPTION;
      l_publication_id NUMBER;
   BEGIN
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      fnd_msg_pub.initialize;
      v_application_id_tbl.DELETE;
      v_usage_id_tbl.DELETE;
      v_language_id_tbl.DELETE;
      --execute the procedure that obsoletes the records
      --if the target has been converted into a development
      --instance
      cz_model_migration_pvt.obsolete_nonpublishable('T', x_return_status, x_msg_count, x_msg_data);

      IF (x_return_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         RAISE pub_maybe_obsoleted;
      END IF;

      BEGIN
         SELECT publication_id
           INTO l_publication_id
           FROM cz_model_publications
          WHERE cz_model_publications.publication_id = publicationid;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RAISE no_pub_found;
      END;

      SELECT COUNT(*)
        INTO v_count
        FROM cz_model_publications
       WHERE cz_model_publications.publication_id = publicationid AND cz_model_publications.export_status NOT IN('PRC', 'PUP', 'ERR');

      IF (v_count = 0)
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_count := 1;
         x_msg_data := 'PUBLICATION HAS STATUS /PRC/PUP';
      ELSE
         get_edit_info(publicationid, v_product_key, v_publication_mode, v_server_id, v_export_status, v_source_target_flag, v_remote_publication_id);

         IF (v_server_id = 0)
         THEN
            v_tgt_link := '';
         ELSE
            v_tgt_link := retrieve_db_link(v_server_id);
         END IF;

            -----UPDATE  cz_model_publications
               -----SET  publication_mode        = publicationMode,
            -----applicable_from      = startDate,
         -----applicable_until     = disableDate
               -----WHERE   publication_id           = publicationId;
         populate_app_tbl(applicationid, v_application_id_tbl);
         populate_app_tbl(usageid, v_usage_id_tbl);
         populate_lang_tbl(languageid, v_language_id_tbl);
         -----delete_src_pb_data(publicationId);
         -----insert_src_pb_data(publicationId,
                    ----v_application_id_tbl,
                    ----v_language_id_tbl,
                    ----v_usage_id_tbl,
                    ----status_str);
         insert_tgt_pb_data(status_str
                           ,v_export_status
                           ,v_tgt_link
                           ,publicationmode
                           ,startdate
                           ,disabledate
                           ,v_remote_publication_id
                           ,v_application_id_tbl
                           ,v_language_id_tbl
                           ,v_usage_id_tbl
                           );

         IF (status_str = '-1')
         THEN
            x_return_status := FND_API.G_RET_STS_ERROR;
            x_msg_count := 1;
            x_msg_data := cz_utils.get_text('CZ_PB_EDIT_FAILURE', 'PUBID', publicationid, 'SQLERRM', SQLERRM);
         END IF;
      END IF;
   EXCEPTION
      WHEN pub_maybe_obsoleted
      THEN
         x_return_status := FND_API.G_RET_STS_SUCCESS;
      WHEN no_pub_found
      THEN
         x_return_status := FND_API.G_RET_STS_SUCCESS;
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := cz_utils.get_text('CZ_PB_EDIT_FAILURE_DETAILS', 'PUBID', publicationid, 'SQLERRM', SQLERRM);
   END edit_tgt_pub;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE chk_pub_overlap_internal(
      productkey IN VARCHAR2
     ,publicationmode IN VARCHAR2
     ,applicationid_tbl IN cz_pb_mgr.t_ref
     ,languageid_tbl IN cz_pb_mgr.t_lang_code
     ,usageid_tbl IN cz_pb_mgr.t_ref
     ,serverid IN NUMBER
     ,startdate IN DATE
     ,disabledate IN DATE
     ,sourcetargetflag IN VARCHAR2   ---DEFAULT 'S'
     ,pubrecid IN NUMBER
     ,publicationidstring IN OUT NOCOPY VARCHAR2
   )
   AS
      x NUMBER := 1;
      i NUMBER := 0;
      y NUMBER := 0;
      k NUMBER := 0;
      v_pb_count NUMBER := 1;
      publicationid NUMBER;
      v_appl_id NUMBER;
      v_lang_id VARCHAR2(4);
      v_usg_id NUMBER;
      v_pub_tbl cz_pb_mgr.t_ref;
      v_ret_pb cz_pb_mgr.t_ref;
      l_str VARCHAR2(2000);

      -- jonatara:bug6375826
      -- these temporary tables are introduced to handle the request from CZ_MODELOPERATIONS_PUB.create_publication_request
      t_languageId_tbl		CZ_PB_MGR.t_lang_code;
      t_usageId_tbl     	CZ_PB_MGR.t_ref;

   BEGIN
	-- jonatara:bug6375826
	-- setting default value to usage_id table and language table if they are NULL

	-- setting default usage value as 'Any Usage'
	IF usageId_tbl.COUNT = 0 THEN
	  t_usageId_tbl(0) := -1;
	ELSE
	  t_usageId_tbl := usageId_tbl;
	END IF;

	-- setting default language value as'US'
	IF languageId_tbl.COUNT = 0 THEN
	  t_languageId_tbl(0) := 'US';
	ELSE
	  t_languageId_tbl := languageId_tbl;
	END IF;

      publicationid := -1;

      IF (applicationid_tbl.COUNT > 0) THEN
      FOR i IN applicationid_tbl.FIRST .. applicationid_tbl.LAST
      LOOP
         v_appl_id := applicationid_tbl(i);
         -- jonatara:bug6375826
         IF (t_usageid_tbl.COUNT > 0) THEN
         FOR j IN t_usageid_tbl.FIRST .. t_usageid_tbl.LAST
         LOOP
            v_usg_id := t_usageid_tbl(j);
            IF (t_languageid_tbl.COUNT > 0) THEN
            FOR k IN t_languageid_tbl.FIRST .. t_languageid_tbl.LAST
            LOOP
               v_lang_id := t_languageid_tbl(k);

               IF ((v_appl_id IS NOT NULL) AND(v_usg_id IS NOT NULL) AND(v_lang_id IS NOT NULL))
               THEN
                  BEGIN
                     l_str :=
                           'productKey : '
                        || productkey
                        || 'mode : '
                        || publicationmode
                        || 'serverId: '
                        || serverid
                        || '
							   appl_id: '
                        || v_appl_id
                        || ' usage '
                        || v_usg_id
                        || 'langid: '
                        || v_lang_id
                        || '
							   startdate : '
                        || TO_CHAR(startdate, 'mm-dd-yyyy')
                        || ' disableDate : '
                        || TO_CHAR(disabledate, 'mm-dd-yyyy');

                     SELECT DISTINCT publication_id
                                INTO publicationid
                                FROM cz_model_applicabilities_v
                               WHERE product_key = LTRIM(RTRIM(productkey))
                                 AND UPPER(publication_mode) = LTRIM(RTRIM(UPPER(publicationmode)))
                                 AND server_id = serverid
                                 AND fnd_application_id = v_appl_id
                                 AND usage_id = v_usg_id
                                 AND LANGUAGE = v_lang_id
                                 AND deleted_flag = '0'
                                 AND UPPER(source_target_flag) = LTRIM(RTRIM(UPPER(sourcetargetflag)))
                                 AND publication_id <> pubrecid
                                 AND (   (    (start_date >= startdate)
                                          AND (startdate IS NOT NULL)
                                          AND (disabledate IS NOT NULL)
                                          AND (start_date < disabledate)
                                         )
                                      OR (    (disable_date > startdate)
                                          AND (startdate IS NOT NULL)
                                          AND (disabledate IS NOT NULL)
                                          AND (disable_date <= disabledate)
                                         )
                                      OR (    (start_date <= startdate)
                                          AND (startdate IS NOT NULL)
                                          AND (disabledate IS NOT NULL)
                                          AND (disable_date >= disabledate)
                                         )
                                      OR ((start_date <= startdate) AND(startdate < disable_date) AND(disabledate IS NULL))
                                      OR ((disable_date >= disabledate) AND(disabledate > start_date) AND(startdate IS NULL))
                                     );
                  EXCEPTION
                     WHEN NO_DATA_FOUND
                     THEN
                        publicationid := -1;
                     WHEN OTHERS
                     THEN
                        publicationid := -666;
                  END;

                  IF publicationid > 0
                  THEN
                     v_pub_tbl(v_pb_count) := publicationid;
                     v_pb_count := v_pb_count + 1;
                  END IF;
               END IF;
            END LOOP;
	   END IF;
         END LOOP;
	END IF;
      END LOOP;
     END IF;

      v_ret_pb.DELETE;

      IF v_pub_tbl.COUNT > 0
      THEN
         FOR i IN v_pub_tbl.FIRST .. v_pub_tbl.LAST
         LOOP
            publicationid := v_pub_tbl(i);

            IF (v_ret_pb.COUNT = 0)
            THEN
               x := 1;
               v_ret_pb(x) := publicationid;
            ELSE
               k := 0;

               FOR j IN v_ret_pb.FIRST .. v_ret_pb.LAST
               LOOP
                  IF (v_ret_pb(j) = publicationid)
                  THEN
                     k := k + 1;
                  END IF;
               END LOOP;

               IF k = 0
               THEN
                  y := v_ret_pb.COUNT + 1;
                  v_ret_pb(y) := publicationid;
               END IF;
            END IF;
         END LOOP;

         IF v_ret_pb.COUNT > 0
         THEN
            FOR m IN v_ret_pb.FIRST .. v_ret_pb.LAST
            LOOP
               IF publicationidstring IS NULL
               THEN
                  publicationidstring := TO_CHAR(v_ret_pb(m));
               ELSE
                  publicationidstring := publicationidstring || ';' || TO_CHAR(v_ret_pb(m));
               END IF;
            END LOOP;
         END IF;
      ELSIF(publicationid = -666)
      THEN
         publicationidstring := 'Fatal Error: More than one overlapping publications found';
      ELSE
         publicationidstring := TO_CHAR(-1);
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END chk_pub_overlap_internal;

-------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------wrapper for check overlap publication - procedure (to be call from the VB)
   PROCEDURE check_publication_overlap(
      productkey IN VARCHAR2
     ,publicationmode IN VARCHAR2
     ,applicationid IN VARCHAR2
     ,languageid IN VARCHAR2
     ,usageid IN VARCHAR2
     ,serverid IN NUMBER
     ,startdate IN DATE
     ,disabledate IN DATE
     ,sourcetargetflag IN VARCHAR2
     ,pubrecid IN NUMBER
     ,publicationidstring OUT NOCOPY VARCHAR2
   )
   AS
      v_app_id_tbl cz_pb_mgr.t_ref;
      v_usg_id_tbl cz_pb_mgr.t_ref;
      v_lang_id_tbl cz_pb_mgr.t_lang_code;
      v_in_appl_id VARCHAR2(2000);
      v_in_lang_id VARCHAR2(2000);
      v_in_usg_id VARCHAR2(2000);
      l_publicationidstring VARCHAR2(2000);
   BEGIN
      fnd_msg_pub.initialize;
      v_in_appl_id := applicationid;
      v_in_lang_id := languageid;
      v_in_usg_id := usageid;
      populate_app_tbl(v_in_appl_id, v_app_id_tbl);
      populate_app_tbl(v_in_usg_id, v_usg_id_tbl);
      populate_lang_tbl(v_in_lang_id, v_lang_id_tbl);
      chk_pub_overlap_internal(productkey
                              ,publicationmode
                              ,v_app_id_tbl
                              ,v_lang_id_tbl
                              ,v_usg_id_tbl
                              ,serverid
                              ,startdate
                              ,disabledate
                              ,sourcetargetflag
                              ,pubrecid
                              ,l_publicationidstring
                              );
      publicationidstring := l_publicationidstring;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END check_publication_overlap;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE reset_processing_pubs
   IS
      v_link_name cz_servers.fndnam_link_name%TYPE;
      v_db_link VARCHAR2(255);
      l_pub_mode cz_model_publications.publication_mode%TYPE := cz_model_migration_pvt.mode_publication;
   BEGIN
      fnd_msg_pub.initialize;

      IF (cz_pb_mgr.v_session_parameter = cz_model_migration_pvt.migrate_model)
      THEN
         l_pub_mode := cz_model_migration_pvt.mode_migration;
      ELSIF(cz_pb_mgr.v_session_parameter = cz_pb_mgr.model_copy)
      THEN
         l_pub_mode := cz_model_migration_pvt.mode_copy;
      END IF;

      FOR i IN (SELECT publication_id, remote_publication_id, server_id
                  FROM cz_model_publications
                 WHERE UPPER(export_status) = publication_processing AND deleted_flag = '0')
      LOOP
         BEGIN
            SELECT fndnam_link_name
              INTO v_link_name
              FROM cz_servers
             WHERE server_local_id = i.server_id;

            v_db_link := '';

            IF v_link_name IS NOT NULL
            THEN
               v_db_link := '@' || v_link_name;
            END IF;

            --
            -- mark remote publication as deleted
            --
            EXECUTE IMMEDIATE 'UPDATE CZ_MODEL_PUBLICATIONS' || v_db_link || ' SET deleted_flag=:1' || ' WHERE publication_id = :2'
                        USING '1', i.remote_publication_id;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
            WHEN OTHERS
            THEN
               NULL;
         END;
      END LOOP;

      DELETE FROM cz_pb_model_exports
            WHERE publication_id IN(SELECT publication_id
                                      FROM cz_model_publications
                                     WHERE UPPER(export_status) = publication_processing);

      UPDATE cz_model_publications
         SET export_status = publication_pending
       WHERE UPPER(export_status) = publication_processing;

      COMMIT;
   END;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
-----procedure that validates input dates for republish
   PROCEDURE validate_pb_dates(p_start_date IN OUT NOCOPY DATE, p_end_date IN OUT NOCOPY DATE, x_status IN OUT NOCOPY VARCHAR2)
   AS
   BEGIN
      IF (p_start_date > p_end_date)
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_VALIDATE_DATES', 'STARTDATE', TO_CHAR(p_start_date), 'ENDDATE', TO_CHAR(p_end_date));
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := 'Error during input start and end dates comparison: ' || SQLERRM;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
   END validate_pb_dates;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that gets applicability parameters for the
------publication to be republished
   PROCEDURE get_pb_parameters(
      p_publication_id IN cz_model_publications.publication_id%TYPE
     ,x_applicationid_tbl IN OUT NOCOPY cz_pb_mgr.t_ref
     ,x_usageid_tbl IN OUT NOCOPY cz_pb_mgr.t_ref
     ,x_languageid_tbl IN OUT NOCOPY cz_pb_mgr.t_lang_code
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      SELECT fnd_application_id
      BULK COLLECT INTO x_applicationid_tbl
        FROM cz_pb_client_apps
       WHERE publication_id = p_publication_id;

      SELECT usage_id
      BULK COLLECT INTO x_usageid_tbl
        FROM cz_publication_usages
       WHERE publication_id = p_publication_id;

      SELECT LANGUAGE
      BULK COLLECT INTO x_languageid_tbl
        FROM cz_pb_languages
       WHERE publication_id = p_publication_id;

      IF ((x_applicationid_tbl.COUNT = 0) OR(x_usageid_tbl.COUNT = 0) OR(x_languageid_tbl.COUNT = 0))
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := 'Republish terminated: all applicability parameters are not found for publication: ' || TO_CHAR(p_publication_id);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_PARAM_ERROR', 'PUBID', p_publication_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
   END get_pb_parameters;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that creates a new publication request
------for republish
   PROCEDURE create_republish_request(
      p_publication_id IN cz_model_publications.publication_id%TYPE
     ,p_start_date IN DATE
     ,p_end_date IN DATE
     ,x_new_publication_id IN OUT NOCOPY cz_model_publications.publication_id%TYPE
     ,p_repub_str IN VARCHAR2
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      v_new_publication_id cz_model_publications.publication_id%TYPE;
      v_old_publication_id cz_model_publications.publication_id%TYPE;
   BEGIN
      x_status := 'OK';

      SELECT cz_model_publications_s.NEXTVAL, p_publication_id
        INTO v_new_publication_id, v_old_publication_id
        FROM DUAL;

      INSERT INTO cz_model_publications
                  (publication_id, model_id, server_id, organization_id, top_item_id, product_key, publication_mode, ui_def_id, ui_style
                  ,applicable_from, applicable_until, export_status, deleted_flag, model_last_struct_update, model_last_logic_update
                  ,model_last_updated, user_str01, user_str02, user_str03, user_str04, user_num01, user_num02, user_num03, user_num04
                  ,model_persistent_id, source_target_flag, remote_publication_id, disabled_flag, object_id, object_type)
         SELECT v_new_publication_id, model_id, server_id, organization_id, top_item_id, product_key, publication_mode, ui_def_id, ui_style
               ,p_start_date, p_end_date, 'PEN', '0', model_last_struct_update, model_last_logic_update, model_last_updated, user_str01, user_str02
               ,user_str03, user_str04, user_num01, user_num02, user_num03, user_num04, model_persistent_id, source_target_flag
               ,remote_publication_id, disabled_flag, object_id, object_type
           FROM cz_model_publications
          WHERE publication_id = p_publication_id;

      v_repub_parameter := pub_model;
      insert_pb_parameters(v_new_publication_id, v_old_publication_id, v_repub_parameter, ' ', x_status);

      IF (p_repub_str = new_copy_str)
      THEN
         UPDATE cz_model_publications
            SET remote_publication_id = NULL
          WHERE publication_id = v_new_publication_id;
      ELSIF(p_repub_str = repub_str)
      THEN
         UPDATE cz_model_publications
            SET export_status = 'PUP'
          WHERE publication_id = p_publication_id;
      END IF;

      x_new_publication_id := v_new_publication_id;
      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_CREATE_REQUEST_ERROR', 'PUBID', p_publication_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
   END create_republish_request;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE create_republish_publication(
      p_publication_id IN NUMBER
     ,x_new_publication_id OUT NOCOPY NUMBER
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   AS
      v_new_publication_id cz_model_publications.publication_id%TYPE;
      v_old_publication_id cz_model_publications.publication_id%TYPE;
      v_source_pb_record cz_model_publications%ROWTYPE;
      l_application_id_tbl cz_pb_mgr.t_ref;
      l_language_id_tbl cz_pb_mgr.t_lang_code;
      l_usage_id_tbl cz_pb_mgr.t_ref;
      l_param_status VARCHAR2(2000);
      v_upto_date_status VARCHAR2(2000);
      v_publicationidstring VARCHAR2(2000);
      l_ui_def_id cz_ui_defs.ui_def_id%TYPE;
      l_deleted_flag VARCHAR2(1);
      l_ui_name cz_ui_defs.NAME%TYPE;
      expstatus_exception EXCEPTION;
      get_params_exception EXCEPTION;
      model_not_upto_date EXCEPTION;
      pub_overlap EXCEPTION;
      ui_def_id_is_deleted EXCEPTION;
   BEGIN
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      fnd_msg_pub.initialize;
      --execute the procedure that obsoletes the records
      --if the target has been converted into a development
      --instance
      cz_model_migration_pvt.obsolete_nonpublishable('T', x_return_status, x_msg_count, x_msg_data);

      ----check status
      IF (x_return_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         RAISE pub_maybe_obsoleted;
      END IF;

      ----get source pb info
      SELECT *
        INTO v_source_pb_record
        FROM cz_model_publications
       WHERE publication_id = p_publication_id AND deleted_flag = record_not_deleted AND source_target_flag = cz_model_migration_pvt.pub_source_flag;

      ----check status
      IF (v_source_pb_record.export_status <> 'OK')
      THEN
         RAISE expstatus_exception;
      END IF;

      ----get applicability parameters
      get_pb_parameters(p_publication_id, l_application_id_tbl, l_usage_id_tbl, l_language_id_tbl, l_param_status);

      IF (l_param_status = PUBLICATION_ERROR)
      THEN
         RAISE get_params_exception;
      END IF;

      ----check if UI exists
      IF (v_source_pb_record.ui_def_id IS NOT NULL)
      THEN
         BEGIN
            SELECT ui_def_id, deleted_flag, NAME
              INTO l_ui_def_id, l_deleted_flag, l_ui_name
              FROM cz_ui_defs
             WHERE cz_ui_defs.ui_def_id = v_source_pb_record.ui_def_id;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RAISE ui_def_id_is_deleted;
         END;

         IF (l_deleted_flag = '1')
         THEN
            RAISE ui_def_id_is_deleted;
         END IF;
      END IF;

      ----check model upto date
      model_upto_date(v_source_pb_record.object_id, v_source_pb_record.ui_def_id, v_upto_date_status);

      IF (v_upto_date_status <> '0')
      THEN
         RAISE model_not_upto_date;
      END IF;

      ----check publication overlap
      chk_pub_overlap_internal(v_source_pb_record.product_key
                              ,v_source_pb_record.publication_mode
                              ,l_application_id_tbl
                              ,l_language_id_tbl
                              ,l_usage_id_tbl
                              ,v_source_pb_record.server_id
                              ,v_source_pb_record.applicable_from
                              ,v_source_pb_record.applicable_until
                              ,v_source_pb_record.source_target_flag
                              ,v_source_pb_record.publication_id
                              ,v_publicationidstring
                              );

      IF (v_publicationidstring <> '-1')
      THEN
         RAISE pub_overlap;
      END IF;

      SELECT cz_model_publications_s.NEXTVAL, p_publication_id
        INTO v_new_publication_id, v_old_publication_id
        FROM DUAL;

      INSERT INTO cz_model_publications
                  (publication_id, model_id, server_id, organization_id, top_item_id, product_key, publication_mode, ui_def_id, ui_style
                  ,applicable_from, applicable_until, export_status, deleted_flag, model_last_struct_update, model_last_logic_update
                  ,model_last_updated, user_str01, user_str02, user_str03, user_str04, user_num01, user_num02, user_num03, user_num04
                  ,model_persistent_id, source_target_flag, remote_publication_id, object_id, object_type, disabled_flag)
         SELECT v_new_publication_id, model_id, server_id, organization_id, top_item_id, product_key, publication_mode, ui_def_id, ui_style
               ,applicable_from, applicable_until, 'PEN', '0', model_last_struct_update, model_last_logic_update, model_last_updated, user_str01
               ,user_str02, user_str03, user_str04, user_num01, user_num02, user_num03, user_num04, model_persistent_id, source_target_flag
               ,remote_publication_id, object_id, object_type, disabled_flag
           FROM cz_model_publications
          WHERE publication_id = p_publication_id;

      v_repub_parameter := pub_model;
      insert_pb_parameters(v_new_publication_id, v_old_publication_id, v_repub_parameter, ' ', x_return_status);

      UPDATE cz_model_publications
         SET export_status = 'PUP'
       WHERE publication_id = p_publication_id;

      x_new_publication_id := v_new_publication_id;
      COMMIT;
   EXCEPTION
      WHEN pub_overlap
      THEN
         ROLLBACK;
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PB_OVERLAP');
         fnd_message.set_token('PUBID', p_publication_id);
         fnd_message.set_token('PUBSTR', v_publicationidstring);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN ui_def_id_is_deleted
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;

         IF (l_ui_name IS NOT NULL)
         THEN
            fnd_message.set_name('CZ', 'CZ_UI_DEF_DELETED');
            fnd_message.set_token('UIDEFID', l_ui_name);
            fnd_msg_pub.ADD;
         ELSE
            fnd_message.set_name('CZ', 'CZ_UI_DEF_DELETED');
            fnd_message.set_token('UIDEFID', v_source_pb_record.ui_def_id);
            fnd_msg_pub.ADD;
         END IF;

         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN model_not_upto_date
      THEN
         ROLLBACK;
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_REPUB_MODEL_NOT_UP_TO_DATE');
         fnd_message.set_token('PUBID', p_publication_id);
         fnd_message.set_token('MODELUPTODATE', v_upto_date_status);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN get_params_exception
      THEN
         ROLLBACK;
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PB_GET_PARAMS_ERROR');
         fnd_message.set_token('PUBID', p_publication_id);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN expstatus_exception
      THEN
         ROLLBACK;
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PB_CREATE_REQUEST_ERR');
         fnd_message.set_token('PUBID', p_publication_id);
         fnd_message.set_token('EXPORT STATUS', v_source_pb_record.export_status);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
         cz_pb_mgr.v_republish_model := no_mode;
      WHEN pub_maybe_obsoleted
      THEN
         x_return_status := fnd_api.g_ret_sts_unexp_error;
      WHEN OTHERS
      THEN
         ROLLBACK;
         x_return_status := fnd_api.g_ret_sts_unexp_error;
         fnd_message.set_name('CZ', 'CZ_PB_CREATE_REQUEST_ERROR');
         fnd_message.set_token('PUBID', p_publication_id);
         fnd_message.set_token('SQLERRM', SQLERRM);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
   END create_republish_publication;

------------>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that resets the start and end dates
------of the original publication
   PROCEDURE reset_pb_dates(
      p_publicationid IN cz_model_publications.publication_id%TYPE
     ,x_applicable_from IN OUT NOCOPY DATE
     ,x_applicable_until IN OUT NOCOPY DATE
     ,x_orig_start_date IN OUT NOCOPY DATE
     ,x_orig_end_date IN OUT NOCOPY DATE
     ,x_start_date IN OUT NOCOPY DATE
     ,x_end_date IN OUT NOCOPY DATE
     ,x_reset_str IN OUT NOCOPY VARCHAR2
     ,x_status IN OUT NOCOPY VARCHAR2
   )
   AS
      v_db_link cz_servers.fndnam_link_name%TYPE;
      v_server_id cz_model_publications.server_id%TYPE;
      v_remote_publication_id cz_model_publications.remote_publication_id%TYPE;
      reset_date_error EXCEPTION;
   BEGIN
      SELECT applicable_from, applicable_until, server_id, remote_publication_id
        INTO v_repub_appl_from, v_repub_appl_until, v_server_id, v_remote_publication_id
        FROM cz_model_publications
       WHERE publication_id = p_publicationid;

      x_orig_start_date := v_repub_appl_from;
      x_orig_end_date := v_repub_appl_until;

      IF ((x_start_date = v_repub_appl_from) AND(x_end_date = v_repub_appl_until))
      THEN
         x_reset_str := repub_str;
      ELSIF(   ((x_start_date > v_repub_appl_until) AND(x_end_date > v_repub_appl_until))
            OR ((x_start_date < v_repub_appl_from) AND(x_end_date < v_repub_appl_from))
           )
      THEN
         x_reset_str := new_copy_str;
      ELSIF((x_start_date > v_repub_appl_from) AND(x_start_date < v_repub_appl_until) AND(x_end_date > v_repub_appl_until))
      THEN
         v_repub_appl_until := x_start_date;
         v_repub_appl_until := x_start_date;
         x_reset_str := new_copy_str;
         cz_pb_mgr.v_republish_model := new_copy_mode;
      ELSIF((x_start_date = v_repub_appl_from) AND(x_end_date > v_repub_appl_until))
      THEN
         x_reset_str := repub_str;
      ELSIF((x_start_date = v_repub_appl_from) AND(x_end_date < v_repub_appl_until))
      THEN
         v_repub_appl_from := x_end_date;
         x_reset_str := new_copy_str;
         cz_pb_mgr.v_republish_model := new_copy_mode;
      ELSIF(    (x_start_date < v_repub_appl_from)
            AND (x_start_date < v_repub_appl_until)
            AND (x_end_date > v_repub_appl_from)
            AND (x_end_date < v_repub_appl_until)
           )
      THEN
         v_repub_appl_from := x_end_date;
         x_reset_str := new_copy_str;
         cz_pb_mgr.v_republish_model := new_copy_mode;
      ELSIF(    (x_start_date < v_repub_appl_from)
            AND (x_start_date < v_repub_appl_until)
            AND (x_end_date > v_repub_appl_from)
            AND (x_end_date > v_repub_appl_until)
           )
      THEN
         x_reset_str := repub_str;
         v_repub_appl_from := x_start_date;
         v_repub_appl_until := x_end_date;
      ELSIF(    (x_start_date > v_repub_appl_from)
            AND (x_start_date < v_repub_appl_until)
            AND (x_end_date > v_repub_appl_from)
            AND (x_end_date < v_repub_appl_until)
           )
      THEN
         v_repub_appl_from := x_start_date;
         v_repub_appl_until := x_end_date;
         x_reset_str := repub_str;
      ELSE
         RAISE reset_date_error;
      END IF;

      UPDATE cz_model_publications
         SET applicable_from = v_repub_appl_from
            ,applicable_until = v_repub_appl_until
       WHERE publication_id = p_publicationid;

      x_applicable_from := v_repub_appl_from;
      x_applicable_until := v_repub_appl_until;
      COMMIT;
   EXCEPTION
      WHEN reset_date_error
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_RESET_DATES_ERROR', 'PUBID', p_publicationid, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
      WHEN OTHERS
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_RESET_DATES_ERROR', 'PUBID', p_publicationid, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
   END reset_pb_dates;

---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
   PROCEDURE reset_repub_changes(
      p_publication_id IN cz_model_publications.publication_id%TYPE
     ,p_orig_start_date IN DATE
     ,p_orig_end_date IN DATE
     ,x_reset_status IN OUT NOCOPY VARCHAR2
   )
   AS
   BEGIN
      UPDATE cz_model_publications
         SET cz_model_publications.applicable_from = p_orig_start_date
            ,cz_model_publications.applicable_until = p_orig_end_date
            ,cz_model_publications.deleted_flag = '0'
            ,cz_model_publications.export_status = 'OK'
       WHERE cz_model_publications.publication_id = p_publication_id;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         x_reset_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_RESET_PB_CHANGES', 'PUBID', p_publication_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
   END reset_repub_changes;

----------->>>>>>>>>>>>>>>>>>>>>>>>>>>>
------procedure that republishes a model
   PROCEDURE republish_model(
      p_publication_id IN OUT NOCOPY NUMBER
     ,p_start_date IN OUT NOCOPY DATE
     ,p_end_date IN OUT NOCOPY DATE
     ,x_run_id OUT NOCOPY NUMBER
     ,x_status OUT NOCOPY cz_model_publications.export_status%TYPE
   )
   AS
      v_upto_date_status VARCHAR2(2000);
      v_source_pb_record cz_model_publications%ROWTYPE;
      v_new_publication_id cz_model_publications.publication_id%TYPE;
      v_publicationidstring VARCHAR2(2000);
      v_reset_str VARCHAR2(100);
      v_reset_status VARCHAR2(2000);
      v_repub_status VARCHAR2(2000);
      v_param_status VARCHAR2(2000);
      v_publication_status VARCHAR2(3);
      v_create_status VARCHAR2(3);
      common_exception EXCEPTION;
   BEGIN
      initialize_pb_parameters(p_publication_id);
      ----initialize global republish parameter to be used in publish model
      cz_pb_mgr.v_republish_model := no_mode;
      x_status := 'OK';
      v_repub_appl_from := NULL;
      v_repub_appl_until := NULL;
      v_repub_remote_pb_id := 0;

      ---get run id
      SELECT cz_xfr_run_infos_s.NEXTVAL
        INTO cz_pb_mgr.v_pb_run_id
        FROM DUAL;

      x_run_id := cz_pb_mgr.v_pb_run_id;

      ----get source pb info
      SELECT *
        INTO v_source_pb_record
        FROM cz_model_publications
       WHERE publication_id = p_publication_id AND deleted_flag = record_not_deleted AND source_target_flag = g_source_flag;

      ----capture original values
      v_repub_remote_pb_id := v_source_pb_record.remote_publication_id;
      v_orig_start_date := v_source_pb_record.applicable_from;
      v_orig_end_date := v_source_pb_record.applicable_until;
      ----check status
      check_export_status(v_source_pb_record.export_status, cz_republish, x_status);

      IF (x_status = PUBLICATION_ERROR)
      THEN
         RAISE common_exception;
      END IF;

      ----get applicability parameters
      get_pb_parameters(p_publication_id, v_application_id_tbl, v_usage_id_tbl, v_language_id_tbl, v_param_status);

      IF (v_param_status = PUBLICATION_ERROR)
      THEN
         RAISE common_exception;
      END IF;

      ----validate input start and end dates
      IF (p_start_date IS NULL)
      THEN
         p_start_date := v_source_pb_record.applicable_from;
      END IF;

      IF (p_end_date IS NULL)
      THEN
         p_end_date := v_source_pb_record.applicable_until;
      END IF;

      validate_pb_dates(p_start_date, p_end_date, x_status);

      IF (x_status = PUBLICATION_ERROR)
      THEN
         RAISE common_exception;
      END IF;

      ----check model upto date
      model_upto_date(v_source_pb_record.object_id, v_source_pb_record.ui_def_id, v_upto_date_status);

      IF (v_upto_date_status <> '0')
      THEN
         cz_pb_mgr.v_err_message := v_upto_date_status;
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
         RAISE common_exception;
      END IF;

      ---reset pb dates
      reset_pb_dates(p_publication_id
                    ,v_repub_appl_from
                    ,v_repub_appl_until
                    ,v_orig_start_date
                    ,v_orig_end_date
                    ,p_start_date
                    ,p_end_date
                    ,v_reset_str
                    ,v_reset_status
                    );

      IF (v_reset_status = PUBLICATION_ERROR)
      THEN
         RAISE common_exception;
      END IF;

      ----check publication overlap
      chk_pub_overlap_internal(v_source_pb_record.product_key
                              ,v_source_pb_record.publication_mode
                              ,v_application_id_tbl
                              ,v_language_id_tbl
                              ,v_usage_id_tbl
                              ,v_source_pb_record.server_id
                              ,p_start_date
                              ,p_end_date
                              ,v_source_pb_record.source_target_flag
                              ,v_source_pb_record.publication_id
                              ,v_publicationidstring
                              );

      IF (v_publicationidstring <> '-1')
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_OVERLAP', 'PUBID', p_publication_id, 'PUBSTR', v_publicationidstring);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
         RAISE common_exception;
      ELSE
         ----create new publication request
         create_republish_request(p_publication_id, p_start_date, p_end_date, v_new_publication_id, v_reset_str, v_create_status);

         IF (v_create_status = PUBLICATION_ERROR)
         THEN
            RAISE common_exception;
         END IF;

         -----publish model
         publish_model(v_new_publication_id, x_run_id, v_publication_status);
      END IF;

      IF (v_publication_status = PUBLICATION_ERROR)
      THEN
         reset_repub_changes(p_publication_id, v_orig_start_date, v_orig_end_date, v_repub_status);
         RAISE common_exception;
      ELSE
         cz_pb_mgr.v_msg_tbl.DELETE;
         cz_pb_mgr.v_pb_run_id := x_run_id;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_REPUBLISH_SUCCESS', 'PUBID', p_publication_id);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUB_MODEL', SQLCODE);
         log_pb_trace;
      END IF;

      x_status := v_publication_status;
      cz_pb_mgr.v_republish_model := no_mode;
   EXCEPTION
      WHEN common_exception
      THEN
         ROLLBACK;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_REPUBLISH_FAILURE', 'PUBID', p_publication_id);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
         x_status := PUBLICATION_ERROR;
         log_pb_trace;
         cz_pb_mgr.v_republish_model := no_mode;
      WHEN OTHERS
      THEN
         x_status := PUBLICATION_ERROR;
         cz_pb_mgr.v_republish_model := no_mode;
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_REPUBLISH_FAILURE', 'PUBID', p_publication_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.REPUBLISH_MODEL', SQLCODE);
         log_pb_trace;
   END republish_model;

--------------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
----------enable publication
   PROCEDURE enable_publication(
      publicationid IN NUMBER
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   AS
      v_server_id cz_model_publications.server_id%TYPE;
      v_cz_link_name cz_servers.cz_link_name%TYPE;
      v_remote_publication_id cz_model_publications.remote_publication_id%TYPE;
      v_app_id_tbl cz_pb_mgr.t_ref;
      v_usg_id_tbl cz_pb_mgr.t_ref;
      v_lang_id_tbl cz_pb_mgr.t_lang_code;
      v_object_type cz_model_publications.object_type%TYPE;
      l_status VARCHAR2(3);
      l_product_key cz_model_publications.product_key%TYPE;
      l_applicable_from cz_model_publications.applicable_from%TYPE;
      l_applicable_until cz_model_publications.applicable_until%TYPE;
      l_source_target_flag cz_model_publications.source_target_flag%TYPE;
      l_publication_mode cz_model_publications.publication_mode%TYPE;
      v_export_status cz_model_publications.export_status%TYPE;
      l_publicationidstring VARCHAR2(2000);
      cannot_enable_template EXCEPTION;
      get_params_exception EXCEPTION;
      pub_overlap EXCEPTION;
      cannot_enable_publication EXCEPTION;
   BEGIN
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      fnd_msg_pub.initialize;
      --execute the procedure that obsoletes the records
      --if the target has been converted into a development
      --instance
      cz_model_migration_pvt.obsolete_nonpublishable('T', x_return_status, x_msg_count, x_msg_data);

      IF (x_return_status <> FND_API.G_RET_STS_SUCCESS)
      THEN
         RAISE pub_maybe_obsoleted;
      END IF;

      BEGIN
         SELECT export_status
           INTO v_export_status
           FROM cz_model_publications
          WHERE cz_model_publications.publication_id = publicationid;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_export_status := NULL;
      END;

      IF (v_export_status = model_publication_obselete)
      THEN
         RAISE cannot_enable_template;
      END IF;

      SELECT object_type, server_id, remote_publication_id, product_key, applicable_from, applicable_until, source_target_flag
            ,publication_mode, v_export_status
        INTO v_object_type, v_server_id, v_remote_publication_id, l_product_key, l_applicable_from, l_applicable_until, l_source_target_flag
            ,l_publication_mode, v_export_status
        FROM cz_model_publications
       WHERE cz_model_publications.publication_id = publicationid AND cz_model_publications.disabled_flag = '1';

      BEGIN
         SELECT fndnam_link_name
           INTO v_cz_link_name
           FROM cz_servers
          WHERE cz_servers.server_local_id = v_server_id;
      EXCEPTION
         WHEN OTHERS
         THEN
            v_cz_link_name := NULL;
      END;

      IF (v_object_type = template_publication)
      THEN
         RAISE cannot_enable_template;
      END IF;

      IF (v_export_status NOT IN('OK', 'PEN'))
      THEN
         RAISE cannot_enable_publication;
      END IF;

      get_pb_parameters(publicationid, v_app_id_tbl, v_usg_id_tbl, v_lang_id_tbl, l_status);

      IF (l_status = PUBLICATION_ERROR)
      THEN
         RAISE get_params_exception;
      END IF;

      chk_pub_overlap_internal(l_product_key
                              ,l_publication_mode
                              ,v_app_id_tbl
                              ,v_lang_id_tbl
                              ,v_usg_id_tbl
                              ,v_server_id
                              ,l_applicable_from
                              ,l_applicable_until
                              ,l_source_target_flag
                              ,publicationid
                              ,l_publicationidstring
                              );

      IF (l_publicationidstring <> '-1')
      THEN
         RAISE pub_overlap;
      END IF;

      IF (v_server_id = 0)
      THEN
         v_cz_link_name := '';
      ELSE
         v_cz_link_name := '@' || LTRIM(RTRIM(v_cz_link_name));
      END IF;

      UPDATE cz_model_publications
         SET disabled_flag = '0'
       WHERE publication_id = publicationid;

      cz_pb_mgr.remote_publication_id := v_remote_publication_id;

      EXECUTE IMMEDIATE    'BEGIN'
                        || ' '
                        || 'UPDATE cz_model_publications'
                        || v_cz_link_name
                        || ' '
                        || 'SET   disabled_flag   = ''0'''
                        || ' '
                        || 'WHERE  publication_id =  cz_pb_mgr.remote_publication_id ;'
                        || ' '
                        || 'END;';

      COMMIT;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN cannot_enable_publication
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := cz_utils.get_text('CZ_CANT_ENABLE_PUB', 'STATUS', v_export_status, 'PUBID', publicationid);
         fnd_message.set_name('CZ', 'CZ_CANT_ENABLE_PUB');
         fnd_message.set_token('STATUS', v_export_status);
         fnd_message.set_token('PUBID', publicationid);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN cannot_enable_template
      THEN
         x_msg_data := cz_utils.get_text('CZ_CANT_ENABLE_TEMPL', 'PUBID', publicationid);
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_CANT_ENABLE_TEMPL');
         fnd_message.set_token('PUBID', publicationid);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN get_params_exception
      THEN
         ROLLBACK;
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PB_GET_PARAMS_ERROR');
         fnd_message.set_token('PUBID', publicationid);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN pub_overlap
      THEN
         ROLLBACK;
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PB_OVERLAP');
         fnd_message.set_token('PUBID', publicationid);
         fnd_message.set_token('PUBSTR', l_publicationidstring);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN pub_maybe_obsoleted
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         x_msg_data := SQLERRM;
   END enable_publication;

---------------------------------
--------function that returns the name of a project that is passed in as
--------a parameter.  IF the name already exists, then the string "Copy of ()"
--------is appended before the original name
--------this function is used in deep_model_copy
--------
FUNCTION copy_name(p_devl_project_id IN	NUMBER)
RETURN VARCHAR2

AS

original_name	cz_devl_projects.name%TYPE;
copy_name		cz_devl_projects.name%TYPE;
L 			PLS_INTEGER := 0;
x_error		BOOLEAN := FALSE;

BEGIN
	BEGIN
		SELECT	name
		INTO		original_name
		FROM		cz_rp_entries
		WHERE		object_id  = p_devl_project_id
		 AND        object_type = 'PRJ'
		 AND		deleted_flag = '0';
	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		original_name := NULL;
	WHEN OTHERS THEN
		original_name := NULL;
	END;

	IF (original_name IS NOT NULL) THEN

		BEGIN

			SELECT	nvl(max(to_number(substr(SUBSTR(name, 1, instr(name,original_name, -1, 1)-1),7,instr(SUBSTR(name, 1, instr(name,original_name, -1, 1)-1),')',7)-7))),0)
			INTO		L
						FROM		cz_rp_entries
						WHERE	 name LIKE 'Copy (%) of '||original_name
						and  instr(SUBSTR(name, 1, instr(name,original_name, -1, 1)-1),'Copy (',7)=0
		                                and is_val_number(substr(SUBSTR(name, 1, instr(name,original_name, -1, 1)-1),7,instr(SUBSTR(name, 1, instr(name,original_name, -1, 1)-1),')',7)-7))='TRUE'
						AND     deleted_flag = '0' and object_type='PRJ';

		--	L	 :=	to_number(substr(copy_name,7,instr(copy_name,')',7)-7));

		EXCEPTION
		WHEN	NO_DATA_FOUND THEN
			L := 0;
		END;
	END IF;

	L := L + 1;
	copy_name := 'Copy ('||to_char(L)||') of '||original_name;
	RETURN	copy_name ;
EXCEPTION
  WHEN OTHERS THEN
    -- x_error:= CZ_UTILS.REPORT(SQLERRM,1,'CZ_UTILS.COPY_NAME',-222);
    log_report('cz_utils', 'copy_name', 1, SQLERRM, fnd_log.LEVEL_UNEXPECTED);
    copy_name := 'ERROR';
    RETURN copy_name ;
END copy_name;

----------------------------------------------------------------------------------
   PROCEDURE create_publication_request(
      p_model_id IN NUMBER
     ,p_ui_def_id IN NUMBER
     ,p_publication_mode IN VARCHAR2
     ,p_server_id IN NUMBER
     ,p_appl_id_tbl IN cz_pb_mgr.t_ref
     ,p_usg_id_tbl IN cz_pb_mgr.t_ref
     ,p_lang_tbl IN cz_pb_mgr.t_lang_code
     ,p_start_date IN DATE
     ,p_end_date IN DATE
     ,x_publication_id OUT NOCOPY NUMBER
     ,x_return_status OUT NOCOPY VARCHAR2
     ,x_msg_count OUT NOCOPY NUMBER
     ,x_msg_data OUT NOCOPY VARCHAR2
   )
   IS
      l_model_id cz_rp_entries.object_id%TYPE;
      l_publication_mode cz_model_publications.publication_mode%TYPE;
      l_usg_id cz_publication_usages.usage_id%TYPE;
      l_lang_code cz_pb_languages.LANGUAGE%TYPE;
      l_start_date DATE;
      l_end_date DATE;
      l_last_struct_update DATE;
      l_last_logic_update DATE;
      l_last_updated DATE;
      l_persistent_project_id cz_devl_projects.persistent_project_id%TYPE;
      v_publicationidstring VARCHAR2(2000);
      v_upto_date_status VARCHAR2(2000);
      l_ui_style cz_ui_defs.ui_style%TYPE;
      v_new_publication_id cz_model_publications.publication_id%TYPE;
      l_inventory_item_id cz_devl_projects.inventory_item_id%TYPE;
      l_organization_id cz_devl_projects.organization_id%TYPE;
      l_product_key cz_devl_projects.product_key%TYPE;
      l_ui_def_id cz_ui_defs.ui_def_id%TYPE;
      l_short_name cz_pb_client_apps.application_short_name%TYPE;
      pub_overlap EXCEPTION;
      no_model_id EXCEPTION;
      no_model_exists EXCEPTION;
      no_ui_exists EXCEPTION;
      invalid_pb_mode EXCEPTION;
      no_appl_id EXCEPTION;
      model_not_upto_date EXCEPTION;
      no_ui_id EXCEPTION;
      product_key_is_null EXCEPTION;
      PUB_SOURCE_FLAG CONSTANT VARCHAR2(1)  := 'S';
   BEGIN
      x_return_status := FND_API.G_RET_STS_SUCCESS;
      fnd_msg_pub.initialize;

      -----check if model id passed in is not null
      -----if not null then check if the model exists and is
      -----a source model
      IF (p_model_id IS NULL)
      THEN
         RAISE no_model_id;
      ELSE
         BEGIN
            SELECT devl_project_id, product_key, inventory_item_id, organization_id, last_struct_update, last_logic_update, last_update_date
                  ,persistent_project_id
              INTO l_model_id, l_product_key, l_inventory_item_id, l_organization_id, l_last_struct_update, l_last_logic_update, l_last_updated
                  ,l_persistent_project_id
              FROM cz_devl_projects
             WHERE cz_devl_projects.devl_project_id = p_model_id
               AND cz_devl_projects.deleted_flag = '0'
               AND cz_devl_projects.devl_project_id IN(SELECT object_id
                                                         FROM cz_rp_entries
                                                        WHERE cz_rp_entries.object_type = 'PRJ' AND cz_rp_entries.deleted_flag = '0');
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RAISE no_model_exists;
         END;
      END IF;

      IF (l_product_key IS NULL)
      THEN
         RAISE product_key_is_null;
      END IF;

      -----verify that the ui_def_id passed in is valid
      -----If a ui_def is passed in verify that it belongs to the
      ----- model that is being published.
      IF (p_ui_def_id < 0)
      THEN
         RAISE no_ui_id;
      ELSIF(p_ui_def_id IS NULL)
      THEN
         l_ui_def_id := NULL;
         l_ui_style := NULL;
      ELSE
         BEGIN
            SELECT ui_def_id, ui_style
              INTO l_ui_def_id, l_ui_style
              FROM cz_ui_defs
             WHERE cz_ui_defs.ui_def_id = p_ui_def_id AND cz_ui_defs.devl_project_id = p_model_id AND cz_ui_defs.deleted_flag = '0';
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RAISE no_ui_exists;
         END;
      END IF;

      ----verify that the publication mode that is passed in
      ---- is a valid one.  If NULL is passed then
      ----- default the mode to 'P'
      l_publication_mode := p_publication_mode;

      IF (l_publication_mode IS NULL)
      THEN
         l_publication_mode := 'P';
      ELSIF(UPPER(l_publication_mode) NOT IN('P', 'T', cz_model_migration_pvt.mode_migration))
      THEN
         RAISE invalid_pb_mode;
      END IF;

      IF (UPPER(l_publication_mode) = cz_model_migration_pvt.mode_migration)
      THEN
         cz_pb_mgr.g_source_flag := cz_model_migration_pvt.mig_source_flag;
         cz_pb_mgr.g_target_flag := cz_model_migration_pvt.mig_target_flag;
      ELSE
         cz_pb_mgr.g_source_flag := cz_model_migration_pvt.pub_source_flag;
         cz_pb_mgr.g_target_flag := cz_model_migration_pvt.pub_target_flag;
      END IF;

      ----check that atleast one application id
      ----- is passed
      IF (p_appl_id_tbl.COUNT = 0)
      THEN
         RAISE no_appl_id;
      END IF;

      ----if no usage is passed the default to
      ---- any usage
      IF (p_usg_id_tbl.COUNT = 0)
      THEN
         l_usg_id := -1;
      END IF;

      ----- if no language is passed then default to
      ------AMERICAN ENGLISH
      IF (p_lang_tbl.COUNT = 0)
      THEN
         l_lang_code := 'US';
      END IF;

      -----if no start or end dates
      ---- are passed, then default to epoch begin and epoch end respectively
      IF (p_start_date IS NULL)
      THEN
         l_start_date := cz_utils.epoch_begin;
      ELSE
         l_start_date := p_start_date;
      END IF;

      IF (p_end_date IS NULL)
      THEN
         l_end_date := cz_utils.epoch_end;
      ELSE
         l_end_date := p_end_date;
      END IF;

      ----check model upto date
      cz_pb_mgr.model_upto_date(p_model_id, p_ui_def_id, v_upto_date_status);

      IF (v_upto_date_status <> '0')
      THEN
         RAISE model_not_upto_date;
      END IF;

      ----check for publication overlap
      chk_pub_overlap_internal(l_product_key
                              ,l_publication_mode
                              ,p_appl_id_tbl
                              ,p_lang_tbl
                              ,p_usg_id_tbl
                              ,p_server_id
                              ,l_start_date
                              ,l_end_date
                              ,PUB_SOURCE_FLAG
                              ,1
                              ,v_publicationidstring
                              );

      IF (v_publicationidstring <> '-1')
      THEN
         RAISE pub_overlap;
      END IF;

      SELECT cz_model_publications_s.NEXTVAL
        INTO v_new_publication_id
        FROM DUAL;

      INSERT INTO cz_model_publications
                  (publication_id, model_id, server_id, organization_id, top_item_id, product_key, publication_mode
                  ,ui_def_id, ui_style, applicable_from, applicable_until, export_status, deleted_flag, model_last_struct_update
                  ,model_last_logic_update, model_last_updated, model_persistent_id, source_target_flag, remote_publication_id, object_id
                  ,object_type, disabled_flag
                  )
           VALUES (v_new_publication_id, p_model_id, p_server_id, l_organization_id, l_inventory_item_id, l_product_key, l_publication_mode
                  ,p_ui_def_id, l_ui_style, l_start_date, l_end_date, 'PEN', '0', l_last_struct_update
                  ,l_last_logic_update, l_last_updated, l_persistent_project_id, PUB_SOURCE_FLAG, NULL, p_model_id
                  ,'PRJ', '0'
                  );

      IF (p_appl_id_tbl.COUNT > 0)
      THEN
         FOR i IN p_appl_id_tbl.FIRST .. p_appl_id_tbl.LAST
         LOOP
            l_short_name := ' ';

            SELECT application_short_name
              INTO l_short_name
              FROM fnd_application
             WHERE application_id = p_appl_id_tbl(i);

            INSERT INTO cz_pb_client_apps
                        (publication_id, fnd_application_id, application_short_name
                        )
                 VALUES (v_new_publication_id, p_appl_id_tbl(i), l_short_name
                        );
         ---- short name must be retrieved from fnd_applications_tl
         END LOOP;
      END IF;

      IF (p_usg_id_tbl.COUNT > 0)
      THEN
         FOR i IN p_usg_id_tbl.FIRST .. p_usg_id_tbl.LAST
         LOOP
            INSERT INTO cz_publication_usages
                        (publication_id, usage_id
                        )
                 VALUES (v_new_publication_id, p_usg_id_tbl(i)
                        );
         END LOOP;
      ELSE
         INSERT INTO cz_publication_usages
                     (publication_id, usage_id
                     )
              VALUES (v_new_publication_id, l_usg_id
                     );
      END IF;

      IF (p_lang_tbl.COUNT > 0)
      THEN
         FOR i IN p_lang_tbl.FIRST .. p_lang_tbl.LAST
         LOOP
            INSERT INTO cz_pb_languages
                        (publication_id, LANGUAGE
                        )
                 VALUES (v_new_publication_id, p_lang_tbl(i)
                        );
         END LOOP;
      ELSE
         INSERT INTO cz_pb_languages
                     (publication_id, LANGUAGE
                     )
              VALUES (v_new_publication_id, l_lang_code
                     );
      END IF;

      x_publication_id := v_new_publication_id;
   EXCEPTION
      WHEN product_key_is_null
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PRODUCT_KEY_IS_NULL');
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN no_model_id
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'cz_pb_mgr_MODEL_ID_NULL');
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN no_model_exists
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'cz_pb_mgr_NO_MODEL_EXISTS');
         fnd_message.set_token('MODELID', p_model_id);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN no_ui_exists
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'cz_pb_mgr_NO_UI_EXISTS');
         fnd_message.set_token('MODELID', p_model_id);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN invalid_pb_mode
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'cz_pb_mgr_IVALID_PB_MODE');
         fnd_message.set_token('PBMODE', l_publication_mode);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN no_appl_id
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'cz_pb_mgr_NO_APPL_ID');
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN pub_overlap
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'PUB_OVERLAP');
         fnd_message.set_token('PUB_OVERLAP', v_publicationidstring);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN model_not_upto_date
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PB_MODEL_NOT_UPTO_DATE');
         fnd_message.set_token('UPTODATESTR', v_upto_date_status);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
      WHEN OTHERS
      THEN
         x_return_status := FND_API.G_RET_STS_ERROR;
         fnd_message.set_name('CZ', 'CZ_PB_CREATE_PB_REQUEST_ERR');
         fnd_message.set_token('ERROR', SQLERRM);
         fnd_msg_pub.ADD;
         fnd_msg_pub.count_and_get(p_count => x_msg_count, p_data => x_msg_data);
   END create_publication_request;

------------------------------------------------------------------------------------------------
--Need to go through get_models_tobe_exported because it makes the decisions on shallow
--migration.
   PROCEDURE mm_get_models_tobe_exported(rootmodelid_tbl IN cz_pb_mgr.t_ref)
   AS
   BEGIN
     IF (rootmodelid_tbl.COUNT > 0) THEN
      FOR i IN rootmodelid_tbl.FIRST .. rootmodelid_tbl.LAST
      LOOP
         get_models_tobe_exported(rootmodelid_tbl(i));
      END LOOP;
      END IF;
   END;

------------------------------------------------------------------------------------------------
   FUNCTION mm_chkifmodelselectedforexport(input_model NUMBER)
      RETURN NUMBER
   AS
      return_value NUMBER := 0;
   BEGIN
     IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0) THEN
      FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
      LOOP
         IF (cz_pb_mgr.v_models_to_be_exported(i) = input_model)
         THEN
            return_value := 1;
            EXIT;
         END IF;
      END LOOP;
     END IF;

      RETURN return_value;
   END mm_chkifmodelselectedforexport;

------------------------------------------------------------------------------------------------
--The current design for model migration will run
--the publication process for every model that has been selected
--to be migrated.  The process of collecting the models is in
--CZ_MODEL_MIGRATION_PVT.  Once the models are collected there, for every
--CZ_MODEL_PUBLICATIONS record, publish model is called.  Given that,
--this procedure gets the model for the current migration cz_model_publication
--record.

   FUNCTION get_rootmodel_and_mig_tgt_fldr(p_publication_id NUMBER)
      RETURN t_ref
   AS
      mm_root_model t_ref;
   BEGIN

      --we load the global variable
      --holding the value of migration target folder
      SELECT migration_group_id, migration_tgt_folder
        INTO cz_pb_mgr.g_migration_group_id, cz_pb_mgr.g_migration_tgt_folder_id
        FROM cz_model_publications
       WHERE publication_id = p_publication_id;

      --get the model corresponding to this publication
      SELECT object_id
      BULK COLLECT INTO mm_root_model
        FROM cz_model_publications
       WHERE publication_id = p_publication_id;

      RETURN mm_root_model;
   END get_rootmodel_and_mig_tgt_fldr;

------------------------------------------------------------------------------------------------
   PROCEDURE mm_loadoldpsnodesforitems
   AS
      v_project_count PLS_INTEGER;
      rec_count PLS_INTEGER;
      l_ps_uits_add_tbl date_tbl_type;      -- cz_ps_nodes.UI_TIMESTAMP_ADD
      l_reverse_connector_tbl  t_ref;
   BEGIN
      clear_tables('cz_ps_nodes', 'tbl', cz_pb_mgr.v_status_code);
      cz_pb_mgr.sequence_const := 0;

      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.v_models_to_be_exported.FIRST .. cz_pb_mgr.v_models_to_be_exported.LAST
         LOOP
            BEGIN
               clear_tables('cz_ps_nodes', 'ref', cz_pb_mgr.v_status_code);
               l_ps_uits_add_tbl.DELETE;
               l_reverse_connector_tbl.DELETE;

               SELECT cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_ps_nodes_seq
                                                 , 'cz_ps_nodes_s.NEXTVAL' || cz_pb_mgr.v_db_link
                                                 ,cz_pb_mgr.v_oraclesequenceincr
                                                 )
                     ,ps_node_id, parent_id, reference_id, effectivity_set_id
                     ,intl_text_id, violation_text_id, displayname_capt_rule_id, component_id
                     ,effective_usage_mask, item_id, ps_node_type
                     ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.psnode_origsysref(orig_sys_ref), 'N', orig_sys_ref)
                     ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.psnode_compseqpath(component_sequence_path), 'N', component_sequence_path)
                     ,DECODE(cz_pb_mgr.bomsynch_flag, 'Y', cz_bom_synch.psnode_compseqid(component_sequence_id), 'N', component_sequence_id)
                     ,NVL(ui_timestamp_add, creation_date), reverse_connector_id, src_application_id
               BULK COLLECT INTO cz_pb_mgr.v_cz_ps_nodes_new_ref
                     ,cz_pb_mgr.v_cz_ps_nodes_old_ref, cz_pb_mgr.v_ps_parent_id_ref, cz_pb_mgr.v_ps_ref_id_ref, cz_pb_mgr.v_ps_eff_set_id_ref
                     ,cz_pb_mgr.v_ps_intl_old_ref, cz_pb_mgr.v_ps_viol_old_ref, cz_pb_mgr.v_ps_capt_rule_ref, cz_pb_mgr.v_cz_ps_nodes_comp_ref
                     ,cz_pb_mgr.v_cz_effective_usage_mask_ref, cz_pb_mgr.v_ps_item_id_ref, cz_pb_mgr.v_ps_type_old_ref
                     ,cz_pb_mgr.v_ps_orig_sys_ref
                     ,cz_pb_mgr.v_ps_comp_seq_path_ref
                     ,cz_pb_mgr.v_ps_comp_seq_id_ref
                     ,l_ps_uits_add_tbl, l_reverse_connector_tbl
                     ,cz_pb_mgr.v_ps_src_appl_id_old_ref
                 FROM cz_ps_nodes
                WHERE cz_ps_nodes.devl_project_id = cz_pb_mgr.v_models_to_be_exported(i) AND deleted_flag = record_not_deleted;
            EXCEPTION
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_BULK_COLLECT_ERR', 'TABLENAME', 'cz_ps_nodes', 'SQLERRM', SQLERRM);
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.MODEL', SQLCODE);
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  RAISE;
            END;

            v_project_count := cz_pb_mgr.v_devl_project_tbl.COUNT;
            rec_count := cz_pb_mgr.v_cz_ps_nodes_new_tbl.COUNT;

            IF (cz_pb_mgr.v_cz_ps_nodes_new_ref.COUNT > 0)
            THEN
               FOR k IN cz_pb_mgr.v_cz_ps_nodes_new_ref.FIRST .. cz_pb_mgr.v_cz_ps_nodes_new_ref.LAST
               LOOP
                  rec_count := rec_count + 1;
                  cz_pb_mgr.v_cz_ps_nodes_new_tbl(rec_count) := cz_pb_mgr.v_cz_ps_nodes_new_ref(k);
                  cz_pb_mgr.v_cz_ps_nodes_old_tbl(rec_count) := cz_pb_mgr.v_cz_ps_nodes_old_ref(k);
                  cz_pb_mgr.v_cz_effective_usage_mask_tbl(rec_count) := cz_pb_mgr.v_cz_effective_usage_mask_ref(k);
                  cz_pb_mgr.v_cz_ps_nodes_idx_tbl(cz_pb_mgr.v_cz_ps_nodes_old_ref(k)):=cz_pb_mgr.v_cz_ps_nodes_new_ref(k);
                  cz_pb_mgr.v_ps_refid_old_tbl(rec_count) := cz_pb_mgr.v_ps_ref_id_ref(k);

                  IF (cz_pb_mgr.v_cz_ps_nodes_old_ref(k) = cz_pb_mgr.v_models_to_be_exported(i))
                  THEN
                     cz_pb_mgr.v_new_devl_id := cz_pb_mgr.v_cz_ps_nodes_new_ref(k);
                  END IF;

                  ------------resolve parent ids
                  IF (cz_pb_mgr.v_ps_parent_id_ref(k) IS NOT NULL)
                  THEN
		    IF (cz_pb_mgr.v_cz_ps_nodes_old_ref.COUNT > 0) THEN
                     FOR i IN cz_pb_mgr.v_cz_ps_nodes_old_ref.FIRST .. cz_pb_mgr.v_cz_ps_nodes_old_ref.LAST
                     LOOP
                        IF (cz_pb_mgr.v_ps_parent_id_ref(k) = cz_pb_mgr.v_cz_ps_nodes_old_ref(i))
                        THEN
                           cz_pb_mgr.v_ps_parent_id_ref(k) := cz_pb_mgr.v_cz_ps_nodes_new_ref(i);
                           EXIT;
                        END IF;
                     END LOOP;
		   END IF;
                  END IF;

                  cz_pb_mgr.v_ps_parent_id_tbl(rec_count) := cz_pb_mgr.v_ps_parent_id_ref(k);
                  cz_pb_mgr.v_ps_eff_set_id_tbl(rec_count) := cz_pb_mgr.v_ps_eff_set_id_ref(k);
                  cz_pb_mgr.v_ps_intl_old_tbl(rec_count) := cz_pb_mgr.v_ps_intl_old_ref(k);
                  cz_pb_mgr.v_ps_viol_old_tbl(rec_count) := cz_pb_mgr.v_ps_viol_old_ref(k);
                  cz_pb_mgr.v_ps_capt_rule_tbl(rec_count) := cz_pb_mgr.v_ps_capt_rule_ref(k);
                  cz_pb_mgr.v_cz_ps_nodes_comp_tbl(rec_count) := cz_pb_mgr.v_cz_ps_nodes_comp_ref(k);
                  cz_pb_mgr.v_ps_orig_sys_tbl(rec_count) := cz_pb_mgr.v_ps_orig_sys_ref(k);
                  cz_pb_mgr.v_ps_comp_seq_path_tbl(rec_count) := cz_pb_mgr.v_ps_comp_seq_path_ref(k);
                  cz_pb_mgr.v_ps_comp_seq_id_tbl(rec_count) := cz_pb_mgr.v_ps_comp_seq_id_ref(k);
                  cz_pb_mgr.v_ps_item_id_tbl(rec_count) := cz_pb_mgr.v_ps_item_id_ref(k);
                  cz_pb_mgr.v_ps_type_old_tbl(rec_count) := cz_pb_mgr.v_ps_type_old_ref(k);
                  cz_pb_mgr.v_ps_src_appl_id_old_tbl(rec_count) := cz_pb_mgr.v_ps_src_appl_id_old_ref(k);
                  cz_pb_mgr.g_ps_uits_add_tbl(rec_count) := l_ps_uits_add_tbl(k);
                  cz_pb_mgr.g_ps_reverse_connector_tbl(rec_count) := l_reverse_connector_tbl(k);
               END LOOP;
            END IF;

            cz_pb_mgr.v_models_to_be_exported_new(i) := cz_pb_mgr.v_new_devl_id;

	    IF (cz_pb_mgr.v_cz_ps_nodes_new_ref.COUNT > 0) THEN
            FOR k IN cz_pb_mgr.v_cz_ps_nodes_new_ref.FIRST .. cz_pb_mgr.v_cz_ps_nodes_new_ref.LAST
            LOOP
               v_project_count := v_project_count + 1;
               cz_pb_mgr.v_devl_project_tbl(v_project_count) := cz_pb_mgr.v_new_devl_id;
--               cz_pb_mgr.v_intl_text_model_tbl(v_project_count) := cz_pb_mgr.v_new_devl_id;
--               cz_pb_mgr.v_intl_text_ui_tbl(v_project_count) := -1;
            END LOOP;
	    END IF;

            insert_devl_projects(cz_pb_mgr.v_new_devl_id, cz_pb_mgr.v_models_to_be_exported(i), cz_pb_mgr.v_devl_orig_sys_ref
                                ,cz_pb_mgr.v_status_code);

            ---------- update remote_model id in the source cz_pb_model_exports
            UPDATE cz_pb_model_exports t
               SET t.remote_model_id = cz_pb_mgr.v_models_to_be_exported_new(i)
             WHERE t.publication_id = cz_pb_mgr.v_publication_id
               AND t.server_id = cz_pb_mgr.v_server_id
               AND t.model_id = cz_pb_mgr.v_models_to_be_exported(i);

            COMMIT;
         END LOOP;                            /* end loop of FOR I IN p_models_for_export */
      END IF;                                 /* end if of p_models_for_export > 0 */
   END mm_loadoldpsnodesforitems;

------------------------------------------------------------------------------------------------
   PROCEDURE get_all_properties
   AS
      v_property_count PLS_INTEGER := 0;
      rec_count PLS_INTEGER := 0;
      v_remote_prop_tbl cz_pb_mgr.t_ref;
      l_data_type_tbl cz_pb_mgr.t_ref;
      l_def_num_value_tbl cz_pb_mgr.t_ref;
      l_prop_num_value_tbl cz_pb_mgr.t_ref;
      l_old_psnode_id NUMBER;

      l_devl_project_id_tbl cz_pb_mgr.t_ref;
      l_devl_project_id     NUMBER;

-- model migration
      l_item_type_id_tbl cz_pb_mgr.t_ref;
      l_item_id_tbl cz_pb_mgr.t_ref;
      l_inherited_flag_tbl cz_pb_mgr.varchar_type_1_tbl;
      l_valuesource_tbl cz_pb_mgr.varchar_type_8_tbl;
   BEGIN
      IF (cz_pb_mgr.v_models_to_be_exported.COUNT > 0)
      THEN
         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start bulk collect from cz_psnode_propval_v');
         END IF;

	 IF (cz_pb_mgr.v_cz_ps_nodes_old_tbl.COUNT > 0) THEN
         FOR i IN cz_pb_mgr.v_cz_ps_nodes_old_tbl.FIRST .. cz_pb_mgr.v_cz_ps_nodes_old_tbl.LAST
         LOOP
            clear_tables('cz_ps_prop_vals', 'tbl', cz_pb_mgr.v_status_code);
            l_data_type_tbl.DELETE;
            l_prop_num_value_tbl.DELETE;
            l_def_num_value_tbl.DELETE;

            BEGIN
               l_old_psnode_id := cz_pb_mgr.v_cz_ps_nodes_old_tbl(i);
               l_devl_project_id := cz_pb_mgr.v_devl_project_tbl(i);

               IF (cz_pb_mgr.v_session_parameter <> model_copy)
               THEN

                  -- Bug 5570651: The view cz_psnode_propval_v returns records for
                  -- REFERENCE nodes (ps_node_type:263), also. So, when publishing a model
                  -- containing references, properties defined on the root of the referred model
                  -- are retrieved more than once: once for the root node, and once for every node
                  -- of type 263 referring to it. This causes publishing to create a record in
                  -- cz_ps_prop_vals for the node with type 263. This is unnecessary because, when
                  -- getting properties for a reference node, CIO always goes to actual root of the
                  -- referred model. In the case of this bug, the multiple records for the same property,
                  -- each with a different devl_project_id were causing a problem when publishing
                  -- translatable text properties. The intl_text_id to devl_project_id map (h_devl_prj_by_intl_text)
                  -- was populated with wrong devl_project_ids just causing the intl_text to be
                  -- written with a wrong model_id. We solve this problem by excluding records with
                  -- ps_node_type = 263 in the query below

                  SELECT ps_node_id, property_id, data_type, property_num_value
                       , property_value, item_type_id, item_id, inherited_flag, valuesource, l_devl_project_id
                       , def_num_value
                  BULK COLLECT INTO cz_pb_mgr.v_prop_vals_node_tbl, cz_pb_mgr.v_prop_vals_prop_tbl, l_data_type_tbl, l_prop_num_value_tbl
                       , cz_pb_mgr.v_prop_vals_data_tbl, l_item_type_id_tbl, l_item_id_tbl, l_inherited_flag_tbl, l_valuesource_tbl
                       , l_devl_project_id_tbl, l_def_num_value_tbl
                    FROM cz_psnode_propval_v t
                   WHERE t.ps_node_id = l_old_psnode_id
                     AND t.ps_node_type <> PS_NODE_REF_TYPE;
               -----ORDER BY ps_node_id;
               ELSE
                  SELECT a.ps_node_id, a.property_id, b.data_type, a.data_num_value
                       , a.data_value, l_devl_project_id
                  BULK COLLECT INTO cz_pb_mgr.v_prop_vals_node_tbl, cz_pb_mgr.v_prop_vals_prop_tbl, l_data_type_tbl, l_prop_num_value_tbl
                       , cz_pb_mgr.v_prop_vals_data_tbl, l_devl_project_id_tbl
                    FROM cz_ps_prop_vals a, cz_properties b
                   WHERE a.property_id = b.property_id AND a.ps_node_id = l_old_psnode_id AND a.deleted_flag = '0';
               -----ORDER BY a.ps_node_id;
               END IF;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  cz_pb_mgr.v_err_message := 'No nodes were found in prop vals view ';
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PROPVALS', SQLCODE);
               WHEN OTHERS
               THEN
                  cz_pb_mgr.v_err_message := 'Error in bulk collect from cz_ps_prop_vals: ' || SQLERRM;
                  cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.PROPVALS', SQLCODE);
                  cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
                  RAISE;
            END;

            IF (cz_pb_mgr.v_prop_vals_node_tbl.COUNT > 0)
            THEN
               v_property_count := cz_pb_mgr.v_prop_vals_node_ref.COUNT;

               FOR j IN cz_pb_mgr.v_prop_vals_node_tbl.FIRST .. cz_pb_mgr.v_prop_vals_node_tbl.LAST
               LOOP
                  v_property_count := v_property_count + 1;

                  cz_pb_mgr.v_prop_vals_node_ref(v_property_count) := cz_pb_mgr.v_prop_vals_node_tbl(j);
                  cz_pb_mgr.v_prop_vals_prop_ref(v_property_count) := cz_pb_mgr.v_prop_vals_prop_tbl(j);
                  cz_pb_mgr.v_prop_vals_data_typ_ref(v_property_count) := l_data_type_tbl(j);
                  cz_pb_mgr.v_prop_vals_data_num_ref(v_property_count) := l_prop_num_value_tbl(j);
                  cz_pb_mgr.v_prop_vals_data_ref(v_property_count) := cz_pb_mgr.v_prop_vals_data_tbl(j);

                  IF(l_data_type_tbl(j) = 8)THEN

                      --Bug #5441580. This is the case of translatable properties, data_num_value contains
                      --intl_text_id of the property value. Hash the node's devl_project_id for later use
                      --inserting into cz_localized_texts.

                      cz_pb_mgr.h_devl_prj_by_intl_text(l_prop_num_value_tbl(j)) := l_devl_project_id_tbl(j);
                  END IF;

                  --model migration, maintain other columns
                  IF (cz_pb_mgr.v_session_parameter <> model_copy)
                  THEN
                     cz_pb_mgr.v_prop_vals_inherited_flag_ref(v_property_count) := l_inherited_flag_tbl(j);
                     cz_pb_mgr.v_prop_vals_item_type_id_ref(v_property_count) := l_item_type_id_tbl(j);
                     cz_pb_mgr.v_prop_vals_item_id_ref(v_property_count) := l_item_id_tbl(j);
                     cz_pb_mgr.v_prop_vals_valuesource_ref(v_property_count) := l_valuesource_tbl(j);

                     --There is no need to make this array public and define it in the spec as it is not used in
                     --any dynamic sql blocks.

                     v_prop_vals_def_num_value_ref(v_property_count) := l_def_num_value_tbl(j);

                  END IF;
               END LOOP;
            END IF;                                                                           /* end if of cz_pb_mgr.v_prop_vals_node_tbl.COUNT > 0 */
         END LOOP;                                                                          /* end loop of FOR I IN cz_pb_mgr.v_cz_ps_nodes_old_tbl */
	END IF;
      END IF;                                                                                          /* cz_pb_mgr.v_cz_ps_nodes_old_tbl.COUNT > 0 */
   END get_all_properties;
------------------------------------------------------------------------------------------------
   PROCEDURE mm_sync_properties
   AS
      s_prop_id NUMBER;
      t_prop_id NUMBER;
      s_item_type_id NUMBER;
      t_item_type_id NUMBER;
      s_item_id NUMBER;
      t_item_id NUMBER;
      t_prop_val_num number;
      new_def_num_val number;
      l_exists_on_target_hash cz_pb_mgr.t_ref;
   BEGIN
/*
 *  For all the properties collected in v_prop_vals_prop_ref
 */
      IF(cz_pb_mgr.v_prop_vals_prop_ref.COUNT > 0) THEN
         FOR j IN cz_pb_mgr.v_prop_vals_prop_ref.FIRST .. cz_pb_mgr.v_prop_vals_prop_ref.LAST LOOP

               /*
                 Get the property_id
                 handle properties  check if the property with the same name, src_application_id exists
                 Add either the existing prop or the new prop id to table mm_v_tbl_sync_prop(old);
               */

               s_prop_id := cz_pb_mgr.v_prop_vals_prop_ref(j);

               --The table l_exists_on_target_hash records the fact that we called mm_get_ifexists_on_target on this s_prop_id
               --and therefore don't have to do it again. If the property does not exist on the target, the value stored will
               --be null.

               IF(NOT l_exists_on_target_hash.EXISTS(s_prop_id))THEN

                  mm_get_ifexists_on_target(s_prop_id, t_prop_id, 'PROP');
                  l_exists_on_target_hash(s_prop_id) := t_prop_id;

               ELSE
                  t_prop_id := l_exists_on_target_hash(s_prop_id);
               END IF;

               IF(t_prop_id IS NULL)THEN

                  t_prop_id := mm_get_newid('PROP');
                  mm_v_tbl_sync_prop(s_prop_id) := t_prop_id;

                  --Because the property does not exist on the target, we will be creating a new property and so we need both
                  --numeric value and numeric default value. These two values are special because of their use for translatable
                  --properties. All other property attributes are handled in a standard way and don't need any special tables.

                  IF(cz_pb_mgr.v_prop_vals_data_typ_ref(j) = 8)THEN /*Translatable properties*/

--First for the numeric value of the translatable property.

                    t_prop_val_num := mm_get_newid('INTL_TEXT');

--mm_v_tbl_prop_vals_trans_new:contains all inl text(new def num vals) which need to be inserted into cz_localized_texts
--mm_v_tbl_prop_vals_trans_old:contains all old inl text(old def num vals) for which data need to be inserted into cz_localized_texts

                    mm_v_tbl_prop_vals_trans_new(mm_v_tbl_prop_vals_trans_new.count+1) := t_prop_val_num;
                    mm_v_tbl_prop_vals_trans_old(mm_v_tbl_prop_vals_trans_old.count+1) := cz_pb_mgr.v_prop_vals_data_num_ref(j);

                    mm_intl_text_model_id_ref(mm_intl_text_model_id_ref.COUNT + 1) := cz_pb_mgr.h_devl_prj_by_intl_text(cz_pb_mgr.v_prop_vals_data_num_ref(j));

--Same for the default value of the translatable property.

                    new_def_num_val := mm_get_newid('INTL_TEXT');

                    mm_v_tbl_prop_vals_trans_new(mm_v_tbl_prop_vals_trans_new.count+1) := new_def_num_val;
                    mm_v_tbl_prop_vals_trans_old(mm_v_tbl_prop_vals_trans_old.count+1) := v_prop_vals_def_num_value_ref(j);

                    mm_intl_text_model_id_ref(mm_intl_text_model_id_ref.COUNT + 1) := 0;
                  ELSE

                    t_prop_val_num := cz_pb_mgr.v_prop_vals_data_num_ref(j); /*Other properties dont need new intl_text_id*/
                    new_def_num_val := v_prop_vals_def_num_value_ref(j);
                  END IF;

--mm_v_tbl_sync_prop_vals_num: contains all new def num vals which need to be inserted into cz_properties

                  --Making mm_v_tbl_sync_prop_vals_num a hash table. Now it cannot be used directly in the only place where
                  --it is currently used - insert_item_schema. Will need to construct an array with the values from this
                  --hash table.

                  mm_v_tbl_sync_prop_vals_num(t_prop_id) := new_def_num_val;
                  mm_v_ht_sync_all_prop_val_num(j) := t_prop_val_num;

                  --The following two arrays are not used.

                  --mm_v_tbl_sync_prop_type(s_prop_id) := 'PRP';
                  --mm_v_tbl_sync_prop_folder(s_prop_id) := cz_pb_mgr.g_migration_tgt_folder_id;

               ELSE /*get the def num values of properties on target*/

                 --The property exists on the target, so t_prop_id is not null. We should not assign a value here to
                 --mm_v_tbl_sync_prop(s_prop_id) because later this table will be used to resolve id(s) and build an
                 --array of all properties that need to be migrated to the target - in a call to
                 --mm_resolve_ids_w_rp_entries in insert_item_schema procedure. So, here the mm_v_tbl_sync_prop is
                 --supposed to have defined keys only for the properties that need to be created on the target.

                 --mm_v_tbl_sync_prop(s_prop_id) := t_prop_id;

                 --We need to find the value of the property t_prop_id for ps_node_id = cz_pb_mgr.v_prop_vals_node_ref(j).
                 --The ps_node_id value has been already resolved to the new id in upload_item_schema after get_all_properties.
                 --So we need to query for this value, or, if there's no such value, than the ps_node_id will be created and
                 --should inherit the property value.

                 --We do not need the default value, because here we prepare data to be inserted into cz_ps_prop_vals, and
                 --this table does not store default values. What we need is a value in mm_v_ht_sync_all_prop_val_num(j) for
                 --every pair of t_prop_id, v_prop_vals_node_ref(j).

                     IF(cz_pb_mgr.v_prop_vals_data_typ_ref(j) = 8)THEN /*Translatable properties*/

                       t_prop_val_num := mm_get_newid('INTL_TEXT');

                       mm_v_tbl_prop_vals_trans_new(mm_v_tbl_prop_vals_trans_new.count+1) := t_prop_val_num;
                       mm_v_tbl_prop_vals_trans_old(mm_v_tbl_prop_vals_trans_old.count+1) := cz_pb_mgr.v_prop_vals_data_num_ref(j);

                       mm_intl_text_model_id_ref(mm_intl_text_model_id_ref.COUNT + 1) := cz_pb_mgr.h_devl_prj_by_intl_text(cz_pb_mgr.v_prop_vals_data_num_ref(j));

                     ELSE

                       t_prop_val_num := cz_pb_mgr.v_prop_vals_data_num_ref(j);
                     END IF;

                     mm_v_ht_sync_all_prop_val_num(j) := t_prop_val_num;
               END IF;

            s_item_id := v_prop_vals_item_id_ref(j);

            --If s_item_id is not null, than the value is defined on the item, not on the ps node.
            --If the value exists on the source in cz_item_property_values, than the value is defined
            --on the item directly, not through item type.

            IF((s_item_id IS NOT NULL) AND (mm_get_ifexists_on_source(s_prop_id, 'ITPROPVAL') = '1'))THEN

               mm_v_ht_sync_it_propval(s_prop_id) := t_prop_id;

               IF(NOT mm_v_ht_sync_items.EXISTS(s_item_id))THEN

                 mm_get_ifexists_on_target(s_item_id, t_item_id, 'ITEM');

                 IF(t_item_id IS NULL)THEN

                     t_item_id := mm_get_newid('ITEM');
                     mm_v_ht_sync_items(s_item_id) := t_item_id;
                 ELSE

                     mm_v_ht_sync_exist_items(s_item_id) := t_item_id;
                 END IF;
               ELSE

                 t_item_id := mm_v_ht_sync_items(s_item_id);
               END IF;

               mm_v_ht_sync_it_propval_itm(s_item_id) := t_item_id;
            END IF;

            --This block selects from all the properties only those that come from cz_ps_prop_vals, as
            --mm_v_ht_sync_ps_propval is used in mm_migrate_into_ps_prop_vals as one of the criteria
            --whether to insert the value into cz_ps_prop_vals.

            IF(mm_get_ifexists_on_source(s_prop_id, 'PSPROPVAL') = '1')THEN

               mm_v_ht_sync_ps_propval(s_prop_id) := t_prop_id;
--mm_v_ht_sync_all_prop: indexed arrays for all the property ids(new/old) associated with the migration
               mm_v_ht_sync_all_prop(s_prop_id) := t_prop_id;
            END IF;
         END LOOP;
      END IF;

--Now we deal with properties associated with Item Types.

--This is the same algorithm as above, but the sources of property_id and property_num_value are different arrays and
--a different query must be used (against cz_item_property_values) when the property and the item exist on the target.
--For item_id, the second part of the above block must be useful.

      IF(cz_pb_mgr.v_item_prop_type_tbl.COUNT > 0)THEN

--This array contains all property_id(s) of properties that are involved in the migration because of their association
--with item types. If a property is defined directly on a node, it has already been processes and stored in the hash
--table mm_v_tbl_sync_prop, so it won't be processed here.

         FOR j IN cz_pb_mgr.v_item_prop_type_tbl.FIRST .. cz_pb_mgr.v_item_prop_type_tbl.LAST LOOP

            s_prop_id := cz_pb_mgr.v_item_prop_id_tbl(j);

            IF(NOT mm_v_tbl_sync_prop.EXISTS(s_prop_id))THEN

               mm_get_ifexists_on_target(s_prop_id, t_prop_id, 'PROP');

               IF(t_prop_id IS NULL)THEN

                  t_prop_id := mm_get_newid('PROP');
                  mm_v_tbl_sync_prop(s_prop_id) := t_prop_id;

                  --Because the property does not exist on the target, we will be creating a new property and so we need the
                  --default numeric value. Note that we should not populate array mm_v_ht_sync_all_prop_val_num in this block
                  --because it is used for insert into cz_ps_prop_vals. We do need to populate the table
                  --mm_v_tbl_sync_prop_vals_num with default numeric values of all properties that will be inserted on the
                  --target, just like in the previous block.

                  IF(cz_pb_mgr.v_item_prop_data_typ_tbl(j) = 8)THEN /*Tranlatable properties*/

                    new_def_num_val := mm_get_newid('INTL_TEXT');

--mm_v_tbl_prop_vals_trans_new:contains all inl text(new def num vals) which need to be inserted into cz_localized_texts
--mm_v_tbl_prop_vals_trans_old:contains all old inl text(old def num vals) for which data need to be inserted into cz_localized_texts

                    mm_v_tbl_prop_vals_trans_new(mm_v_tbl_prop_vals_trans_new.count+1) := new_def_num_val;
                    mm_v_tbl_prop_vals_trans_old(mm_v_tbl_prop_vals_trans_old.count+1) := cz_pb_mgr.v_item_prop_num_val_tbl(j);

                    --These properties are associated with item types, not ps nodes, therefore we can set 0 for model_id.

                    mm_intl_text_model_id_ref(mm_intl_text_model_id_ref.COUNT + 1) := 0;
                  ELSE /*Other properties dont need new def num ids*/

                    new_def_num_val := cz_pb_mgr.v_item_prop_num_val_tbl(j);
                  END IF;

--mm_v_tbl_sync_prop_vals_num: contains all new def num vals which need to be inserted into cz_properties

                  mm_v_tbl_sync_prop_vals_num(t_prop_id) := new_def_num_val;
               ELSE  /*get the def num values of properties on target*/

                 --The property exists on the target, so t_prop_id is not null. Again, these are properties associated with item types,
                 --so we need only the default numeric value. This query cannot fail with NO_DATA_FOUND.

                 EXECUTE IMMEDIATE 'SELECT def_num_value FROM cz_properties' || cz_pb_mgr.v_db_link ||
                                   ' WHERE property_id = :1 AND deleted_flag = 0'
                    INTO new_def_num_val
                   USING t_prop_id;

                 mm_v_tbl_sync_prop_vals_num(t_prop_id) := new_def_num_val;
               END IF;
            ELSE

              t_prop_id := mm_v_tbl_sync_prop(s_prop_id);
            END IF;

            s_item_type_id := v_item_prop_type_tbl(j);

            IF(NOT mm_v_ht_sync_item_type.EXISTS(s_item_type_id))THEN

               mm_get_ifexists_on_target(s_item_type_id, t_item_type_id, 'ITEM_TYPE');

               IF(t_item_type_id IS NULL)THEN

                  t_item_type_id := mm_get_newid('ITEM_TYPE');
                  mm_v_ht_sync_item_type(s_item_type_id) := t_item_type_id;
               END IF;
            ELSE
               t_item_type_id := mm_v_ht_sync_item_type(s_item_type_id);
            END IF;

            mm_v_ht_sync_itmtype_for_prop(s_item_type_id) := t_item_type_id;
            mm_v_ht_sync_item_type_prop(s_prop_id) := t_prop_id;
--mm_v_ht_sync_all_prop: indexed arrays for all the property ids(new/old) associated with the migration
            mm_v_ht_sync_all_prop(s_prop_id) := t_prop_id;
         END LOOP;
      END IF;
   END mm_sync_properties;
------------------------------------------------------------------------------------------------
   PROCEDURE mm_sync_itemschema
   AS
      s_prop_id NUMBER;
      t_prop_id NUMBER;
      s_item_type_id NUMBER;
      t_item_type_id NUMBER;
      s_item_id NUMBER;
      t_item_id NUMBER;

   BEGIN
      IF (cz_pb_mgr.v_item_masters_tbl.COUNT > 0)
      THEN
         FOR i IN cz_pb_mgr.v_item_masters_tbl.FIRST .. cz_pb_mgr.v_item_masters_tbl.LAST
         LOOP
            s_item_id := cz_pb_mgr.v_item_masters_tbl(i);

            IF (NOT mm_v_ht_sync_items.EXISTS(s_item_id))
            THEN
                mm_get_ifexists_on_target(s_item_id, t_item_id, 'ITEM');
                IF (t_item_id IS NULL)
                THEN
                  t_item_id := mm_get_newid('ITEM');
                  mm_v_ht_sync_items(s_item_id) := t_item_id;
                ELSE
                  mm_v_ht_sync_exist_items(s_item_id) := t_item_id;  --Bug9180063
                END IF;
            ELSE
                t_item_id := mm_v_ht_sync_items(s_item_id);
            END IF;

            s_item_type_id := v_item_types_tbl(i);
            IF (NOT mm_v_ht_sync_item_type.EXISTS(s_item_type_id))
            THEN
               mm_get_ifexists_on_target(s_item_type_id, t_item_type_id, 'ITEM_TYPE');
               IF (t_item_type_id IS NULL)
               THEN
                  t_item_type_id := mm_get_newid('ITEM_TYPE');
                  mm_v_ht_sync_item_type(s_item_type_id) := t_item_type_id;
               END IF;
            ELSE
               t_item_type_id := mm_v_ht_sync_item_type(s_item_type_id);
            END IF;

            IF (NOT mm_v_ht_sync_exist_items.EXISTS(s_item_id))
            THEN
               mm_v_ht_sync_item_type_items(s_item_id) := t_item_type_id;
            ELSE
               mm_v_ht_sync_exist_item_types(s_item_id) := t_item_type_id;
            END IF;

         END LOOP;
      END IF;
   END mm_sync_itemschema;

   FUNCTION mm_get_ifexists_on_source(source_id IN NUMBER, what_exists VARCHAR2)
      RETURN VARCHAR2
   AS
      record_exists VARCHAR2(1) := '0';
   BEGIN
      IF (what_exists = 'PSPROPVAL')
      THEN
         SELECT '1'
           INTO record_exists
           FROM DUAL
          WHERE EXISTS(SELECT property_id
                         FROM cz_ps_prop_vals
                        WHERE property_id = source_id);
      ELSIF(what_exists = 'ITPROPVAL')
      THEN
         SELECT '1'
           INTO record_exists
           FROM DUAL
          WHERE EXISTS(SELECT property_id
                         FROM cz_item_property_values
                        WHERE property_id = source_id);
      END IF;

      RETURN record_exists;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN record_exists;
   END mm_get_ifexists_on_source;

   PROCEDURE mm_get_ifexists_on_target(source_id IN NUMBER, target_id IN OUT NOCOPY NUMBER, what_exists IN VARCHAR2)
   AS
      l_sql_str VARCHAR2(2000);
      l_sync_msg_object_type_tkn VARCHAR2(50);
      l_sync_msg_object_name_tkn VARCHAR2(50);
      cz_property_caption VARCHAR2(50) := 'Property';
      cz_item_caption VARCHAR2(50) := 'Item';
      cz_item_type_caption VARCHAR2(50) := 'Item Type';
      cz_archive_caption VARCHAR2(50) := 'Archive';
      cz_effset_caption VARCHAR2(50) := 'Effectivity Set';
   BEGIN
      IF (what_exists = 'PROP')
      THEN
         l_sql_str :=
            'SELECT t.property_id, t.NAME FROM cz_properties' || cz_pb_mgr.v_db_link || ' t' ||  ',' ||
                                           'cz_rp_entries' || cz_pb_mgr.v_db_link || ' t1' || ',' ||
                                           'cz_properties s' || ' ' ||
            'WHERE t1.object_id = t.property_id AND t1.object_type = ''PRP'' ' || ' ' ||
             'AND t1.DELETED_FLAG = ''0'' '|| ' ' ||
             'AND t.NAME = s.NAME AND t1.NAME = s.NAME' || ' ' ||
             'AND t.data_type = s.data_type' || ' ' ||
             'AND NVL(t.src_application_id,-1) = NVL(s.src_application_id,-1)'  || ' ' ||
             'AND s.property_id = :1';
         l_sync_msg_object_type_tkn := cz_property_caption;
      ELSIF(what_exists = 'ITEM')
      THEN
--- Bug9180063 Joined with cz_item_types to get the uniqueness of item as item
-- with same name can be under two different item types. This is mostly for non-BOM items case.
         l_sql_str :=
            'SELECT t.item_id, t.ref_part_nbr FROM cz_item_masters' || cz_pb_mgr.v_db_link || ' t' || ',' ||
                                                  'cz_item_types' || cz_pb_mgr.v_db_link || ' t1' || ',' ||
                                                  'cz_item_masters s' || ',' ||
                                                  'cz_item_types s1' || ' ' ||
            'WHERE t.ref_part_nbr = s.ref_part_nbr' || ' ' ||
             'AND NVL(t.src_application_id,-1) = NVL(s.src_application_id,-1)' || ' ' ||
             'AND NVL(t1.src_application_id,-1) = NVL(s1.src_application_id,-1)' || ' ' ||
             'AND t1.name = s1.name' || ' ' ||
             'AND s1.item_type_id = s.item_type_id' || ' ' ||
             'AND t1.item_type_id = t.item_type_id' || ' ' ||
             'AND NVL(t.orig_sys_ref, 0) = :1' || ' ' ||
             'AND t.DELETED_FLAG = ''0'' '|| ' ' ||
             'AND t1.DELETED_FLAG = ''0'' '|| ' ' ||
             'AND s.item_id = :2';
         l_sync_msg_object_type_tkn := cz_item_caption;
      ELSIF(what_exists = 'ITEM_TYPE')
      THEN
         l_sql_str :=
            'SELECT t.item_type_id, t.NAME FROM cz_item_types' || cz_pb_mgr.v_db_link || ' t' || ',' ||
                                               'cz_item_types s' || ' ' ||
            'WHERE t.NAME = s.NAME' || ' ' ||
             'AND t.DELETED_FLAG = ''0'' '|| ' ' ||
             'AND NVL(t.src_application_id,-1) = NVL(s.src_application_id,-1)' || ' ' ||
             'AND s.item_type_id = :1';
         l_sync_msg_object_type_tkn := cz_item_type_caption;
      ELSIF(what_exists = 'ARCHIVE')
      THEN
         l_sql_str :=
             'SELECT t.object_id, t.NAME FROM cz_rp_entries' || cz_pb_mgr.v_db_link || ' t' || ',' ||
                                             'cz_archives s' || ' ' ||
              'WHERE t.object_type = ''ARC'' AND t.NAME = s.NAME' || ' ' ||
               'AND t.DELETED_FLAG = ''0'' '|| ' ' ||
               'AND s.archive_id = :1';
         l_sync_msg_object_type_tkn := cz_archive_caption;
      ELSIF(what_exists = 'EFF_SETS')
      THEN
         l_sql_str :=
             'SELECT t.object_id, t.NAME FROM cz_rp_entries' || cz_pb_mgr.v_db_link || 't' || ',' ||
                                             'cz_effectivity_sets s' || ' ' ||
              'WHERE t.object_type = ''EFF'' AND t.NAME = s.NAME' || ' ' ||
               'AND t.DELETED_FLAG = ''0'' '|| ' ' ||
               'AND s.effectivity_set_id = :1';
         l_sync_msg_object_type_tkn := cz_effset_caption;
      END IF;

      IF(what_exists = 'ITEM')THEN

        EXECUTE IMMEDIATE l_sql_str
                     INTO target_id, l_sync_msg_object_name_tkn
                    USING NVL(mm_v_ht_items_orig_ref(source_id), 0)
                        , source_id;

      ELSE

        EXECUTE IMMEDIATE l_sql_str
                     INTO target_id, l_sync_msg_object_name_tkn
                    USING source_id;
      END IF;

      IF (target_id IS NOT NULL)
      THEN
         cz_pb_mgr.v_err_message :=
              cz_utils.get_text('CZ_MM_EXISTING_GLOBAL_DATA', 'GLOBAL_ENTITY', l_sync_msg_object_type_tkn, 'ENTITY_NAME', l_sync_msg_object_name_tkn);
         log_pb_errors(cz_pb_mgr.v_err_message, 0, 'mm_get_ifexists_on_target', -1);
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         target_id := NULL;
      WHEN TOO_MANY_ROWS
      THEN
           --this is an error condition where there are too many rows with the same
           --name, which is not likely to happen
            target_id := -1;

         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.mm_get_ifexists_on_target', SQLCODE);
   END mm_get_ifexists_on_target;

------------------------------------------------------------------------------------------------
   FUNCTION mm_get_newid(what_id IN VARCHAR2)
      RETURN NUMBER
   AS
      returnid NUMBER;
      l_sql_str VARCHAR2(2000);
      l_seq VARCHAR2(32);

   BEGIN
      IF (what_id = 'PROP')
      THEN
         RETURN  cz_pb_mgr.sequence_generate(cz_pb_mgr.CZ_PROPERTIES_SEQ
                                             , 'CZ_PROPERTIES_S.nextval' || cz_pb_mgr.v_db_link
                                             ,cz_pb_mgr.v_oraclesequenceincr
                                             );

      ELSIF(what_id = 'ITEM')
      THEN
         RETURN  cz_pb_mgr.sequence_generate(cz_pb_mgr.CZ_ITEM_MASTERS_SEQ
                                             , 'CZ_ITEM_MASTERS_S.nextval' || cz_pb_mgr.v_db_link
                                             ,cz_pb_mgr.v_oraclesequenceincr
                                             );
      ELSIF(what_id = 'ITEM_TYPE')
      THEN
         RETURN  cz_pb_mgr.sequence_generate(cz_pb_mgr.CZ_ITEM_TYPES_SEQ
                                             , 'CZ_ITEM_TYPES_S.nextval' || cz_pb_mgr.v_db_link
                                             ,cz_pb_mgr.v_oraclesequenceincr
                                             );

      ELSIF(what_id = 'ARCHIVE')
      THEN
         RETURN  cz_pb_mgr.sequence_generate(cz_pb_mgr.CZ_ARCHIVES_SEQ
                                             , 'CZ_ARCHIVES_S.nextval' || cz_pb_mgr.v_db_link
                                             ,cz_pb_mgr.v_oraclesequenceincr
                                             );
      ELSIF(what_id = 'INTL_TEXT')
      THEN
         RETURN  cz_pb_mgr.sequence_generate(cz_pb_mgr.cz_intl_texts_seq
                                             , 'cz_intl_texts_s.nextval' || cz_pb_mgr.v_db_link
                                             ,cz_pb_mgr.v_oraclesequenceincr
                                             );

      END IF;

   END mm_get_newid;

------------------------------------------------------------------------------------------------
-----procedure inserts data into cz_ps_prop_vals
   PROCEDURE mm_migrate_into_ps_prop_vals
   AS
      v_migrate_error NUMBER := 0;
      l_sql_str VARCHAR2(32000);
   BEGIN
      IF ((cz_pb_mgr.v_status_code <> PUBLICATION_ERROR) AND(cz_pb_mgr.v_prop_vals_node_ref.COUNT > 0))
      THEN
         l_sql_str :=
               'BEGIN'
            || ' '
            || 'cz_pb_mgr.v_expr_count := 0;'
            || ' '
            || 'FOR I IN cz_pb_mgr.v_prop_vals_node_ref.FIRST..cz_pb_mgr.v_prop_vals_node_ref.LAST'
            || ' '
            || 'LOOP'
            || ' '
            ||
               ---only if a ps_prop_val needs to be inserted
               'IF ( '
            || 'cz_pb_mgr.mm_v_ht_sync_ps_propval.EXISTS(cz_pb_mgr.v_prop_vals_prop_ref(i))'
            || ' '
            || 'AND ( '
            || ' '
            || 'cz_pb_mgr.v_prop_vals_inherited_flag_ref(i) <> ''1'' '
            || ' '
            || 'OR'
            || ' '
            || 'cz_pb_mgr.v_prop_vals_valuesource_ref(i) = '
            || ''''
            || cz_pb_mgr.prop_valuesource_psvalue
            || ''''
            || ' '
            || ')'
            || ' '
            || ') THEN'
            || ' '
            ||
               -- we always recreate ps nodes, so there is no issue there
               'cz_pb_mgr.v_propval_node_id    := cz_pb_mgr.v_prop_vals_node_ref(i);'
            || ' '
            ||
               -- the key thing here is to ensure that the target property id gets in, they have already been synchronized earlier
               -- in mm_sync_properties
               'cz_pb_mgr.v_propval_prop_id    := cz_pb_mgr.mm_v_ht_sync_ps_propval(cz_pb_mgr.v_prop_vals_prop_ref(i));'
            || ' '
            || 'cz_pb_mgr.v_propval_data_value := cz_pb_mgr.v_prop_vals_data_ref(i);'
            || ' '
            || 'cz_pb_mgr.v_propval_data_num_value := cz_pb_mgr.mm_v_ht_sync_all_prop_val_num(i);'
            || ' '
            || 'INSERT INTO cz_ps_prop_vals'
            || cz_pb_mgr.v_db_link
            || '('
            || ' '
            || 'ps_node_id,PROPERTY_ID,DATA_VALUE,DELETED_FLAG,data_num_value)'
            || ' '
            || 'VALUES (cz_pb_mgr.v_propval_node_id,cz_pb_mgr.v_propval_prop_id,cz_pb_mgr.v_propval_data_value,'
            || ' '
            || ' ''0'',cz_pb_mgr.v_propval_data_num_value);'
            || ' '
            || 'IF ( cz_pb_mgr.v_expr_count > cz_pb_mgr.RECORD_COMMIT_SIZE) THEN'
            || ' '
            || 'COMMIT; cz_pb_mgr.v_expr_count := 0;'
            || ' '
            || 'END IF;'
            || ' '
            || 'cz_pb_mgr.v_expr_count := cz_pb_mgr.v_expr_count + 1;'
            || ' '
            || 'END IF;'
            || ' '
            || 'END LOOP;'
            || ' '
            || 'END;';

         EXECUTE IMMEDIATE l_sql_str;
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_TABLE_POPULATION_ERR', 'TABLENAME', 'cz_ps_prop_vals', 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.LOAD_DATA:cz_ps_prop_vals', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
   END mm_migrate_into_ps_prop_vals;

------------------------------------------------------------------------------------------------
   FUNCTION mm_sync_eff_sets(old_eff_set_id NUMBER, new_eff_set_id NUMBER)
      RETURN NUMBER
   AS
      rec_count PLS_INTEGER := 0;
      s_effset_id NUMBER := NULL;
      t_effset_id NUMBER := NULL;
   BEGIN

      /* don't go to through the link everytime.  if you can get the
         effectivity set through memory, use it.  Only go to the link
         if it is not collected already */

      IF (NOT mm_v_ht_eff_set_tbl_s.EXISTS(old_eff_set_id)) THEN
        mm_get_ifexists_on_target(old_eff_set_id, t_effset_id, 'EFF_SETS');
        IF (t_effset_id IS NOT NULL) THEN
          mm_v_ht_eff_set_tbl_s(old_eff_set_id) := t_effset_id;
        END IF;
      ELSE
         t_effset_id := mm_v_ht_eff_set_tbl_s(old_eff_set_id);
      END IF;


      --we will maintain an array of old versus new effectivity set id
      --when we migrate the rule sequences, if a particular rule in a rule sequence has
      --an effectivity set id that already exists on the target, we will disable the
      --the rule sequence.
      IF (t_effset_id IS NOT NULL)
      THEN
         mm_v_ht_eff_set_tbl_t(t_effset_id) := t_effset_id;
         RETURN t_effset_id;
      END IF;

      RETURN NULL;
   END mm_sync_eff_sets;

------------------------------------------------------------------------------------------------
   PROCEDURE mm_sync_archives
   AS
      rec_count PLS_INTEGER := 0;
      s_archive_id NUMBER;
      t_archive_id NUMBER;
      t_new_archive_id NUMBER;
   BEGIN
/*check if an Archive already exists with the same name,
* if it does, add to the table mm_v_ht_archive_tbl(old)
* else, create a new sequence number and add to mm_v_ht_archive_tbl(old)
*/
      cz_pb_mgr.g_archives_mig_idx_ref.DELETE;
      cz_pb_mgr.mm_v_ht_sync_archives.DELETE;
      cz_pb_mgr.g_archives_obj_type.DELETE;
      cz_pb_mgr.g_enclosing_fld_rp_entry.DELETE;
      cz_pb_mgr.g_archives_old_tbl.DELETE;

    IF (cz_pb_mgr.g_archives_new_ref.COUNT > 0) THEN
     FOR i IN cz_pb_mgr.g_archives_new_ref.FIRST .. cz_pb_mgr.g_archives_new_ref.LAST
      LOOP
         s_archive_id := cz_pb_mgr.g_archives_old_ref(i);
         t_new_archive_id := cz_pb_mgr.g_archives_new_ref(i);

         IF (NOT g_archives_mig_idx_ref.EXISTS(s_archive_id)) THEN
           mm_get_ifexists_on_target(s_archive_id, t_archive_id, 'ARCHIVE');
           IF (t_archive_id IS NULL) THEN
              rec_count := rec_count + 1;
              cz_pb_mgr.mm_v_ht_sync_archives(rec_count) := t_new_archive_id;
              cz_pb_mgr.g_archives_obj_type(rec_count) := 'ARC';
              cz_pb_mgr.g_enclosing_fld_rp_entry(rec_count) := cz_pb_mgr.g_migration_tgt_folder_id;
              cz_pb_mgr.g_archives_mig_idx_ref(s_archive_id) := t_new_archive_id;
              cz_pb_mgr.g_archives_old_tbl(rec_count) := s_archive_id;
           ELSE
              cz_pb_mgr.g_archives_mig_idx_ref(s_archive_id) := t_archive_id;
           END IF;
        END IF;
      END LOOP;
     END IF;
   END mm_sync_archives;

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------
   PROCEDURE mm_insert_archives_for_pb
   IS
      rec_count PLS_INTEGER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
   BEGIN
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'archive_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_archives_new_ref';

      IF (cz_pb_mgr.g_log_timing = publication_timing)
      THEN
         log_timing_message('start insert_into_table cz_archives');
      END IF;

      insert_into_table('cz_archives'
                       ,'archive_id'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.g_archives_old_ref'
                       ,cz_pb_mgr.g_archives_old_ref
                       );
      resolve_ids(cz_pb_mgr.g_devl_proj_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'resolve proj of archives');
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'archive_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_archive_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'devl_project_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_devl_proj_ref';
      insert_into_table('cz_archive_refs'
                       ,'archive_id'
                       ,'devl_project_id'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.g_archive_id_old_ref'
                       ,'cz_pb_mgr.g_devl_proj_old_ref'
                       ,cz_pb_mgr.g_archive_id_old_ref
                       ,cz_pb_mgr.g_devl_proj_old_ref
                       );
   END mm_insert_archives_for_pb;

------------------------------------------------------------------------------------------------
   PROCEDURE mm_insert_archives
   IS
      rec_count PLS_INTEGER := 0;
      plsql_table_list cz_pb_mgr.col_plsql_table_list;
      mm_source_table_list cz_pb_mgr.col_plsql_table_list;
      mm_rec_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.mm_v_ht_sync_archives.COUNT > 0)
      THEN
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'archive_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_v_ht_sync_archives';

         IF (cz_pb_mgr.g_log_timing = publication_timing)
         THEN
            log_timing_message('start insert_into_table cz_archives');
         END IF;

         insert_into_table('cz_archives'
                          ,'archive_id'
                          ,cz_pb_mgr.v_db_link
                          ,plsql_table_list
                          ,'cz_pb_mgr.g_archives_old_tbl'
                          ,cz_pb_mgr.g_archives_old_tbl
                          );
         ----------begin insert into cz_rp_entries----------------
         plsql_table_list.DELETE;
         rec_count := 1;
         plsql_table_list(rec_count).col_name := 'object_id';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.mm_v_ht_sync_archives';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'object_type';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_archives_obj_type';
         rec_count := rec_count + 1;
         plsql_table_list(rec_count).col_name := 'enclosing_folder';
         plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_enclosing_fld_rp_entry';
         insert_into_rp_entries('cz_rp_entries'
                               ,'object_id'
                               ,'object_type'
                               ,cz_pb_mgr.v_db_link
                               ,plsql_table_list
                               ,'cz_pb_mgr.g_archives_old_tbl'
                               ,'cz_pb_mgr.g_archives_obj_type'
                               ,cz_pb_mgr.g_archives_old_tbl
                               ,cz_pb_mgr.g_archives_obj_type
                               );
      ----------end insert into cz_rp_entries----------------
      END IF;

      resolve_ids(cz_pb_mgr.g_archive_id_old_ref,cz_pb_mgr.g_archive_id_ref, cz_pb_mgr.g_archives_mig_idx_ref, 'rsolve archive ids for ref');
      -- Need to use the right array to resolve the devl project ids.
      resolve_ids(cz_pb_mgr.g_devl_proj_ref, cz_pb_mgr.v_cz_ps_nodes_idx_tbl, 'resolve proj of archives');
      plsql_table_list.DELETE;
      rec_count := 1;
      plsql_table_list(rec_count).col_name := 'archive_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_archive_id_ref';
      rec_count := rec_count + 1;
      plsql_table_list(rec_count).col_name := 'devl_project_id';
      plsql_table_list(rec_count).table_name := 'cz_pb_mgr.g_devl_proj_ref';
      insert_into_table('cz_archive_refs'
                       ,'archive_id'
                       ,'devl_project_id'
                       ,cz_pb_mgr.v_db_link
                       ,plsql_table_list
                       ,'cz_pb_mgr.g_archive_id_old_ref'
                       ,'cz_pb_mgr.g_devl_proj_old_ref'
                       ,cz_pb_mgr.g_archive_id_old_ref
                       ,cz_pb_mgr.g_devl_proj_old_ref
                       );
   END mm_insert_archives;

------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
--procedure to debug long strings
--does nothing outside of break the long str into
--smaller strings so it is visible in the debugger
   PROCEDURE mm_break_long_str(v_inp_str IN VARCHAR2)
   AS
      v_temp_str VARCHAR2(255);
   BEGIN
      v_temp_str := SUBSTR(v_inp_str, 1, 250);
      v_temp_str := SUBSTR(v_inp_str, 251, 250);
      v_temp_str := SUBSTR(v_inp_str, 501, 250);
      v_temp_str := SUBSTR(v_inp_str, 751, 250);
      v_temp_str := SUBSTR(v_inp_str, 1001, 250);
      v_temp_str := SUBSTR(v_inp_str, 1251, 250);
      v_temp_str := SUBSTR(v_inp_str, 1501, 250);
      v_temp_str := SUBSTR(v_inp_str, 1751, 250);
      v_temp_str := SUBSTR(v_inp_str, 2001, 250);
      v_temp_str := SUBSTR(v_inp_str, 2251, 250);
      v_temp_str := SUBSTR(v_inp_str, 2501, 250);
      v_temp_str := SUBSTR(v_inp_str, 2751, 250);
      v_temp_str := SUBSTR(v_inp_str, 3001, 250);
      v_temp_str := SUBSTR(v_inp_str, 3251, 250);
      v_temp_str := SUBSTR(v_inp_str, 3501, 250);
      v_temp_str := SUBSTR(v_inp_str, 3751, 250);
      v_temp_str := SUBSTR(v_inp_str, 4001, 250);
   END mm_break_long_str;
------------------------------------------------------------------------------------------------
   PROCEDURE mm_resync_ps_items
   AS
   BEGIN
      FOR i IN 1 .. v_ps_item_id_tbl.COUNT
      LOOP
         IF (mm_v_ht_sync_items.EXISTS(v_ps_item_id_tbl(i)))
         THEN
            mm_v_ps_item_id_tbl(i) := mm_v_ht_sync_items(v_ps_item_id_tbl(i));
         ELSIF(mm_v_ht_sync_exist_items.EXISTS(v_ps_item_id_tbl(i)))
         THEN
            mm_v_ps_item_id_tbl(i) := mm_v_ht_sync_exist_items(v_ps_item_id_tbl(i));
         ELSE
            mm_v_ps_item_id_tbl(i) := v_ps_item_id_tbl(i);
         END IF;
      END LOOP;
   END;

   ------------------------------------------------------------------------------------------------
   PROCEDURE mm_resync_ps_item_types
   AS
   BEGIN
      FOR i IN 1 .. v_ps_item_id_tbl.COUNT
       LOOP
         IF (mm_v_ht_sync_item_type_items.EXISTS(v_ps_item_id_tbl(i)))
         THEN
            mm_v_ps_item_type_id_tbl(i) := mm_v_ht_sync_item_type_items(v_ps_item_id_tbl(i));
         ELSIF(mm_v_ht_sync_exist_item_types.EXISTS(v_ps_item_id_tbl(i)))
         THEN
            mm_v_ps_item_type_id_tbl(i) := mm_v_ht_sync_exist_item_types(v_ps_item_id_tbl(i));
         ELSE
            mm_v_ps_item_type_id_tbl(i) := NULL;
         END IF;
       END LOOP;
   END;
------------------------------------------------------------------------------------------------
   PROCEDURE mm_resolve_ids(
      array_to_resolve IN cz_pb_mgr.t_ref
     ,array_of_new_keys IN cz_pb_mgr.t_ref_idx_vc2
     ,resolving_id IN VARCHAR2
     ,resolved_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,source_array IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   IS
      resolved_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF (array_to_resolve.COUNT > 0)
         THEN
            FOR j IN array_to_resolve.FIRST .. array_to_resolve.LAST
            LOOP
               BEGIN
                  IF (array_to_resolve(j) IS NOT NULL AND TO_CHAR (array_to_resolve(j)) <> '0')  -- Bug9031588
                  THEN
                     resolved_count := resolved_count + 1;
                     resolved_array(resolved_count) := array_of_new_keys(array_to_resolve(j));
                     source_array(resolved_count) := array_to_resolve(j);
                  END IF;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     resolved_count := resolved_count - 1;
               END;
            END LOOP;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_KEY_RES_ERR', 'ResolvingId', resolving_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEIDS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
   END mm_resolve_ids;
------------------------------------------------------------------------------------------------
   PROCEDURE mm_resolve_orig_refs(
      array_to_resolve IN cz_pb_mgr.t_ref
     ,array_of_new_keys IN cz_pb_mgr.orig_sys_ref_type
     ,resolving_id IN VARCHAR2
     ,resolved_array IN OUT NOCOPY cz_pb_mgr.orig_sys_ref_type
     ,source_array IN OUT NOCOPY cz_pb_mgr.orig_sys_ref_type
   )
   IS
      resolved_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF (array_to_resolve.COUNT > 0)
         THEN
            FOR j IN array_to_resolve.FIRST .. array_to_resolve.LAST
            LOOP
               BEGIN
                  IF (array_to_resolve(j) IS NOT NULL AND TO_CHAR (array_to_resolve(j)) <> '0')    -- Bug9031588
                  THEN
                     resolved_count := resolved_count + 1;
                     resolved_array(resolved_count) := array_of_new_keys(array_to_resolve(j));
                     source_array(resolved_count) := array_to_resolve(j);
                  END IF;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     resolved_count := resolved_count - 1;
               END;
            END LOOP;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_KEY_RES_ERR', 'ResolvingId', resolving_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEIDS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
   END mm_resolve_orig_refs;
------------------------------------------------------------------------------------------------
   PROCEDURE mm_resolve_orig_refs(
      array_to_resolve IN cz_pb_mgr.orig_sys_ref_type
     ,array_of_new_keys IN cz_pb_mgr.orig_sys_ref_type_vc2
     ,resolving_id IN VARCHAR2
     ,resolved_array IN OUT NOCOPY cz_pb_mgr.orig_sys_ref_type
     ,source_array IN OUT NOCOPY cz_pb_mgr.orig_sys_ref_type
   )
   IS
      resolved_count NUMBER := 0;
   BEGIN
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF (array_to_resolve.COUNT > 0)
         THEN
            FOR j IN array_to_resolve.FIRST .. array_to_resolve.LAST
            LOOP
               BEGIN
                  IF (array_to_resolve(j) IS NOT NULL)
                  THEN
                     resolved_count := resolved_count + 1;
                     resolved_array(resolved_count) := array_of_new_keys(array_to_resolve(j));
                     source_array(resolved_count) := array_to_resolve(j);
                  END IF;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     resolved_count := resolved_count - 1;
               END;
            END LOOP;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_KEY_RES_ERR', 'ResolvingId', resolving_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEIDS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
   END mm_resolve_orig_refs;
------------------------------------------------------------------------------------------------
   PROCEDURE mm_resolve_ids_w_rp_entries(
      array_to_resolve IN cz_pb_mgr.t_ref
     ,array_of_new_keys IN cz_pb_mgr.t_ref_idx_vc2
     ,object_type IN VARCHAR2
     ,target_folder IN NUMBER
     ,resolving_id IN VARCHAR2
     ,resolved_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,object_type_array IN OUT NOCOPY cz_pb_mgr.varchar_tbl_type_3
     ,tgt_folder_array IN OUT NOCOPY cz_pb_mgr.t_ref
     ,source_array IN OUT NOCOPY cz_pb_mgr.t_ref
   )
   IS
      resolved_count NUMBER := 0;
      resolved_array_idx cz_pb_mgr.t_ref_idx_vc2;

   BEGIN
      resolved_array_idx.DELETE;
      IF (cz_pb_mgr.v_status_code <> PUBLICATION_ERROR)
      THEN
         IF (array_to_resolve.COUNT > 0)
         THEN
            FOR j IN array_to_resolve.FIRST .. array_to_resolve.LAST
            LOOP
               BEGIN
                  IF (array_to_resolve(j) IS NOT NULL)
                  THEN
                     IF NOT (resolved_array_idx.EXISTS(array_to_resolve(j))) THEN
                         resolved_count := resolved_count + 1;
                         resolved_array(resolved_count) := array_of_new_keys(array_to_resolve(j));
                         resolved_array_idx(array_to_resolve(j)) := array_of_new_keys(array_to_resolve(j));
                         object_type_array(resolved_count) := object_type;
                         tgt_folder_array(resolved_count) := target_folder;
                         source_array(resolved_count) := array_to_resolve(j);
                     END IF;
                  END IF;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     resolved_count := resolved_count - 1;
               END;
            END LOOP;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_KEY_RES_ERR', 'ResolvingId', resolving_id, 'SQLERRM', SQLERRM);
         cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEIDS', SQLCODE);
         cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
         cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
   END mm_resolve_ids_w_rp_entries;
------------------------------------------------------------------------------------------------
--if a rule_seq has a rule whose effectivity_set_id already
--exists on the target, then set the rule effectivity to be
--never effective for all the rules in that rule sequence
   PROCEDURE mm_resolve_rule_seq_effsetid
   AS
      b_update_rules BOOLEAN := FALSE;
      new_folder_id NUMBER;
      l_sql_string VARCHAR2(2000);
      remote_effs_cv ref_cursor;
      remote_rule_seq_name_cv ref_cursor;
      l_effecivity_set_id NUMBER;
      l_rule_folder_name cz_rule_folders.NAME%TYPE;
      l_rule_name cz_rules.NAME%TYPE;
   BEGIN
--all the rule sequences have been accumulated here
     IF (mm_v_tbl_rule_seq.COUNT > 0) THEN
      FOR rule_seq IN mm_v_tbl_rule_seq.FIRST .. mm_v_tbl_rule_seq.LAST
      LOOP
         --get the new folder id from the hash table
         new_folder_id := v_cz_folders_id_idx_ref(mm_v_tbl_rule_seq(rule_seq));
         --get all the effectivity_set_ids for the rules in that rule sequence
         l_sql_string :=
               'SELECT effectivity_set_id, name'
            || ' '
            || 'FROM cz_rules'
            || cz_pb_mgr.v_db_link
            || ' '
            || 'WHERE rule_folder_id = :1'
            || ' '
            || '  AND effectivity_set_id is not null'
            || ' '
            || '  AND deleted_flag = ''0'' ';
         b_update_rules := FALSE;

         OPEN remote_effs_cv FOR l_sql_string USING new_folder_id;

         LOOP
            FETCH remote_effs_cv
             INTO l_effecivity_set_id, l_rule_name;

            EXIT WHEN remote_effs_cv%NOTFOUND;

            IF (mm_v_ht_eff_set_tbl_t.EXISTS(l_effecivity_set_id))
            THEN
               b_update_rules := TRUE;
               EXIT;
            END IF;
         END LOOP;

         CLOSE remote_effs_cv;

         --update the rules to be never effective
         IF b_update_rules
         THEN
            --log the event
            l_sql_string :=
                  'SELECT name'
               || ' '
               || 'FROM cz_rule_folders'
               || cz_pb_mgr.v_db_link
               || ' '
               || 'WHERE rule_folder_id = :1'
               || ' '
               || 'AND deleted_flag = ''0'' ';

            OPEN remote_rule_seq_name_cv FOR l_sql_string USING new_folder_id;

            FETCH remote_rule_seq_name_cv
             INTO l_rule_folder_name;

            CLOSE remote_rule_seq_name_cv;

            cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_MM_EFFSET_CORRUPT_RULSEQ', 'RULE_NAME', l_rule_name, 'RULE_SEQUENCE', l_rule_folder_name);
            log_pb_errors(cz_pb_mgr.v_err_message, 0, 'mm_resolve_rule_seq_effsetid', -1);
            l_sql_string :=
                  'UPDATE cz_rules'
               || cz_pb_mgr.v_db_link
               || ' '
               || 'SET effective_from =  :1'
               || ', '
               || '    effective_until = :2'
               || ','
               || '    effectivity_set_id = NULL'
               || ' '
               || 'WHERE rule_folder_id ='
               || new_folder_id
               || ' '
               || '  AND deleted_flag = ''0'' ';

            EXECUTE IMMEDIATE l_sql_string
                        USING cz_utils.epoch_end, cz_utils.epoch_begin;
         END IF;
      END LOOP;
     END IF;
   END mm_resolve_rule_seq_effsetid;
------------------------------------------------------------------------------------------------
/*
* Bug 5516478
* On migrating a model to a remote server, if there are BOM models involved,
* CZ_XFR_PROJECT_BILLS are also migrated.  However, the column SOURCE_SERVER
* in CZ_XFR_PROJECT_BILLS needs to be resolved to the import server on the
* migration target.  Currently it was being copied from the source to the
* target.  In order to do this we need to query CZ_SERVERS in the migration
* target to get the SERVER_LOCAL_ID.
*/
FUNCTION getRemoteImportServer(x_import_server_on_local IN OUT NOCOPY cz_servers.server_local_id%TYPE) RETURN NUMBER
   AS

     l_sql_string        VARCHAR2(2000);
     l_remote_server_id  cz_servers.server_local_id%TYPE;
     l_hostname          cz_servers.hostname%TYPE;
     l_db_listener_port  cz_servers.db_listener_port%TYPE;
     l_instance_name     cz_servers.instance_name%TYPE;

BEGIN

     l_sql_string :=  'SELECT server_local_id, hostname, db_listener_port, instance_name' ||
                      '  FROM cz_servers' || cz_pb_mgr.v_db_link ||
                      ' WHERE import_enabled = 1';

     BEGIN

       EXECUTE IMMEDIATE l_sql_string INTO l_remote_server_id, l_hostname, l_db_listener_port, l_instance_name;

     EXCEPTION
       WHEN OTHERS THEN
         --'Unable to resolve the import source server ID for the migration target.'
          cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_ERR_MIGTGT_IMPORT_SERVER ');
          cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEIDS', SQLCODE);
          cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
          cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
         RAISE;
     END;

     --Now we need to identify a record in the local cz_servers that points to the target's import
     --source server. Per migration design, such record should exist.
     --We are not trying to detect the case when the target's import server is the migration source
     --itself - to do this we need to match the target's server record to the LOCAL record, but we
     --don't consistently populate instance parameters for the LOCAL record.

     l_db_listener_port := UPPER(LTRIM(RTRIM(l_db_listener_port)));
     l_hostname := UPPER(LTRIM(RTRIM(l_hostname)));
     l_instance_name := UPPER(LTRIM(RTRIM(l_instance_name)));

     x_import_server_on_local := NULL;

     IF(l_remote_server_id = 0)THEN

        --If the migration target import source is local, then it is the same as the target server.

        x_import_server_on_local := cz_pb_mgr.v_server_id;
     ELSE

       FOR c_server IN (SELECT server_local_id FROM cz_servers
                         WHERE UPPER(LTRIM(RTRIM(db_listener_port))) = l_db_listener_port
                           AND UPPER(LTRIM(RTRIM(hostname))) = l_hostname
                           AND UPPER(LTRIM(RTRIM(instance_name))) = l_instance_name)LOOP

         --The first matched instance will be used.

         x_import_server_on_local := c_server.server_local_id;
       END LOOP;
     END IF;

     IF(x_import_server_on_local IS NULL)THEN

          --The import source of the migration target instance is not defined as a remote server on the migration source instance.
          --Please create a link to hostname '%HOSTNAME', listener port %LISTENER, instance name '%INSTANCE' by running the
          --Define Remote Server and Enable Remote Server concurrent programs on the migration source instance.

          cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_ERR_MIGTGT_TARGET_SERVER', 'HOSTNAME', l_hostname, 'LISTENER', l_db_listener_port, 'INSTANCE', l_instance_name);
          cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message, 'cz_pb_mgr.RESOLVEIDS', SQLCODE);
          cz_pb_mgr.v_status_code := PUBLICATION_ERROR;
          cz_pb_mgr.v_sql_err_msg := SUBSTR(SQLERRM, 1, 2000);
          RETURN -1;
     END IF;

     RETURN l_remote_server_id;
END;
------------------------------------------------------------------------------------------------
/*
* Bug 5523268
* THis function will check if there are any child models that
* have changed.  At this point, we have considered only
* UI Changes, but there may be a requirement to check
* everything that happens in has_tobe_published.  We
* need to revisit this at a later date.  We call
* this for model migration in get_models_tobe_exported;
*/
FUNCTION has_ui_inany_chld_mdl_changed(rootmodelid IN NUMBER) RETURN boolean IS

v_models_tbl cz_pb_mgr.t_ref;
v_last_update_date cz_ui_defs.last_update_date%TYPE;
v_last_xfr_activity cz_pb_model_exports.last_xfr_activity%TYPE;
curr_model_tbl cz_pb_mgr.t_ref;

BEGIN
  get_source_models(rootmodelid,   v_models_tbl);

  /* do this only for child models
    * We iterate through the children and check if the UI has changed
    * for anything.  For model migration, the root will
    * ALWAYS be migrated.
    */
  FOR i IN v_models_tbl.FIRST .. v_models_tbl.LAST
  LOOP
    curr_model_tbl(0) := v_models_tbl(i);

    IF(v_models_tbl(i) <> rootmodelid) THEN

      v_last_xfr_activity := get_mdl_last_xfr_activity(v_models_tbl(i),   cz_pb_mgr.v_server_id);
      IF cz_pb_mgr.v_server_id<>0 THEN
        get_source_uis(rootmodelid, curr_model_tbl, cz_pb_mgr.v_cz_ui_defs_old_ref);
      END IF;
      get_oa_uis(curr_model_tbl,   cz_pb_mgr.v_cz_ui_defs_old_ref,   cz_pb_mgr.v_cz_ui_defs_old_oa_ref);

      IF(cz_pb_mgr.v_cz_ui_defs_old_ref.COUNT > 0) THEN
        FOR j IN cz_pb_mgr.v_cz_ui_defs_old_ref.FIRST .. cz_pb_mgr.v_cz_ui_defs_old_ref.LAST
        LOOP
          get_max_ui_date(cz_pb_mgr.v_cz_ui_defs_old_ref(j),   v_last_update_date);

          IF(v_last_xfr_activity IS NULL) THEN
            RETURN TRUE;
            ELSIF((v_last_xfr_activity IS NOT NULL)
             AND(v_last_update_date > v_last_xfr_activity)) THEN
              RETURN TRUE;
            END IF;

          END LOOP;
        END IF;

      END IF;

    END LOOP;

    RETURN FALSE;

  EXCEPTION
  WHEN others THEN
    cz_pb_mgr.v_err_message := cz_utils.get_text('CZ_PB_MODEL_TO_PUBLISH_ERR',   'SQLERRM',   sqlerrm);
    cz_pb_mgr.error_msg_populate(cz_pb_mgr.v_err_message,   'cz_pb_mgr.HAS_TOBE_PUBLISHED',   SQLCODE);
    cz_pb_mgr.v_err_message := LTRIM(RTRIM(SUBSTR(cz_pb_mgr.v_err_message,   1,   2000)));
    RAISE;
  END has_ui_inany_chld_mdl_changed;
------------------------------------------------------------------------------------------------
/* Bug 5523268
* this routine will check for the last transfer activity.
* There is already a routine 'get_last_xfr_activity', but
* it does check the transfer activity of the ROOT MODEL and
* NOT the current child model.  So we need to check if the
* CHILD was transfered before during migration.
*/
  FUNCTION get_mdl_last_xfr_activity(
      p_model_id IN cz_model_publications.model_id%TYPE
     ,p_server_id IN cz_model_publications.server_id%TYPE

   ) RETURN DATE
   AS
   x_last_xfr_activity DATE := NULL;
   BEGIN

         SELECT last_xfr_activity
           INTO x_last_xfr_activity
           FROM cz_pb_model_exports
          WHERE cz_pb_model_exports.export_id =
                   (SELECT MAX(export_id)
                      FROM cz_pb_model_exports z
                     WHERE z.model_id = p_model_id
                       AND z.server_id = p_server_id
                       AND z.status = 'OK'
                       AND z.publication_id IN(
                              SELECT publication_id
                                FROM cz_model_publications
                               WHERE export_status IN('OK', 'PUP')
                                 AND server_id = p_server_id
                                 AND UPPER(publication_mode) = cz_model_migration_pvt.mode_migration));
				 --SPUPPALA bug#7116052 7-AUG-2009
         RETURN x_last_xfr_activity;


 EXCEPTION
      WHEN OTHERS
      THEN

         RETURN x_last_xfr_activity;
 END get_mdl_last_xfr_activity;
------------------------------------------------------------------------------------------------
BEGIN
   get_seq_incrementor(cz_pb_mgr.v_oraclesequenceincr);
END cz_pb_mgr;

/
