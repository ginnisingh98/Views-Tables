--------------------------------------------------------
--  DDL for Package Body FUN_XLA_TAB_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "APPS"."FUN_XLA_TAB_PKG" AS
/* $Header: funxlatabb.pls 120.1.12010000.3 2009/07/02 13:04:50 abhaktha ship $   */
/*======================================================================+
|                Copyright (c) 2004 Oracle Corporation                  |
|                       Redwood Shores, CA, USA                         |
|                         All rights reserved.                          |
+=======================================================================+
| PACKAGE NAME                                                          |
|     FUN_XLA_TAB_PKG                                                   |
|                                                                       |
| DESCRIPTION                                                           |
|                                                                       |
|     Transaction Account Builder API.                                  |
|                                                                       |
|     Package generated by Oracle Subledger Accounting for              |
|                                                                       |
|     Financials Common Modules                                         |
|     (application_id: 435)                                             |
|                                                                       |
|     ATTENTION:                                                        |
|     This package has been automatically generated by the              |
|     Oracle Subledger Accounting Compiler. You should not modify its   |
|     content manually.                                                 |
|     This package has been generated according to the Transaction      |
|     Account Types setup for this application.                         |
|     In case of issues independent of the setup (e.g. GSCC errors)     |
|     please log a bug against Oracle Subledger Accounting.             |
|                                                                       |
|                                                                       |
| HISTORY                                                               |
|     02-JUL-09 XLA Generated by Oracle Subledger Accounting Compiler   |
|                                                                       |
+=======================================================================*/
--Private exceptions
   le_fatal_error  EXCEPTION;
--Private constants
   C_API_VERSION          CONSTANT NUMBER(1)    := 1;
   C_PACKAGE_NAME         CONSTANT VARCHAR2(30) := 'FUN_XLA_TAB_PKG';


--=============================================================================
--               *********** Local Trace Routine **********
--=============================================================================
C_LEVEL_STATEMENT     CONSTANT NUMBER := FND_LOG.LEVEL_STATEMENT;
C_LEVEL_PROCEDURE     CONSTANT NUMBER := FND_LOG.LEVEL_PROCEDURE;
C_LEVEL_EVENT         CONSTANT NUMBER := FND_LOG.LEVEL_EVENT;
C_LEVEL_EXCEPTION     CONSTANT NUMBER := FND_LOG.LEVEL_EXCEPTION;
C_LEVEL_ERROR         CONSTANT NUMBER := FND_LOG.LEVEL_ERROR;
C_LEVEL_UNEXPECTED    CONSTANT NUMBER := FND_LOG.LEVEL_UNEXPECTED;

C_LEVEL_LOG_DISABLED  CONSTANT NUMBER := 99;
C_DEFAULT_MODULE      CONSTANT VARCHAR2(240) := 'fun.plsql.fun_xla_tab_pkg';

g_log_level           NUMBER;
g_log_enabled         BOOLEAN;

PROCEDURE trace
       ( p_module                     IN VARCHAR2 DEFAULT C_DEFAULT_MODULE
        ,p_msg                        IN VARCHAR2
        ,p_level                      IN NUMBER
        )
IS
BEGIN
   IF (p_msg IS NULL AND p_level >= g_log_level) THEN
      fnd_log.message(p_level, p_module);
   ELSIF p_level >= g_log_level THEN
      fnd_log.string(p_level, p_module, p_msg);
   END IF;

EXCEPTION
WHEN app_exceptions.application_exception THEN
   RAISE;
WHEN OTHERS THEN
   fnd_message.set_name('XLA', 'XLA_TAB_UNHANDLED_EXCEPTION');
   fnd_message.set_token( 'PROCEDURE'
                         ,'fun_xla_tab_pkg.trace');
   RAISE;
END trace;

--Private procedure
   PROCEDURE reset_online_interface
   IS
      l_log_module           VARCHAR2 (2000);
   BEGIN
      IF g_log_enabled THEN
         l_log_module := C_DEFAULT_MODULE||'.reset_online_interface';
      END IF;

      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'BEGIN ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

      --Remove all the elements from the PLSQL tables
      g_array_xla_tab.DELETE;


      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           (p_msg      => 'END ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

   EXCEPTION
   WHEN OTHERS THEN
      RAISE;
   END reset_online_interface;



--Public procedures
   PROCEDURE run
   (
     p_api_version                      IN NUMBER
    ,p_account_definition_type_code     IN VARCHAR2
    ,p_account_definition_code          IN VARCHAR2
    ,p_transaction_coa_id               IN NUMBER
    ,p_mode                             IN VARCHAR2
    ,x_return_status                    OUT NOCOPY VARCHAR2
    ,x_msg_count                        OUT NOCOPY NUMBER
    ,x_msg_data                         OUT NOCOPY VARCHAR2
   )
   IS
      l_return_status     VARCHAR2(1);
      l_return_msg_name   VARCHAR2(30);
      l_msg_count         NUMBER;
      l_msg_data          VARCHAR2(2000);
      l_log_module           VARCHAR2 (2000);
   BEGIN
      IF g_log_enabled THEN
         l_log_module := C_DEFAULT_MODULE||'.run';
      END IF;

      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'BEGIN ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

      --Initialize the global message table
      FND_MSG_PUB.Initialize;

      xla_tab_pub_pkg.run
         (
           p_api_version                  => p_api_version
          ,p_application_id               => 435
          ,p_account_definition_type_code => p_account_definition_type_code
          ,p_account_definition_code      => p_account_definition_code
          ,p_transaction_coa_id           => p_transaction_coa_id
          ,p_mode                         => p_mode
          ,x_return_status                => l_return_status
          ,x_msg_count                    => l_msg_count
          ,x_msg_data                     => l_msg_data
         );

      IF l_return_status <> C_RET_STS_SUCCESS
      THEN
         --Push the error message again so that it does not get lost
         IF l_msg_data IS NOT NULL
         THEN
            fnd_msg_pub.initialize;

            fnd_message.set_encoded
            (
              encoded_message => l_msg_data
            );

            --Add it to the message table
            fnd_msg_pub.add;

            --Reset single message variables
            l_msg_count := NULL;
            l_msg_data  := NULL;
         END IF;
         RAISE le_fatal_error;
      END IF;

      --Assign out parameters
      x_msg_count     := NVL(l_msg_count, 0);
      x_msg_data      := l_msg_data;
      x_return_status := C_RET_STS_SUCCESS;

      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'END ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

   EXCEPTION
   WHEN le_fatal_error THEN
      --Remove all the elements from the PLSQL table
      reset_online_interface;
      --If there is a no token message to log
      --Set the failure message on the stack
      fnd_message.set_name
            (
              application => 'XLA'
             ,name        => 'XLA_TAB_RUN_FAILED'
         );
      fnd_message.set_token( 'FUNCTION_NAME'
                            ,'fun_xla_tab_pkg.run');

      --Add it to the message table
      fnd_msg_pub.add;

      --If there is only one message retrieve it
      fnd_msg_pub.Count_And_Get
         (
           p_count => l_msg_count
          ,p_data  => l_msg_data
         );
      --Put the message on the stack to ensure old Forms detect the error
      fnd_message.set_encoded
         (
           encoded_message => l_msg_data
         );
      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;
      IF l_return_status IS NOT NULL
      THEN
         x_return_status := l_return_status;
      ELSE
         x_return_status := C_RET_STS_UNEXP_ERROR;
      END IF;
   WHEN OTHERS THEN
      --Remove all the elements from the PLSQL table
      reset_online_interface;
      --Add the standard unexpected error message
      fnd_msg_pub.Add_Exc_Msg
         ( p_pkg_name       => C_PACKAGE_NAME
          ,p_procedure_name => 'run'
         );
      --If there is only one message retrieve it
      fnd_msg_pub.Count_And_Get
         (
           p_count => l_msg_count
          ,p_data  => l_msg_data
         );
      --Put the message on the stack to ensure all Forms detect the error
      fnd_message.set_encoded
         (
           encoded_message => l_msg_data
         );
      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;
      x_return_status := C_RET_STS_UNEXP_ERROR;
   END run;


   PROCEDURE reset_online_interface
    (
      p_api_version                      IN  NUMBER
     ,x_return_status                    OUT NOCOPY VARCHAR2
     ,x_msg_count                        OUT NOCOPY NUMBER
     ,x_msg_data                         OUT NOCOPY VARCHAR2
    )
   IS
      l_return_status         VARCHAR2(1);
      l_return_msg_name       VARCHAR2(30);

      l_msg_count             NUMBER;
      l_msg_data              VARCHAR2(2000);

      l_log_module           VARCHAR2 (2000);

   BEGIN
      IF g_log_enabled THEN
         l_log_module := C_DEFAULT_MODULE||'.reset_online_interface';
      END IF;

      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'BEGIN ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

      --Initialize the global message table
      FND_MSG_PUB.Initialize;

      --Initialize return status and message local variables
      l_return_msg_name:= NULL;
      l_return_status  := NULL;

      IF NOT FND_API.Compatible_API_Call
         (
           p_current_version_number => C_API_VERSION
          ,p_caller_version_number  => p_api_version
          ,p_api_name               => 'reset_online_interface'
          ,p_pkg_name               => C_PACKAGE_NAME
         )
      THEN
         RAISE FND_API.G_EXC_UNEXPECTED_ERROR;
      END IF;

      --Remove all the elements from the PLSQL tables
      reset_online_interface;

      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;

      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'END ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

   EXCEPTION
   WHEN le_fatal_error THEN
      --If there is a no token message to log
      IF l_return_msg_name IS NOT NULL
      THEN
         --Set it on the stack
         fnd_message.set_name
            (
              application => 'XLA'
             ,name        => l_return_msg_name
         );
         --Add it to the message table
         fnd_msg_pub.add;
      END IF;
      --If there is only one message retrieve it
      fnd_msg_pub.Count_And_Get
         (
           p_count => l_msg_count
          ,p_data  => l_msg_data
         );
      --Put the message on the stack to ensure old Forms detect the error
      fnd_message.set_encoded
         (
           encoded_message => l_msg_data
         );
      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;
      IF l_return_status IS NOT NULL
      THEN
         x_return_status := l_return_status;
      ELSE
         x_return_status := C_RET_STS_UNEXP_ERROR;
      END IF;
   WHEN OTHERS THEN
      --Add the standard unexpected error message
      fnd_msg_pub.Add_Exc_Msg
         ( p_pkg_name       => C_PACKAGE_NAME
          ,p_procedure_name => 'reset_online_interface'
         );
      --If there is only one message retrieve it
      fnd_msg_pub.Count_And_Get
         (
           p_count => l_msg_count
          ,p_data  => l_msg_data
         );
      --Put the message on the stack to ensure all Forms detect the error
      fnd_message.set_encoded
         (
           encoded_message => l_msg_data
         );
      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;
      x_return_status := C_RET_STS_UNEXP_ERROR;
   END reset_online_interface;


   PROCEDURE write_online_tab
   (
     p_api_version                      IN NUMBER           --INPUT NOT NULL
    ,p_source_distrib_id_num_1          IN NUMBER           --INPUT
    ,p_source_distrib_id_num_2          IN NUMBER           --INPUT
    ,p_source_distrib_id_num_3          IN NUMBER           --INPUT
    ,p_source_distrib_id_num_4          IN NUMBER           --INPUT
    ,p_source_distrib_id_num_5          IN NUMBER           --INPUT
    ,p_account_type_code                IN VARCHAR2         --INPUT NOT NULL
    --START of source list
    ,ftb_attribute1                     IN VARCHAR2                  --INPUT
    ,ftb_attribute10                    IN VARCHAR2                  --INPUT
    ,ftb_attribute11                    IN VARCHAR2                  --INPUT
    ,ftb_attribute12                    IN VARCHAR2                  --INPUT
    ,ftb_attribute13                    IN VARCHAR2                  --INPUT
    ,ftb_attribute14                    IN VARCHAR2                  --INPUT
    ,ftb_attribute15                    IN VARCHAR2                  --INPUT
    ,ftb_attribute2                     IN VARCHAR2                  --INPUT
    ,ftb_attribute3                     IN VARCHAR2                  --INPUT
    ,ftb_attribute4                     IN VARCHAR2                  --INPUT
    ,ftb_attribute5                     IN VARCHAR2                  --INPUT
    ,ftb_attribute6                     IN VARCHAR2                  --INPUT
    ,ftb_attribute7                     IN VARCHAR2                  --INPUT
    ,ftb_attribute8                     IN VARCHAR2                  --INPUT
    ,ftb_attribute9                     IN VARCHAR2                  --INPUT
    ,ftb_category_code                  IN VARCHAR2                  --INPUT
    ,ftb_currency_code                  IN VARCHAR2                  --INPUT
    ,ftb_from_ledger_id                 IN NUMBER                    --INPUT
    ,ftb_from_le_id                     IN NUMBER                    --INPUT
    ,ftb_initiator_bsv                  IN VARCHAR2                  --INPUT
    ,ftb_initiator_id                   IN NUMBER                    --INPUT
    ,fth_attribute1                     IN VARCHAR2                  --INPUT
    ,fth_attribute10                    IN VARCHAR2                  --INPUT
    ,fth_attribute11                    IN VARCHAR2                  --INPUT
    ,fth_attribute12                    IN VARCHAR2                  --INPUT
    ,fth_attribute13                    IN VARCHAR2                  --INPUT
    ,fth_attribute14                    IN VARCHAR2                  --INPUT
    ,fth_attribute15                    IN VARCHAR2                  --INPUT
    ,fth_attribute2                     IN VARCHAR2                  --INPUT
    ,fth_attribute3                     IN VARCHAR2                  --INPUT
    ,fth_attribute4                     IN VARCHAR2                  --INPUT
    ,fth_attribute5                     IN VARCHAR2                  --INPUT
    ,fth_attribute6                     IN VARCHAR2                  --INPUT
    ,fth_attribute7                     IN VARCHAR2                  --INPUT
    ,fth_attribute8                     IN VARCHAR2                  --INPUT
    ,fth_attribute9                     IN VARCHAR2                  --INPUT
    ,fth_attribute_category             IN VARCHAR2                  --INPUT
    ,fth_recipient_bsv                  IN VARCHAR2                  --INPUT
    ,fth_recipient_id                   IN NUMBER                    --INPUT
    ,fth_to_ledger_id                   IN NUMBER                    --INPUT
    ,fth_to_le_id                       IN NUMBER                    --INPUT
    ,ftt_allow_interest_accr_flag       IN VARCHAR2                  --INPUT
    ,ftt_allow_invoicing_flag           IN VARCHAR2                  --INPUT
    ,ftt_attribute1                     IN VARCHAR2                  --INPUT
    ,ftt_attribute10                    IN VARCHAR2                  --INPUT
    ,ftt_attribute11                    IN VARCHAR2                  --INPUT
    ,ftt_attribute12                    IN VARCHAR2                  --INPUT
    ,ftt_attribute13                    IN VARCHAR2                  --INPUT
    ,ftt_attribute14                    IN VARCHAR2                  --INPUT
    ,ftt_attribute15                    IN VARCHAR2                  --INPUT
    ,ftt_attribute2                     IN VARCHAR2                  --INPUT
    ,ftt_attribute3                     IN VARCHAR2                  --INPUT
    ,ftt_attribute4                     IN VARCHAR2                  --INPUT
    ,ftt_attribute5                     IN VARCHAR2                  --INPUT
    ,ftt_attribute6                     IN VARCHAR2                  --INPUT
    ,ftt_attribute7                     IN VARCHAR2                  --INPUT
    ,ftt_attribute8                     IN VARCHAR2                  --INPUT
    ,ftt_attribute9                     IN VARCHAR2                  --INPUT
    ,ftt_attribute_category             IN VARCHAR2                  --INPUT
    ,ftt_manual_approve_flag            IN VARCHAR2                  --INPUT
    ,ftt_trx_type_id                    IN NUMBER                    --INPUT
    ,ftt_vat_taxable_flag               IN VARCHAR2                  --INPUT
    --END of source list
    ,x_return_status                    OUT NOCOPY VARCHAR2 --OUTPUT
    ,x_msg_count                        OUT NOCOPY NUMBER   --OUTPUT
    ,x_msg_data                         OUT NOCOPY VARCHAR2 --OUTPUT
   )
   IS
      l_return_status     VARCHAR2(1);
      l_return_msg_name   VARCHAR2(30);
      l_msg_count         NUMBER;
      l_msg_data          VARCHAR2(2000);
      l_watermark         NUMBER;
      l_start          	  NUMBER;
      l_new_idx           NUMBER;

      l_log_module           VARCHAR2 (2000);
   BEGIN
      IF g_log_enabled THEN
         l_log_module := C_DEFAULT_MODULE||'write_online_tab ';
      END IF;

      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'BEGIN ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

      --Initialize the global message table
      FND_MSG_PUB.Initialize;

      --Initialize return status and message local variables
      l_return_msg_name  := NULL;
      l_return_status    := NULL;

      IF NOT FND_API.Compatible_API_Call
         (
           p_current_version_number => C_API_VERSION
          ,p_caller_version_number  => p_api_version
          ,p_api_name               => 'write_online_tab '
          ,p_pkg_name               => C_PACKAGE_NAME
         )
      THEN
         RAISE FND_API.G_EXC_UNEXPECTED_ERROR;
      END IF;

      --p_account_type_code cannot be NULL
      IF p_account_type_code IS NULL
      THEN
         --Assign an error message and a return code of FAILURE
         l_return_msg_name  := 'XLA_TAB_WR_ROW_ACCT_TYPE_NULL';
         RAISE le_fatal_error;
      END IF;

      --Get the highest index of the PL/SQL table
      --Cannot use COUNT since some elements might have been
      --collected and deleted
      l_watermark := NVL(g_array_xla_tab .LAST, 1);
      l_start     := NVL(g_array_xla_tab .FIRST, 1);

      --Loop on all the rows of the PL/SQL table
      FOR i IN l_start..l_watermark
      LOOP
         --If the current row has the same key of the new row
         IF  g_array_xla_tab .EXISTS(i)
         AND (   g_array_xla_tab (i).source_distribution_id_num_1 = p_source_distrib_id_num_1
              OR g_array_xla_tab (i).source_distribution_id_num_1 IS NULL AND p_source_distrib_id_num_1 IS NULL
             )
         AND (   g_array_xla_tab (i).source_distribution_id_num_2 = p_source_distrib_id_num_2
              OR g_array_xla_tab (i).source_distribution_id_num_2 IS NULL AND p_source_distrib_id_num_2 IS NULL
             )
         AND (   g_array_xla_tab (i).source_distribution_id_num_3 = p_source_distrib_id_num_3
              OR g_array_xla_tab (i).source_distribution_id_num_3 IS NULL AND p_source_distrib_id_num_3 IS NULL
             )
         AND (   g_array_xla_tab (i).source_distribution_id_num_4 = p_source_distrib_id_num_4
              OR g_array_xla_tab (i).source_distribution_id_num_4 IS NULL AND p_source_distrib_id_num_4 IS NULL
             )
         AND (   g_array_xla_tab (i).source_distribution_id_num_5 = p_source_distrib_id_num_5
              OR g_array_xla_tab (i).source_distribution_id_num_5 IS NULL AND p_source_distrib_id_num_5 IS NULL
             )
         AND g_array_xla_tab (i).account_type_code            = p_account_type_code
         THEN
            --Assign a return code of FAILURE
            l_return_status    := C_RET_STS_UNEXP_ERROR;
            --Set the TAB message onto the message stack
            FND_MESSAGE.SET_NAME
            (
              application => 'XLA'
             ,name        => 'XLA_TAB_WR_ROW_DUPLICATE'
            );

            --Replace the token for the flex message retrieved above
            FND_MESSAGE.SET_TOKEN
            (
              token => 'TRX_ACCT_TYPE_CODE'
             ,value => g_array_xla_tab (i).account_type_code
            );
            --Replace the token for the flex message retrieved above
            FND_MESSAGE.SET_TOKEN
            (
              token => 'SOURCE_DIST_ID_NUM1'
             ,value => g_array_xla_tab (i).source_distribution_id_num_1
            );
            --Replace the token for the flex message retrieved above
            FND_MESSAGE.SET_TOKEN
            (
              token => 'SOURCE_DIST_ID_NUM2'
             ,value => g_array_xla_tab (i).source_distribution_id_num_2
            );
            --Replace the token for the flex message retrieved above
            FND_MESSAGE.SET_TOKEN
            (
              token => 'SOURCE_DIST_ID_NUM3'
             ,value => g_array_xla_tab (i).source_distribution_id_num_3
            );
            --Replace the token for the flex message retrieved above
            FND_MESSAGE.SET_TOKEN
            (
              token => 'SOURCE_DIST_ID_NUM4'
             ,value => g_array_xla_tab (i).source_distribution_id_num_4
            );
            --Replace the token for the flex message retrieved above
            FND_MESSAGE.SET_TOKEN
            (
              token => 'SOURCE_DIST_ID_NUM5'
             ,value => g_array_xla_tab (i).source_distribution_id_num_5
            );

            fnd_msg_pub.add;

            --Raise a local exception
            RAISE le_fatal_error;
         --Elsif the current row has already been processed
         ELSIF g_array_xla_tab .EXISTS(i)
           AND g_array_xla_tab (i).target_ccid   IS NOT NULL
           AND g_array_xla_tab (i).msg_data IS NOT NULL
         THEN
            --It means the caller has previously uploaded the interface and run
            --the processing but has not collected all the results.
            --Assign an error message and a return code of FAILURE
            l_return_msg_name  := 'XLA_TAB_WR_ROW_PROCESSED';
            l_return_status    := C_RET_STS_UNEXP_ERROR;
            --Raise a local exception
            RAISE le_fatal_error;
         END IF;
      END LOOP;

      --Get the index of the new row
      l_new_idx := g_array_xla_tab .COUNT + 1;
      --Assign the values to the new row
      g_array_xla_tab (l_new_idx).source_distribution_id_num_1   := p_source_distrib_id_num_1;
      g_array_xla_tab (l_new_idx).source_distribution_id_num_2   := p_source_distrib_id_num_2;
      g_array_xla_tab (l_new_idx).source_distribution_id_num_3   := p_source_distrib_id_num_3;
      g_array_xla_tab (l_new_idx).source_distribution_id_num_4   := p_source_distrib_id_num_4;
      g_array_xla_tab (l_new_idx).source_distribution_id_num_5   := p_source_distrib_id_num_5;
      g_array_xla_tab (l_new_idx).account_type_code              := p_account_type_code;
    --START of source list
      g_array_xla_tab (l_new_idx).ftb_attribute1                 := ftb_attribute1;
      g_array_xla_tab (l_new_idx).ftb_attribute10                := ftb_attribute10;
      g_array_xla_tab (l_new_idx).ftb_attribute11                := ftb_attribute11;
      g_array_xla_tab (l_new_idx).ftb_attribute12                := ftb_attribute12;
      g_array_xla_tab (l_new_idx).ftb_attribute13                := ftb_attribute13;
      g_array_xla_tab (l_new_idx).ftb_attribute14                := ftb_attribute14;
      g_array_xla_tab (l_new_idx).ftb_attribute15                := ftb_attribute15;
      g_array_xla_tab (l_new_idx).ftb_attribute2                 := ftb_attribute2;
      g_array_xla_tab (l_new_idx).ftb_attribute3                 := ftb_attribute3;
      g_array_xla_tab (l_new_idx).ftb_attribute4                 := ftb_attribute4;
      g_array_xla_tab (l_new_idx).ftb_attribute5                 := ftb_attribute5;
      g_array_xla_tab (l_new_idx).ftb_attribute6                 := ftb_attribute6;
      g_array_xla_tab (l_new_idx).ftb_attribute7                 := ftb_attribute7;
      g_array_xla_tab (l_new_idx).ftb_attribute8                 := ftb_attribute8;
      g_array_xla_tab (l_new_idx).ftb_attribute9                 := ftb_attribute9;
      g_array_xla_tab (l_new_idx).ftb_category_code              := ftb_category_code;
      g_array_xla_tab (l_new_idx).ftb_currency_code              := ftb_currency_code;
      g_array_xla_tab (l_new_idx).ftb_from_ledger_id             := ftb_from_ledger_id;
      g_array_xla_tab (l_new_idx).ftb_from_le_id                 := ftb_from_le_id;
      g_array_xla_tab (l_new_idx).ftb_initiator_bsv              := ftb_initiator_bsv;
      g_array_xla_tab (l_new_idx).ftb_initiator_id               := ftb_initiator_id;
      g_array_xla_tab (l_new_idx).fth_attribute1                 := fth_attribute1;
      g_array_xla_tab (l_new_idx).fth_attribute10                := fth_attribute10;
      g_array_xla_tab (l_new_idx).fth_attribute11                := fth_attribute11;
      g_array_xla_tab (l_new_idx).fth_attribute12                := fth_attribute12;
      g_array_xla_tab (l_new_idx).fth_attribute13                := fth_attribute13;
      g_array_xla_tab (l_new_idx).fth_attribute14                := fth_attribute14;
      g_array_xla_tab (l_new_idx).fth_attribute15                := fth_attribute15;
      g_array_xla_tab (l_new_idx).fth_attribute2                 := fth_attribute2;
      g_array_xla_tab (l_new_idx).fth_attribute3                 := fth_attribute3;
      g_array_xla_tab (l_new_idx).fth_attribute4                 := fth_attribute4;
      g_array_xla_tab (l_new_idx).fth_attribute5                 := fth_attribute5;
      g_array_xla_tab (l_new_idx).fth_attribute6                 := fth_attribute6;
      g_array_xla_tab (l_new_idx).fth_attribute7                 := fth_attribute7;
      g_array_xla_tab (l_new_idx).fth_attribute8                 := fth_attribute8;
      g_array_xla_tab (l_new_idx).fth_attribute9                 := fth_attribute9;
      g_array_xla_tab (l_new_idx).fth_attribute_category         := fth_attribute_category;
      g_array_xla_tab (l_new_idx).fth_recipient_bsv              := fth_recipient_bsv;
      g_array_xla_tab (l_new_idx).fth_recipient_id               := fth_recipient_id;
      g_array_xla_tab (l_new_idx).fth_to_ledger_id               := fth_to_ledger_id;
      g_array_xla_tab (l_new_idx).fth_to_le_id                   := fth_to_le_id;
      g_array_xla_tab (l_new_idx).ftt_allow_interest_accr_flag   := ftt_allow_interest_accr_flag;
      g_array_xla_tab (l_new_idx).ftt_allow_invoicing_flag       := ftt_allow_invoicing_flag;
      g_array_xla_tab (l_new_idx).ftt_attribute1                 := ftt_attribute1;
      g_array_xla_tab (l_new_idx).ftt_attribute10                := ftt_attribute10;
      g_array_xla_tab (l_new_idx).ftt_attribute11                := ftt_attribute11;
      g_array_xla_tab (l_new_idx).ftt_attribute12                := ftt_attribute12;
      g_array_xla_tab (l_new_idx).ftt_attribute13                := ftt_attribute13;
      g_array_xla_tab (l_new_idx).ftt_attribute14                := ftt_attribute14;
      g_array_xla_tab (l_new_idx).ftt_attribute15                := ftt_attribute15;
      g_array_xla_tab (l_new_idx).ftt_attribute2                 := ftt_attribute2;
      g_array_xla_tab (l_new_idx).ftt_attribute3                 := ftt_attribute3;
      g_array_xla_tab (l_new_idx).ftt_attribute4                 := ftt_attribute4;
      g_array_xla_tab (l_new_idx).ftt_attribute5                 := ftt_attribute5;
      g_array_xla_tab (l_new_idx).ftt_attribute6                 := ftt_attribute6;
      g_array_xla_tab (l_new_idx).ftt_attribute7                 := ftt_attribute7;
      g_array_xla_tab (l_new_idx).ftt_attribute8                 := ftt_attribute8;
      g_array_xla_tab (l_new_idx).ftt_attribute9                 := ftt_attribute9;
      g_array_xla_tab (l_new_idx).ftt_attribute_category         := ftt_attribute_category;
      g_array_xla_tab (l_new_idx).ftt_manual_approve_flag        := ftt_manual_approve_flag;
      g_array_xla_tab (l_new_idx).ftt_trx_type_id                := ftt_trx_type_id;
      g_array_xla_tab (l_new_idx).ftt_vat_taxable_flag           := ftt_vat_taxable_flag;
    --END of source list
      g_array_xla_tab (l_new_idx).target_ccid                    := NULL;
      g_array_xla_tab (l_new_idx).msg_data                       := NULL;

      --Assign out parameters
      x_return_status    := C_RET_STS_SUCCESS;
      x_msg_data         := NULL;
      x_msg_count        := 0;


      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'END ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

   EXCEPTION
   WHEN le_fatal_error THEN
      --Remove all the elements from the PLSQL table
      g_array_xla_tab .DELETE;
      --If there is a no token message to log
      IF l_return_msg_name IS NOT NULL
      THEN
         --Set it on the stack
         fnd_message.set_name
            (
              application => 'XLA'
             ,name        => l_return_msg_name
         );
         --Add it to the message table
         fnd_msg_pub.add;
      END IF;
      --If there is only one message retrieve it
      fnd_msg_pub.Count_And_Get
         (
           p_count => l_msg_count
          ,p_data  => l_msg_data
         );
      --Put the message on the stack to ensure old Forms detect the error
      fnd_message.set_encoded
         (
           encoded_message => l_msg_data
         );
      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;
      IF l_return_status IS NOT NULL
      THEN
         x_return_status := l_return_status;
      ELSE
         x_return_status := C_RET_STS_UNEXP_ERROR;
      END IF;
   WHEN OTHERS THEN
      --Remove all the elements from the PLSQL table
      g_array_xla_tab .DELETE;
      --Add the standard unexpected error message
      fnd_msg_pub.Add_Exc_Msg
         ( p_pkg_name       => C_PACKAGE_NAME
          ,p_procedure_name => 'write_online_tab '
         );
      --If there is only one message retrieve it
      fnd_msg_pub.Count_And_Get
         (
           p_count => l_msg_count
          ,p_data  => l_msg_data
         );
      --Put the message on the stack to ensure all Forms detect the error
      fnd_message.set_encoded
         (
           encoded_message => l_msg_data
         );
      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;
      x_return_status := C_RET_STS_UNEXP_ERROR;
   END write_online_tab ;


   PROCEDURE read_online_tab
    (
      p_api_version                      IN  NUMBER
     ,p_source_distrib_id_num_1          IN  NUMBER
     ,p_source_distrib_id_num_2          IN  NUMBER
     ,p_source_distrib_id_num_3          IN  NUMBER
     ,p_source_distrib_id_num_4          IN  NUMBER
     ,p_source_distrib_id_num_5          IN  NUMBER
     ,p_account_type_code                IN  VARCHAR2
     ,x_target_ccid                      OUT NOCOPY NUMBER
     ,x_concatenated_segments            OUT NOCOPY VARCHAR2
     ,x_return_status                    OUT NOCOPY VARCHAR2
     ,x_msg_count                        OUT NOCOPY NUMBER
     ,x_msg_data                         OUT NOCOPY VARCHAR2
    )
   IS
      TYPE lt_table_V2000         IS TABLE OF VARCHAR2(2000);

      l_return_status             VARCHAR2(1);
      l_return_msg_name           VARCHAR2(30);

      l_msg_count                 NUMBER;
      l_msg_data                  VARCHAR2(2000);

      l_found                     BOOLEAN;
      l_watermark                 NUMBER;
      l_start                     NUMBER;
      l_row_base_rowid            UROWID;
      l_row_target_ccid           NUMBER;
      l_row_concatenated_segments VARCHAR2(2000);
      l_row_msg_count             NUMBER;
      l_row_msg_data              VARCHAR2(2000);
      l_table_of_row_errors       lt_table_V2000;

      l_log_module                VARCHAR2 (2000);
   BEGIN
      IF g_log_enabled THEN
         l_log_module := C_DEFAULT_MODULE||'read_online_tab ';
      END IF;

      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'BEGIN ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

      --Initialize the global message table
      FND_MSG_PUB.Initialize;

      --Initialize return status and message local variables
      l_return_msg_name:= NULL;
      l_return_status  := NULL;

      IF NOT FND_API.Compatible_API_Call
         (
           p_current_version_number => C_API_VERSION
          ,p_caller_version_number  => p_api_version
          ,p_api_name               => 'read_online_tab '
          ,p_pkg_name               => C_PACKAGE_NAME
         )
      THEN
         RAISE FND_API.G_EXC_UNEXPECTED_ERROR;
      END IF;

      --Start the actual logic

      --p_account_type_code cannot be NULL
      IF p_account_type_code IS NULL
      THEN
         --Assign an error message and a return code of FAILURE
         l_return_msg_name  := 'XLA_TAB_RD_ROW_ACCT_TYPE_NULL';
         RAISE le_fatal_error;
      END IF;

      l_found     := FALSE;

      --Get the highest index of the PL/SQL table
      --Cannot use COUNT since some elements might have been
      --collected and deleted
      l_watermark := NVL(g_array_xla_tab .LAST, 1);
      l_start     := NVL(g_array_xla_tab .FIRST, 1);

      --Loop on all the rows of the PL/SQL table
      FOR i IN l_start..l_watermark
      LOOP
         --If the current row identifiers correspond to the IN parameters
         IF  g_array_xla_tab .EXISTS(i)
         AND (   g_array_xla_tab (i).source_distribution_id_num_1 = p_source_distrib_id_num_1
              OR g_array_xla_tab (i).source_distribution_id_num_1 IS NULL AND p_source_distrib_id_num_1 IS NULL
             )
         AND (   g_array_xla_tab (i).source_distribution_id_num_2 = p_source_distrib_id_num_2
              OR g_array_xla_tab (i).source_distribution_id_num_2 IS NULL AND p_source_distrib_id_num_2 IS NULL
             )
         AND (   g_array_xla_tab (i).source_distribution_id_num_3 = p_source_distrib_id_num_3
              OR g_array_xla_tab (i).source_distribution_id_num_3 IS NULL AND p_source_distrib_id_num_3 IS NULL
             )
         AND (   g_array_xla_tab (i).source_distribution_id_num_4 = p_source_distrib_id_num_4
              OR g_array_xla_tab (i).source_distribution_id_num_4 IS NULL AND p_source_distrib_id_num_4 IS NULL
             )
         AND (   g_array_xla_tab (i).source_distribution_id_num_5 = p_source_distrib_id_num_5
              OR g_array_xla_tab (i).source_distribution_id_num_5 IS NULL AND p_source_distrib_id_num_5 IS NULL
             )
         AND g_array_xla_tab (i).account_type_code                = p_account_type_code
         THEN
            --Set the element found flag
            l_found := TRUE;

            --Assign the target ccid and encoded message to local variables
            l_row_base_rowid            :=
                      g_array_xla_tab (i).base_rowid;

            l_row_target_ccid           :=
                      g_array_xla_tab (i).target_ccid;

            l_row_concatenated_segments :=
                      g_array_xla_tab (i).concatenated_segments;

            l_row_msg_count             :=
                      NVL(g_array_xla_tab (i).msg_count, 0);

            l_row_msg_data              :=
                      g_array_xla_tab (i).msg_data;

            IF (C_LEVEL_STATEMENT >= g_log_level) THEN
               trace
                  (p_module => l_log_module
                  ,p_msg      => 'l_row_base_rowid = ' || l_row_base_rowid
                  ,p_level    => C_LEVEL_STATEMENT);
               trace
                  (p_module => l_log_module
                  ,p_msg      => 'l_row_target_ccid = ' || l_row_target_ccid
                  ,p_level    => C_LEVEL_STATEMENT);
               trace
                  (p_module => l_log_module
                  ,p_msg      => 'l_row_msg_count = ' || l_row_msg_count
                  ,p_level    => C_LEVEL_STATEMENT);
               trace
                  (p_module => l_log_module
                  ,p_msg      => 'l_row_msg_data = ' || l_row_msg_data
                  ,p_level    => C_LEVEL_STATEMENT);
            END IF;

            --If the line has not been processed raise an error
            IF  l_row_target_ccid IS NULL
            AND l_row_msg_count   = 0
            THEN
               l_return_msg_name := 'XLA_TBA_RD_ROW_UNPROCESSED';
               --Raise a local exception
               RAISE le_fatal_error;
            END IF;

            --remove the element
            g_array_xla_tab .DELETE(i);

            --exit the loop
            EXIT;
         END IF;
      END LOOP;

      --If no match found raise an error
      IF NOT l_found
      THEN
         l_return_msg_name := 'XLA_TBA_RD_ROW_NOT_FOUND';
         RAISE le_fatal_error;
      END IF;

      --If the row has only one error push it on the stack
      IF l_row_msg_count = 1
      THEN
         --push it on the message stack
         fnd_message.set_encoded
            (
              encoded_message => l_row_msg_data
            );
         --Add it to the message table
         fnd_msg_pub.add;
         --If there is only one message retrieve it
         fnd_msg_pub.count_and_get
            (
              p_count => l_msg_count
             ,p_data  => l_msg_data
            );
         --Put the message on the stack to ensure old Forms detect the error
         fnd_message.set_encoded
            (
              encoded_message => l_msg_data
            );
         --Set the return values
         l_msg_count     := l_msg_count;
         l_msg_data      := l_msg_data;
         --Set return status
         l_return_status := C_RET_STS_ERROR;
      --If the row has more than one error fetch them from the error table
      ELSIF l_row_msg_count > 1
      THEN
         --Read the errors from XLA_TAB_ERRORS_GT and push them on the stack
         SELECT xte.msg_data
           BULK COLLECT
           INTO l_table_of_row_errors
           FROM xla_tab_errors_gt xte
          WHERE xte.base_rowid = l_row_base_rowid;
         --Loop on the errors and push them on the stack
         FOR i IN l_table_of_row_errors.FIRST .. l_table_of_row_errors.LAST
         LOOP
            --Push the current message on the stack
            fnd_message.set_encoded
            (
              encoded_message => l_table_of_row_errors(i)
            );
            --Add the stacked message to the table
            fnd_msg_pub.add;
         END LOOP;
         --Set the return values
         l_msg_count     := l_row_msg_count;
         l_msg_data      := NULL;
         l_return_status := C_RET_STS_ERROR;
      ELSE
         --The row has been found and has no errors
         l_msg_count     := 0;
         l_msg_data      := NULL;
         l_return_status := C_RET_STS_SUCCESS;
      END IF;

      --Assign out parameters
      x_target_ccid           := l_row_target_ccid;
      x_concatenated_segments := l_row_concatenated_segments;
      x_msg_count             := l_msg_count;
      x_msg_data              := l_msg_data;

      IF l_return_status IS NOT NULL
      THEN
         x_return_status := l_return_status;
      ELSE
         x_return_status := C_RET_STS_UNEXP_ERROR;
      END IF;

      IF (C_LEVEL_PROCEDURE >= g_log_level) THEN
         trace
           ( p_module   => l_log_module
            ,p_msg      => 'END ' || l_log_module
            ,p_level    => C_LEVEL_PROCEDURE);
      END IF;

   EXCEPTION
   WHEN le_fatal_error THEN
      --Remove all the elements from the PLSQL table
      g_array_xla_tab .DELETE;
      --If there is a no token message to log
      IF l_return_msg_name IS NOT NULL
      THEN
         --Set it on the stack
         fnd_message.set_name
            (
              application => 'XLA'
             ,name        => l_return_msg_name
         );
         --Add it to the message table
         fnd_msg_pub.add;
      END IF;
      --If there is only one message retrieve it
      fnd_msg_pub.Count_And_Get
         (
           p_count => l_msg_count
          ,p_data  => l_msg_data
         );
      --Put the message on the stack to ensure old Forms detect the error
      fnd_message.set_encoded
         (
           encoded_message => l_msg_data
         );
      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;
      IF l_return_status IS NOT NULL
      THEN
         x_return_status := l_return_status;
      ELSE
         x_return_status := C_RET_STS_UNEXP_ERROR;
      END IF;
   WHEN OTHERS THEN
      --Remove all the elements from the PLSQL table
      g_array_xla_tab .DELETE;
      --Add the standard unexpected error message
      fnd_msg_pub.Add_Exc_Msg
         ( p_pkg_name       => C_PACKAGE_NAME
          ,p_procedure_name => 'read_online_tab '
         );
      --If there is only one message retrieve it
      fnd_msg_pub.Count_And_Get
         (
           p_count => l_msg_count
          ,p_data  => l_msg_data
         );
      --Put the message on the stack to ensure all Forms detect the error
      fnd_message.set_encoded
         (
           encoded_message => l_msg_data
         );
      --Assign out parameters
      x_msg_count     := l_msg_count;
      x_msg_data      := l_msg_data;
      x_return_status := C_RET_STS_UNEXP_ERROR;
   END read_online_tab ;



--Trace initialization
BEGIN
   g_log_level      := FND_LOG.G_CURRENT_RUNTIME_LEVEL;
   g_log_enabled    := fnd_log.test
                          (log_level  => g_log_level
                          ,module     => C_DEFAULT_MODULE);

   IF NOT g_log_enabled  THEN
      g_log_level := C_LEVEL_LOG_DISABLED;
   END IF;


END FUN_XLA_TAB_PKG;

/
